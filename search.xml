<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2018-第一场雪</title>
    <url>/2018/01/04/2018-first-snow/</url>
    <content><![CDATA[<p>用文字和图片记录下生活的点点滴滴。</p>
<p>2018的第一场雪。</p>
<img src="/2018/01/04/2018-first-snow/2018-snow-1.jpg" class="" title="2018第一场雪:亚青村">
<span id="more"></span>
<img src="/2018/01/04/2018-first-snow/2018-snow-2.jpg" class="" title="2018第一场雪：亚青前">
<img src="/2018/01/04/2018-first-snow/2018-snow-3.jpg" class="" title="2018第一场雪：镜湖1">
<img src="/2018/01/04/2018-first-snow/2018-snow-4.jpg" class="" title="2018第一场雪：镜湖2">
<img src="/2018/01/04/2018-first-snow/2018-snow-all.jpg" class="" title="2018第一场雪：镜湖全景">
<img src="/2018/01/04/2018-first-snow/2018-snow-office.jpg" class="" title="2018第一场雪：篮球场">
<p>来自系里小朋友： <img src="/2018/01/04/2018-first-snow/2018-others-1.jpg" class="" title="2018第一场雪：降龙十八掌"> <img src="/2018/01/04/2018-first-snow/2018-others-2.jpg" class="" title="2018第一场雪：镜湖（by通信16 陆恒屹）"> <img src="/2018/01/04/2018-first-snow/2018-others-3.jpg" class="" title="2018第一场雪：亚青学生宿舍1（by通信16 蒲宇琦）"> <img src="/2018/01/04/2018-first-snow/2018-others-4.jpg" class="" title="2018第一场雪：亚青学生宿舍2（by通信16 蒲宇琦）"> <img src="/2018/01/04/2018-first-snow/2018-others-5.jpg" class="" title="2018第一场雪：东苑蓝球场前（by通信16 萨吉代）"> <img src="/2018/01/04/2018-first-snow/2018-others-6.jpg" class="" title="2018第一场雪：校医院南（by通信16 萨吉代）"> <img src="/2018/01/04/2018-first-snow/2018-others-7.jpg" class="" title="2018第一场雪：音悦台（by通信16 魏大源）"></p>
<img src="/2018/01/04/2018-first-snow/2018-others-unknow.jpg" class="" title="2018第一场雪：镜湖（by 未知）">
]]></content>
      <categories>
        <category>生活点滴</category>
        <category>在南京</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>在南京</tag>
      </tags>
  </entry>
  <entry>
    <title>方差、协方差和相关系数</title>
    <url>/2019/07/26/2019-07-26-covariance/</url>
    <content><![CDATA[<p>　　一直没明白，方差、协方差以及相关系数这几个概念的含义及其在统计学中作用和计算方法，这里简单做一个记录和梳理。</p>
<h3 id="概念">1、概念</h3>
<p>　　 <strong>方差(Variance)</strong> ，表征统计量（随机变量）对均值的误差（偏离度或离散度），方差越小离散度越小，统计量越接近统计平均值。</p>
<p>　　 <strong>协方差(Covariance)</strong> 表征统计量（随机变量）不同维度之间的误差，衡量该量不同维度之间的相关性。</p>
<p>　　 <strong>相关系数(Coefficient)</strong> ，统计学上常用是皮尔森相关系数(Pearson correlation coefficient)，定义为两个维度（特征）之间的协方差和标准差之比，用于度量两个维度之间的(线性)相关程度，其值介于<span class="math inline">\([-1,1]\)</span>之间。</p>
<span id="more"></span>
<p>　　当协方差为正时，两个维度呈正相关（同增同减）；当协方差为负时，两个维度负相关（一增一减）。将所有将所有维度之间的协方差关系以矩阵的形式表现，即为协方差矩阵。</p>
<p>　　<strong>几点说明</strong>：</p>
<ol type="1">
<li>无论是方差、协方差还是相关系数，针对的对象始终是<strong>随机变量的各个维度</strong>，而非针对样本。所以在实际使用时，切记注意目标矩阵中，哪些是特征，哪些是样本。</li>
<li>方差，是协方差的一个特例，即两个维度相同时的情况。</li>
<li>协方差，反映随机变量各个维度之间的统计特性。如果协方差趋近于 <span class="math inline">\(0\)</span> ，则该随机变量的 <span class="math inline">\(x_i\)</span> 维度和 <span class="math inline">\(x_j\)</span> 维度相关性很弱。极端情况下，协方差为 $ 0 $，则这两个维度无关。</li>
<li>协方差矩阵是一个方阵，其大小由随机变量的维度决定。如果该随机变量维度为 $ N $ ，则协方差矩阵的大小为 <span class="math inline">\((N \times N )\)</span> 。</li>
<li>相关系数，也可以看成协方差：一种剔除了两个变量量纲影响、标准化后的特殊协方差（其值为<span class="math inline">\([-1,1]\)</span>之间）。</li>
</ol>
<p>　　另外提一下 <strong>标准差(Standard Deviation)</strong> 。标准差定义为方差的算术平方根（习惯使用<span class="math inline">\(\sigma\)</span>表示），由于方差在量纲上与被测物理量不同，因此，标准差可以消除量纲带来的差异。</p>
<h3 id="数学定义">2、数学定义</h3>
<p>　　设样本集 <span class="math inline">\(S\)</span> 由 <span class="math inline">\(m\)</span> 个 <span class="math inline">\(n\)</span> 维随机变量构成， <span class="math inline">\(S = \{ s_1,s_2,\cdots,s_m \}\)</span> ，其中 <span class="math inline">\(s_k=[x_{k1}, x_{k2},...,x_{kn}]\)</span> <span class="math inline">\(\; (1\le k \le m)\)</span> 。则样本矩阵为： <span class="math display">\[
S
=\begin{bmatrix}
S_{1}   \\
S_{2}   \\
\vdots  \\
S_{m}   \\
\end{bmatrix}
=\begin{bmatrix}
x_{11}  &amp;x_{12}  &amp; \cdots\ &amp;x_{1n}      \\
x_{21}  &amp;x_{22}  &amp; \cdots\ &amp;x_{2n}      \\
 \vdots   &amp; \vdots &amp; \ddots  &amp; \vdots   \\
x_{m1}  &amp;x_{m2}  &amp; \cdots\ &amp;x_{mn}      \\
\end{bmatrix}
=\begin{bmatrix}
X_{1}&amp; X_{2}&amp; \cdots &amp; X_{n}            \\
\end{bmatrix}
\]</span> 　　<strong>注意</strong>：<span class="math inline">\(m\)</span>是样本数，<span class="math inline">\(n\)</span>是随机变量的维度（特征），<font color="#dd00dd"><span class="math inline">\(S_k\)</span>为行向量，针对行（样本），<span class="math inline">\(X_k\)</span>为列向量，针对列（特征）</font>。第1下标表示样本编号，第2个下标表示维度编号，例如<span class="math inline">\(x_{34}\)</span>表示第<span class="math inline">\(3\)</span>个样本的第<span class="math inline">\(4\)</span>个维度。</p>
<ul>
<li><strong>方差</strong>：（针对维度，纵向） <span class="math display">\[
Var(S)=\begin{bmatrix}
Var(X_{1})&amp; Var(X_{2})&amp; \cdots &amp; Var(X_{n})\\\\
\end{bmatrix}
=\begin{bmatrix}
\sigma^{2}(X_{1})&amp; \sigma^{2}(X_{2})&amp; \cdots &amp; \sigma^{2}(X_{n})\\
\end{bmatrix}
\]</span> 　　其中： <span class="math display">\[
Var(X_{i})=\sigma^{2}(X_{i})=\frac{1}{m-1} {(X_{i}-\overline X_{i})^{T} \cdot {(X_{i}-\overline X_{i})}}\;\;\;\;\; (1\le i \le n)
\]</span></li>
</ul>
<p>　　使用统计学符号表示 <span class="math display">\[
Var(X_{i})=\sigma^{2}(X_{i})=E \left ( [X-E(X)]^T [X-E(X)] \right ) 
\]</span></p>
<ul>
<li><strong>协方差</strong>：（同样针对维度）</li>
</ul>
<p><span class="math display">\[
Cov(S)
=\begin{bmatrix}
Cov(X_{1},X_{1})  &amp;Cov(X_{1},X_{2})  &amp; \cdots\ &amp;Cov(X_{1},X_{n})\\
Cov(X_{2},X_{1})  &amp;Cov(X_{2},X_{2})  &amp; \cdots\ &amp;Cov(X_{2},X_{n})\\
 \vdots   &amp; \vdots &amp; \ddots  &amp; \vdots  \\
Cov(X_{n},X_{1})  &amp;Cov(X_{n},X_{2})  &amp; \cdots\ &amp;Cov(X_{n},X_{n})\\
\end{bmatrix}
\]</span> 　　其中： <span class="math display">\[
Cov(X_{i},X_{j})=\frac{1}{m-1}{(X_{i} - \overline X_{i})^{T} \cdot { (X_{j}-\overline X_{j})}}\ \ \ \ \  (1\le i,j \le n)
\]</span> 　　使用统计学符号表示 <span class="math display">\[
Cov(X_{i},X_{j})=E \left ([X_{i} - E(X_{i})]^{T} [X_{j} - E(X_{j})] \right )\;\;\;\;\; (1\le i,j \le n)
\]</span></p>
<p>　　当<span class="math inline">\(i=j\)</span>时，即协方差矩阵的对角矩阵，就是方差。</p>
<ul>
<li><strong>(Pearson)相关系数</strong>：</li>
</ul>
<p>　　考虑样本矩阵<span class="math inline">\(S\)</span>由各列向量构成：<span class="math inline">\(S=[X_1,X_2,\cdots,X_n]\)</span> ，则各列标准差 <span class="math inline">\(\sigma=[\sigma_{X_1},\sigma_{X_2},\cdots,\sigma_{X_n}]\)</span>， 记 <span class="math inline">\(\sigma_S \equiv \sigma^T \cdot \sigma\)</span>，同时记 <span class="math inline">\(\sigma_{X_i,X_j} \equiv \sigma_{X_i}\cdot \sigma_{X_j}\)</span>，则： <span class="math display">\[
\sigma_S \equiv \sigma^T \cdot \sigma =\begin{bmatrix}
\sigma_{X_1} \cdot \sigma_{X_1} &amp; \sigma_{X_1} \cdot \sigma_{X_2}&amp; \cdots&amp; \sigma_{X_1} \cdot \sigma_{X_n} \\
\sigma_{X_2} \cdot \sigma_{X_1} &amp; \sigma_{X_2} \cdot \sigma_{X_2}&amp; \cdots&amp; \sigma_{X_2} \cdot \sigma_{X_n} \\
 \vdots   &amp; \vdots &amp; \ddots  &amp; \vdots  \\
\sigma_{X_n} \cdot \sigma_{X_1} &amp; \sigma_{X_n} \cdot \sigma_{X_2}&amp; \cdots&amp; \sigma_{X_n} \cdot \sigma_{X_n} \\
\end{bmatrix}   
=\begin{bmatrix}
\sigma_{X_{1},X_{1}}  &amp;\sigma_{X_{1},X_{2}}  &amp; \cdots\ &amp;\sigma_{X_{1},X_{n}}\\
\sigma_{X_{2},X_{1}}  &amp;\sigma_{X_{2},X_{2}}  &amp; \cdots\ &amp;\sigma_{X_{2},X_{n}}\\
 \vdots   &amp; \vdots &amp; \ddots  &amp; \vdots  \\
\sigma_{X_{n},X_{1}}  &amp;\sigma_{X_{n},X_{2}}  &amp; \cdots\ &amp;\sigma_{X_{n},X_{n}}\\
\end{bmatrix}
\]</span></p>
<p>对样本空间<span class="math inline">\(S\)</span>，其相关系数矩阵<span class="math inline">\(\rho\)</span>定义为： <span class="math display">\[
\rho = \frac{Cov(S)}{\sigma_{S}} =\frac{Cov(S)}{\sigma^T \cdot \sigma} 
\]</span> 　　代入协方差矩阵和<span class="math inline">\(\sigma_S\)</span>： <span class="math display">\[
\begin{align*}
\rho &amp;=\frac{\begin{bmatrix}
Cov(X_{1},X_{1})  &amp;Cov(X_{1},X_{2})  &amp; \cdots\ &amp;Cov(X_{1},X_{n})\\
Cov(X_{2},X_{1})  &amp;Cov(X_{2},X_{2})  &amp; \cdots\ &amp;Cov(X_{2},X_{n})\\
 \vdots   &amp; \vdots &amp; \ddots  &amp; \vdots  \\
Cov(X_{n},X_{1})  &amp;Cov(X_{n},X_{2})  &amp; \cdots\ &amp;Cov(X_{n},X_{n})\\
\end{bmatrix}
}{\begin{bmatrix}
\sigma_{X_{1},X_{1}}  &amp;\sigma_{X_{1},X_{2}}  &amp; \cdots\ &amp;\sigma_{X_{1},X_{n}}\\
\sigma_{X_{2},X_{1}}  &amp;\sigma_{X_{2},X_{2}}  &amp; \cdots\ &amp;\sigma_{X_{2},X_{n}}\\
 \vdots   &amp; \vdots &amp; \ddots  &amp; \vdots  \\
\sigma_{X_{n},X_{1}}  &amp;\sigma_{X_{n},X_{2}}  &amp; \cdots\ &amp;\sigma_{X_{n},X_{n}}\\
\end{bmatrix}
}   
\end{align*}
\]</span> 　　上述矩阵除法，指的是对应元素相除。其中： <span class="math display">\[
\rho_{X_{i},X_{j}} = \frac{Cov(X_{i},X_{j})}{\sigma_{X{i},X_{j}}} = \frac{Cov(X_{i},X_{j})}{\sigma_{X{i}} \cdot \sigma_{X_{j}}}
\]</span> 　　完整表达式： <span class="math display">\[
\rho = \begin{bmatrix}
\rho_{X_{1},X_{1}}  &amp;\rho_{X_{1},X_{2}}  &amp; \cdots\ &amp;\rho_{X_{1},X_{n}}\\
\rho_{X_{2},X_{1}}  &amp;\rho_{X_{2},X_{2}}  &amp; \cdots\ &amp;\rho_{X_{2},X_{n}}\\
 \vdots   &amp; \vdots &amp; \ddots  &amp; \vdots  \\
\rho_{X_{n},X_{1}}  &amp;\rho_{X_{n},X_{2}}  &amp; \cdots\ &amp;\rho_{X_{n},X_{n}}\\
\end{bmatrix} 
=\begin{bmatrix}
\frac{Cov(X_{1},X_{1})}{\sigma_{X_{1}} \cdot \sigma_{X_{1}}}  &amp;\frac{Cov(X_{1},X_{2})}{\sigma_{X_{1}} \cdot \sigma_{X_{2}}}  &amp; \cdots\ &amp;\frac{Cov(X_{1},X_{n})}{\sigma_{X_{1}} \cdot \sigma_{X_{n}}}\\
\frac{Cov(X_{2},X_{1})}{\sigma_{X_{2}} \cdot \sigma_{X_{1}}}  &amp;\frac{Cov(X_{2},X_{2})}{\sigma_{X_{2}} \cdot \sigma_{X_{2}}}  &amp; \cdots\ &amp;\frac{Cov(X_{2},X_{n})}{\sigma_{X_{2}} \cdot \sigma_{X_{n}}}\\
 \vdots   &amp; \vdots &amp; \ddots  &amp; \vdots  \\
\frac{Cov(X_{n},X_{1})}{\sigma_{X_{n}} \cdot \sigma_{X_{1}}}  &amp;\frac{Cov(X_{n},X_{2})}{\sigma_{X_{n}} \cdot \sigma_{X_{2}}}  &amp; \cdots\ &amp;\frac{Cov(X_{n},X_{n})}{\sigma_{X_{n}} \cdot \sigma_{X_{n}}}\\
\end{bmatrix}
\]</span> 　　由<span class="math inline">\(Cov(X_i,X_i)=\sigma^2_{X_i}\)</span>可得，相关系数矩阵<span class="math inline">\(\rho\)</span>对角线元素的值均为<span class="math inline">\(1\)</span>。</p>
<h3 id="协方差矩阵的计算">3、协方差矩阵的计算</h3>
<h4 id="维随机变量的协方差矩阵">1) <span class="math inline">\(2\)</span>维随机变量的协方差矩阵</h4>
<p>　　设<span class="math inline">\(4\)</span>个二维随机变量样本，<span class="math inline">\(S = \{ s_1,s_2,s_3,s_4 \}\)</span>，其中：<span class="math inline">\(s_1=(1,2)\)</span>，<span class="math inline">\(s_2=(3,6)\)</span>，<span class="math inline">\(s_3=(4,2)\)</span>，<span class="math inline">\(s_4=(5,2)\)</span>。矩阵表示为：</p>
<p><span class="math display">\[
S=\begin{bmatrix}
s_1 \\
s_2 \\
s_3 \\
s_4
\end{bmatrix}
=\begin{bmatrix}
1 &amp; 2 \\
3 &amp; 6 \\
4 &amp; 2 \\
5 &amp; 2
\end{bmatrix}
=\begin{bmatrix}
X_1 &amp; X_2 \\
\end{bmatrix}
\]</span></p>
<p>　　二维随机变量的两个特征分别用<span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>： <span class="math display">\[
X_1=\begin{bmatrix} 1 \\ 3 \\ 4 \\ 5 \end{bmatrix},  \ \ \    X_2=\begin{bmatrix} 2 \\ 6 \\ 2 \\ 2 \end{bmatrix}
\]</span></p>
<p>　　(1) 手算</p>
<p>　　两个特征的平均值分别为：<span class="math inline">\(\overline X_1=3.25\)</span>，<span class="math inline">\(\overline X_2=3\)</span>。</p>
<p><span class="math inline">\(Cov(X_1,X_1)=\frac{1}{4-1}[(1-3.25)^2+(3-3.25)^2+(4-3.25)^2+(5-3.25)^2]=2.9167\)</span></p>
<p><span class="math inline">\(Cov(X_1,X_2)=\frac{1}{4-1}[(1-3.25)(2-3)+(3-3.25)(6-3)+(4-3.25)(2-3)+(5-3.25)(2-3)]=-0.3333\)</span></p>
<p><span class="math inline">\(Cov(X_2,X_1)=\frac{1}{4-1}[(2-3)(1-3.25)+(6-3)(3-3.25)+(2-3)(4-3.25)+(2-3)(5-3.25)]=-0.3333\)</span></p>
<p><span class="math inline">\(Cov(X_2,X_2)=\frac{1}{4-1}[(2-3)^2+(6-3)^2+(2-3)^2+(2-3)^2]=4\)</span></p>
<p>所以，协方差矩阵 <span class="math inline">\(Cov(S)=\begin{bmatrix} 2.9167 &amp; -0.3333 \\ -0.3333 &amp; 4.000 \end{bmatrix}\)</span></p>
<p>　　(2) <code>numpy</code>计算</p>
<p>　　<code>numpy</code>中，使用<code>np.cov</code>用来计算协方差，函数原型： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.cov(m, y=<span class="literal">None</span>, rowvar=<span class="literal">True</span>, bias=<span class="literal">False</span>, ddof=<span class="literal">None</span>, fweights=<span class="literal">None</span>, aweights=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure> 　　首先厘清两个概念：</p>
<p>　　<code>variable</code>：变量，也就是特征</p>
<p>　　<code>observation</code>：观测，也就是样本</p>
<p>参数说明：</p>
<ul>
<li><code>m</code>:一维向量或者二维矩阵，当<code>m</code>为一个向量时，它相当于一个1行n列的矩阵，最终输出的协方差矩阵为 <span class="math inline">\(1 \times 1\)</span> 的矩阵（也就是一个标量）。当<code>m</code>是一个二维矩阵时，它的每一行表示一个特征（<code>numpy</code>文档称之为<code>variable</code>），每一列表示一个样本（<code>observation</code>）。</li>
<li><code>y</code>和<code>m</code>一样，可以是一维向量，也可以是二维矩阵。<code>y</code>相当于给<code>m</code>添加了若干个新行，也就是<code>m=np.hstack(m,y)</code>。<code>y</code>的列数必须和<code>m</code>一致，否则没法把<code>m</code>和<code>y</code>的行拼起来。这个参数基本可以不用。</li>
<li><code>rowvar</code>:默认值为<code>True</code>，用来描述矩阵<code>m</code>和<code>y</code>使用行作为特征，还是列作为特征。默认情况下，矩阵的行对应特征，列对应样本。由于在机器学习中，习惯上行表示样本，列表示特征，因此在计算时需要将<code>rowvar</code>置为<code>False</code>。</li>
<li><code>bias</code>：默认值<code>False</code>，表示在计算协方差时是否为有偏估计，<code>True</code>表示有偏估计，分母为N（N表示样本数，也就是观测个数）；默认情况下，表示分母为<code>N-1</code>的无偏估计。一般来说，无偏估计要优于有偏估计。关于有偏估计和无偏估计的问题，详见<a href="https://www.matongxue.com/madocs/607.html">这篇文章</a></li>
<li><code>ddof</code>:表示自由度，当此值不为<code>None</code>，分母为<code>N-ddof</code>，同时<code>bias</code>参数失效。</li>
<li><code>fweights</code>：一个一维整型数组，表示每个观测出现的次数。提供此参数的目的是，防止m矩阵过大。</li>
<li><code>aweights</code>：一个一维浮点数组，表示每个观测的权重。权重大表明这个观测准确，权重小表明这个权重不太重要。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.set_printoptions(precision=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cov</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       使用公式计算协方差矩阵，行向量为样本数，列向量为特征数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 对每列数据，减去该列均值</span></span><br><span class="line">    dm  = m - m.mean(axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 点乘，求内积</span></span><br><span class="line">    c = dm.T.dot(dm)/(m.shape[<span class="number">0</span>]-<span class="number">1</span>)   </span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">t1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>]).reshape(-<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">t1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out[14]: </span></span><br><span class="line"><span class="comment"># array([[1, 2],</span></span><br><span class="line"><span class="comment">#        [3, 6],</span></span><br><span class="line"><span class="comment">#        [4, 2],</span></span><br><span class="line"><span class="comment">#        [5, 2]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 根据公式计算</span></span><br><span class="line">cov(t1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out[15]: </span></span><br><span class="line"><span class="comment"># array([[ 2.9167, -0.3333],</span></span><br><span class="line"><span class="comment">#        [-0.3333,  4.    ]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用内置协方差函数计算</span></span><br><span class="line">np.cov(t1,rowvar=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Out[16]: </span></span><br><span class="line"><span class="comment"># array([[ 2.9167, -0.3333],</span></span><br><span class="line"><span class="comment">#        [-0.3333,  4.    ]])</span></span><br></pre></td></tr></table></figure>
<h4 id="n维随机变量的协方差矩阵">2) <span class="math inline">\(n\)</span>维随机变量的协方差矩阵</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">t2 = np.random.randint(-<span class="number">10</span>,<span class="number">10</span>,size=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">t2</span><br><span class="line"><span class="comment"># Out[17]: </span></span><br><span class="line"><span class="comment"># array([[  1,   4,  -9,   8,  -4,  -3],</span></span><br><span class="line"><span class="comment">#        [  6,  -9,  -2,   8,   4,  -4],</span></span><br><span class="line"><span class="comment">#        [ -5,   9,  -1,  -4,   7,   4],</span></span><br><span class="line"><span class="comment">#        [ -5, -10,  -9,   2, -10,   6],</span></span><br><span class="line"><span class="comment">#        [  5,   4,  -3,   3,  -9,  -9],</span></span><br><span class="line"><span class="comment">#        [  3,  -8,  -2,   1,  -6,  -1],</span></span><br><span class="line"><span class="comment">#        [  3,   7,   0,  -7,   3,   5],</span></span><br><span class="line"><span class="comment">#        [  9,   8,   2,  -5,   1,  -4],</span></span><br><span class="line"><span class="comment">#        [ -2,  -7,   6,   2,   5,  -2],</span></span><br><span class="line"><span class="comment">#        [ -9,   2,   2,   1,  -2, -10]])</span></span><br><span class="line"></span><br><span class="line">cov(t2)</span><br><span class="line"><span class="comment"># Out[18]: </span></span><br><span class="line"><span class="comment"># array([[ 3.2489e+01,  4.4444e+00,  6.2222e-01, -4.4444e-02,  5.1111e-01,  -4.5778e+00],</span></span><br><span class="line"><span class="comment">#        [ 4.4444e+00,  5.8222e+01,  5.0000e+00, -2.1444e+01,  1.2556e+01,  -3.4444e+00],</span></span><br><span class="line"><span class="comment">#        [ 6.2222e-01,  5.0000e+00,  2.2044e+01, -1.0511e+01,  1.7822e+01,  -6.9778e+00],</span></span><br><span class="line"><span class="comment">#        [-4.4444e-02, -2.1444e+01, -1.0511e+01,  2.5433e+01, -9.9000e+00,  -1.1200e+01],</span></span><br><span class="line"><span class="comment">#        [ 5.1111e-01,  1.2556e+01,  1.7822e+01, -9.9000e+00,  3.6100e+01,   5.8000e+00],</span></span><br><span class="line"><span class="comment">#        [-4.5778e+00, -3.4444e+00, -6.9778e+00, -1.1200e+01,  5.8000e+00,   3.0178e+01]])</span></span><br><span class="line"></span><br><span class="line">np.cov(t2, rowvar=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># Out[19]: </span></span><br><span class="line"><span class="comment"># array([[ 3.2489e+01,  4.4444e+00,  6.2222e-01, -4.4444e-02,  5.1111e-01,  -4.5778e+00],</span></span><br><span class="line"><span class="comment">#        [ 4.4444e+00,  5.8222e+01,  5.0000e+00, -2.1444e+01,  1.2556e+01,  -3.4444e+00],</span></span><br><span class="line"><span class="comment">#        [ 6.2222e-01,  5.0000e+00,  2.2044e+01, -1.0511e+01,  1.7822e+01,  -6.9778e+00],</span></span><br><span class="line"><span class="comment">#        [-4.4444e-02, -2.1444e+01, -1.0511e+01,  2.5433e+01, -9.9000e+00,  -1.1200e+01],</span></span><br><span class="line"><span class="comment">#        [ 5.1111e-01,  1.2556e+01,  1.7822e+01, -9.9000e+00,  3.6100e+01,   5.8000e+00],</span></span><br><span class="line"><span class="comment">#        [-4.5778e+00, -3.4444e+00, -6.9778e+00, -1.1200e+01,  5.8000e+00,   3.0178e+01]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的矩阵元均小于1e-10?</span></span><br><span class="line">(np.<span class="built_in">abs</span>(cov(t2)-np.cov(t2, rowvar=<span class="literal">False</span>)) &lt; <span class="number">1e-10</span>).<span class="built_in">all</span>()</span><br><span class="line"><span class="comment"># Out[20]: True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方差的计算">4、方差的计算</h3>
<p>　　方差的计算实际上用的是协方差计算取对角矩阵方法，但是内置的<code>np.var</code>函数有个坑，默认参数计算的是有偏估计(<code>ddof</code>=0)，如果计算无偏估计，那么需要<code>ddof=1</code>。</p>
<p>　　首先还是二维情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1</span><br><span class="line"><span class="comment"># Out[21]: </span></span><br><span class="line"><span class="comment"># array([[1, 2],</span></span><br><span class="line"><span class="comment">#        [3, 6],</span></span><br><span class="line"><span class="comment">#        [4, 2],</span></span><br><span class="line"><span class="comment">#        [5, 2]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出对角矩阵</span></span><br><span class="line">np.diag(cov(t1))</span><br><span class="line"><span class="comment"># Out[22]: array([2.9167, 4.    ])	&lt;== 无偏估计</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再来一次，创建对角矩阵</span></span><br><span class="line">np.diag(np.diag(cov(t1)))</span><br><span class="line"><span class="comment"># Out[23]: </span></span><br><span class="line"><span class="comment"># array([[2.9167, 0.    ],</span></span><br><span class="line"><span class="comment">#        [0.    , 4.    ]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内置函数计算方差（有偏估计）</span></span><br><span class="line">np.var(t1,axis=<span class="number">0</span>)	<span class="comment"># 或 t1.var(axis=0,ddof=0)</span></span><br><span class="line"><span class="comment"># Out[24]: array([2.1875, 3.    ])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内置函数计算方差（无偏估计）</span></span><br><span class="line">np.var(t1,axis=<span class="number">0</span>,ddof=<span class="number">1</span>)	<span class="comment"># 或 t1.var(axis=0,ddof=1)</span></span><br><span class="line"><span class="comment"># Out[25]: array([2.9167, 4.    ])	&lt;== 无偏估计</span></span><br></pre></td></tr></table></figure>
<p>　　再来多维情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t2</span><br><span class="line"><span class="comment"># Out[26]: </span></span><br><span class="line"><span class="comment"># array([[  1,   4,  -9,   8,  -4,  -3],</span></span><br><span class="line"><span class="comment">#        [  6,  -9,  -2,   8,   4,  -4],</span></span><br><span class="line"><span class="comment">#        [ -5,   9,  -1,  -4,   7,   4],</span></span><br><span class="line"><span class="comment">#        [ -5, -10,  -9,   2, -10,   6],</span></span><br><span class="line"><span class="comment">#        [  5,   4,  -3,   3,  -9,  -9],</span></span><br><span class="line"><span class="comment">#        [  3,  -8,  -2,   1,  -6,  -1],</span></span><br><span class="line"><span class="comment">#        [  3,   7,   0,  -7,   3,   5],</span></span><br><span class="line"><span class="comment">#        [  9,   8,   2,  -5,   1,  -4],</span></span><br><span class="line"><span class="comment">#        [ -2,  -7,   6,   2,   5,  -2],</span></span><br><span class="line"><span class="comment">#        [ -9,   2,   2,   1,  -2, -10]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出对角矩阵</span></span><br><span class="line">np.diag(cov(t2))</span><br><span class="line"><span class="comment"># Out[27]: array([32.4889, 58.2222, 22.0444, 25.4333, 36.1   , 30.1778])	&lt;== 无偏估计</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内置函数计算方差（无偏估计）</span></span><br><span class="line">np.var(t2,axis=<span class="number">0</span>,ddof=<span class="number">1</span>)	<span class="comment"># 或 t2.var(axis=0,ddof=1)</span></span><br><span class="line"><span class="comment"># Out[27]: array([32.4889, 58.2222, 22.0444, 25.4333, 36.1   , 30.1778])	&lt;== 无偏估计</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺便计算一下标准差</span></span><br><span class="line">t2.std(axis=<span class="number">0</span>,ddof=<span class="number">1</span>)		<span class="comment"># 或 np.sqrt(t2.var(axis=0,ddof=1))</span></span><br><span class="line"><span class="comment"># Out[263]: array([5.6999, 7.6303, 4.6952, 5.0431, 6.0083, 5.4934])</span></span><br></pre></td></tr></table></figure>
<h3 id="相关系数的计算">5、相关系数的计算</h3>
<p>　　计算过程基本类似，按照公式来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t3=t2.copy()</span><br><span class="line">t3</span><br><span class="line"><span class="comment"># Out[26]: </span></span><br><span class="line"><span class="comment"># array([[  1,   4,  -9,   8,  -4,  -3],</span></span><br><span class="line"><span class="comment">#        [  6,  -9,  -2,   8,   4,  -4],</span></span><br><span class="line"><span class="comment">#        [ -5,   9,  -1,  -4,   7,   4],</span></span><br><span class="line"><span class="comment">#        [ -5, -10,  -9,   2, -10,   6],</span></span><br><span class="line"><span class="comment">#        [  5,   4,  -3,   3,  -9,  -9],</span></span><br><span class="line"><span class="comment">#        [  3,  -8,  -2,   1,  -6,  -1],</span></span><br><span class="line"><span class="comment">#        [  3,   7,   0,  -7,   3,   5],</span></span><br><span class="line"><span class="comment">#        [  9,   8,   2,  -5,   1,  -4],</span></span><br><span class="line"><span class="comment">#        [ -2,  -7,   6,   2,   5,  -2],</span></span><br><span class="line"><span class="comment">#        [ -9,   2,   2,   1,  -2, -10]])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coef</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">       使用公式计算相关系数，行向量为样本数，列向量为特征数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    c = np.cov(m,rowvar=<span class="literal">False</span>)					<span class="comment"># 分子协方差矩阵</span></span><br><span class="line">    sigma =  m.std(axis=<span class="number">0</span>,ddof=<span class="number">1</span>,keepdims=<span class="literal">True</span>)			<span class="comment"># 注意ddof...坑</span></span><br><span class="line">    sigma = sigma.T.dot(sigma)					<span class="comment"># 分母标准差矩阵</span></span><br><span class="line">    <span class="keyword">return</span> c/sigma</span><br><span class="line"></span><br><span class="line">coef(t3)</span><br><span class="line"><span class="comment"># Out[24]: </span></span><br><span class="line"><span class="comment"># array([[ 1.    ,  0.1022,  0.0233, -0.0015,  0.0149, -0.1462],</span></span><br><span class="line"><span class="comment">#        [ 0.1022,  1.    ,  0.1396, -0.5573,  0.2739, -0.0822],</span></span><br><span class="line"><span class="comment">#        [ 0.0233,  0.1396,  1.    , -0.4439,  0.6318, -0.2705],</span></span><br><span class="line"><span class="comment">#        [-0.0015, -0.5573, -0.4439,  1.    , -0.3267, -0.4043],</span></span><br><span class="line"><span class="comment">#        [ 0.0149,  0.2739,  0.6318, -0.3267,  1.    ,  0.1757],</span></span><br><span class="line"><span class="comment">#        [-0.1462, -0.0822, -0.2705, -0.4043,  0.1757,  1.    ]])</span></span><br><span class="line"></span><br><span class="line">np.corrcoef(t3,rowvar=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># Out[25]: </span></span><br><span class="line"><span class="comment"># array([[ 1.    ,  0.1022,  0.0233, -0.0015,  0.0149, -0.1462],</span></span><br><span class="line"><span class="comment">#        [ 0.1022,  1.    ,  0.1396, -0.5573,  0.2739, -0.0822],</span></span><br><span class="line"><span class="comment">#        [ 0.0233,  0.1396,  1.    , -0.4439,  0.6318, -0.2705],</span></span><br><span class="line"><span class="comment">#        [-0.0015, -0.5573, -0.4439,  1.    , -0.3267, -0.4043],</span></span><br><span class="line"><span class="comment">#        [ 0.0149,  0.2739,  0.6318, -0.3267,  1.    ,  0.1757],</span></span><br><span class="line"><span class="comment">#        [-0.1462, -0.0822, -0.2705, -0.4043,  0.1757,  1.    ]])</span></span><br></pre></td></tr></table></figure>
<h3 id="各维度相互独立也称独立变量的协方差">6. 各维度相互独立（也称独立变量）的协方差</h3>
<p>　　机器学习中，经常采用主成分分析（PCA）和独立成分分析（ICA）方法进行数据预处理。使用PCA方法的目的，是为了降低运算量而对原始数据进行降维处理；使用ICA方法的目的，则主要是去除不相关的噪声和干扰。无论是PCA还是ICA，协方差矩阵都是一个重要衡量工具。理想情况下，当协方差矩阵退化为纯对角矩阵时，各个维度之间相互独立，即独立变量情况，这种情况属于珍稀品种，比较少见，以下为推导。</p>
<p>根据协方差公式，利用矩阵的结合律和转置性质：</p>
<p><span class="math display">\[
\begin{align*}
Cov(X_{i},X_{j})&amp;=E \left ([X_{i} - E(X_{i})]^{T} [X_{j} - E(X_{j})] \right ) \\
 &amp;= E \left ([X_{i} - E(X_{i})]^{T} X_{j} - [X_{i} - E(X_{i})]^{T} E(X_{j}) \right )\\ 
 &amp;= E \left ([X^T_{i} - E(X_{i})] X_{j} - [X^T_{i} - E(X_{i})] E(X_{j}) \right ) \\
 &amp;= E \left (X^T_{i} X_{j} - E(X_{i}) X_{j} - X^T_{i} E(X_{j}) + E(X_{i}) E(X_{j}) \right ) \\
 &amp;= E (X^T_{i} X_{j})- E(X_{i}) E(X_{j}) - E(X^T_{i}) E(X_{j}) + E(X_{i}) E(X_{j})  \\
 &amp;= E (X^T_{i} X_{j}) - E(X^T_{i}) E(X_{j})  \\
 &amp;= E (X^T_{i} X_{j}) - E(X_{i}) E(X_{j})  
\end{align*}
\]</span></p>
<p>　　由于 <span class="math inline">\(X_{i}, X_{j}\)</span> 独立时：<span class="math inline">\(E(X^T_{i} X_{j})=E(X^T_{i})E(X_{j})=E(X_{i})E(X_{j})\)</span> （证明请参考其他资料）。故 <span class="math inline">\(Cov(X_{i},X_{j})=0\)</span> 。</p>
<p>　　这时，协方差矩阵就变成一个对角矩阵了：</p>
<p><span class="math display">\[
Cov(X)=\begin{bmatrix} Cov(X_{1},X_{1}) &amp; 0\\ 0 &amp; Cov(X_{n},X_{n}) \end{bmatrix}
\]</span></p>
<p>　　如果觉得符号比较乱，可以简单的令 $ A=X_{i}, B=X_{j} $，上述公式可以写为：</p>
<p><span class="math display">\[
Cov(A,B)=E \left ([A - E(B)]^{T} [B - E(B)] \right ) = E (A^T B) - E(A) E(B)  
\]</span></p>
<p>　　推导中应用的矩阵性质：</p>
<p>　　矩阵转置性质：$ (A+B)^{T} = A^T + B^T $</p>
<p>　　矩阵乘法分配率：$ (A+B)C = AC + BC $</p>
<p>　　矩阵转置的期望值（<span class="math inline">\(E(A^T)\)</span> 实数）与其本身期望值（<span class="math inline">\(E(A)\)</span>）相等：$ E(A^T) = E(A) $ 。</p>
<p>　　期望值（实数）的期望值仍然是一个实数：$ E[E(A)] = E(A) $</p>
<p>　　随机变量和的期望值（实数）等于期望值的和：$ E[A+B] = E(A) + E(B) $</p>
<h3 id="协方差矩阵的应用">7、协方差矩阵的应用</h3>
<p>　　参见：<a href="/2019/07/31/2019-07-31_pca-ica/" title="主成分分析与独立成分分析">主成分分析与独立成分分析</a></p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html">numpy文档：np.var</a></li>
<li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.cov.html">numpy文档：np.cov</a></li>
<li><a href="http://jermmy.xyz/2017/03/19/2017-3-19-covariance-matrix/">协方差矩阵</a></li>
<li><a href="https://www.cnblogs.com/weiyinfu/p/10693445.html">numpy中的方差、协方差、相关系数</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>协方差矩阵</tag>
        <tag>PCA</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译：协方差矩阵的几何解释</title>
    <url>/2019/07/28/2019-07-28_geometric-interpretation-covariance-matrix/</url>
    <content><![CDATA[<h2 id="译序">0、译序</h2>
<p>　　Google时，发现了这一篇文章的译文，然而完全看不懂译文的意思，遂找到原文对照阅读，最后有了重新翻译一遍的想法。</p>
<p>　　本文结合直观的图形解释，说明了协方差矩阵实质上是一个线性变换，主要思想有如下几点：</p>
<ol type="1">
<li>协方差矩阵是怎么来的：方差表征了沿特征轴方向的离散度，但无法表征特征间的相关性，因此引入协方差来进行描述这种相关性；</li>
<li>线性变换由旋转和缩放组成，通过特征值分解的方法可以导出，协方差矩阵等价于对原特征空间的白数据做了一个线性变换；</li>
<li>协方差矩阵的最大特征值对应的特征向量，总是指向方差最大的方向；次最大特征值对应的特征向量，正交于最大特征值对应的特征向量，并指向次最大方差指向的方向。</li>
</ol>
<span id="more"></span>
<h2 id="引言">1、引言</h2>
<p>　　本文通过研究线性变换，及变换后得到数据的协方差(Covariance)之间的关系，给出了协方差矩阵的一个直观图形解释。大部分教材是根据协方差矩阵的概念解释数据的形状。我们反其道而行之，通过数据的形状来阐述协方差矩阵的概念。</p>
<p>　　在<a href="https://www.visiondummy.com/2014/03/divide-variance-n-1/">《为什么样本方差除以N-1？》</a>文章中，我们讨论了方差(Variance)的概念，给出了著名的样本方差估算公式的推导和证明。如图1所示，标准差（方差的平方根）表明了数据在特征空间中的离散度。 <img src="/2019/07/28/2019-07-28_geometric-interpretation-covariance-matrix/fig01.png" class=""> 　　式 <span class="math inline">\((\ref{Unbiased})\)</span> 给出了样本方差的无偏估计： <span class="math display">\[
\begin{equation} 
\begin{split}   
\sigma^2_x &amp;= \frac{1}{N-1}\sum^N_{i=1}(x_i-\mu)^2  \\
&amp;=E[(x-E(x))(x-E(x))]   \\
&amp;=\sigma(x,x)   \\
\end{split}
\label{Unbiased} \end{equation} 
\]</span> 　　不过，方差只能说明数据在平行于特征空间坐标轴方向上的离散度。考虑如图2所示的二维特征空间：</p>
<img src="/2019/07/28/2019-07-28_geometric-interpretation-covariance-matrix/fig02.png" class="">
<p>　　对图2中的数据，我们可以计算 <span class="math inline">\(x\)</span> 轴方向上的方差 <span class="math inline">\(\sigma(x,x)\)</span>，和 <span class="math inline">\(y\)</span> 轴方向上的方差<span class="math inline">\(\sigma(y,y)\)</span>。但是，数据在水平和垂直方向上的离散度，无法解释数据呈对角线分布的特点。图2中可以很清楚地看到，总体来说，数据点 <span class="math inline">\(x\)</span> 值增加，其 <span class="math inline">\(y\)</span> 值也增加，即正相关性。这种相关性，可通过推广方差的概念，得到所谓的“协方差”： <span class="math display">\[
\sigma(x,y)=E[(x-E(x))(y-E(y))] 
\]</span> 　　对二维数据，可以得到 <span class="math inline">\(\sigma(x,x)\)</span> 、 <span class="math inline">\(\sigma(y,y)\)</span> 、 <span class="math inline">\(\sigma(x,y)\)</span> 和 <span class="math inline">\(\sigma(y,x)\)</span> 。这四个值构成的矩阵，称为协方差矩阵： <span class="math display">\[
\Sigma = 
\begin{bmatrix}
\sigma(x,x)&amp;  \sigma(x,y) \\
\sigma(y,x)&amp;  \sigma(y,y) \\
\end{bmatrix}
\]</span></p>
<p>　　由于 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(y\)</span> 的相关性，等价于 <span class="math inline">\(y\)</span> 与 <span class="math inline">\(x\)</span> 的相关性。也就是说，<span class="math inline">\(\sigma(x,y) = \sigma(y,x)\)</span>。因此，协方差矩阵，始终是一个由位于对角线上的方差和非对角线上的协方差构成的对称矩阵。二维的正态分布特性，可以用均值及 <span class="math inline">\(2 \times 2\)</span> 协方差矩阵完整描述。同样， <span class="math inline">\(3 \times 3\)</span> 协方差矩阵，可用于描述三维数据， <span class="math inline">\(N \times N\)</span> 协方差矩阵可以描述 <span class="math inline">\(N\)</span> 维数据。</p>
<p>　　图3展示了数据的整体形状和协方差矩阵的关系： <img src="/2019/07/28/2019-07-28_geometric-interpretation-covariance-matrix/fig03.png" class=""></p>
<h2 id="协方差矩阵的特征值分解">2、协方差矩阵的特征值分解</h2>
<p>　　下一节，讨论协方差矩阵是如何作为一个线性算子，将白数据(white data)转换为观测数据。不过，在进入技术细节前，直观理解特征向量和特征值如何唯一地定义协方差矩阵和数据形状，非常重要。</p>
<p>　　如图3所示，协方差矩阵定义了数据的离散程度（方差）和走向（orientation）（协方差）。因此，可以简单的使用指向最大离散度方向的向量和其值（该值等于这个方向上的方差），表示协方差矩阵。</p>
<p>　　定义向量 <span class="math inline">\(\vec{v}\)</span> ，将数据<span class="math inline">\(D\)</span>投影到该向量后得到 <span class="math inline">\(\vec{v}^T D\)</span> ，投影后数据的方差为 <span class="math inline">\(\vec{v}^T \Sigma \vec{v}\)</span> 。为了获得指向最大方差方向的向量 <span class="math inline">\(\vec{v}\)</span>，需要找到使投影后数据的协方差矩阵 <span class="math inline">\(\vec{v}^T \Sigma \vec{v}\)</span> 最大的成分。当 <span class="math inline">\(\vec{v}\)</span> 为归一化单位向量时，求解关于向量 <span class="math inline">\(\vec{v}\)</span> 的函数 <span class="math inline">\(\vec{v}^T \Sigma \vec{v}\)</span> 的最大值，可以用使用最大化<a href="https://en.wikipedia.org/wiki/Rayleigh_quotient">瑞利熵</a>方法。当<span class="math inline">\(\vec{v}\)</span>等于协方差矩阵<span class="math inline">\(\Sigma\)</span>的最大特征向量时，瑞利熵最大。</p>
<blockquote>
<p>　　<strong>说明1</strong>，数学习惯上使用列向量表示一个基向量，例如平面坐标系的两个基向量<span class="math inline">\(\vec{x}\)</span>和<span class="math inline">\(\vec{y}\)</span>分别表示为<span class="math inline">\([1,0]^T\)</span>和<span class="math inline">\([0,1]^T\)</span>。机器学习中则习惯使用行向量表示一个样本（行数即为样本数），即基向量是一个行向量，如：<span class="math inline">\([1,0]\)</span>。</p>
</blockquote>
<blockquote>
<p>　　<strong>说明2</strong>，向量<span class="math inline">\(\vec{d_1}\)</span>在向量<span class="math inline">\(\vec {v_1}\)</span>上的投影，就是两个向量的内积<span class="math inline">\(\vec{v_1}^T \cdot \vec{d_1}\)</span>，向量均使用列向量形式表示。如果是向量<span class="math inline">\(\vec{d_1}\)</span>分别在向量<span class="math inline">\(\vec {v_1}\)</span>和<span class="math inline">\(\vec {v_2}\)</span>上投影，那么只需要简单的将两个向量组成一个矩阵，<span class="math inline">\(V = [v_1, v_2]\)</span>，然后继续点乘： <span class="math inline">\(V^T d_1\)</span>。再推广下，如果是<span class="math inline">\(n\)</span>个向量构成的样本<span class="math inline">\(D\)</span>：<span class="math inline">\(D = [d_1,d_2,\cdots, d_n]\)</span>，则数据集<span class="math inline">\(D\)</span>在向量空间<span class="math inline">\(V\)</span>的投影可以表示为： <span class="math display">\[
D^{&#39;} =  V^T D
\]</span> 　　因此，协方差矩阵<span class="math inline">\(\Sigma\)</span>向量空间<span class="math inline">\(V\)</span>中的投影矩阵为<span class="math inline">\(\Sigma^{&#39;}=V^T \Sigma\)</span>，对角线元素为方差。则对应于<span class="math inline">\(\vec{v_1}\)</span>的方差为<span class="math inline">\(\Sigma^{&#39;} v_1=V^T \Sigma v_1\)</span></p>
</blockquote>
<p>　　换句话说，协方差矩阵的最大特征值对应的特征向量，总是指向方差最大的方向。第二大特征值对应的特征向量，正交于最大特征值对应的特征向量，并指向第二大方差指向的方向。</p>
<p>　　现在，让我们来看一些例子。在《特征值和特征向量》(<a href="https://www.visiondummy.com/2014/03/eigenvalues-eigenvectors/">原文</a>，<a href="http://blog.csdn.net/u010182633/article/details/45921929">译文</a>)中，线性变换矩阵 <span class="math inline">\(T\)</span> 仅由特征向量和特征值确定。将其应用于协方差矩阵（注：协方差矩阵相当于两个特征向量之间的线性变换，可以通过特征方程求出特征向量和特征值）： <span class="math display">\[
\begin{equation} 
\Sigma \vec{v}=\lambda \vec{v}  \qquad \qquad （\vec{v} 为 \Sigma 的属于特征值 \lambda 的特征向量）
\label {CovMatrix}
\end{equation} 
\]</span></p>
<p>　　如果协方差矩阵是对角矩阵，即协方差部分为零，则方差必然等于特征值 <span class="math inline">\(\lambda\)</span>。如图4所示，特征向量用绿色和红色表示，特征值明显等于协方差矩阵的方差分量。 <img src="/2019/07/28/2019-07-28_geometric-interpretation-covariance-matrix/fig04.png" class=""></p>
<p>　　如果协方差矩阵是非对角矩阵，即协方差部分不为零，则情况稍微复杂一些。特征值仍是最大离散方向的方差，协方差矩阵的对角线（方差）分量，仍然是 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span> 轴方向的方差大小。但因为数据是非轴对齐（最大方差对应的向量与x/ <span class="math inline">\(y\)</span> 轴有一个夹角），所以协方差矩阵对角线上的值不再与图5所示的相同。 <img src="/2019/07/28/2019-07-28_geometric-interpretation-covariance-matrix/fig05.png" class=""></p>
<p>　　比较图5与图4，可以清楚地看到，特征值表示沿特征向量方向的方差，而协方差矩阵的方差分量表示沿轴的方差。如果协方差为0，则两个值相等。</p>
<h2 id="使用协方差矩阵作线性变换">3、使用协方差矩阵作线性变换</h2>
<p>　　现在，暂时放一放协方差矩阵。图3中的例子，可以简单地认为是图6的一个线性变换： <img src="/2019/07/28/2019-07-28_geometric-interpretation-covariance-matrix/fig06.png" class=""></p>
<p>　　令图6中数据为 <span class="math inline">\(D\)</span> ，则图3中的各示例可以通过对 <span class="math inline">\(D\)</span> 做线性变换得到： <span class="math display">\[
D^{&#39;}=TD
\]</span> 　　其中，<span class="math inline">\(T\)</span> 是含有旋转矩阵 <span class="math inline">\(R\)</span> 和缩放矩阵 <span class="math inline">\(S\)</span> 的变换矩阵： <span class="math display">\[
\begin{equation}
T=RS
\label {matrixT}
\end {equation}
\]</span></p>
<p>　　矩阵 <span class="math inline">\(R\)</span> 和 <span class="math inline">\(S\)</span> 的定义如式 <span class="math inline">\((\ref{matrixR})\)</span> 和式 <span class="math inline">\((\ref{matrixS})\)</span>： <span class="math display">\[
\begin{align}
R &amp;= \begin{bmatrix}
cos(\theta) &amp; -sin(\theta) \\
sin(\theta) &amp; cos(\theta) 
\end{bmatrix}
\label {matrixR} \\
S &amp;= \begin{bmatrix}
s_x &amp; 0 \\
0 &amp; s_y \\
\end{bmatrix}
\label {matrixS}
\end{align}
\]</span> 　　式 <span class="math inline">\((\ref{matrixR})\)</span> 中， <span class="math inline">\(\theta\)</span> 为旋转角度。式 <span class="math inline">\((\ref{matrixS})\)</span> 中， <span class="math inline">\(s_x\)</span> 、 <span class="math inline">\(s_y\)</span> 分别是 <span class="math inline">\(x\)</span> 方向和 <span class="math inline">\(y\)</span> 方向的缩放比例因子。</p>
<p>　　接下来讨论，协方差矩阵 <span class="math inline">\(\Sigma\)</span> 和线性变换矩阵 <span class="math inline">\(T\)</span> 之间的关系。</p>
<p>　　先从无缩放（缩放比例为1）、无旋转数据开始。此类样本服从标准正态分布，对应于白（非相关）噪声，统计学习惯称之为“白数据”： <img src="/2019/07/28/2019-07-28_geometric-interpretation-covariance-matrix/fig07.png" class=""></p>
<p>　　“白”数据的协方差矩阵，等于单位矩阵，因此方差和标准差为1，协方差等于0： <span class="math display">\[
\Sigma=
\begin{bmatrix}
\sigma^2_x &amp; 0      \\
0      &amp; \sigma^2_y \\
\end{bmatrix}
=\begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1 \\
\end{bmatrix}
\]</span></p>
<p>　　现在，对 <span class="math inline">\(x\)</span> 方向乘4： <span class="math display">\[
D^{&#39;}=
\begin{bmatrix}
4 &amp; 0 \\
0 &amp; 1 \\
\end{bmatrix}
D
\]</span></p>
<p>　　则变换后的数据 <span class="math inline">\(D^{&#39;}\)</span> 如图8所示： <img src="/2019/07/28/2019-07-28_geometric-interpretation-covariance-matrix/fig08.png" class=""></p>
<p>　　 <span class="math inline">\(D^{&#39;}\)</span> 的协方差矩阵 <span class="math inline">\(\Sigma^{&#39;}\)</span> 为： <span class="math display">\[
\Sigma^{&#39;}=
\begin{bmatrix}
\sigma^2_x &amp; 0 \\
0 &amp; \sigma^2_y \\
\end{bmatrix}
=\begin{bmatrix}
16 &amp; 0 \\
0 &amp; 1 \\
\end{bmatrix}
\]</span></p>
<p>　　故 <span class="math inline">\(D^{&#39;}\)</span> 的协方差矩阵 <span class="math inline">\(\Sigma^{&#39;}\)</span> ，与作用在原始数据上的线性变换矩阵<span class="math inline">\(T\)</span>的关系为 <span class="math inline">\(D^{&#39;}=TD\)</span>，这里: <span class="math display">\[
\begin{equation}
T=\sqrt{\Sigma^{&#39;}}=
\begin{bmatrix}
4 &amp; 0 \\
0 &amp; 1 \\
\end{bmatrix}
\label {transformMatrix}
\end{equation}
\]</span></p>
<p>　　式 <span class="math inline">\((\ref {transformMatrix})\)</span> 在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 方向上进行缩放变换时成立，但该式是否可用于旋转变换？考虑一般情况下，线性变换矩阵 <span class="math inline">\(T\)</span> 和协方差矩阵 <span class="math inline">\(\Sigma^{&#39;}\)</span> 之间的关系，我们将协方差矩阵分解为旋转和缩放矩阵的乘积。</p>
<p>　　如前所述，协方差矩阵可以用特征向量和特征值表示，式 <span class="math inline">\((\ref {CovMatrix})\)</span> 包括了矩阵 <span class="math inline">\(\Sigma\)</span> 的每一个“特征向量-特征值”对。在二维情况下，有2个特征向量和2个特征值。矩阵可以有效的描述式 <span class="math inline">\((\ref {CovMatrix})\)</span> 定义的两个等式关系： <span class="math display">\[
\begin{equation}
\Sigma V = VL
\label {eigenvectors}
\end{equation}
\]</span> 　　式 <span class="math inline">\((\ref {eigenvectors})\)</span> 中， <span class="math inline">\(V\)</span> 是由 <span class="math inline">\(\Sigma\)</span> 的各特征向量构成的矩阵，<span class="math inline">\(L\)</span> 为相应特征向量对应的非0特征值组成的对角矩阵。</p>
<p>　　解得协方差矩阵： <span class="math display">\[
\begin{equation}
\Sigma = VLV^{-1}
\label {Eigendecomposition}
\end{equation}
\]</span></p>
<p>　　式 <span class="math inline">\((\ref {Eigendecomposition})\)</span> 称为协方差矩阵的特征值分解，可通过<strong><a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">奇异值分解(SVD)</a></strong>算法求解。由于特征向量表示了最大方差的方向，特征值表示该方向上方差的值。也就是说，<span class="math inline">\(V\)</span> 就是旋转矩阵，而 <span class="math inline">\(\sqrt{L}\)</span> 就是缩放矩阵。协方差矩阵可进一步分解为： <span class="math display">\[
\begin{equation}
\Sigma = RSSR^{-1}
\label {cov_decompose}
\end{equation}
\]</span> 　　式中，<span class="math inline">\(R=V\)</span> 为旋转矩阵，<span class="math inline">\(S=\sqrt{L}\)</span>为缩放矩阵。式<span class="math inline">\((\ref {matrixT})\)</span> 定义了线性变换 <span class="math inline">\(T\)</span> ( <span class="math inline">\(T=RS\)</span> ) 。因为 <span class="math inline">\(S\)</span> 为对角缩放矩阵，故 <span class="math inline">\(S=S^T\)</span>。另外， <span class="math inline">\(R\)</span> 为正交矩阵，所以 <span class="math inline">\(R^{-1}=R^T\)</span> 。从而，协方差矩阵可以写为： <span class="math display">\[
\Sigma=RSSR^{-1}=(RS)(SR^{-1})=(RS)(S^{T}R^{T})=(RS)(RS)^{T}=TT^T
\]</span></p>
<p>　　也就是说，对图7中的原始“白”数据 <span class="math inline">\(D\)</span> 使用线性变换 <span class="math inline">\(T\)</span> ( <span class="math inline">\(T=RS\)</span> )，即可得到旋转和缩放后的数据 <span class="math inline">\(D^{&#39;}\)</span>及其协方差矩阵 <span class="math inline">\(\Sigma^{&#39;}\)</span> （ <span class="math inline">\(\Sigma^{&#39;}=TT^{T}=RSSR^{-1}\)</span> ），如图10所示： <img src="/2019/07/28/2019-07-28_geometric-interpretation-covariance-matrix/fig10.png" class=""></p>
<p>　　图10中彩色箭头表示特征向量。与最大特征值对应的特征向量，总是指向数据最大方差的方向，并规定了其走向（orientation）。由旋转矩阵的正交性，次最大特征值对应的特征向量，总是与最大特征值对应的特征向量正交。</p>
<h2 id="总结">4、总结</h2>
<p>　　本文说明了，被观测数据的协方差矩阵，直接与针对白（非相关）数据的线性变换有关。该线性变换完全由特征向量和特征值定义。特征向量表示了矩阵的旋转，特征值对应于每个维度上缩放因子的平方。</p>
<h2 id="补充说明">5、补充说明</h2>
<h3 id="线性变换特征值和特征向量">线性变换、特征值和特征向量</h3>
<p>　　<a href="https://en.wikipedia.org/wiki/Linear_map">线性变换(线性映射)</a>，表征了向量在两个向量空间之间变换的一种映射关系，它保持向量加法和标量乘法的运算，向量加法对应于旋转矩阵，标量乘法对应于缩放矩阵。</p>
<p>　　<a href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors">特征值和特征向量</a>是一体的概念：</p>
<blockquote>
<p>对于一个给定的线性变换，其特征向量 <span class="math inline">\(\xi\)</span> 经过该线性变换之后，得到的新向量仍然与原来的 <span class="math inline">\(\xi\)</span> 保持在同一条直线上，但其长度可能会改变。一个特征向量的长度在该线性变换下的缩放比例，称为其特征值（本征值）。</p>
</blockquote>
<p>　　数学描述如下： <span class="math display">\[
A \xi=\lambda \xi
\]</span> 　　在线性变换 <span class="math inline">\(A\)</span> 的作用下，向量 <span class="math inline">\(\xi\)</span> 仅仅在尺度上变为原来的 <span class="math inline">\(\lambda\)</span> 倍。<span class="math inline">\(\lambda\)</span>称为特征值，<span class="math inline">\(\xi\)</span>称为线性变换<span class="math inline">\(A\)</span>的属于特征值<span class="math inline">\(\lambda\)</span>的特征向量。</p>
<p>　　矩阵 <span class="math inline">\(A\)</span> 的非零特征值最大数目是该矩阵的秩 <span class="math inline">\(rank(A)\)</span> 。对于每个特征值 <span class="math inline">\(\lambda_i\)</span> 均满足特征方程(Characteristic equation) <span class="math inline">\((A−\lambda_{i}I)\xi=0\)</span> 。</p>
<p>　　简言之，特征向量和特征值表达了线性变换的针对的对象和大小，两者一一对应，成对出现。在物理上，特征值表明线性变换对基向量的缩放程度，特征向量表明线性变换针对的基向量方向，同时特征向量之间是线性无关的。</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="http://www.visiondummy.com/2014/04/geometric-interpretation-covariance-matrix/">A geometric interpretation of the covariance matrix</a></li>
<li><a href="http://demo.netfoucs.com/u010182633/article/details/45937051">协方差矩阵的几何解释</a></li>
<li><a href="http://blog.jqian.net/post/pca.html">特征值分解和主成份分析</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>协方差矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之点点滴滴</title>
    <url>/2019/09/22/2019-09-22_cpp_basic/</url>
    <content><![CDATA[<p>记录C++语法的点点滴滴</p>
<span id="more"></span>
<h2 id="新式类型转换">1.新式类型转换</h2>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>static_cast</code></td>
<td>用于兼容类型转换，如整型和浮点型、字符型之间的互相转换。</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>const_cast</code></td>
<td>仅用于进行去除 const 属性的转换</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>reinterpret_cast</code></td>
<td>用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>dynamic_cast</code></td>
<td>专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针</td>
</tr>
</tbody>
</table>
<p><code>xxxxxx_cast&lt;T2&gt;T1</code>:</p>
<ul>
<li>语法：<code>xxxxxx_cast&lt;类型2&gt;(类型1变量)</code></li>
<li>功能：将指针变量由类型1转换为类型2</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下都是合法的转换</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">const</span> uchar *&gt;(p)         <span class="comment">// p 类型为 uchar*</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(p)                <span class="comment">// p 类型为 int</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;uchar *&gt;(p)                <span class="comment">// p 类型为 const uchar*</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> uchar *&gt;(p);   <span class="comment">// p 类型为 uchar*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="static_cast示例">1.1 <code>static_cast</code>示例：</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">char</span>*() &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span>* p = <span class="string">&quot;New Dragon Inn&quot;</span>;</span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (<span class="number">3.14</span>);  <span class="comment">// n 的值变为 3</span></span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (a);     <span class="comment">//调用 a.operator int，n 的值变为 1</span></span><br><span class="line">    p = <span class="keyword">static_cast</span> &lt;<span class="type">char</span>*&gt; (a);   <span class="comment">//调用 a.operator char*，p 的值变为 NULL</span></span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (p);     <span class="comment">//编译错误，static_cast不能将指针转换成整型</span></span><br><span class="line">    p = <span class="keyword">static_cast</span> &lt;<span class="type">char</span>*&gt; (n);   <span class="comment">//编译错误，static_cast 不能将整型转换成指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reinterpret_cast示例">1.2 <code>reinterpret_cast</code>示例：</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n):<span class="built_in">i</span>(n),<span class="built_in">j</span>(n) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> &amp;r = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>&amp;&gt;(a);	    <span class="comment">//强行让 r 引用 a</span></span><br><span class="line">    r = <span class="number">200</span>;                                <span class="comment">//把 a.i 变成了 200</span></span><br><span class="line">    cout &lt;&lt; a.i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.j &lt;&lt; endl;      <span class="comment">// 输出 200,100</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">300</span>;</span><br><span class="line">    A *pa = <span class="built_in">reinterpret_cast</span>&lt;A*&gt; ( &amp; n);    <span class="comment">//强行让 pa 指向 n</span></span><br><span class="line">    pa-&gt;i = <span class="number">400</span>;                            <span class="comment">// n 变成 400</span></span><br><span class="line">    pa-&gt;j = <span class="number">500</span>;                            <span class="comment">//此条语句不安全，很可能导致程序崩溃</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;                      <span class="comment">// 输出 400</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> la = <span class="number">0x12345678abcd</span>LL;</span><br><span class="line">    pa = <span class="built_in">reinterpret_cast</span>&lt;A*&gt;(la);          <span class="comment">//la太长，只取低32位0x5678abcd拷贝给pa</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> u = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(pa);        <span class="comment">//pa逐个比特拷贝到u</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; u &lt;&lt; endl;               <span class="comment">//输出 5678abcd</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* PF1)</span> <span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* PF2)</span> <span class="params">(<span class="type">int</span>,<span class="type">char</span> *)</span></span>;</span><br><span class="line">    PF1 pf1;  PF2 pf2;</span><br><span class="line">    pf2 = <span class="built_in">reinterpret_cast</span>&lt;PF2&gt;(pf1);       <span class="comment">//两个不同类型的函数指针之间可以互相转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 200, 100</span></span><br><span class="line"><span class="comment">// 400</span></span><br><span class="line"><span class="comment">// 5678abed</span></span><br></pre></td></tr></table></figure>
<h3 id="const_cast示例">1.3 <code>const_cast</code>示例</h3>
<h3 id="dynamic_cast示例">1.4 <code>dynamic_cast</code>示例</h3>
<p><code>reinterpret_cast</code> 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。<code>dynamic_cast</code>专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。</p>
<p>如果类型转换成功，则 <code>dynamic_cast</code> 返回 <code>新类型</code> 的值。若转换失败且<code>新类型</code>是指针类型，则它返回该类型的空指针。若转型失败且<code>新类型</code>是引用类型，则它抛出与类型 <code>std::bad_cast</code> 的处理块匹配的异常。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">// 必须为多态以使用运行时检查的 dynamic_cast</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> : <span class="keyword">virtual</span> V &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> V &#123;</span><br><span class="line">  <span class="built_in">B</span>(V* v, A* a) &#123;</span><br><span class="line">    <span class="comment">// 构造中转型（见后述 D 的构造函数中的调用）</span></span><br><span class="line">    <span class="built_in">dynamic_cast</span>&lt;B*&gt;(v); <span class="comment">// 良好定义：v 有类型 V*，B 的 V 基类，产生 B*</span></span><br><span class="line">    <span class="built_in">dynamic_cast</span>&lt;B*&gt;(a); <span class="comment">// 未定义行为：a 有类型 A*，A 非 B 的基类</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : A, B &#123;</span><br><span class="line">    <span class="built_in">D</span>() : <span class="built_in">B</span>((A*)<span class="keyword">this</span>, <span class="keyword">this</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d; <span class="comment">// 最终派生对象</span></span><br><span class="line">    A&amp; a = d; <span class="comment">// 向上转型，可以用 dynamic_cast，但不必须</span></span><br><span class="line">    D&amp; new_d = <span class="built_in">dynamic_cast</span>&lt;D&amp;&gt;(a); <span class="comment">// 向下转型</span></span><br><span class="line">    B&amp; new_b = <span class="built_in">dynamic_cast</span>&lt;B&amp;&gt;(a); <span class="comment">// 侧向转型</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    Base* b1 = <span class="keyword">new</span> Base;</span><br><span class="line">    <span class="keyword">if</span>(Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b1))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;downcast from b1 to d successful\n&quot;</span>;</span><br><span class="line">        d-&gt;<span class="built_in">name</span>(); <span class="comment">// 可以安全调用</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Base* b2 = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">if</span>(Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b2))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;downcast from b2 to d successful\n&quot;</span>;</span><br><span class="line">        d-&gt;<span class="built_in">name</span>(); <span class="comment">// 可以安全调用</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> b1;</span><br><span class="line">    <span class="keyword">delete</span> b2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;  <span class="comment">//有虚函数，因此是多态基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line">    Derived* pd;</span><br><span class="line">    pd = <span class="keyword">reinterpret_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//此处pd不会为 NULL。reinterpret_cast不检查安全性，总是进行转换</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe reinterpret_cast&quot;</span> &lt;&lt; endl;	<span class="comment">//不会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)					<span class="comment">//结果会是NULL，因为 &amp;b 不指向派生类对象，此转换不安全</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast1&quot;</span> &lt;&lt; endl;		<span class="comment">//会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;d);			<span class="comment">//安全的转换</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)					<span class="comment">//此处 pd 不会为 NULL</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast2&quot;</span> &lt;&lt; endl;		<span class="comment">//不会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>主成分分析与独立成分分析</title>
    <url>/2019/07/31/2019-07-31_pca-ica/</url>
    <content><![CDATA[<p>　　<a href="https://en.wikipedia.org/wiki/Principal_component_analysis">主成分分析</a>(Principle Component Analysis, PCA)和<a href="https://en.wikipedia.org/wiki/Independent_component_analysis">独立成分分析</a>(Independent Components Analysis, ICA)，是目前应用最为广泛的机器学习数据预处理的手段之一。</p>
<p>　　PCA，顾名思义，取信号中的最为主要的成分，对非重要部分进行去除，从而达到数据降维的目的，避免<a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality">维度灾难</a>。PCA只对符合高斯分布的样本较为有效。</p>
<p>　　ICA，是<a href="https://en.wikipedia.org/wiki/Signal_separation">盲源分离(Blind source separation, BSS)</a>的一个特例，来源于“鸡尾酒会问题”，如果被观测信号由若干个统计独立的分量的线性组合（混合信号），ICA的目的是将被观测信号解混为若干独立信号源，从而对感兴趣的信号进行处理。</p>
<span id="more"></span>
<h2 id="pca">1、PCA</h2>
<h3 id="一个简单的例子">1.1 一个简单的例子</h3>
<p>　　二维平面上有若干个样本点，现在希望使用1维坐标对其进行降维处理，同时又希望尽量保留原始的信息，如何实现？ <img src="/2019/07/31/2019-07-31_pca-ica/fig01.png" class="" title="图1.二维样本的降维处理"></p>
<h3 id="最大方差理论">1.2 最大方差理论</h3>
<p>　　最懒的一种降维方法，直接将数据点投影至<span class="math inline">\(x\)</span>/<span class="math inline">\(y\)</span>坐标轴。这样处理的结果会使得样本叠加，导致有效样本减少，从而丢失信息。例如，所有的样本投影至<span class="math inline">\(x\)</span>上，此时横坐标上只有3个点，这就造成了原始样本丢失的情况。更为极端的一个例子，如果5个点的横坐标均相同，则投影后只剩下1个点（此时各点在<span class="math inline">\(x\)</span>轴的方差为0）。如果选择<span class="math inline">\(y=x\)</span>作为基准坐标轴，可以发现，5个点的信息都会被保留下来。可以看出，方差是衡量样本信息量的关键指标。 <img src="/2019/07/31/2019-07-31_pca-ica/fig02.gif" class="" title="图2.基向量与方差的关系"> 　　从信号处理的角度来说，一个随机信号最有用的信息体包含在方差里，<strong>方差越大，信号所包含的信息量越多</strong>。另一方面，样本的多样性，是保证机器学习算法能够有效学习到特征的前提条件，而方差即为反应样本多样性的关键指标。如图2所示，基向量不同，样本在基向量上的投影长度（方差）不同。设想一组由10个方差为0的数据构成的样本，方差为0说明这10个数据完全相等，故实际有效的样本仅为1个。因此<strong>最大化方差，即意味着最大化样本的多样性</strong>。图1中，样本在<span class="math inline">\(x&#39;\)</span>轴上的投影方差较大，在<span class="math inline">\(y&#39;\)</span>轴上的投影方差较小。当希望将样本数据从二维降至一维时，可以认为选择<span class="math inline">\(x&#39;\)</span>轴丢失的信息量较少，是较为合理的选择。</p>
<p>　　因此，如果需要对<span class="math inline">\(n\)</span>维特征数据进行降维处理，如果能够找到<span class="math inline">\(k (k&lt;n)\)</span>维特征，使得<span class="math inline">\(\sum_{i=1}^{k} \sigma_{i}^{(k)} \approx \sum_{i=1}^{n} \sigma_{i}^{(n)}\)</span>，那么<span class="math inline">\((n-k)\)</span>维数据都属于冗余数据，可以丢弃，从而使计算量大大下降。</p>
<p>　　这里有2个问题：</p>
<ol type="1">
<li>如何使得所选维度上方差最大？</li>
<li>在找到第一个维度之后，如何找第二个使得方差最大的维度，且与前一个维度线性无关？</li>
</ol>
<h3 id="pca方法">1.3 PCA方法</h3>
<p>　　PCA在数学上定义为，一个将原数据变换到新坐标系统下的线性变换，要求原数据投影后，最大方差位于第一坐标轴上（称为第一主成分），第二大方差位于第二坐标轴上（第二主成分），以此类推。</p>
<p>　　以一个随机信号<span class="math inline">\(\vec{x}=\left [ x_1,\cdots,x_p \right ]\)</span>为例，PCA的基本思想是找到一个向量<span class="math inline">\(\vec{w}_1\)</span>，使得随机信号在该方向上的投影的方差<span class="math inline">\(\left (\vec{w}^T_1 \vec{x} \right )\)</span>最大。然后，在与<span class="math inline">\(\vec{w}_1\)</span>向量正交的空间里到向量<span class="math inline">\(\vec{w}_2\)</span>，使得信号在<span class="math inline">\(\vec{w}_2\)</span>投影的方差<span class="math inline">\(\left (\vec{w}^T_2 \vec{x} \right )\)</span>最大，以此类推直到找到所有向量，用这种方法我们最终可以得到一列非相关的随机变量<span class="math inline">\(\left [\vec{w}^T_1 \vec{x}, \cdots, \vec{w}^T_n \vec{x} \right]\)</span>。</p>
<p>　　设各特征列均值为<span class="math inline">\(0\)</span>的样本集<span class="math inline">\(X\)</span>，由<span class="math inline">\(n\)</span>个包含<span class="math inline">\(p\)</span>个特征的样本构成(注意：每行一个样本，每列一个特征)，即：</p>
<p><span class="math display">\[
X=X_{np}=       \label{eq1}
\begin{bmatrix}
x_{11}  &amp; x_{12} &amp; \cdots &amp; x_{1p} \\
x_{21}  &amp; x_{22} &amp; \cdots &amp; x_{2p} \\
\vdots  &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n1}  &amp; x_{n2} &amp; \cdots &amp; x_{np} 
\end{bmatrix}
\]</span></p>
<blockquote>
<p>　　<strong>注1</strong>：对一般样本集<span class="math inline">\(X&#39;\)</span>，可以简单的将各元素减去所在特征列的均值，即可得到特征列均值为0的样本集<span class="math inline">\(X\)</span>。记<span class="math inline">\(X&#39;\)</span>各特征列的均值为 <span class="math inline">\(\bar{X_{p}&#39;} \equiv \left [ \bar {X_{1}&#39;}, \bar {X_{2}&#39;}, \cdots, \bar {X_{p}&#39;} \right ]\)</span> ，则：</p>
</blockquote>
<p><span class="math display">\[
X \equiv X&#39; -  {\begin{bmatrix} 1&amp; \cdots &amp; 1 \\ \end{bmatrix}}^T_{n} \cdot \bar{X_{p}&#39;} \label{eq2}
\]</span></p>
<p>　　下文讨论均对去均值后的样本集<span class="math inline">\(X\)</span>展开。</p>
<p>　　对样本矩阵<span class="math inline">\(X_{n \times p}\)</span>，找到一组由基向量<span class="math inline">\(\vec{w_i}=[w_1,\cdots,w_p]^T\)</span>构成的矩阵<span class="math inline">\(W_{p \times p}\)</span>，使得<span class="math inline">\(Y=X W\)</span>，其中：</p>
<ul>
<li><span class="math inline">\(Y\)</span>各分量线性无关；</li>
<li><span class="math inline">\(Y_1, \cdots,Y_p\)</span>的方差递减；</li>
<li>构成矩阵<span class="math inline">\(W\)</span>的各基向量<span class="math inline">\(w_i\)</span>模值为<span class="math inline">\(1\)</span>，即<span class="math inline">\(\lVert w_i \rVert=1\)</span>（<span class="math inline">\(L1\)</span>范数）；</li>
</ul>
<p>　　考虑方差为协方差矩阵的对角线元素，且当各分量线性无关时，协方差为0，即满足上述条件：</p>
<p><span class="math display">\[
\begin{align*}      \label{eq3}
Var(Y) &amp;= Cov(Y) = \frac{1}{n-1}Y^T Y       \\
&amp;= \frac{1}{n-1}  (XW)^T (XW)           \\
&amp;= \frac{1}{n-1}  W^T X^T X W           \\
&amp;=   W^T \left( \frac{1}{n-1} X X^T \right ) W  \\
&amp;=  W^T Cov(X) W                \\
\end{align*}
\]</span></p>
<p>　　<span class="math inline">\(Cov(Y)\)</span>和<span class="math inline">\(Cov(X)\)</span>以及<span class="math inline">\(W\)</span>均为对称方阵(<span class="math inline">\(W^T=W^{-1}\)</span>)，从而：</p>
<p><span class="math display">\[
\begin{align*}                  \label{eq4}
Cov(Y) &amp;= W^T Cov(X) W = W^{-1} Cov(X) W \\
&amp;\Rightarrow W Cov(Y) W^{-1} = W W^{-1} Cov(X) W W^{-1}\\
&amp;\Rightarrow W Cov(Y) W^T = Cov(X)
\end{align*}
\]</span></p>
<p>　　因此上述问题等价于：求矩阵<span class="math inline">\(W\)</span>(每列为一个基向量)，使随机信号<span class="math inline">\(X\)</span>的协方差矩阵的对角化（对称矩阵变为对角矩阵）：</p>
<p><span class="math display">\[
\text{求}w\text{使}：\; \max \limits_{\lVert w \rVert=1} \{Var(W^T X) \} \;  \Leftrightarrow \; \text{求} w \text{使}：\{W^T Cov(X) W \} \text{为对角矩阵}
\]</span></p>
<p>　　常规的矩阵对角化方法，有<a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">特征值分解</a>(Eigenvalue Decomposition, EVD)，<a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">奇异值分解</a>(Singular Value Decomposition, SVD)等。其中EVD针对<span class="math inline">\(N \times N\)</span>方阵，SVD是EVD的一个推广，可以针对任意形状矩阵。</p>
<h3 id="矩阵的对角化">1.4 矩阵的对角化</h3>
<p>　　利用EVD或SVD方法，我们可以将协方差矩阵对角化，并求出相应的变化基向量矩阵。</p>
<p>　　矩阵对角化定理(Matrix diagonalization theorem)：对于<span class="math inline">\(m\)</span>维方阵<span class="math inline">\(C\)</span>，如果它有<span class="math inline">\(m\)</span>个线性无关的特征向量，那么存在一个特征分解：</p>
<p><span class="math display">\[
C = W \Lambda W^{−1}
\]</span></p>
<p>　　其中， <span class="math inline">\(W\)</span>为<span class="math inline">\(m \times m\)</span>方阵，且<span class="math inline">\(W\)</span>的第 <span class="math inline">\(i\)</span> 列为 <span class="math inline">\(C\)</span> 的特征向量<span class="math inline">\(\vec{q_i}\)</span>。<span class="math inline">\(\Lambda\)</span>是对角矩阵，其对角线上的元素为对应的特征值，即 <span class="math inline">\(\Lambda_{ii}=\lambda_i\)</span> 。</p>
<p>　　对称对角化定理(Symmetric diagonalization theorem)：更进一步，如果方阵<span class="math inline">\(C\)</span>是对称方阵，可得<span class="math inline">\(W\)</span>的每一列都是<span class="math inline">\(C\)</span>的互相正交且归一化（单位长度）的特征向量，即<span class="math inline">\(W^{−1}=W^{T}\)</span> 。</p>
<p>　　求出基向量矩阵<span class="math inline">\(W\)</span>后，特征值矩阵 $ $ 已经按照各特征值(方差)大小排列，故可以根据重要性，简单的选取前<span class="math inline">\(k\)</span>个向量即可。设需要取 <span class="math inline">\(k (1 &lt; k &lt; m)\)</span> 个基向量（例如前<span class="math inline">\(k\)</span>个特征值占全部<span class="math inline">\(p\)</span>个特征值的<span class="math inline">\(90\%\)</span>，即<span class="math inline">\(\sum^k_{i=1} \lambda_i / \sum^p_{i=1} \lambda_i &gt; 0.9\)</span>），令<span class="math inline">\(W_{p \times k}\)</span>为<span class="math inline">\(W\)</span>的前<span class="math inline">\(k\)</span>维基向量子矩阵，则变换后的数据<span class="math inline">\(Y\)</span>为：</p>
<p><span class="math display">\[ 
Y =  X W_{p \times k}
\]</span></p>
<p>　　其中，新的数据矩阵<span class="math inline">\(Y\)</span>为<span class="math inline">\(n \times k\)</span>矩阵，较原<span class="math inline">\((n \times p)\)</span>维数据矩阵<span class="math inline">\(X\)</span>，减少了<span class="math inline">\((p-k)\)</span>维，从而达到了降维的目的。</p>
<h3 id="奇异值分解">1.5 奇异值分解</h3>
<p>　　<strong>奇异值分解</strong>定义：假设<span class="math inline">\(X\)</span>是一个<span class="math inline">\(n×p\)</span>阶矩阵，其中的元素全部属于域<span class="math inline">\(K\)</span>(实数域或复数域)。如此则存在一个分解使得</p>
<p><span class="math display">\[
M=U \Sigma V^* = U \Sigma V^{T} \quad (V\text{为实矩阵})
\]</span></p>
<p>　　其中<span class="math inline">\(U\)</span>是<span class="math inline">\(n×n\)</span>阶<a href="https://en.wikipedia.org/wiki/Unitary_matrix">酉矩阵(也叫幺正矩阵)</a>；$ <span class="math inline">\(是\)</span> m n <span class="math inline">\(阶非负实数对角矩阵；\)</span>V$的<a href="https://en.wikipedia.org/wiki/Conjugate_transpose">共轭转置</a> $ V^{*} <span class="math inline">\(，是\)</span>p p<span class="math inline">\(阶酉矩阵（当\)</span>V<span class="math inline">\(为实矩阵时，\)</span>V^*=V^T<span class="math inline">\(）。这样的分解就称作\)</span>M<span class="math inline">\(的奇异值分解。\)</span><span class="math inline">\(对角线上的元素\)</span>_{i,i}<span class="math inline">\(即为\)</span>M$的奇异值。如图3所示：</p>
<img src="/2019/07/31/2019-07-31_pca-ica/fig03_svd.png" class="" title="图3.SVD分解可视化">
<p>　　设<span class="math inline">\(Cov(X)=WLW^{T}\)</span>，考虑矩阵<span class="math inline">\(X\)</span>的奇异值分解：<span class="math inline">\(X=U\Sigma V^T\)</span>，且<span class="math inline">\(\Sigma 为实对角矩阵\)</span>，则：</p>
<p><span class="math display">\[
\begin{align*}
  \left \{ 
  \begin{array}{r@{\mskip\thickmuskip}l}
    Cov(X) &amp;=&amp;  \underline{WLW^{T} }              \\
    Cov(X) &amp;=&amp; \displaystyle \frac{1}{n-1} X^{T} X    \\
    X\ &amp;=&amp;\ U \Sigma V^{T}                \\
  \end{array} \right .
  \, \implies \,  
  \begin{array}{r@{\mskip\thickmuskip}l}\\
  Cov(x) &amp;=&amp; \displaystyle \frac{1}{n-1} \left ( U\Sigma V^{T} \right )^T U\Sigma V^{T} \\
&amp;=&amp; \displaystyle V \frac{\Sigma^T \Sigma}{n-1} V^T = \underline{\displaystyle V \frac{\Sigma^2}{n-1} V^T}
\end{array}
\end{align*}
\]</span></p>
<p>　　比较式中划线部分的协方差<span class="math inline">\(Cov(X)\)</span>的表达式，可以发现：</p>
<p><span class="math display">\[
\begin{array}{r@{\mskip\thickmuskip}l}
    WLW^{T} =\displaystyle V \frac{\Sigma^2}{n-1} V^T \\
\end{array}
\; \implies \;
\left \{ 
\begin{array}{r@{\mskip\thickmuskip}l}
    W &amp;=&amp; V              &amp;\, &amp; \text{(基向量 vs 右奇异矢量)}                     \\
    L &amp;=&amp; \displaystyle \frac{1}{n-1}\Sigma^2 &amp;\, &amp; \text{(特征值 vs 奇异值)}  \\
\end{array}
\right.
\]</span></p>
<p>　　上式说明，奇异值分解后的右奇异矢量与特征向量是一样的，即主成分方向向量；特征值矩阵<span class="math inline">\(L\)</span>和奇异值矩阵<span class="math inline">\(\Sigma\)</span>之间的关系为<span class="math inline">\(\lambda_{i} = \Sigma^2_{ii}/(n-1)\)</span>。主成分由<span class="math inline">\(XV = USV^T V= US\)</span>给出。</p>
<h3 id="pca的计算">1.6 PCA的计算</h3>
<p>　　特征值分解和奇异值分解均能实现PCA功能，以下代码使用SVD方法进行： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> decomposition</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pca</span>(<span class="params">data,threshs=<span class="number">0.9</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        实现pca降维，行向量为样本数，列向量为特征数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 去均值</span></span><br><span class="line">    data = data - data.mean(axis=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># SVD分解</span></span><br><span class="line">    _,s,vh = np.linalg.svd(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 由奇异值求特征值</span></span><br><span class="line">    s = s*s/(data.shape[<span class="number">0</span>]-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算特征值累积占比</span></span><br><span class="line">    <span class="comment"># print(&#x27;特征值累积占比:&#x27;)</span></span><br><span class="line">    cum =np.cumsum(s)/s.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="comment">#print(cum)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 寻找距离阈值最小的索引</span></span><br><span class="line">    k = np.argmin(np.<span class="built_in">abs</span>(cum-threshs))</span><br><span class="line"></span><br><span class="line">    k = k + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data.dot(vh.T[:,:k])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sk_pca</span>(<span class="params">data,ncoms=<span class="number">1</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    使用sklearn函数求解pca</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    data = data-data.mean(axis=<span class="number">0</span>)</span><br><span class="line">    dec = decomposition.PCA(n_components=ncoms)</span><br><span class="line">    dec.fit(data)</span><br><span class="line">    <span class="comment"># print(dec.singular_values_)</span></span><br><span class="line">    <span class="keyword">return</span> dec.fit_transform(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n=<span class="number">10</span></span><br><span class="line">p=<span class="number">5</span></span><br><span class="line"></span><br><span class="line">d = np.random.randn(n,p)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,p):</span><br><span class="line">    d[:,i] = d[:,i-<span class="number">2</span>]*<span class="number">0.2</span> + d[:,i-<span class="number">1</span>]*<span class="number">0.1</span> + d[:,i]*<span class="number">3</span></span><br><span class="line">d</span><br><span class="line"><span class="comment"># Out[38]: </span></span><br><span class="line"><span class="comment"># array([[ 0.3339,  0.289 , -0.1083,  0.8498, -6.5554],</span></span><br><span class="line"><span class="comment">#        [-0.1016, -0.7047,  0.4679,  4.3804,  1.1741],</span></span><br><span class="line"><span class="comment">#        [ 0.3309, -0.1823, -3.3715,  2.7843,  2.1753],</span></span><br><span class="line"><span class="comment">#        [-0.5411,  0.3759, -1.3554,  3.3289, -4.585 ],</span></span><br><span class="line"><span class="comment">#        [-1.8377, -1.2617,  7.2369,  4.0068, -0.5727],</span></span><br><span class="line"><span class="comment">#        [ 0.1038, -0.958 , -3.85  , -3.3861, -0.3578],</span></span><br><span class="line"><span class="comment">#        [ 2.4289, -0.6595, -0.8572, -4.1682, -1.2252],</span></span><br><span class="line"><span class="comment">#        [ 0.228 ,  0.6531,  3.0009,  4.116 ,  0.2939],</span></span><br><span class="line"><span class="comment">#        [ 1.7679, -1.2958,  2.9587,  1.7904, -0.1354],</span></span><br><span class="line"><span class="comment">#        [-0.9489, -0.2181, -1.1429, -0.4187, -1.6981]])</span></span><br><span class="line"></span><br><span class="line">p1 = pca(d)</span><br><span class="line">p1</span><br><span class="line"><span class="comment"># Out[39]: </span></span><br><span class="line"><span class="comment"># array([[-1.3118, -5.1628, -1.2068],</span></span><br><span class="line"><span class="comment">#        [ 2.4578,  2.5278, -1.5113],</span></span><br><span class="line"><span class="comment">#        [-1.3398,  4.2623, -2.5864],</span></span><br><span class="line"><span class="comment">#        [-0.2347, -2.7441, -3.4702],</span></span><br><span class="line"><span class="comment">#        [ 7.1897, -0.958 ,  2.3557],</span></span><br><span class="line"><span class="comment">#        [-6.0142,  1.3158,  0.9834],</span></span><br><span class="line"><span class="comment">#        [-4.7649, -0.2436,  3.5921],</span></span><br><span class="line"><span class="comment">#        [ 3.9656,  0.9283, -0.1481],</span></span><br><span class="line"><span class="comment">#        [ 2.1713,  0.5124,  2.04  ],</span></span><br><span class="line"><span class="comment">#        [-2.1189, -0.4381, -0.0484]])</span></span><br><span class="line"></span><br><span class="line">sk_pca(d,p1.shape[-<span class="number">1</span>])</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line"><span class="comment"># array([[-1.3118,  5.1628, -1.2068],</span></span><br><span class="line"><span class="comment">#        [ 2.4578, -2.5278, -1.5113],</span></span><br><span class="line"><span class="comment">#        [-1.3398, -4.2623, -2.5864],</span></span><br><span class="line"><span class="comment">#        [-0.2347,  2.7441, -3.4702],</span></span><br><span class="line"><span class="comment">#        [ 7.1897,  0.958 ,  2.3557],</span></span><br><span class="line"><span class="comment">#        [-6.0142, -1.3158,  0.9834],</span></span><br><span class="line"><span class="comment">#        [-4.7649,  0.2436,  3.5921],</span></span><br><span class="line"><span class="comment">#        [ 3.9656, -0.9283, -0.1481],</span></span><br><span class="line"><span class="comment">#        [ 2.1713, -0.5124,  2.04  ],</span></span><br><span class="line"><span class="comment">#        [-2.1189,  0.4381, -0.0484]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两者比较，中间维度数值正确，符号相反，</span></span><br><span class="line"><span class="comment"># 这是np.linalg.svd计算和np.linalg.eig计算结果差异造成的</span></span><br><span class="line"></span><br><span class="line">np.allclose(np.<span class="built_in">abs</span>(p1), np.<span class="built_in">abs</span>(p2) )</span><br><span class="line"><span class="comment"># Out[41]: True</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>　　上述代码使用了SVD计算特征向量和特征值，<code>numpy</code>中的<code>svd</code>函数计算结果中，特征向量已经按照特征值的降序排序。<code>numpy</code>文档中有如下说明：</p>
<blockquote>
<pre><code>numpy.linalg.svd(a, full_matrices=True, compute_uv=True, hermitian=False)
Returns
  s : (…, K) array
    Vector(s) with the singular values, within each vector sorted in descending order.

numpy.linalg.eig(a)
  Returns:    
    w : (…, M) array
    ... The eigenvalues are not necessarily ordered. ...</code></pre>
</blockquote>
<p>　　在小样本时，自己编写的函数速度较快，但是对于大样本，还实用<code>sklearn</code>的函数吧。另一方面，对于大样本，<code>sklearn</code>还有一个<code>IncrementalPCA</code>函数，可以实现批<code>PCA</code>。同样，函数以计算的精确度为代价，换区少量内存的使用。</p>
<h2 id="ica">2、ICA</h2>
<p>　　待续</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://stats.stackexchange.com/questions/134282/relationship-between-svd-and-pca-how-to-use-svd-to-perform-pca">Relationship between SVD and PCA. How to use SVD to perform PCA?</a></li>
<li><a href="https://en.wikipedia.org/wiki/Singular_value_decomposition#/media/File:Singular_value_decomposition_visualisation.svg">SVD分解可视化</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>协方差矩阵</tag>
        <tag>PCA</tag>
        <tag>numpy</tag>
        <tag>ICA</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt之点滴</title>
    <url>/2020/09/24/2020-09-24_qt/</url>
    <content><![CDATA[<p>记录Qt中的一些小方法。</p>
<span id="more"></span>
<h2 id="qt之工程配置文件.pro">1 Qt之工程配置文件(.pro)</h2>
<h3 id="之编译前复制需要的文件">1.1 之编译前复制需要的文件</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 获取绝对路径</span><br><span class="line"># 也可以使用 clean_path 来获取相对“干净”的路径 (去除 .. 和 .)</span><br><span class="line">GSL_DIR = $$<span class="built_in">absolute_path</span>($$PWD/../<span class="number">3</span>rdParty/gsl<span class="number">-2.6</span>)</span><br><span class="line">INCLUDEPATH += $$GSL_DIR/include</span><br><span class="line">LIBS        += \</span><br><span class="line">            -L$$GSL_DIR/lib -lgsl \</span><br><span class="line">            -L$$GSL_DIR/lib -lgslcblas</span><br><span class="line"></span><br><span class="line"># 复制动态链接库.</span><br><span class="line">win32 &#123;</span><br><span class="line">   # 获取路径下的所有dll文件，第二个参数如果为<span class="literal">true</span>：递归子目录</span><br><span class="line">   GSL_DLLs = $$<span class="built_in">files</span>($$GSL_DIR/bin<span class="comment">/*.dll, false)</span></span><br><span class="line"><span class="comment">   for(gsl_dll, GSL_DLLs)&#123;</span></span><br><span class="line"><span class="comment">      # windows下路径为\\，以下替换路径里的 / 为 \\</span></span><br><span class="line"><span class="comment">      gsl_dll ~= s,/,\\,g</span></span><br><span class="line"><span class="comment">      # copy命令，注意必须有escape_expend</span></span><br><span class="line"><span class="comment">      cmd = copy /Y $$shell_quote($$gsl_dll) $$shell_quote(..\\Dest) $$escape_expand(\\n\\t)</span></span><br><span class="line"><span class="comment">      QMAKE_PRE_LINK += $$cmd</span></span><br><span class="line"><span class="comment">#      message($$cmd)</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else &#123;</span></span><br><span class="line"><span class="comment">   # <span class="doctag">TODO:</span> Unices</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="qt之编译">2 qt之编译</h2>
<h3 id="更新qt自带的freetype">2.1 更新qt自带的freetype</h3>
<p>　　Qt的源码中自带的<code>import_from_tarball.sh</code>脚本，可用于更新Qt内含的freetype库。Qt使用的Freetype库，位于<code>$&#123;QT_SRC&#125;/qtbase/src/3rdparty/freetype</code>，在该目录下有一个导入第三方库脚本：<code>import_from_tarball.sh</code>，可以使用msys2将新版本的freetype导入到Qt中。</p>
<p>　　msys2命令格式，设 Qt src 位于 <code>E:\qt\qt_build\qt-everywhere-src-5.15.1</code> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sh import_from_tarball.sh freetype_src_dir freetype_to_dir</span></span><br><span class="line"></span><br><span class="line">sh import_from_tarball.sh freetype-2.10.2 /E/qt/qt_build/qt-everywhere-src-5.15.1/qtbase/src/3rdparty/freetype</span><br></pre></td></tr></table></figure> 　　Qt编译时创建的freetype库为： <code>$&#123;QT_INSTALL_DIR&#125;/lib/libqtfreetype.a</code></p>
<p>　　使用时，需复制头文件(<code>$&#123;QT_SRC&#125;/qtbase/src/3rdparty/freetype/include</code>)至指定的位置，此处为 Qt 安装路径下的<code>3rdParty</code>目录，以下内容抄自<code>%&#123;cmake&#125;/share/cmake-3.18/Modules/FindFreetype.cmake</code>文件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(QT_DIR D:/Dev/Qt/<span class="number">5.15</span>.<span class="number">1</span>/qt)</span><br><span class="line"><span class="keyword">set</span>(FREETYPE_DIR <span class="variable">$&#123;QT_DIR&#125;</span>/../<span class="number">3</span>rdParty/freetype)</span><br><span class="line"><span class="keyword">set</span>(FREETYPE_INCLUDE_DIR_freetype2 <span class="variable">$&#123;FREETYPE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">set</span>(FREETYPE_INCLUDE_DIR_ft2build <span class="variable">$&#123;FREETYPE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">set</span>(FREETYPE_LIBRARIES qtfreetype qtlibpng)   <span class="comment"># 必须加上png库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;FREETYPE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;QT_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后别忘记链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJ_NAME&#125;</span> 其他库... <span class="variable">$&#123;FREETYPE_LIBRARIES&#125;</span> )</span><br></pre></td></tr></table></figure>
<h3 id="qmake用法">2.2　<code>qmake</code>用法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Qt 内置常量，可通过 qmake -query 查询</span><br><span class="line">INCLUDEPATH += $$clean_path($$[QT_INSTALL_PREFIX]/../3rdParty/freetype/include)</span><br><span class="line">LIBS += -L$$[QT_INSTALL_LIBS]</span><br><span class="line">LIBS += -lqtfreetype -lqtlibpng</span><br></pre></td></tr></table></figure>
<h2 id="qt容器类使用基于范围的for循环range-based-for-loops">3 Qt容器类使用基于范围的<code>for</code>循环(Range-Based for Loops)</h2>
<p><code>C++11</code>规范引入了基于范围的<code>for</code>循环，例如对<code>std:vector</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> name: names) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>C++11</code>编译器将上述内容翻译为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> name: names) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp; __range = names;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> __begin = <span class="built_in">begin</span>(names), __end = <span class="built_in">end</span>(names); __begin != __end; ++__begin) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp;&amp; name = *__begin;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器使用<code>begin</code>/<code>end</code>迭代器遍历整个<code>names</code>集合。</p>
<p>由于Qt采用<code>copy-on-write</code>的隐式共享特性，在Qt容器类中使用基于范围的<code>for</code>循环时，由于<code>for</code>循环内部调用<code>begin()</code>和<code>end()</code>函数，会产生一个非<code>const</code>的容器对象从隐式共享的数据中分离出来(cause a non-const container to detach from shared data)，从而出现容器类<code>深拷贝</code>的情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QDir dir;</span><br><span class="line"><span class="comment">//c++11 range-loop might detach Qt container (QStringList) [clazy-range-loop]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;file : dir.<span class="built_in">entryList</span>()) &#123;	</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解决方案很简单：</p>
<ol type="1">
<li>如果容器类是一个 <code>non-const</code> 的右值(<code>rvalue</code>), 定义一个<code>const</code>变量保存之，然后再遍历:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> strings = <span class="built_in">functionReturningQStringList</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> QString &amp;s : strings)</span><br><span class="line">    <span class="built_in">doSomethingWith</span>(s);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>如果容器类是一个 <code>non-const</code> 的左值(<code>lvalue</code>), 先使该容器对象成为<code>const</code>,然后再遍历，如果无法解决，则使用<code>std::as_const()</code>(<code>C++17</code>后支持)或<code>qAsConst()</code>:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> QString &amp;s : <span class="built_in">qAsConst</span>(container))</span><br><span class="line">    <span class="built_in">doSomethingWith</span>(s);</span><br></pre></td></tr></table></figure>
<p>上述处理后，没有分离，也没有非必须的"深拷贝"，使性能和可读性最大化。</p>
<h2 id="qt之结构化绑定structured-bindings">4 Qt之结构化绑定(Structured bindings)</h2>
<p><code>Python</code>中常用类似解绑做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line">values = <span class="built_in">tuple</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">x,y = values		<span class="comment"># 解绑</span></span><br></pre></td></tr></table></figure>
<p>从<code>C++17</code>开始，C++支持类似操作，称为结构化绑定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPair&lt;QString, QString&gt; values = &#123;<span class="string">&quot;new&quot;</span>, <span class="string">&quot;old&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = values;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;x&lt;&lt;y;		<span class="comment">// x=&quot;new&quot;,y=&quot;old&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于与<code>std::map</code>的API不兼容，<code>QMap</code>/<code>QHash</code>无法使用结构化绑定实现参数解绑，问题在于Qt的迭代器仅返回值而非<code>std</code>中的键值对：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMap&lt;QString, QString&gt; map = &#123;&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;no1&quot;</span>&#125;, &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;no2&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;v : map) &#123;</span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; v;</span><br><span class="line">&#125;				</span><br><span class="line"><span class="comment">// 返回： no1,no2</span></span><br></pre></td></tr></table></figure>
<p><code>Qt</code>自 <code>5.10</code> 起提供了 <code>key_value_iterator</code>和 <code>const_key_value_iterator</code>迭代器:</p>
<blockquote>
<p>The QMap::key_value_iterator typedef provides an STL-style iterator for QMap and QMultiMap.</p>
<p>QMap::key_value_iterator is essentially the same as QMap::iterator with the difference that operator*() returns a key/value pair instead of a value.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMap&lt;QString, QString&gt; map = &#123;&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;no1&quot;</span>&#125;, &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;no2&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">auto</span> [key, value] = *map.<span class="built_in">keyValueBegin</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; key &lt;&lt; value;</span><br><span class="line"><span class="comment">// 返回： &quot;hello&quot; &quot;no1&quot;</span></span><br></pre></td></tr></table></figure>
<p>因此使用一个封装类做一个简单的转换，将<code>keyValueBegin</code>/<code>keyValueEnd</code>转换为<code>begin</code>/<code>end</code>，就可以使用基于范围的<code>for</code>循环结合结构化绑定，直接实现变量解绑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">asKeyValueRange</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">asKeyValueRange</span>(T &amp;data) : m_data&#123;data&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_data.<span class="built_in">keyValueBegin</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_data.<span class="built_in">keyValueEnd</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T &amp;m_data;		<span class="comment">// 引用，值可修改</span></span><br><span class="line">    <span class="comment">// const T &amp;m_data	//常引用，无法修改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QMap&lt;QString, QString&gt; map = &#123;&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;no1&quot;</span>&#125;, &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;no2&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [key, value]: <span class="built_in">asKeyValueRange</span>(map)) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;key&lt;&lt;value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">// &quot;hello&quot; &quot;no1&quot;</span></span><br><span class="line"><span class="comment">// &quot;hi&quot; &quot;no2&quot;</span></span><br><span class="line"><span class="comment">// QMap((&quot;hello&quot;, &quot;no1&quot;)(&quot;hi&quot;, &quot;no2&quot;))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，无论是否使用<code>const</code>关键字，key和value均为非<code>const</code>引用，由于<code>T &amp;m_data</code>非<code>const</code>，对上述值的修改，会影响原来的容器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> [key, value]: <span class="built_in">asKeyValueRange</span>(map)) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;key&lt;&lt;value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回：</span></span><br><span class="line"><span class="comment">// &quot;hello&quot; &quot;hello[no1]&quot;</span></span><br><span class="line"><span class="comment">// &quot;hi&quot; &quot;hi[no2]&quot;</span></span><br><span class="line"><span class="comment">// QMap((&quot;hello&quot;, &quot;hello[no1]&quot;)(&quot;hi&quot;, &quot;hi[no2]&quot;))</span></span><br></pre></td></tr></table></figure>
<p>修改也很简单，将 <code>T &amp;m_data</code> 定义改为 <code>const T &amp;m_data</code>即可保证是常引用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 const T &amp;m_data 时：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : <span class="built_in">asKeyValueRange</span>(map)) &#123;</span><br><span class="line">  v = k + <span class="string">&quot;[&quot;</span> + v + <span class="string">&quot;]&quot;</span>;		<span class="comment">// 报错</span></span><br><span class="line">  <span class="built_in">qDebug</span>() &lt;&lt; k &lt;&lt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考">参考</h2>
<ol type="1">
<li><code>Qt, range-based for loops and structured bindings</code>(<a href="https://www.kdab.com/qt-range-based-for-loops-and-structured-bindings/">https://www.kdab.com/qt-range-based-for-loops-and-structured-bindings/</a>)</li>
<li><code>Goodbye, Q_FOREACH</code> (<a href="https://www.kdab.com/goodbye-q_foreach/">https://www.kdab.com/goodbye-q_foreach/</a>)</li>
</ol>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>qmake</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>plantuml + graphviz配置</title>
    <url>/2020/10/07/2020-10-07_plantuml_graphviz/</url>
    <content><![CDATA[<p>最近希望使用<code>plantuml</code>来绘制流程图，以下记录配置过程；</p>
<span id="more"></span>
<h2 id="安装plantuml和graphviz">1.安装<code>plantuml</code>和<code>graphviz</code></h2>
<h3 id="下载">1.1 下载</h3>
<ol type="1">
<li><a href="https://plantuml.com/zh/download">plantuml</a>，jar包，需要<code>java</code>支持</li>
<li><a href="https://www2.graphviz.org/Packages/stable/windows/">graphviz</a>，可<code>7z</code>直接提取，绿色可执行文件。</li>
</ol>
<p>　　注：本机安装了<code>anaconda3</code>，<code>graphviz</code>可以使用<code>conda</code>安装，但是<code>anaconda3</code>安装版本为<code>2.38</code>版，这里替换为上述链接下载的版本(<code>2.44.1</code>)，附<code>conda</code>安装命令： <figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">conda install python-graphviz graphviz --<span class="built_in">copy</span> -y</span><br></pre></td></tr></table></figure></p>
<h3 id="配置环境变量">1.2 配置环境变量</h3>
<p>　　<code>plantuml</code>使用<code>java</code>编写，需要<code>java</code>运行时支持，环境变量配置核心为配置<code>java</code>路径。<code>graphviz</code>同样需要添加环境变量。以下创建批处理完成：</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 如果出现&quot;Error: dot generates empty file. Check you dot installation.&quot;错误</span></span><br><span class="line"><span class="comment">rem 执行dot -c 命令，见plantuml说明faq</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 配置graphviz和java路径</span></span><br><span class="line"><span class="built_in">set</span> GRAPHVIZ_DIR=D:\Dev\Anaconda3\Library\bin\graphviz</span><br><span class="line"><span class="built_in">set</span> JAVA_DIR=D:\Dev\java\jre</span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 配置java环境变量</span></span><br><span class="line"><span class="built_in">set</span> JAVA_HOME=<span class="variable">%JAVA_DIR%</span></span><br><span class="line"><span class="built_in">set</span> CLASSPATH=<span class="variable">%JAVA_DIR%</span>;<span class="variable">%JAVA_HOME%</span>\lib</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">Path</span>=<span class="variable">%Path%</span>;<span class="variable">%GRAPHVIZ_DIR%</span>;<span class="variable">%JAVA_DIR%</span>\bin</span><br><span class="line"></span><br><span class="line">:java -version</span><br><span class="line"></span><br><span class="line">java -jar plantuml.jar -version | <span class="built_in">findstr</span> version</span><br><span class="line">java -jar plantuml.jar -charset utf-<span class="number">8</span> %<span class="number">1</span></span><br><span class="line"></span><br><span class="line">@<span class="built_in">echo</span> on</span><br></pre></td></tr></table></figure>
<h3 id="测试">1.3 测试</h3>
<p>　　示例代码如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">&#x27; modify from https://real-world-plantuml.com/umls/4620670503747584</span><br><span class="line"></span><br><span class="line">&#x27; 设置默认字体为 方正细黑</span><br><span class="line">skinparam defaultFontName stxihei</span><br><span class="line">&#x27; 输出图片分辨率为150</span><br><span class="line">skinparam dpi 150</span><br><span class="line">&#x27; 设置背景颜色</span><br><span class="line">skinparam backgroundColor #EEEBDC</span><br><span class="line"></span><br><span class="line">title 示例</span><br><span class="line"></span><br><span class="line">actor 使用者</span><br><span class="line">participant &quot; 头等舱&quot; as A</span><br><span class="line">participant &quot; 第二类&quot; as B</span><br><span class="line">participant &quot; 最后一堂课&quot; as 别的东西</span><br><span class="line">使用者-&gt; A: 完成这项工作</span><br><span class="line">activate A</span><br><span class="line">A -&gt; B: 创建请求</span><br><span class="line">activate B</span><br><span class="line">B -&gt; 别的东西: 创建请求</span><br><span class="line">activate 别的东西</span><br><span class="line">别的东西--&gt; B: 这项工作完成</span><br><span class="line">destroy 别的东西</span><br><span class="line">B --&gt; A: 请求创建</span><br><span class="line">deactivate B</span><br><span class="line">A --&gt; 使用者: 做完</span><br><span class="line">deactivate A</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure> 　　将上述代码保存为<code>test.puml</code>，执行命令： <figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">plantuml.bat test.puml</span><br></pre></td></tr></table></figure> 结果如图1所示： <img src="/2020/10/07/2020-10-07_plantuml_graphviz/test.png" class="" title="图1.示例"></p>
<p>参考： 1. https://plantuml.com/zh/command-line 2. https://real-world-plantuml.com</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>plantuml</tag>
        <tag>graphviz</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32之MicroPython</title>
    <url>/2021/07/28/2021-07-28_micropython/</url>
    <content><![CDATA[<p>买了2块mini开发板，一块<code>STM32F407VE</code>，另一块<code>STM32H743VI</code>。无他，唯体积小。看到<code>OpenMV</code>大行其道，开始折腾<code>MicroPython</code>。</p>
<ul>
<li>环境： <code>Ubuntu 16.04 x64</code></li>
<li>开发板： <code>DevEBox STM32H7XX_M Ver:V2.0 SN:1907</code></li>
</ul>
<span id="more"></span>
<p><code>STM32H743VI</code>开发板外观如下（<code>STM32F407VE</code>板样子都一样）。</p>
<img src="/2021/07/28/2021-07-28_micropython/STM32H7XX_M.jpg" class="" title="STM32H7XX开发板">
<h2 id="安装make和gcc">1、安装<code>make</code>和<code>gcc</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装gcc相关</span></span><br><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line">sudo apt-get update </span><br><span class="line"><span class="comment"># 顺便安装g++-9</span></span><br><span class="line">sudo apt-get install make gcc-9 g++-9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装交叉编译相关</span></span><br><span class="line">sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install gcc-arm-embedded</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="下载micropython源码">2、下载<code>micropython</code>源码</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;SRC_ROOT&gt;</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/micropython/micropython.git</span><br><span class="line"><span class="built_in">cd</span> micropython</span><br><span class="line">git submodule update --init</span><br><span class="line"></span><br><span class="line"><span class="comment"># （更新）拉取远程库</span></span><br><span class="line"><span class="comment"># git pull --progress -v --no-rebase &quot;origin&quot;   </span></span><br></pre></td></tr></table></figure>
<h2 id="下载开发板的配置代码">3、下载开发板的配置代码</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;SRC_ROOT&gt;/micropython/ports/stm32/boards</span><br><span class="line"><span class="comment"># H743的移植文件</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mcauser/MCUDEV_DEVEBOX_H7XX_M.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># F407VE的一移植文件</span></span><br><span class="line"><span class="comment"># git clone https://github.com/mcauser/MCUDEV_DEVEBOX_F407VET6.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后：</span></span><br><span class="line"><span class="comment">#  H743: https://github.com/njuFerret/MCUDEV_DEVEBOX_H7XX_M.git</span></span><br><span class="line"><span class="comment">#  F407Ve https://github.com/njuFerret/MCUDEV_DEVEBOX_F407VET6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此处编译出错，按照<code>MCUDEV_DEVEBOX_H7XX_M</code>中的<code>Issues/1</code>说明，编辑 <code>MCUDEV_DEVEBOX_H7XX_M/mpconfigboard.h</code>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------原定义----------------------------------------*/</span></span><br><span class="line"><span class="comment">// // HSE is 25MHz</span></span><br><span class="line"><span class="comment">// #define MICROPY_HW_CLK_PLLM (25) // divide external clock by this to get 1MHz</span></span><br><span class="line"><span class="comment">// #define MICROPY_HW_CLK_PLLN (160) // PLL clock in MHz</span></span><br><span class="line"><span class="comment">// #define MICROPY_HW_CLK_PLLP (RCC_PLLP_DIV2) // divide PLL clock by this to get core clock</span></span><br><span class="line"><span class="comment">// #define MICROPY_HW_CLK_PLLQ (4) // divide core clock by this to get 40MHz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------修改后定义---------------------------------------*/</span></span><br><span class="line"><span class="comment">// The board has an 25MHz HSE, the following gives 480MHz CPU speed</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_CLK_PLLM (5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_CLK_PLLN (192)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_CLK_PLLP (2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_CLK_PLLQ (5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_CLK_PLLR (2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The USB clock is set using PLL3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_CLK_PLL3M (5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_CLK_PLL3N (48)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_CLK_PLL3P (2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_CLK_PLL3Q (5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_CLK_PLL3R (2)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="编译">4、编译</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;SRC_ROOT&gt;/micropython</span><br><span class="line">make -C mpy-cross</span><br><span class="line"><span class="built_in">cd</span> ports/stm32</span><br><span class="line">make submodules</span><br><span class="line">make BOARD=MCUDEV_DEVEBOX_H7XX_M clean</span><br><span class="line">make BOARD=MCUDEV_DEVEBOX_H7XX_M</span><br></pre></td></tr></table></figure>
<h2 id="烧入开发板">5、烧入开发板</h2>
<p>编译完成后，在<code>micropython/ports/stm32</code>目录下会出现<code>build-MCUDEV_DEVEBOX_H7XX_M</code>目录，找到固件文件<code>firmware.hex</code>，使用<code>STM32 ST-LINK Utility</code>烧入即可。</p>
<p>烧写完成后出现<code>low power</code>的情况，插入<code>usb</code>之后会出现windows安装设备等提示，以一个U盘形式出现。</p>
<h2 id="使用方法">6、使用方法</h2>
<p>两种模式，解释器模式和文件模式。前者使用<code>putty</code>打开串口，与其他解释器一样使用。后者直接修改<code>main.py</code>文件。<code>IDE</code>方面，<code>VScode</code>略显不便，可以采用<code>Thonny</code>，写完代码可以直接烧入开发板，比较方便。</p>
<h2 id="例子">7、例子</h2>
<p>查看当前运行主频：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> machine</span><br><span class="line">machine.freq()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; import pyb</span></span><br><span class="line"><span class="comment">#&gt;&gt;&gt; pyb.freq()</span></span><br><span class="line"><span class="comment">#(480000000, 240000000, 120000000, 120000000)</span></span><br></pre></td></tr></table></figure>
<p>首先点个灯：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyb</span><br><span class="line"></span><br><span class="line">tim = pyb.Timer(<span class="number">4</span>,freq=<span class="number">2</span>)	<span class="comment"># 2Hz ,500ms</span></span><br><span class="line">tim.callback(<span class="keyword">lambda</span> t:pyb.LED(<span class="number">1</span>).toggle())</span><br><span class="line"><span class="comment"># tim.callback(None) # 停止回调</span></span><br></pre></td></tr></table></figure>
<p>如果用<code>sleep</code>函数，必须等待其执行完成，或 <code>Ctrl+C</code>终止执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line"><span class="meta">... </span>    pyb.LED(<span class="number">1</span>).toggle()</span><br><span class="line"><span class="meta">... </span>    time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>再来一个PWM：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyb </span><br><span class="line"></span><br><span class="line">p = pyb.Pin(<span class="string">&#x27;D12&#x27;</span>)	<span class="comment"># Tim4, PWM ch1, PD12</span></span><br><span class="line">tim = pyb.Timer(<span class="number">4</span>, freq=<span class="number">1000</span>)</span><br><span class="line">ch = tim.channel(<span class="number">1</span>, pyb.Timer.PWM, pin=p)</span><br><span class="line">ch.pulse_width_percent(<span class="number">50</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用板载flash-vs-mcu内置flash">8、使用板载<code>Flash</code> vs <code>MCU</code>内置<code>Flash</code></h2>
<p>上述编译中，使用的是<code>MCU</code>内置<code>flash</code>，<code>hex</code>固件约<code>1.26M</code>，烧完之后，几乎没啥空间了，考虑折腾板载的外置<code>Flash</code>。</p>
<p><code>H7xx</code>开发板板载一颗<code>W25Q64</code>的<code>8MByte flash</code>，F407开发板板载的是<code>W25Q16</code>的<code>2MByte flash</code>。前者支持<code>QSPI</code>，后者不支持。</p>
<blockquote>
<p><code>SPI</code>协议包括：<code>Standard SPI</code>、<code>Dual SPI</code>和<code>Queued SPI</code>三种协议，分别对应<code>3-wire</code>, <code>4-wire</code>, <code>6-wire</code>。</p>
<ol type="1">
<li><p><code>Standard SPI</code>，有4根信号线，分别为CLK、CS、MOSI和MISO。数据线工作在全双工。</p></li>
<li><p><code>Dual SPI</code>，只针对SPI Flash而言，不是针对所有SPI外设。对于SPI Flash，全双工并不常用，因此扩展了mosi和miso的用法，让它们工作在半双工，用以加倍数据传输。也就是对于Dual SPI Flash，可以发送一个命令字节进入dual mode，这样mosi变成SIO0（serial io 0），mosi变成SIO1（serial io 1）,这样一个时钟周期内就能传输2个bit数据，加倍了数据传输。</p></li>
<li><p>类似的，<code>QSPI</code>也是针对<code>SPI Flash</code>，<code>Qual SPI Flash</code>增加了两根I/O线（SIO2,SIO3），目的是一个时钟内传输4个bit</p></li>
</ol>
</blockquote>
<h3 id="增加管脚定义">8.1 增加管脚定义</h3>
<p><code>micropython</code>自带的<code>PYBD_SF</code>开发板是很好的参考资料，位于<code>ports\stm32\boards\PYBD_SF2</code></p>
<blockquote>
<ol type="1">
<li>可参考<code>ports/stm32/boards/PYBD_SF2</code>中相关内容</li>
<li>也可参考 <code>MCUDEV_DEVEBOX_F407VET6</code>中相关内容</li>
</ol>
</blockquote>
<p>打开<code>MCUDEV_DEVEBOX_H7XX_M/mpconfigboard.h</code>，增加如下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 = use internal flash (2048 KByte)</span></span><br><span class="line"><span class="comment">// 0 = use onboard SPI flash (8 MByte) Winbond W25Q64 with QSPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_ENABLE_INTERNAL_FLASH_STORAGE (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If using onboard SPI flash</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !MICROPY_HW_ENABLE_INTERNAL_FLASH_STORAGE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_SPIFLASH_ENABLE_CACHE (1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Winbond W25Q16 SPI Flash = 64 Mbit (8 MByte)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_SPIFLASH_SIZE_BITS (64 * 1024 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_QSPIFLASH_SIZE_BITS_LOG2 (26)</span></span><br><span class="line"><span class="comment">// 引脚参照原理图</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_QSPIFLASH_CS         (pin_B6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_QSPIFLASH_SCK        (pin_B2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_QSPIFLASH_IO0        (pin_D11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_QSPIFLASH_IO1        (pin_D12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_QSPIFLASH_IO2        (pin_E2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_QSPIFLASH_IO3        (pin_D13)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_BOARD_EARLY_INIT    Mcudev_Devebox_H743VI_board_early_init</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mcudev_Devebox_H743VI_board_early_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">mp_spiflash_config_t</span> <span class="title">spiflash_config</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">spi_bdev_t</span> <span class="title">spi_bdev</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_BDEV_IOCTL(op, arg) ( \</span></span><br><span class="line"><span class="meta">    (op) == BDEV_IOCTL_NUM_BLOCKS ? (MICROPY_HW_SPIFLASH_SIZE_BITS / 8 / FLASH_BLOCK_SIZE) : \</span></span><br><span class="line"><span class="meta">    (op) == BDEV_IOCTL_INIT ? spi_bdev_ioctl(&amp;spi_bdev, (op), (uint32_t)&amp;spiflash_config) : \</span></span><br><span class="line"><span class="meta">    spi_bdev_ioctl(&amp;spi_bdev, (op), (arg)) \</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_BDEV_READBLOCKS(dest, bl, n) spi_bdev_readblocks(&amp;spi_bdev, (dest), (bl), (n))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_BDEV_WRITEBLOCKS(src, bl, n) spi_bdev_writeblocks(&amp;spi_bdev, (src), (bl), (n))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="补全qspi实现函数">8.2 补全<code>QSPI</code>实现函数</h3>
<p>增加<code>bdev.c</code>和<code>board_init.c</code>文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bdev.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;storage.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !MICROPY_HW_ENABLE_INTERNAL_FLASH_STORAGE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// External SPI flash uses QSPI interface</span></span><br><span class="line">STATIC <span class="type">const</span> <span class="type">mp_soft_qspi_obj_t</span> qspi_bus = &#123;</span><br><span class="line">    .cs  = MICROPY_HW_QSPIFLASH_CS,</span><br><span class="line">    .clk = MICROPY_HW_QSPIFLASH_SCK,</span><br><span class="line">    .io0 = MICROPY_HW_QSPIFLASH_IO0,</span><br><span class="line">    .io1 = MICROPY_HW_QSPIFLASH_IO1,</span><br><span class="line">    .io2 = MICROPY_HW_QSPIFLASH_IO2,</span><br><span class="line">    .io3 = MICROPY_HW_QSPIFLASH_IO3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">STATIC <span class="type">mp_spiflash_cache_t</span> spi_bdev_cache;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">mp_spiflash_config_t</span> spiflash_config = &#123;</span><br><span class="line">    .bus_kind = MP_SPIFLASH_BUS_QSPI,</span><br><span class="line">    .bus.u_qspi.data = (<span class="type">void</span>*)&amp;qspi_bus,</span><br><span class="line">    .bus.u_qspi.proto = &amp;mp_soft_qspi_proto, </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MICROPY_HW_SPIFLASH_ENABLE_CACHE</span></span><br><span class="line">    .cache = &amp;spi_bdev_cache,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">spi_bdev_t</span> spi_bdev;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// board_init.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;py/mphal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mcudev_Devebox_H743VI_board_early_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;py/mphal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mcudev_Devebox_H743VI_board_early_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// set SPI flash CS pin high</span></span><br><span class="line">    <span class="comment">// mp_hal_pin_output(pin_A15);</span></span><br><span class="line">    <span class="comment">// mp_hal_pin_write(pin_A15, 0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="补全管脚定义">8.3 补全管脚定义</h3>
<p>打开<code>MCUDEV_DEVEBOX_H7XX_M/pins.csv</code>，增加如下内容</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">QSPIFLASH_CS,PB6</span><br><span class="line">QSPIFLASH_SCK,PB2</span><br><span class="line">QSPIFLASH_IO0,PD11</span><br><span class="line">QSPIFLASH_IO1,PD12</span><br><span class="line">QSPIFLASH_IO2,PE2</span><br><span class="line">QSPIFLASH_IO3,PD13</span><br></pre></td></tr></table></figure>
<h3 id="编译-1">8.4 编译</h3>
<p>可根据情况，选取是否使用<code>SPI Flash</code>，修改宏定义后，重新编译即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 = use internal flash (2048 KByte)</span></span><br><span class="line"><span class="comment">// 0 = use onboard SPI flash (8 MByte) Winbond W25Q64 with QSPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MICROPY_HW_ENABLE_INTERNAL_FLASH_STORAGE (0)</span></span><br></pre></td></tr></table></figure>
<h2 id="mini-f407ve板">9、 <code>Mini F407VE</code>板</h2>
<ul>
<li><code>F407VE</code>板已经自带了<code>bdev.c</code>和<code>board_init.c</code>，只是缺少一个开启<code>cache</code>的宏，可以参考<code>PYBD_SF2</code>在<code>bdev.c</code>中分开加，也可以参考<code>STM32L476DISC</code>在<code>mpconfigboard.h</code>中一次性加入。</li>
<li>另外需要注意的是，<code>F407VE</code>板使用的是标准<code>SPI</code>，可以直接copy<code>STM32L476DISC</code>内容，只是需要增加一个开启关闭使用外部<code>Flash</code>的宏，最后注意<code>SPI</code>低电平有效，需要预先将管脚位置低。</li>
</ul>
<p>最后放上<code>patch</code>。</p>
<figure class="highlight patch"><table><tr><td class="code"><pre><span class="line"> board_init.c    |  3 ++-</span><br><span class="line"> mpconfigboard.h | 19 +++++++++++--------</span><br><span class="line"> 2 files changed, 13 insertions(+), 9 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/board_init.c b/board_init.c</span></span><br><span class="line"><span class="comment">index c60141e..896f698 100644</span></span><br><span class="line"><span class="comment">--- a/board_init.c</span></span><br><span class="line"><span class="comment">+++ b/board_init.c</span></span><br><span class="line"><span class="meta">@@ -3,5 +3,6 @@</span></span><br><span class="line"> void Mcudev_Devebox_F407VE_board_early_init(void) &#123;</span><br><span class="line">     // set SPI flash CS pin high</span><br><span class="line">     mp_hal_pin_output(pin_A15);</span><br><span class="line"><span class="deletion">-    mp_hal_pin_write(pin_A15, 1);</span></span><br><span class="line"><span class="addition">+    // mp_hal_pin_write(pin_A15, 1);</span></span><br><span class="line"><span class="addition">+    mp_hal_pin_write(pin_A15, 0);</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">diff --git a/mpconfigboard.h b/mpconfigboard.h</span></span><br><span class="line"><span class="comment">index 13f6306..e7a2b31 100644</span></span><br><span class="line"><span class="comment">--- a/mpconfigboard.h</span></span><br><span class="line"><span class="comment">+++ b/mpconfigboard.h</span></span><br><span class="line"><span class="meta">@@ -1,10 +1,6 @@</span></span><br><span class="line"> #define MICROPY_HW_BOARD_NAME       &quot;MCUDEV DEVEBOX STM32F407VE&quot;</span><br><span class="line"> #define MICROPY_HW_MCU_NAME         &quot;STM32F407VE&quot;</span><br><span class="line"><span class="deletion">-#define MICROPY_HW_FLASH_FS_LABEL   &quot;DEVEBOXF407VE&quot;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-// 1 = use internal flash (512 KByte)</span></span><br><span class="line"><span class="deletion">-// 0 = use onboard SPI flash (2 MByte) Winbond W25Q16</span></span><br><span class="line"><span class="deletion">-#define MICROPY_HW_ENABLE_INTERNAL_FLASH_STORAGE (1)</span></span><br><span class="line"><span class="addition">+#define MICROPY_HW_FLASH_FS_LABEL   &quot;MiniF407VE&quot;</span></span><br><span class="line"> </span><br><span class="line"> #define MICROPY_HW_HAS_SWITCH       (1)		// has 1 button KEY0</span><br><span class="line"> #define MICROPY_HW_HAS_FLASH        (1)</span><br><span class="line"><span class="meta">@@ -15,9 +11,9 @@</span></span><br><span class="line"> #define MICROPY_HW_ENABLE_SDCARD    (0)		// it has a sd scard, but i am not sure what the detect pin is, yet</span><br><span class="line"> </span><br><span class="line"> // HSE is 8MHz</span><br><span class="line"><span class="deletion">-#define MICROPY_HW_CLK_PLLM (8) // divide external clock by this to get 1MHz</span></span><br><span class="line"><span class="deletion">-#define MICROPY_HW_CLK_PLLN (336) // PLL clock in MHz</span></span><br><span class="line"><span class="deletion">-#define MICROPY_HW_CLK_PLLP (RCC_PLLP_DIV2) // divide PLL clock by this to get core clock</span></span><br><span class="line"><span class="addition">+#define MICROPY_HW_CLK_PLLM (4) // divide external clock by this to get 1MHz</span></span><br><span class="line"><span class="addition">+#define MICROPY_HW_CLK_PLLN (168) // PLL clock in MHz</span></span><br><span class="line"><span class="addition">+#define MICROPY_HW_CLK_PLLP (2) // divide PLL clock by this to get core clock</span></span><br><span class="line"> #define MICROPY_HW_CLK_PLLQ (7) // divide core clock by this to get 48MHz</span><br><span class="line"> </span><br><span class="line"> // The board has a 32kHz crystal for the RTC</span><br><span class="line"><span class="meta">@@ -106,9 +102,16 @@</span></span><br><span class="line"> #define MICROPY_HW_LED_ON(pin)      (mp_hal_pin_low(pin))</span><br><span class="line"> #define MICROPY_HW_LED_OFF(pin)     (mp_hal_pin_high(pin))</span><br><span class="line"> </span><br><span class="line"><span class="addition">+// 1 = use internal flash (512 KByte)</span></span><br><span class="line"><span class="addition">+// 0 = use onboard SPI flash (2 MByte) Winbond W25Q16</span></span><br><span class="line"><span class="addition">+#define MICROPY_HW_ENABLE_INTERNAL_FLASH_STORAGE (0)</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> // If using onboard SPI flash</span><br><span class="line"> #if !MICROPY_HW_ENABLE_INTERNAL_FLASH_STORAGE</span><br><span class="line"> </span><br><span class="line"><span class="addition">+// fix &quot;error: unknown type name &#x27;mp_spiflash_cache_t&#x27;&quot;</span></span><br><span class="line"><span class="addition">+#define MICROPY_HW_SPIFLASH_ENABLE_CACHE (1)</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> // Winbond W25Q16 SPI Flash = 16 Mbit (2 MByte)</span><br><span class="line"> #define MICROPY_HW_SPIFLASH_SIZE_BITS (16 * 1024 * 1024)</span><br><span class="line"> #define MICROPY_HW_SPIFLASH_CS      (pin_A15)</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ol type="1">
<li>https://blog.csdn.net/liaoze22/article/details/106708796</li>
<li>https://blog.csdn.net/wangguchao/article/details/105593303</li>
</ol>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>usages</category>
      </categories>
      <tags>
        <tag>stm32</tag>
        <tag>python</tag>
        <tag>micropython</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32之RT Thread</title>
    <url>/2021/08/25/2021-08-25_rtthread/</url>
    <content><![CDATA[<p><code>RTOS</code>在嵌入式开发大行其道，<code>RT-Thread</code>有很丰富的外设驱动，遂折腾以下<code>RT-Thread</code>(本文的<code>RT-Thread</code>均指<code>RT-Thread Nano</code>)。</p>
<ul>
<li>环境： <code>Win10x64, STM32CubeIDE v1.7.0</code></li>
<li>开发板： <code>DevEBox STM32F407VE</code></li>
</ul>
<span id="more"></span>
<h2 id="stm32f407ve开发板基本参数">1、<code>STM32F407VE</code>开发板基本参数。</h2>
<h3 id="specifications">(1) Specifications</h3>
<ul>
<li>STM32F407VET6 ARM Cortex M4</li>
<li>168MHz, 210 DMIPS / 1.25 DMIPS / MHz</li>
<li>1.8V - 3.6V operating voltage</li>
<li>8MHz system crystal</li>
<li>32.768KHz RTC crystal</li>
<li>2.54mm pitch pins</li>
<li>SWD header</li>
<li>512 KByte Flash, 192 + 4 KByte SRAM</li>
<li>3x SPI, 3x USART, 2x UART, 2x I2S, 3x I2C</li>
<li>1x FSMC, 1x SDIO, 2x CAN</li>
<li>1x USB 2.0 FS / HS controller (with dedicated DMA)</li>
<li>1x USB HS ULPI (for external USB HS PHY)</li>
<li>Micro SD</li>
<li>Winbond W25Q16 16Mbit SPI Flash</li>
<li>1x 10/100 Ethernet MAC</li>
<li>1x 8 to 12-bit Parallel Camera interface</li>
<li>3x ADC (12-bit / 16-channel)</li>
<li>2x DAC (12-bit)</li>
<li>12x general timers, 2x advanced timers</li>
<li>AMS1117-3.3V: 3.3V LDO voltage regulator, max current 800mA</li>
<li>Micro USB for power and comms</li>
<li>Power LED D1</li>
<li>User LED D2 (PA1) active low</li>
<li>Reset button, 1x user buttons K0</li>
<li>2x22 side header</li>
<li>SPI TFT/OLED header (3V3, GND, MOSI, SCK, CS, MISO, RST, BL)</li>
<li>RTC battery header B1 beside SD card</li>
<li>M3 mounting holes</li>
<li>Dimensions: 40.89mm x 68.59mm</li>
</ul>
<h3 id="exposed-port-pins">(2) Exposed Port Pins</h3>
<ul>
<li>PA0-PA15</li>
<li>PB0-PB3, PB5-PB15 (PB4 SPI1_MISO used exclusively with SPI Flash)</li>
<li>PC0-PC13 (PC14 OSC32_IN and PC15 OSC32_OUT not broken out)</li>
<li>PD0-PD15</li>
<li>PE0-PE15</li>
</ul>
<h3 id="peripherals">(3) Peripherals</h3>
<h4 id="tftoled-j4">TFT/OLED (J4)</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">3V3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">PB12</td>
<td style="text-align: center;">CS</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">GND</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">PB14</td>
<td style="text-align: center;">MISO</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">PB15</td>
<td style="text-align: center;">MOSI</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">PC5</td>
<td style="text-align: center;">RS</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">PB13</td>
<td style="text-align: center;">SCK</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">PB1</td>
<td style="text-align: center;">BLK</td>
</tr>
</tbody>
</table>
<h4 id="spi-flash-w25q16-u3">SPI Flash W25Q16 (U3)</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">PA15</td>
<td style="text-align: center;">F_CS</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">PB5</td>
<td style="text-align: center;">SPI1_MOSI</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">PB4</td>
<td style="text-align: center;">SPI1_MISO</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">PB3</td>
<td style="text-align: center;">SPI1_SCK</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">WP</td>
<td style="text-align: center;">3V3</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">HOLD</td>
<td style="text-align: center;">3V3</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">GND</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">VCC</td>
<td style="text-align: center;">3V3</td>
</tr>
</tbody>
</table>
<h4 id="swd-debug-j1">SWD debug (J1)</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Boot0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">PA13</td>
<td style="text-align: center;">SWDIO</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">3V3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">PA14</td>
<td style="text-align: center;">SWCLK</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">GND</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h4 id="usb-j5">USB (J5)</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">VCC</td>
<td style="text-align: center;">5V</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">NC</td>
<td style="text-align: center;">ID</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">PA11</td>
<td style="text-align: center;">USB_DM</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">GND</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">PA12</td>
<td style="text-align: center;">USB_DP</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h4 id="micro-sd-u5">Micro SD (U5)</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">PC10</td>
<td style="text-align: center;">SDIO_D2</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">GND</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">PC11</td>
<td style="text-align: center;">SDIO_D3</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">PC8</td>
<td style="text-align: center;">SDIO_D0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">PD2</td>
<td style="text-align: center;">SDIO_CMD</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">PC9</td>
<td style="text-align: center;">SDIO_D1</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">3V3</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">NC</td>
<td style="text-align: center;">SD_NC</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">PC12</td>
<td style="text-align: center;">SDIO_SCK</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h4 id="user-button-k1">User Button (K1)</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">PA0</td>
<td style="text-align: center;">WK_UP</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h4 id="user-led-d2">User LED (D2)</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">PA1</td>
<td style="text-align: center;">User LED</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h4 id="battery-b1">Battery (B1)</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
<th style="text-align: center;">index</th>
<th style="text-align: center;">Pin</th>
<th style="text-align: center;">Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">BAT54C</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">GND</td>
</tr>
</tbody>
</table>
<h2 id="工程创建与修改">2、工程创建与修改</h2>
<p>使用<code>STM32CubeIDE</code>(以下简称<code>CubeIde</code>)创建工程的过程非常程序化，选芯片-&gt;配置外设-&gt;配置时钟-&gt;配置所用的库，具体过程网上很多，此处略过。以下核心记录<code>RT-Thread</code>的使用方法。</p>
<h3 id="安装并在工程中导入rt-thread-nano包">(1) 安装并在工程中导入<code>RT-Thread Nano</code>包，</h3>
<p>基本过程请参考<a href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-nano/nano-port-cube/an0041-nano-port-cube">RT-Thread 文档</a>。重点是在<code>CubeIde</code>中通过连接<code>https://www.rt-thread.org/download/cube/RealThread.RT-Thread.pdsc</code>安装，并在工程中配置。</p>
<h3 id="cubeide中配置rt-thread-nano需要注意的几个问题">(2) <code>CubeIde</code>中配置<code>RT-Thread Nano</code>需要注意的几个问题</h3>
<ol type="1">
<li>如文档所述， <code>RT-Thread</code>重定义<code>HardFault_Handler</code>、<code>PendSV_Handler</code>、<code>SysTick_Handler</code> 中断函数，为了避免重复定义的问题，需要在<code>NVIC-&gt;Code generate</code>中禁止生成<code>Hard fault interrupt</code>, <code>Pendable request</code>, <code>Time base :System tick timer</code>三个函数。实际操作中，如果选择了定时器作为时基，那么只需要禁止生成<code>Hard fault interrupt</code>即可。</li>
<li>启用<code>RT_USING_HEAP</code>、<code>RT_USING_DEVICE</code>和<code>finsh</code>。前两个直接在<code>CubeIde</code>点选即可，最后一个需要打开<code>rtconfig.h</code>编辑。</li>
</ol>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;h&gt;Enable FinSH Configuration</span></span><br><span class="line"><span class="comment">// &lt;c1&gt;include shell config</span></span><br><span class="line"><span class="comment">//  &lt;i&gt; Select this choice if you using FinSH</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;finsh_config.h&quot;</span></span></span><br><span class="line"><span class="comment">// &lt;/c&gt;</span></span><br><span class="line"><span class="comment">// &lt;/h&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3" type="1">
<li>编译器参数修改，<code>Project-&gt;properties-&gt;C/C++ Build-&gt;Settings-&gt;Tool Settings</code>，在<code>MCU GCC Assembler-&gt;Miscellaneous</code>添加<code>-Wa,-mimplicit-it=thumb</code>。<code>MCU GCC Compiler-&gt;Include paths</code>添加相应的头文件(如果没有，貌似<code>nano 3.1.5</code>已经自动添加了<code>5</code>个相关头文件路径)</li>
<li>修改启动文件<code>Core/Startup/startup_stm32f407vetx.s</code>，第<code>100</code>行<code>bl main =&gt; bl entry</code>。（注第<code>98</code>行<code>bl __libc_init_array</code>在<code>RT-Thread Studio</code>自带的代码中，是注释的，不过此处保留后，尚未遇到问题）</li>
<li>修改<code>STM32F407VETX_FLASH.ld</code>文件，开启自动初始化，并使<code>finsh</code>正常工作。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  . = ALIGN(4);</span><br><span class="line">  _etext = .;        /* define a global symbols at end of code */</span><br><span class="line">  /**************添加以下内容*************/</span><br><span class="line">  /* section information for finsh shell */</span><br><span class="line">   . = ALIGN(4);</span><br><span class="line">   __fsymtab_start = .;</span><br><span class="line">   KEEP(*(FSymTab))</span><br><span class="line">   __fsymtab_end = .;</span><br><span class="line">   . = ALIGN(4);</span><br><span class="line">   __vsymtab_start = .;</span><br><span class="line">   KEEP(*(VSymTab))</span><br><span class="line">   __vsymtab_end = .;</span><br><span class="line">   . = ALIGN(4);</span><br><span class="line">   </span><br><span class="line">   /* section information for initial. */</span><br><span class="line">   . = ALIGN(4);</span><br><span class="line">   __rt_init_start = .;</span><br><span class="line">   KEEP(*(SORT(.rti_fn*)))</span><br><span class="line">   __rt_init_end = .;</span><br><span class="line">   . = ALIGN(4);</span><br><span class="line">  /**************添加内容结束*************/     </span><br><span class="line">&#125; &gt;FLASH</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考">参考</h2>
<ol type="1">
<li><a href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-nano/nano-port-cube/an0041-nano-port-cube">RT-Thread Nano 文档</a></li>
<li><a href="https://blog.csdn.net/lzs2327/article/details/113825154">STM32CubeIDE 使用RTThread-Nano无法自动初始化</a></li>
</ol>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>stm32</tag>
        <tag>rt-thread</tag>
        <tag>STM32CubeIDE</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派的使用</title>
    <url>/2021/01/20/20210120_raspib4/</url>
    <content><![CDATA[<p>禁不住好评如潮，开始折腾树莓派。型号4B，操作系统<code>Ubuntu server 20.04</code>（无GUI）。</p>
<span id="more"></span>
<h2 id="查看系统信息">0、查看系统信息</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----------当前计算机信息---------------&quot;</span></span><br><span class="line"><span class="comment"># 显示当前系统及版本号</span></span><br><span class="line"><span class="built_in">echo</span> 系统版本：$<span class="string">&#x27;\t&#x27;</span> `lsb_release -a 2&gt;&amp;1 | grep -i <span class="string">&#x27;description&#x27;</span> | <span class="built_in">cut</span> -d$<span class="string">&#x27;\t&#x27;</span> -f2`</span><br><span class="line"><span class="comment"># 显示内核及版本号</span></span><br><span class="line"><span class="comment"># Kernel=`uname -s -r`</span></span><br><span class="line"><span class="built_in">echo</span> 内核版本：$<span class="string">&#x27;\t&#x27;</span>  `<span class="built_in">uname</span> -s -r`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示CPU信息</span></span><br><span class="line"><span class="built_in">echo</span> CPU型号：\(详细信息可使用 lscpu 查看\)</span><br><span class="line"><span class="comment">#grep -i &#x27;model name&#x27; /proc/cpuinfo	# Ubuntu桌面版本适用</span></span><br><span class="line">grep -i <span class="string">&#x27;model&#x27;</span> /proc/cpuinfo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示显卡信息</span></span><br><span class="line"><span class="comment">#echo 显卡信息：</span></span><br><span class="line"><span class="comment">#lspci | grep -i &#x27;vga&#x27;			# Ubuntu桌面版本适用</span></span><br><span class="line"><span class="built_in">echo</span> PCI设备:</span><br><span class="line">lspci</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示网口信息</span></span><br><span class="line"><span class="comment">#echo 以太网信息：</span></span><br><span class="line"><span class="comment">#lspci | grep -i &#x27;Ethernet&#x27;		# Ubuntu桌面版本适用</span></span><br><span class="line"><span class="comment">#echo &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示内存信息</span></span><br><span class="line"><span class="built_in">echo</span> 内存容量：`grep -i <span class="string">&#x27;MemTotal&#x27;</span> /proc/meminfo | <span class="built_in">cut</span> -d: -f2`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示硬盘信息</span></span><br><span class="line"><span class="built_in">echo</span> 硬盘信息：</span><br><span class="line">lsblk -d -o NAME,SIZE,TYPE,MOUNTPOINT</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-------------DONE---------------------&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>将上述命令存为shell脚本，如<code>info.sh</code> 然后执行即可 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi info.sh</span><br><span class="line">bash ./info.sh</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----------当前计算机信息---------------</span><br><span class="line">系统版本：       Ubuntu 20.04.1 LTS</span><br><span class="line">内核版本：       Linux 5.4.0-1026-raspi</span><br><span class="line"> </span><br><span class="line">CPU型号：(详细信息可使用 lscpu 查看)</span><br><span class="line">Model           : Raspberry Pi 4 Model B Rev 1.2</span><br><span class="line"></span><br><span class="line">PCI设备:</span><br><span class="line">00:00.0 PCI bridge: Broadcom Inc. and subsidiaries Device 2711 (rev 10)</span><br><span class="line">01:00.0 USB controller: VIA Technologies, Inc. VL805 USB 3.0 Host Controller (rev 01)</span><br><span class="line"></span><br><span class="line">以太网信息：</span><br><span class="line"></span><br><span class="line">内存容量： 3831216 kB</span><br><span class="line"></span><br><span class="line">硬盘信息：</span><br><span class="line">NAME     SIZE TYPE MOUNTPOINT</span><br><span class="line">loop0   48.5M loop /snap/core18/1883</span><br><span class="line">loop1   48.9M loop /snap/core18/1949</span><br><span class="line">loop2   63.6M loop /snap/lxd/16103</span><br><span class="line">loop3   59.9M loop /snap/lxd/18152</span><br><span class="line">loop4     27M loop /snap/snapd/10494</span><br><span class="line">loop5     27M loop /snap/snapd/10709</span><br><span class="line">mmcblk0 14.9G disk</span><br><span class="line"></span><br><span class="line">-------------DONE---------------------</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="修改软件更新源">1、修改软件更新源</h2>
<p>　　外网速度令人发指，改为国内镜像，速度快、ipv6不计流量，价格便宜量又足...</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先保留备份</span></span><br><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"><span class="comment"># 替换为清华镜像</span></span><br><span class="line">sudo sed -i <span class="string">&#x27;s/http:\/\/ports.ubuntu.com/https:\/\/mirrors.tuna.tsinghua.edu.cn/&#x27;</span> /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留备份</span></span><br><span class="line">sudo <span class="built_in">cp</span> /root/.config/pip/pip.conf /root/.config/pip/pip.conf.bak &gt;nul 2&gt;&amp;1</span><br><span class="line"><span class="comment"># python 源改为工大镜像</span></span><br><span class="line">sudo pip config <span class="built_in">set</span> global.index-url https://mirrors.njtech.edu.cn/pypi/web/simple </span><br></pre></td></tr></table></figure>
<blockquote>
<p>注1: 请在对系统进行修改前，对原始文件进行备份<br/> 注2: 如果使用<code>apt</code>更新时提示<code>ssl</code>错误，则先把 <code>https://mirrors.tuna...</code>改为 <code>http://mirrors.tuna...</code>更新，再使用<code>https</code>即可。</p>
</blockquote>
<h2 id="安装raspi-config配置外设">2、安装<code>raspi-config</code>，配置外设</h2>
<h3 id="安装raspi-config">1) 安装<code>raspi-config</code>；</h3>
<p>　　进入工大镜像，找到最新的<a href="https://mirrors.njtech.edu.cn/raspberrypi/pool/main/r/raspi-config/"><code>raspi-config</code></a>(点击进入下载);</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最新为 raspi-config_20210119_all.deb</span></span><br><span class="line">wget -c -4 https://mirrors.njtech.edu.cn/raspberrypi/pool/main/r/raspi-config/raspi-config_20210119_all.deb -P /tmp</span><br><span class="line"><span class="comment"># 安装（会失败）</span></span><br><span class="line">sudo dpkg -i ./raspi-config_20210119_all.deb</span><br><span class="line"><span class="comment"># 根据提示安装依赖库....</span></span><br><span class="line"><span class="comment"># sudo apt instal xxxxx</span></span><br><span class="line"><span class="comment"># 修复</span></span><br><span class="line">sudo apt --fix-broken install</span><br><span class="line"><span class="comment"># 再次安装（应该会成功）</span></span><br><span class="line">sudo dpkg -i ./raspi-config_20210119_all.deb</span><br><span class="line"><span class="comment"># done</span></span><br></pre></td></tr></table></figure>
<h3 id="使用raspi-config配置树莓派">2) 使用<code>raspi-config</code>配置树莓派</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下开始使用 raspi-config 配置树莓派</span></span><br><span class="line"><span class="comment"># SSH 开启远程登录，是应当第一个打开的服务</span></span><br><span class="line">sudo raspi-config</span><br><span class="line"><span class="comment"># 进入3 Interface，启用 Camera, SSH, I2C, SPI, Serial Port，保存退出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">i2cdetect -y 1</span><br><span class="line"><span class="comment"># 结果如下：注意40有个设备，如果没有接I2C设备，那么全部为空</span></span><br><span class="line"><span class="comment">#       0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f</span></span><br><span class="line"><span class="comment">#  00:          -- -- -- -- -- -- -- -- -- -- -- -- --</span></span><br><span class="line"><span class="comment">#  10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span></span><br><span class="line"><span class="comment">#  20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span></span><br><span class="line"><span class="comment">#  30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span></span><br><span class="line"><span class="comment">#  40: 40 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span></span><br><span class="line"><span class="comment">#  50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span></span><br><span class="line"><span class="comment">#  60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --</span></span><br><span class="line"><span class="comment">#  70: 70 -- -- -- -- -- -- --</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注1: 当开启Camera，如果出现固件过时的错误时： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your firmwave appears to be out of <span class="built_in">date</span> (no start_x.elf). Please ...</span><br></pre></td></tr></table></figure> 解决方法： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看boot分区所在的设备号，设备号可能是：/dev/mmcblk0p1 </span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 将该设备号挂载在/boot上</span></span><br><span class="line">mount /dev/mmcblk0p1 /boot</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>注2: 如果上述命令显示用户无权限，那么可以通过添加一个用户在来解决（以下方法未测试）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd i2c (group may exist already)</span><br><span class="line">sudo <span class="built_in">chown</span> :i2c /dev/i2c-1 (or i2c-0)</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/i2c-1</span><br><span class="line">sudo usermod -aG i2c *INSERT YOUR USERNAME*</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>注3: 也可以通过配置文件打开spi/i2c/uart/1-wire等设备：<code>sudo vi /boot/config.txt</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dtparam=spi=on</span><br><span class="line">dtparam=i2c_arm=on</span><br><span class="line"># For the best performance, tweak the I2C core to run at 1MHz.</span><br><span class="line"># By default it may be 100KHz or 400KHz</span><br><span class="line">dtparam=i2c_baudrate=1000000</span><br><span class="line">enable_uart=1</span><br><span class="line">dtoverlay=w1-gpio</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/sinat_25259461/article/details/108353324">https://blog.csdn.net/sinat_25259461/article/details/108353324</a></p>
</blockquote>
<h2 id="安装-net-toolswireless-toolsi2c和蓝牙工具">3、安装 <code>net-tools</code>、<code>wireless-tools</code>、<code>I2C</code>和蓝牙工具</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># net-tools -&gt; ifconfig命令等</span></span><br><span class="line"><span class="comment"># wireless-tools -&gt; iwconfig 命令等</span></span><br><span class="line">sudo apt install net-tools wireless-tools i2c-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装蓝牙</span></span><br><span class="line">sudo apt install pi-bluetooth </span><br><span class="line"></span><br><span class="line"><span class="comment"># 蓝牙配置 /boot/firmware/syscfg.txt</span></span><br><span class="line"><span class="comment"># sudo bluetoothctl     # 进入蓝牙控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 wpasupplicant 没有安装，也需要这个软件</span></span><br><span class="line">sudo apt install wpasupplicant</span><br><span class="line"><span class="comment"># 几个工具的使用：</span></span><br><span class="line"><span class="comment"># ls /sys/class/net/ # 查看网卡信息，树莓派输出： eth0  lo  wlan0</span></span><br><span class="line"><span class="comment"># ifconfig  # 以太网络参数</span></span><br><span class="line"><span class="comment"># iwconfig  # 无线网络参数</span></span><br><span class="line"><span class="comment"># 扫描SSID</span></span><br><span class="line"><span class="comment"># sudo iwlist wlan0 scan | grep ESSID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装g++， 安装RPi.GPIO时需要使用</span></span><br><span class="line">sudo apt install g++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试：</span></span><br><span class="line"><span class="comment"># ubuntu@ubuntu:~$ g++ -v</span></span><br><span class="line"><span class="comment">#  Using built-in specs.</span></span><br><span class="line"><span class="comment">#  COLLECT_GCC=g++</span></span><br><span class="line"><span class="comment">#  COLLECT_LTO_WRAPPER=/usr/lib/gcc/aarch64-linux-gnu/9/lto-wrapper</span></span><br><span class="line"><span class="comment">#  Target: aarch64-linux-gnu</span></span><br><span class="line"><span class="comment">#  Configured with: ....</span></span><br><span class="line"><span class="comment">#  Thread model: posix</span></span><br><span class="line"><span class="comment">#  gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果希望安装 gcc 10.xx版本可以使用，但无法编译安装RPi.GPIO</span></span><br><span class="line"><span class="comment"># sudo apt install g++-10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以安装build-essential，gcc/g++/make/dpkg等都安装了</span></span><br><span class="line"><span class="comment"># sudo apt install build-essential</span></span><br></pre></td></tr></table></figure>
<h2 id="配置无线网络">4、配置无线网络</h2>
<p>无线网络的配置有两种模式，1) 首次系统启动前，在已安装系统的SD卡上修改；2) 非首次启动，进入系统后修改（需要本地/SSH登录）</p>
<h3 id="第一种方式">1) 第一种方式：</h3>
<p>（未测试）进入SDK的<code>system-boot</code>分区，编辑<code>network-config</code>文件，添加 <code>Wi-Fi</code> 信息. <code>network-config</code>文件已经内含了一个简单示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">wifis:</span></span><br><span class="line">  <span class="attr">wlan0:</span></span><br><span class="line">  <span class="attr">dhcp4:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">optional:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">access-points:</span></span><br><span class="line">    <span class="string">&lt;wifi</span> <span class="string">network</span> <span class="string">name&gt;:</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;&lt;wifi password&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="第二种方式">2) 第二种方式：</h3>
<p>编辑/etc/netplan/01-netconfig.yaml文件（没有就创建）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd</span><br><span class="line">  ethernets:</span><br><span class="line">      eth0:</span><br><span class="line">          optional: true</span><br><span class="line">          dhcp4: yes</span><br><span class="line">          # addresses:</span><br><span class="line">          #    - 10.3.89.200/24</span><br><span class="line">          # gateway4: 10.3.89.1</span><br><span class="line">          # nameservers:</span><br><span class="line">          #     addresses: [202.119.248.66,218.2.135.1]</span><br><span class="line">          dhcp6: yes</span><br><span class="line">  wifis:</span><br><span class="line">      wlan0:</span><br><span class="line">          dhcp4: true</span><br><span class="line">          optional: true</span><br><span class="line">          access-points:</span><br><span class="line">              &quot;NJCD&quot;:</span><br><span class="line">                  password: &quot;PASSWORD&quot;</span><br><span class="line">              &quot;NJTech&quot;: &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="安装pythonpip和opencv">5、安装<code>python</code>、<code>pip</code>和<code>opencv</code></h2>
<h3 id="安装-python">1) 安装 <code>python</code></h3>
<p>　　严格来说，这不叫安装。<code>Ubuntu 20.04</code>已经自带<code>Python</code> 3.8版本.如果只需要使用<code>python 3</code>，并且不愿每次都输入<code>python3</code>来执行脚本，那么简单的做一个软链接即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /bin/python3.8 /bin/python</span><br></pre></td></tr></table></figure>
<h3 id="安装pip">2) 安装<code>pip</code></h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一，通过Ubuntu安装</span></span><br><span class="line">sudo apt install python-pip</span><br><span class="line"><span class="comment"># 方法二：利用getpip.py安装，详见: https://pip.pypa.io/en/stable/installing/</span></span><br><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</span><br><span class="line"><span class="comment"># 使用管理员权限，</span></span><br><span class="line">sudo python get-pip.py --proxy=<span class="string">&quot;http://[user:passwd@]proxy.server:port&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="通过pip安装常用的python第三方包和opencv">3) 通过<code>pip</code>安装常用的<code>python</code>第三方包和<code>OpenCV</code></h3>
<p>　　<code>OpenCV</code>的部分依赖库，需要<code>cmake</code>联网下载，直接安装会出错，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先安装常用的python库</span></span><br><span class="line">sudo pip install -U numpy scipy matplotlib pandas lxml requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 adafruit硬件操作库</span></span><br><span class="line">sudo pip install -U RPi.GPIO smbus2 Adafruit-Blinka adafruit-circuitpython-busdevice \</span><br><span class="line">               adafruit-circuitpython-framebuf adafruit-circuitpython-motor \</span><br><span class="line">	       adafruit-circuitpython-pca9685 adafruit-circuitpython-register \</span><br><span class="line">	       adafruit-circuitpython-ssd1306 Adafruit-PlatformDetect Adafruit-PureIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 OpenCV</span></span><br><span class="line">sudo pip install -U opencv-contrib-python-headless</span><br></pre></td></tr></table></figure>
<p>　　<code>OpenCV</code>的安装如果能成功，可以略过以下步骤。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下为OpenCV源码编译安装，</span></span><br><span class="line"><span class="comment"># 基本过程为将源码(.tar.gz结尾)复制到一个临时文件夹内进行编译，</span></span><br><span class="line"><span class="comment"># 然后使用pip直接安装编译成功的whl文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先安装cmake</span></span><br><span class="line"></span><br><span class="line">sudo apt install cmake</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入管理员模式，一般情况，尽量避免在管理员模式下操作。</span></span><br><span class="line">sudo su</span><br><span class="line">find /root -name opencv-contrib*.tar.gz</span><br><span class="line"><span class="comment"># find会返回已经查找到的opencv-contrib*tar.gz的压缩包文件</span></span><br><span class="line"><span class="built_in">cp</span> /root/.cache/pip/xxx(一串路径)xx/opencv-contrib-python-headless-4.4.0.46.tar.gz /root</span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line">tar xvfz opencv-contrib-python-headless-4.4.0.46.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> opencv-contrib-python-headless-4.4.0.46</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我这里编译不成功的关键是缺少xfeatures2d，也可以禁用该模块，</span></span><br><span class="line"><span class="built_in">mkdir</span> -p opencv/.cache/xfeatures2d/boostdesc</span><br><span class="line"><span class="built_in">mkdir</span> -p .cache/xfeatures2d/vgg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入opencv_contrib/modules/xfeatures2d/cmake目录，</span></span><br><span class="line"><span class="comment"># 打开download_boostdesc.cmake和download_vgg.cmake文件</span></span><br><span class="line"><span class="comment"># 需要下载的文件链接为：</span></span><br><span class="line"><span class="comment">#   https://raw.githubusercontent.com/opencv/opencv_3rdparty/$&#123;OPENCV_3RDPARTY_COMMIT&#125;/$&#123;file_name&#125;</span></span><br><span class="line"><span class="comment"># 保存的文件名为 $&#123;hash&#125;-$&#123;file_name&#125;</span></span><br><span class="line"><span class="comment"># 分别下载vgg和bootsdesc文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 截至 2020.1.20日编译时，下载的xfeature2d所需文件</span></span><br><span class="line"><span class="comment"># xfeatures2d/boostdesc/0ae0675534aa318d9668f2a179c2a052-boostdesc_lbgm.i</span></span><br><span class="line"><span class="comment"># xfeatures2d/boostdesc/0ea90e7a8f3f7876d450e4149c97c74f-boostdesc_bgm.i</span></span><br><span class="line"><span class="comment"># xfeatures2d/boostdesc/202e1b3e9fec871b04da31f7f016679f-boostdesc_binboost_064.i</span></span><br><span class="line"><span class="comment"># xfeatures2d/boostdesc/232c966b13651bd0e46a1497b0852191-boostdesc_bgm_bi.i</span></span><br><span class="line"><span class="comment"># xfeatures2d/boostdesc/324426a24fa56ad9c5b8e3e0b3e5303e-boostdesc_bgm_hd.i</span></span><br><span class="line"><span class="comment"># xfeatures2d/boostdesc/98ea99d399965c03d555cef3ea502a0b-boostdesc_binboost_128.i</span></span><br><span class="line"><span class="comment"># xfeatures2d/boostdesc/e6dcfa9f647779eb1ce446a8d759b6ea-boostdesc_binboost_256.i</span></span><br><span class="line"><span class="comment"># xfeatures2d/vgg/151805e03568c9f490a5e3a872777b75-vgg_generated_120.i</span></span><br><span class="line"><span class="comment"># xfeatures2d/vgg/7126a5d9a8884ebca5aea5d63d677225-vgg_generated_64.i</span></span><br><span class="line"><span class="comment"># xfeatures2d/vgg/7cd47228edec52b6d82f46511af325c5-vgg_generated_80.i</span></span><br><span class="line"><span class="comment"># xfeatures2d/vgg/e8d0dcd54d1bcfdc29203d011a797179-vgg_generated_48.i</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pip正常安装opencv</span></span><br><span class="line"></span><br><span class="line">pip install -U .</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：上述安装过程中，可能需要安装相应的编译工具。</p>
</blockquote>
<h2 id="安装配置-nginxuwsgiflask">6、安装配置 <code>nginx</code>、<code>uWSGI</code>、<code>flask</code>；</h2>
<h3 id="安装">1) 安装；</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx uwsgi uwsgi-plugin-python3</span><br><span class="line">sudo pip install flask</span><br></pre></td></tr></table></figure>
<h3 id="配置">2) 配置：</h3>
<h2 id="非管理员访问硬件">7、非管理员访问硬件：</h2>
<p>使用管理员权限进行硬件操作太过危险，还是使用非管理员权限比较安全，以下将用户<code>ubuntu</code>添加至<code>device</code>用户组，修改<code>device</code>用户组，使之具有各个设备的访问权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo groupadd devices</span><br><span class="line"></span><br><span class="line"><span class="comment">#sudo chown :devices /dev/i2c-0</span></span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/i2c-1</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/spidev0.0</span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/spidev0.1</span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/gpiochip0</span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/gpiochip1</span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/gpiomem</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/i2c-0</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/i2c-1</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/spidev0.0</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/spidev0.1</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/gpiomem</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/gpiochip0</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/gpiochip1</span><br><span class="line"></span><br><span class="line">sudo usermod -aG devices ubuntu</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试时发现，貌似仅在当前session中执行后有效（原因不明），可以将上述命令作为服务，每次启动自动运行一次：</p>
<p>创建启动服务<code>my-start-up</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/init.d/my-start-up</span><br></pre></td></tr></table></figure>
<p>添加如下内容： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          ferret</span></span><br><span class="line"><span class="comment"># Required-Start:    $remote_fs $syslog</span></span><br><span class="line"><span class="comment"># Required-Stop:     $remote_fs $syslog</span></span><br><span class="line"><span class="comment"># Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:      0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: Make devices accessiable at boot time</span></span><br><span class="line"><span class="comment"># Description:       None.....</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将用户添加至devices组，以直接访问外设</span></span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/i2c-1 <span class="comment">#(or i2c-0)</span></span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/spidev0.0</span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/spidev0.1</span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/gpiochip0</span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/gpiochip1</span><br><span class="line">sudo <span class="built_in">chown</span> :devices /dev/gpiomem</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/i2c-1</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/spidev0.0</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/spidev0.1</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/gpiomem</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/gpiochip0</span><br><span class="line">sudo <span class="built_in">chmod</span> g+rw /dev/gpiochip1</span><br><span class="line"></span><br><span class="line">sudo usermod -aG devices ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出，重新登录，测试</span></span><br><span class="line">i2cdetect -y 1</span><br></pre></td></tr></table></figure></p>
<p>执行以下命令，创建启动服务 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动创建</span></span><br><span class="line">sudo update-rc.d my-start-up defaults</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果创建失败，以下可以手动创建</span></span><br><span class="line"><span class="comment"># 手动创建</span></span><br><span class="line"><span class="comment"># cd /etc/rc2.d</span></span><br><span class="line"><span class="comment"># sudo ln -s ../init.d/my-start-up S20my-start-up</span></span><br><span class="line"><span class="comment"># cd /etc/rc3.d</span></span><br><span class="line"><span class="comment"># sudo ln -s ../init.d/my-start-up S20my-start-up</span></span><br><span class="line"><span class="comment"># cd /etc/rc4.d</span></span><br><span class="line"><span class="comment"># sudo ln -s ../init.d/my-start-up S20my-start-up</span></span><br><span class="line"><span class="comment"># cd /etc/rc5.d</span></span><br><span class="line"><span class="comment"># sudo ln -s ../init.d/my-start-up S20my-start-up</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用红外遥控">8、使用红外遥控</h2>
<p>安装： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装libgpiod库</span></span><br><span class="line">sudo apt install libgpiod2</span><br><span class="line"><span class="comment"># 安装 adafruit-circuitpython-irremote</span></span><br><span class="line">sudo pip install adafruit-circuitpython-irremote</span><br><span class="line"></span><br></pre></td></tr></table></figure> 需要注意，<code>adafruit</code>的<code>blinka</code>库自带一个<code>libgpiod_pulsein</code>，使用<code>file</code>命令查看，为32位版本，需要使用64位替换： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file /usr/local/lib/python3.8/dist-packages/adafruit_blinka/microcontroller/bcm283x/pulseio/libgpiod_pulsein</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下为编译`libgpiod_pulsein`64bit版本</span></span><br><span class="line">sudo apt install libgpiod-dev</span><br><span class="line"><span class="comment">#git clone https://github.com/adafruit/libgpiod_pulsein.git</span></span><br><span class="line"><span class="built_in">cd</span> libgpiod_pulsein/src</span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>待续</p>
<h2 id="x更新ubuntu和各个python库">X、更新<code>Ubuntu</code>和各个<code>python</code>库</h2>
<h3 id="添加一个alias方便更新">1) 添加一个<code>alias</code>，方便更新</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi ~/.bash_aliases</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制添加以下内容至 ~/.bash_aliases文件</span></span><br><span class="line"><span class="built_in">alias</span> pipupdate =<span class="string">&#x27;sudo pip install -U numpy scipy matplotlib pandas lxml requests RPi.GPIO \</span></span><br><span class="line"><span class="string">	     smbus2 opencv-contrib-python-headless adafruit-circuitpython-ssd1306 \</span></span><br><span class="line"><span class="string">	     Adafruit-Blinka adafruit-circuitpython-busdevice Adafruit-PureIO\</span></span><br><span class="line"><span class="string">             adafruit-circuitpython-framebuf adafruit-circuitpython-motor \</span></span><br><span class="line"><span class="string">	     adafruit-circuitpython-pca9685 adafruit-circuitpython-register \</span></span><br><span class="line"><span class="string">	     Adafruit-PlatformDetect adafruit-circuitpython-mpu6050 \</span></span><br><span class="line"><span class="string">             adafruit-circuitpython-lsm9ds0 adafruit-circuitpython-adxl34x \</span></span><br><span class="line"><span class="string">             adafruit-circuitpython-vl53l0x adafruit-circuitpython-pcf8591&#x27;</span></span><br><span class="line">	       </span><br><span class="line"><span class="comment"># 激活</span></span><br><span class="line">sudo <span class="built_in">source</span> ~/.bash_aliases</span><br></pre></td></tr></table></figure>
<h2 id="xx题外话">XX、题外话</h2>
<p>　　1. 如果使用的是树莓派自己的系统（2020-12-02-raspios-buster-armhf-lite，非ubuntu)，首先需要卸载自带的vim-common 安装完整版的vim，才能正常使用vim。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt remove vim-common</span><br><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure>
<p>　　2. 如果希望在 <code>Ubuntu Server</code>下使用桌面，命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt insatll ubuntu-desktop</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>折腾</category>
        <category>Linux</category>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>树莓派</tag>
        <tag>20.04</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32之Keil v5 MDK</title>
    <url>/2022/08/12/2022-08-12_keilmdk/</url>
    <content><![CDATA[<p>记录将<code>Keil v5</code>老版本使用的<code>version 5</code>编译器升级到<code>version 6</code>之后，编译出现的问题。</p>
<ul>
<li>环境： <code>Win10x64, Keil MDK v5.37</code></li>
<li>开发板： <code>DevEBox STM32F407VE</code></li>
</ul>
<span id="more"></span>
<h2 id="解决以下警告">1、解决以下警告：</h2>
<ol type="1">
<li><code>warning: illegal character encoding</code></li>
<li><code>invalid conversion specifier</code></li>
</ol>
<p>点击<code>Options For Target ...</code>，选择<code>C/C++(AC6)</code>，在<code>Misc Controls</code>内添加<code>-Wno-invalid-source-encoding -Wno-format-invalid-specifier</code></p>
<h2 id="使用clang-format格式化代码">2、使用<code>clang-format</code>格式化代码</h2>
<p>点击<code>Tools</code>-&gt;<code>Customize Tools Menu</code>，双击增加一个菜单，命名为<code>clang-format</code>，勾选<code>Run Minized</code>，<code>Command</code>栏点击导入<code>clang-format.exe</code>文件路径，<code>Arguments</code>内添加如下参数：<code>-style="&#123;ColumnLimit: 120, SpacesBeforeTrailingComments: 8,AllowShortCaseLabelsOnASingleLine: true&#125;" -i !E</code></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>stm32</tag>
        <tag>Keil v5</tag>
      </tags>
  </entry>
  <entry>
    <title>Botan的编译</title>
    <url>/2017/08/01/Botan%E7%9A%84%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>今天心血来潮想编译一个Qt版本的SS，首先需要编译Botan，翻出以前的老帖子，重新编译了一下，没想到Botan 2.x版本编译很轻松。以下记录编译过程：</p>
<p>编译环境：Win10x64，MinGW 5.3.0(32bit), Botan 2.1.0</p>
<span id="more"></span>
<h2 id="botan下载">1.Botan下载</h2>
<p>Botan的地址有两个，一个是<a href="https://github.com/randombit/botan">Github主页</a>，一个是<a href="https://botan.randombit.net/">文档</a>。打开<a href="https://botan.randombit.net/">文档</a>地址，找到<code>Current Stable Release</code>，点击版本号(<a href="https://botan.randombit.net/releases/Botan-2.1.0.tgz">2.1.0</a>)下载。</p>
<h2 id="编译命令">2.编译命令</h2>
<p>Botan的编译需要使用msys2和Python，将源码放在msys2的用户目录（假设为yourname）下，进入源码目录。使用以下命令配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./configure.py --prefix=/home/yourname/build/botan-<span class="number">2.1</span><span class="number">.0</span> --os=mingw --cc=gcc --cpu=i686 --link-method=copy --disable-shared --amalgamation</span><br></pre></td></tr></table></figure>
<p>配置完成后，修改<Botan_Src>/Makefile文件，将：<code>SCRIPTS_DIR    = .\src\scripts</code>改为：<code>SCRIPTS_DIR    = ./src/scripts</code>，然后开始<code>make &amp; make install</code></p>
<h2 id="搞定">3.搞定</h2>
]]></content>
      <categories>
        <category>折腾</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Botan</tag>
        <tag>MinGW</tag>
      </tags>
  </entry>
  <entry>
    <title>南京的经纬各条路</title>
    <url>/2011/05/07/F016442378020114781035646/</url>
    <content><![CDATA[<p>经常听到“经x路”，“纬y路”的说法，这里做个记录。 <span id="more"></span></p>
<p>纬： 1. 幕府路一线 2. 建宁路一线 3. 模范马路一线 4. 北京东西路一线 5. 汉中路中山东路一线 6. 升州路健康路一线 7. 应天大街一线 8. 梦都大街雨花南路？ 9. 阅城大道？</p>
<p>经： 1. 中央路中山路一线 2. 虎踞路一线 3. 龙蟠中路一线 4. 江东路一线 5. 墨香板仓北安门明故宫一线 6. 扬子江大道一线</p>
<p>本文来自：<a href="http://ferret.blog.163.com/blog/static/6442378020114781035646" title="南京的经纬各条路">南京的经纬各条路</a></p>
]]></content>
      <categories>
        <category>生活点滴</category>
        <category>在南京</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>在南京</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt中的自定义类型</title>
    <url>/2016/10/26/F0264423780201692601941474/</url>
    <content><![CDATA[<p>将自定义类型加入元对象系统（meta-object system），可以获得运行时类型、信号槽等Qt特性支持。 <span id="more"></span></p>
<p>1、自定义类型必须至少满足以下3个条件：</p>
<p>   1）1个公有默认构造函数；<br/>    2）1个公有拷贝构造函数：<br/>    3）1个公有析构函数。<br/></p>
<p>2、使用<code>QMetaType</code>声明类型：</p>
<p>在头文件中使用<code>Q_DECLARE_METATYPE</code>宏声明类型： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(UserDefinedType);</span><br></pre></td></tr></table></figure> 使用该宏声明类型后，Qt可以将自定义类型的值以<code>QVariant</code>类型存储； <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MESSAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMetaType&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStringList&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Message</span>();</span><br><span class="line">    <span class="built_in">Message</span>(<span class="type">const</span> Message &amp;other);</span><br><span class="line">    ~<span class="built_in">Message</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Message</span>(<span class="type">const</span> QString &amp;body, <span class="type">const</span> QStringList &amp;headers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">QString <span class="title">body</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">QStringList <span class="title">headers</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_body;</span><br><span class="line">    QStringList m_headers;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(Message);</span><br><span class="line">QDebug <span class="keyword">operator</span>&lt;&lt;(QDebug dbg, <span class="type">const</span> Message &amp;message);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>以上两步骤完成后，该自定义类型仅能作为直接连接（线程内）的信号槽函数的参数使用。按照文档</p>
<blockquote>
<p>“This is because the meta-object system does not know how to handle creation and destruction of objects of the custom type at run-time.”</p>
</blockquote>
<p>如果需要跨线程使用自定义类型，那么必须继续完成以下步骤：</p>
<p>3、使用<code>qRegisterMetaType</code>模板函数向系统注册该自定义类型。 如：<code>qRegisterMetaType&lt;Block&gt;();</code>，注册后，该类型可以用于信号槽机制中（无论是线程内，还是线程间） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">qRegisterMetaType</span>&lt;Block&gt;();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 参见：</p>
<blockquote>
<p>http://doc.qt.io/qt-5/custom-types.html</p>
</blockquote>
<p>本文来自：<a href="http://ferret.blog.163.com/blog/static/64423780201692601941474" title="Qt中的自定义类型">Qt中的自定义类型</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Python应用与开发</title>
    <url>/2016/07/27/F036442378020166273284540/</url>
    <content><![CDATA[<p>记录Python使用的点点滴滴。</p>
<span id="more"></span>
<h2 id="numpy中的axis">1、numpy中的axis</h2>
<p>设<code>axis=i</code>，则<code>numpy</code>沿着第<code>i</code>个下标变化的方向进行操作。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = np.random.randint(<span class="number">0</span>, <span class="number">5</span>, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">axisCount = t.ndim   <span class="comment">#axis的数目=4</span></span><br><span class="line"></span><br><span class="line">t.<span class="built_in">sum</span>(axis=<span class="number">0</span>).shape   <span class="comment">#沿着第1个维度方向变化，此处sum结果的shape=(3,4,5)</span></span><br><span class="line">t.<span class="built_in">sum</span>(axis=<span class="number">1</span>).shape   </span><br><span class="line"><span class="comment">#沿着第2个维度方向变化，此处sum结果的shape=(2,4,5)</span></span><br><span class="line">t.<span class="built_in">sum</span>(axis=<span class="number">2</span>).shape   </span><br><span class="line"><span class="comment">#沿着第3个维度方向变化，此处sum结果的shape=(2,3,5)</span></span><br><span class="line">t.<span class="built_in">sum</span>(axis=<span class="number">3</span>).shape   </span><br><span class="line"><span class="comment">#沿着第4个维度方向变化，此处sum结果的shape=(2,3,4)</span></span><br><span class="line"></span><br><span class="line">ax1,ax2,ax3,ax4 = t.shape   </span><br><span class="line"></span><br><span class="line">v = np.zeros((ax2,ax3,ax4))   </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ax1):     <span class="comment"># 沿着第1个维度   </span></span><br><span class="line">    v = v + t[i]   </span><br><span class="line"><span class="built_in">print</span>((v==t.<span class="built_in">sum</span>(axis=<span class="number">0</span>)).<span class="built_in">all</span>())     <span class="comment"># 结果为true</span></span><br><span class="line">   </span><br><span class="line">v = np.zeros((ax1,ax3,ax4))   </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ax2):   </span><br><span class="line">    <span class="comment"># 沿着第2个维度</span></span><br><span class="line">    v = v + t[:,i,:,:]   </span><br><span class="line"><span class="built_in">print</span>((v==t.<span class="built_in">sum</span>(axis=<span class="number">1</span>)).<span class="built_in">all</span>())     <span class="comment"># 结果为true</span></span><br><span class="line">   </span><br><span class="line">v = np.zeros((ax1,ax2,ax4))    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ax3):   </span><br><span class="line">    <span class="comment"># 沿着第3个维度</span></span><br><span class="line">    v = v + t[:,:,i,:]   </span><br><span class="line"><span class="built_in">print</span>((v==t.<span class="built_in">sum</span>(axis=<span class="number">2</span>)).<span class="built_in">all</span>())     <span class="comment"># 结果为true</span></span><br><span class="line">   </span><br><span class="line">v = np.zeros((ax1,ax2,ax3))   </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ax4):   </span><br><span class="line">    <span class="comment"># 沿着第4个维度</span></span><br><span class="line">    v = v + t[:,:,:,i]   </span><br><span class="line"><span class="built_in">print</span>((v==t.<span class="built_in">sum</span>(axis=<span class="number">3</span>)).<span class="built_in">all</span>())     <span class="comment"># 结果为true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="绘制s形函数与双极s形函数">2、绘制S形函数与双极S形函数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制S形函数与双极S形函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line">    result = <span class="number">1.0</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tanh</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*sigmoid(x)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">6</span>,<span class="number">2.25</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">x = np.linspace(-<span class="number">5</span>,<span class="number">5</span>,<span class="number">500</span>)</span><br><span class="line">ax.plot(x,sigmoid(x),label=<span class="string">r&#x27;$\sigma(x)$&#x27;</span>,c=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">ax.plot(x,tanh(x),label=<span class="string">r&#x27;双极S型函数&#x27;</span>,c=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">ax.plot(x,np.tanh(x),label=<span class="string">r&quot;$\tanh(x)$&quot;</span>,c=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ax.set_xlim(-<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.2</span>,<span class="number">1.2</span>)</span><br><span class="line">ax.set_xticks(np.arange(x.<span class="built_in">min</span>(),x.<span class="built_in">max</span>()+<span class="number">0.1</span>,<span class="number">1</span>))</span><br><span class="line">ax.set_xlabel(<span class="string">r&#x27;$X$&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">r&#x27;$Y$&#x27;</span>)</span><br><span class="line">ax.legend(prop=font_manager.FontProperties(family=<span class="string">&#x27;stsong&#x27;</span>, size=<span class="number">11</span>),loc=<span class="number">4</span>,frameon=<span class="literal">False</span>)</span><br><span class="line">ax.axhline(c=<span class="string">&#x27;#000000&#x27;</span>)</span><br><span class="line">ax.axvline(c=<span class="string">&quot;#000000&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">r&#x27;常见激活函数&#x27;</span>,fontproperties=font_manager.FontProperties(family=<span class="string">&#x27;stkaiti&#x27;</span>, size=<span class="number">16</span>))</span><br><span class="line">plt.savefig(<span class="string">&#x27;activationFunc.png&#x27;</span>,dpi=<span class="number">120</span>)</span><br></pre></td></tr></table></figure>
<p>图像如下： <img src="/2016/07/27/F036442378020166273284540/activationFunc.png" class="" title="常见激活函数"> </p>
<h2 id="matplotlib-2.0.0中latex的字体问题">3、Matplotlib 2.0.0中Latex的字体问题</h2>
<p>Matplotlib 1.x版本中默认的Latex字体是<code>Computer Modern Roman</code>(简写为<code>cm</code>)，2.0.0版本中mathtext的字体为<code>dejavusans</code>，显示公式很难看。作一下修改： 方法一：在<code>matplotlibrc</code>中修改： 在用户目录的<code>.matplotlib</code>文件夹（<code>C:\Users\YourName\.matplotlib</code>）内，复制一份<code>matplotlibrc</code>文件，并将<code>mathtext.fontset</code>修改为<code>cm</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mathtext.sf  : sans</span><br><span class="line">mathtext.fontset : cm # Should be &#x27;dejavusans&#x27; (default),</span><br><span class="line">                      # &#x27;dejavuserif&#x27;, &#x27;cm&#x27; (Computer Modern), &#x27;stix&#x27;,</span><br><span class="line">                      # &#x27;stixsans&#x27; or &#x27;custom&#x27;</span><br><span class="line">#mathtext.fallback_to_cm : True  # When True, use symbols from the Computer Modern</span><br><span class="line">                                 # fonts when a symbol can not be found in one of</span><br><span class="line">                                 # the custom math fonts.</span><br></pre></td></tr></table></figure> 方法二：程序中使用<code>rc</code>函数修改 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复默认配置</span></span><br><span class="line"><span class="comment">#plt.rcdefaults()</span></span><br><span class="line"><span class="comment"># 显示默认配置</span></span><br><span class="line"><span class="comment">#plt.rcParamsDefault</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数学公式字体设为&#x27;Computer Modern Roman&#x27;(简写为cm)，Latex默认字体</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> rc</span><br><span class="line">rc(<span class="string">&#x27;mathtext&#x27;</span>,fontset=<span class="string">&#x27;cm&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示当前配置</span></span><br><span class="line"><span class="comment">#plt.rcParams</span></span><br></pre></td></tr></table></figure></p>
<h2 id="绘制3d矢量与颜色混合图">4、绘制3D矢量与颜色混合图</h2>
<p>参考： http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html http://matplotlib.org/gallery.html http://matplotlib.org/examples/index.html 效果： <img src="/2016/07/27/F036442378020166273284540/vector.jpg" class="" title="3D矢量">  <img src="/2016/07/27/F036442378020166273284540/circle.jpg" class="" title="颜色混合">  Code: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Sun Jan 05 13:14:34 2014</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Ferret</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> linalg</span><br><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> mpatches</span><br><span class="line"><span class="keyword">from</span> matplotlib.collections <span class="keyword">import</span> PatchCollection</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_angle</span>(<span class="params">aPoint,bPoint</span>):</span><br><span class="line">	<span class="comment">##  余弦定理求夹角</span></span><br><span class="line">	dot_value = np.dot(aPoint,bPoint)</span><br><span class="line">	aPoint_length = linalg.norm(aPoint)</span><br><span class="line">	bPoint_length = linalg.norm(bPoint) <span class="comment">#  == sqrt(np.dot(bPoint,bPoint))</span></span><br><span class="line">	angle = np.arccos(dot_value/(aPoint_length*bPoint_length))*<span class="number">180</span>/np.pi</span><br><span class="line">	point_dist = linalg.norm(aPoint-bPoint)</span><br><span class="line">	<span class="keyword">return</span> point_dist,angle</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label_point</span>(<span class="params">ax,points</span>):</span><br><span class="line">	<span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">		(xpt,ypt,zpt)=<span class="built_in">tuple</span>(point)</span><br><span class="line">		label = <span class="string">&#x27;  (%d, %d, %d)&#x27;</span> % (xpt, ypt, zpt)</span><br><span class="line">		ax.text(xpt, ypt, zpt, label)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_vector</span>(<span class="params">points</span>):</span><br><span class="line"></span><br><span class="line">	fig = plt.figure()</span><br><span class="line">	ax = fig.gca(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	ax.set_xlabel(<span class="string">&quot;X&quot;</span>)</span><br><span class="line">	ax.set_ylabel(<span class="string">&quot;Y&quot;</span>)</span><br><span class="line">	ax.set_zlabel(<span class="string">&quot;Z&quot;</span>)</span><br><span class="line"></span><br><span class="line">	ax.set_xlim(-<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">	ax.set_ylim(-<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">	ax.set_zlim(-<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	ax.plot(points[:,<span class="number">0</span>],points[:,<span class="number">1</span>],points[:,<span class="number">2</span>],<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">	label_point(ax,points)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">		line = np.vstack((point,np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])))</span><br><span class="line">		ax.plot(line[:,<span class="number">0</span>],line[:,<span class="number">1</span>],line[:,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">	plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_grid</span>():</span><br><span class="line">	radius=<span class="number">0.1</span></span><br><span class="line">	center = np.array([<span class="number">0.5</span>,<span class="number">0.5</span>])</span><br><span class="line">	patch_bottom = np.array([<span class="number">0</span>,-radius])</span><br><span class="line">	x = radius*np.cos(np.pi/<span class="number">6</span>)</span><br><span class="line">	y = radius*np.sin(np.pi/<span class="number">6</span>)</span><br><span class="line">	patch_left = np.array([-x,y])</span><br><span class="line">	patch_right = np.array([x,y])</span><br><span class="line">	bottom = center + patch_bottom</span><br><span class="line">	left = center + patch_left</span><br><span class="line">	right = center + patch_right</span><br><span class="line">	grid = np.vstack((bottom,left,right))</span><br><span class="line">	<span class="keyword">return</span> grid</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_circle</span>():</span><br><span class="line">	fig, ax = plt.subplots()</span><br><span class="line">	<span class="comment"># create 3x3 grid to plot the artists</span></span><br><span class="line">	<span class="comment">#grid = np.mgrid[0.2:0.8:3j, 0.2:0.8:3j].reshape(2, -1).T</span></span><br><span class="line">	grid = make_grid()</span><br><span class="line"></span><br><span class="line">	circles = []</span><br><span class="line"></span><br><span class="line">	<span class="comment"># add a circle</span></span><br><span class="line">	radius = <span class="number">0.1</span></span><br><span class="line">	circle1 = mpatches.Circle(grid[<span class="number">0</span>], radius,ec=<span class="string">&quot;none&quot;</span>)</span><br><span class="line">	circles.append(circle1)</span><br><span class="line"></span><br><span class="line">	circle2 = mpatches.Circle(grid[<span class="number">1</span>], radius,ec=<span class="string">&quot;none&quot;</span>)</span><br><span class="line">	circles.append(circle2)</span><br><span class="line"></span><br><span class="line">	circle3 = mpatches.Circle(grid[<span class="number">2</span>], radius,ec=<span class="string">&quot;none&quot;</span>)</span><br><span class="line">	circles.append(circle3)</span><br><span class="line"></span><br><span class="line">	colors = np.linspace(<span class="number">0.2</span>, <span class="number">1</span>, <span class="built_in">len</span>(circles)*<span class="number">2</span>)</span><br><span class="line">	collection = PatchCollection(circles, cmap=plt.cm.hsv, alpha=<span class="number">0.3</span>)</span><br><span class="line">	collection.set_array(colors)</span><br><span class="line">	<span class="built_in">print</span> colors</span><br><span class="line">	ax.add_collection(collection)</span><br><span class="line">	<span class="comment">#ax.add_line(line)</span></span><br><span class="line"></span><br><span class="line">	plt.subplots_adjust(left=<span class="number">0</span>, right=<span class="number">1</span>, bottom=<span class="number">0</span>, top=<span class="number">1</span>)</span><br><span class="line">	plt.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">	<span class="comment">#plt.axis(&#x27;off&#x27;)</span></span><br><span class="line"></span><br><span class="line">	plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vect_line</span>():</span><br><span class="line">	N=<span class="number">4</span> <span class="comment"># 4个点</span></span><br><span class="line">	pts= np.<span class="built_in">round</span>(np.random.random(N*<span class="number">3</span>).reshape(N,<span class="number">3</span>)*<span class="number">10</span>)</span><br><span class="line">	<span class="comment">#pts = np.array([[10,0,0],[1,10,0]])</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;pt:&quot;</span>,<span class="built_in">tuple</span>(pts[<span class="number">0</span>]),<span class="string">&quot;and pt:&quot;</span>,<span class="built_in">tuple</span>(pts[<span class="number">1</span>])</span><br><span class="line">	<span class="built_in">print</span> (<span class="string">&quot;distance:%0.2f, angle:%0.2f&quot;</span> %(cal_angle(pts[<span class="number">0</span>],pts[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">	plot_vector(pts)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#make_grid()</span></span><br><span class="line">	plot_circle()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span> :</span><br><span class="line">	vect_line()</span><br></pre></td></tr></table></figure></p>
<h2 id="正则表达式">5、正则表达式</h2>
<figure>
<img src="http://7xk3em.com1.z0.glb.clouddn.com/python%E6%AD%A3%E5%88%99.jpg" title="正则表达式" alt="正则表达式" /><figcaption aria-hidden="true">正则表达式</figcaption>
</figure>
<p>使用<code>re.compile(pattern,flag)</code>创建正则表达式匹配模式时<code>flag</code>含义： 
<table>
<thead>
<tr>
<th style="width:120px;">标志</th>
<th style="text-align:center;width:50px;">简写</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.ASCII</td>
<td style="text-align:center">re.A</td>
<td >\w, \W, \b, \B, \d, \D, \s 和 \S 只匹配ASCII码</td>
</tr>
<tr>
<td>re.DEBUG</td>
<td style="text-align:center">\</td>
<td >显示表达式编译的调试信息</td>
</tr>
<tr>
<td>re.IGNORECASE</td>
<td style="text-align:center">re.I</td>
<td >忽略大小写（只针对ASCII码）</td>
</tr>
<tr>
<td>re.LOCALE</td>
<td style="text-align:center">re.L</td>
<td >指示\w, \W, \b, \B, \s 和 \S 依赖于本地语言编码. 仅限于 bytes 匹配模式.</td>
</tr>
<tr>
<td>re.MULTILINE</td>
<td style="text-align:center">re.M</td>
<td >设定时，模式”^”在字符串的开始处和每行的开头匹配（紧跟在每个换行符之后）; 且模式”<span>$</span>”匹配字符串的末尾和每行的末尾（紧邻每个换行符）之间匹配。 默认情况下，’^’仅匹配字符串的开头，而’$’仅在字符串的末尾，紧跟在字符串末尾的换行符（如果有）。</td>
</tr>
<tr>
<td>re.DOTALL</td>
<td style="text-align:center">re.S</td>
<td >设定该标志时， ‘.’ 可以匹配所有字符包括换行符”\n”，否则不匹配换行符</td>
</tr>
<tr>
<td>re.VERBOSE</td>
<td style="text-align:center">re.X</td>
<td >在pattern内部，视’#’开始的字串为注释，对pattern无影响。</td>
</tr>
</tbody>
</table>
</p>
<h2 id="使用lxml解析svg">6、使用<code>lxml</code>解析<code>SVG</code></h2>
<p>以下代码获取svg中的各个图片元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">xml = etree.parse(<span class="string">&#x27;resources.svg&#x27;</span>)</span><br><span class="line">xml.xpath(<span class="string">&#x27;//*[local-name()=&quot;svg&quot;]//*[local-name()=&quot;g&quot;]/*[local-name()=&quot;g&quot;]/@id&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>结合Qt，将Svg中的图片保存为PNG图片格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtGui</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtSvg</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">svg2Png</span>(<span class="params">svgFile</span>):</span><br><span class="line">    xml = etree.parse(svgFile)</span><br><span class="line">    svgs = xml.xpath(<span class="string">&#x27;//*[local-name()=&quot;svg&quot;]//*[local-name()=&quot;g&quot;]/*[local-name()=&quot;g&quot;]/@id&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    render = QtSvg.QSvgRenderer(<span class="string">&#x27;resources.svg&#x27;</span>)</span><br><span class="line">    src = QtGui.QImage(<span class="number">400</span>,<span class="number">400</span>,QtGui.QImage.Format_RGBA8888)</span><br><span class="line">    <span class="keyword">if</span>(render.isValid()):           </span><br><span class="line">        <span class="keyword">for</span> svg <span class="keyword">in</span> svgs:            </span><br><span class="line">            img = src.copy()</span><br><span class="line">            p = QtGui.QPainter(img)</span><br><span class="line">            r = QtCore.QRectF(img.rect())</span><br><span class="line">            render.render(p,svg,r)</span><br><span class="line">            img.save(<span class="string">&#x27;&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(svg))   </span><br><span class="line">            p=<span class="literal">None</span>				<span class="comment">#一定要删除，否则无法释放QImage</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;svg bad&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">svg2Png(<span class="string">&#x27;resources.svg&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>本文来自：<a href="http://ferret.blog.163.com/blog/static/6442378020166273284540" title="Python绘图">Python绘图</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake记录</title>
    <url>/2015/09/13/F046442378020158132732906/</url>
    <content><![CDATA[<p>记录使用cmake的点滴。</p>
<span id="more"></span>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> DEPS_DIR=..\deps</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exist</span> &quot;<span class="variable">%DEPS_DIR%</span>&quot;  <span class="built_in">mkdir</span> &quot;<span class="variable">%DEPS_DIR%</span>&quot;</span><br></pre></td></tr></table></figure>
<h2 id="编译zlib">1、编译zlib</h2>
<p>在当前目录下创建MinGW编译文件，指定安装路径为<code>./install</code>。 <figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">cmake ..\zlib-<span class="number">1</span>.<span class="number">2</span>.<span class="number">8</span> -G &quot;MinGW Makefiles&quot; -DCMAKE_INSTALL_PREFIX=&quot;<span class="variable">%DEPS_DIR%</span>&quot;</span><br></pre></td></tr></table></figure> ## 2、OpenSSL的编译，需要使用msys2，没有cmake文件</p>
<h2 id="编译libssh2">3、编译LibSSH2</h2>
<p>条件：预先编译好了OpenSSL和zlib，       OpenSSL和zlib编译后文件均位于.. <figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">cmake ..\libssh2-master -G &quot;MinGW Makefiles&quot; -DOPENSSL_INCLUDE_DIR=&quot;<span class="variable">%DEPS_DIR%</span>\include&quot; -DLIB_EAY=&quot;<span class="variable">%DEPS_DIR%</span>\bin\libeay32.dll&quot; -DSSL_EAY=&quot;<span class="variable">%DEPS_DIR%</span>\bin\ssleay32.dll&quot; -DBUILD_SHARED_LIBS=true -DCMAKE_INSTALL_PREFIX=&quot;<span class="variable">%DEPS_DIR%</span>&quot; -DDLL_LIBEAY32=&quot;<span class="variable">%DEPS_DIR%</span>\bin\libeay32.dll&quot; -DDLL_SSLEAY32=&quot;<span class="variable">%DEPS_DIR%</span>\bin\ssleay32.dll&quot; -DENABLE_ZLIB_COMPRESSION=true -DZLIB_LIBRARY=&quot;<span class="variable">%DEPS_DIR%</span>\lib\zlibstatic.a&quot; -DZLIB_INCLUDE_DIR=&quot;<span class="variable">%DEPS_DIR%</span>\include&quot;</span><br></pre></td></tr></table></figure> 本文来自：<a href="http://ferret.blog.163.com/blog/static/6442378020158132732906" title="CMake记录">CMake记录</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>转：Qt 线程基础(QThread、QtConcurrent等)</title>
    <url>/2015/05/20/F0564423780201542092749179/</url>
    <content><![CDATA[<p>From: <a href="http://blog.csdn.net/dbzhang800/article/details/6554104">Qt 线程基础</a></p>
<p>注意： - 该链接以后会失效，但是到时候你直接看Qt自带Manual就行了 - 本文不是严格的翻译 dbzhang800，2011.06.18</p>
<span id="more"></span>
<div class="bct fc05 fc11 nbw-blog ztag">
<h2 id="A.2BT391KH6.2Fegs-" style="margin: 0px; padding: 0px 0px 0.3em; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(4, 115, 7);">
<a style="color: rgb(51, 102, 153);" name="t0" rel="nofollow"></a>使用线程
</h2>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
基本上有种使用线程的场合：
</p>
<ul style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
<li>
通过利用处理器的多个核使处理速度更快。
</li>
<li>
为保持GUI线程或其他高实时性线程的响应，将耗时的操作或阻塞的调用移到其他线程。
</li>
</ul>
<h3 id="A.2BT1Vl9k9.2FdShRdk7WYoBnL2b.2FTuN.2Bv3oL-" style="margin: 0px; padding: 0px 0px 0.3em; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(4, 115, 7);">
<a style="color: rgb(51, 102, 153);" name="t1" rel="nofollow"></a>何时使用其他技术替代线程
</h3>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
开发人员使用线程时需要非常小心。启动线程是很容易的，但确保所有共享数据保持一致很难。遇到问题往往很难解决，这是由于在一段时间内它可能只出现一次或只在特定的硬件配置下出现。<span style="color: rgb(0, 0, 255);"><strong>在创建线程来解决某些问题之前，应该考虑一些替代的技术</strong> </span>：
</p>
<div style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
<table border="0" style="margin: 0.5em 0px 0px 0.5em; border-collapse: collapse;">
<tbody>
<tr>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7); width:30%;text-align: center;">
<p style="margin-top: 0px; margin-bottom: 0px;">
<strong>替代技术</strong>
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);text-align: center;">
<p style="margin-top: 0px; margin-bottom: 0px;">
<strong>注解</strong>
</p>
</td>
</tr>
<tr>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
<tt>QEventLoop::processEvents()</tt>
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
在一个耗时的计算操作中反复调用<tt>QEventLoop::processEvents()</tt> 可以防止界面的假死。尽管如此，这个方案可伸缩性并不太好，因为该函数可能会被调用地过于频繁或者不够频繁。
</p>
</td>
</tr>
<tr>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
<tt>QTimer</tt>
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
后台处理操作有时可以方便地使用Timer安排在一个在未来的某一时刻执行的槽中来完成。在没有其他事件需要处理时，时间隔为0的定时器超时事件被相应
</p>
</td>
</tr>
<tr>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
<tt>QSocketNotifier</tt> <br><tt>QNetworkAccessManager</tt> <br><tt>QIODevice::readyRead()</tt>
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
这是一个替代技术，替代有一个或多个线程在慢速网络执行阻塞读的情况。只要响应部分的计算可以快速执行，这种设计比在线程中实现的同步等待更好。与线程相比这种设计更不容易出错且更节能(energy efficient)。在许多情况下也有性能优势。
</p>
</td>
</tr>
</tbody>
</table>
</div>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
一般情况下，建议只使用安全和经过测试的方案而避免引入特设线程的概念。QtConcurrent 提供了一个将任务分发到处理器所有的核的易用接口。线程代码完全被隐藏在 QtConcurrent 框架下，所以你不必考虑细节。尽管如此，QtConcurrent 不能用于线程运行时需要通信的情况，而且它也不应该被用来处理阻塞操作。
</p>
<h3 id="A.2BXpSL5U9.2FdShU6nnN_Qt_.2Bfr96C3aEVOp5zWKAZy.2F.2FHw-" style="margin: 0px; padding: 0px 0px 0.3em; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(4, 115, 7);">
<a style="color: rgb(51, 102, 153);" name="t2" rel="nofollow"></a>应该使用 Qt 线程的哪种技术？
</h3>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
有时候，你需要的不仅仅是在另一线程的上下文中运行一个函数。您可能需要有一个生存在另一个线程中的对象来为GUI线程提供服务。也许你想在另一个始终运行的线程中来轮询硬件端口并在有关注的事情发生时发送信号到GUI线程。Qt为开发多线程应用程序提供了多种不同的解决方案。<strong><span style="color: rgb(0, 0, 255);">解决方案的选择依赖于新线程的目的以及线程的生命周期。</span></strong>
</p>
<div style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
<table border="0" style="margin: 0.5em 0px 0px 0.5em; border-collapse: collapse;">
<tbody>
<tr>
<td style="width:12%;padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);text-align: center;">
<p style="margin-top: 0px; margin-bottom: 0px;">
<strong>生命周期</strong>
</p>
</td>
<td style="width:40%;padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);text-align: center;">
<p style="margin-top: 0px; margin-bottom: 0px;">
<strong>开发任务</strong>
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);text-align: center;">
<p style="margin-top: 0px; margin-bottom: 0px;">
<strong>解决方案</strong>
</p>
</td>
</tr>
<tr>
<td rowspan="3" style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
一次调用
</p>
</td>
<td rowspan="3" style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
在另一个线程中运行一个函数，函数完成时退出线程
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
编写函数，使用<tt>QtConcurrent::run</tt> 运行它
</p>
</td>
</tr>
<tr>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
派生QRunnable，使用<tt>QThreadPool::globalInstance()-&gt;start()</tt> 运行它
</p>
</td>
</tr>
<tr>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
派生QThread，重新实现<tt>QThread::run()</tt> ，使用<tt>QThread::start()</tt> 运行它
</p>
</td>
</tr>
<tr>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
一次调用
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
需要操作一个容器中所有的项。使用处理器所有可用的核心。一个常见的例子是从图像列表生成缩略图。
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
<tt>QtConcurrent</tt> 提供了map()函你数来将操作应用到容器中的每一个元素，提供了fitler()函数来选择容器元素，以及指定reduce函数作为选项来组合剩余元素。
</p>
</td>
</tr>
<tr>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
一次调用
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
一个耗时运行的操作需要放入另一个线程。在处理过程中，状态信息需要发送会GUI线程。
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
使用QThread，重新实现run函数并根据需要发送信号。使用信号槽的queued连接方式将信号连接到GUI线程的槽函数。
</p>
</td>
</tr>
<tr>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
持久运行
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
生存在另一个线程中的对象，根据要求需要执行不同的任务。这意味着工作线程需要双向的通讯。
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
派生一个QObject对象并实现需要的信号和槽，将对象移动到一个运行有事件循环的线程中并通过queued方式连接的信号槽进行通讯。
</p>
</td>
</tr>
<tr>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
持久运行
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
生存在另一个线程中的对象，执行诸如轮询端口等重复的任务并与GUI线程通讯。
</p>
</td>
<td style="padding: 0.25em 0.5em; border: 1px solid rgb(4, 115, 7);">
<p style="margin-top: 0px; margin-bottom: 0px;">
同上，但是在工作线程中使用一个定时器来轮询。尽管如此，处理轮询的最好的解决方案是彻底避免它。有时QSocketNotifer是一个替代。
</p>
</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Qt.2Bfr96C1f6eEA-" style="margin: 0px; padding: 0px 0px 0.3em; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(4, 115, 7);">
<a style="color: rgb(51, 102, 153);" name="t3" rel="nofollow"></a>Qt线程基础
</h2>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
QThread是一个非常便利的跨平台的对平台原生线程的抽象。启动一个线程是很简单的。让我们看一个简短的代码：生成一个在线程内输出"hello"并退出的线程。
</p>
<pre style="white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51); font-size: 14px; line-height: 26px; padding: 0.5em; font-family: courier, monospace; border: 1pt solid rgb(192, 192, 192); background-color: rgb(240, 236, 230);"> // hellothread/hellothread.h
 class HelloThread : public QThread
 {
     Q_OBJECT
 private:
     void run();
 };</pre>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
我们从QThread派生出一个类，并重新实现run方法。
</p>
<pre style="white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51); font-size: 14px; line-height: 26px; padding: 0.5em; font-family: courier, monospace; border: 1pt solid rgb(192, 192, 192); background-color: rgb(240, 236, 230);"> // hellothread/hellothread.cpp
 void HelloThread::run()
 {
      qDebug() &lt;&lt; "hello from worker thread " &lt;&lt; thread()-&gt;currentThreadId();
 }</pre>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
run方法中包含将在另一个线程中运行的代码。在本例中，一个包含线程ID的消息被打印出来。  <tt>QThread::start()</tt>将在另一个线程中被调用。
</p>
<pre style="white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51); font-size: 14px; line-height: 26px; padding: 0.5em; font-family: courier, monospace; border: 1pt solid rgb(192, 192, 192); background-color: rgb(240, 236, 230);"> int main(int argc, char *argv[])
 {
     QCoreApplication app(argc, argv);
     HelloThread thread;
     thread.start();
     qDebug() &lt;&lt; "hello from GUI thread " &lt;&lt; app.thread()-&gt;currentThreadId();
     thread.wait();  // do not exit before the thread is completed!
     return 0;
 }</pre>
<h3 id="QObject.2BTg5.2Bv3oL-" style="margin: 0px; padding: 0px 0px 0.3em; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(4, 115, 7);">
<a style="color: rgb(51, 102, 153);" name="t4" rel="nofollow"></a>QObject与线程
</h3>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
QObject有线程关联(thread affinity)[如何翻译？关联？依附性？dbzhang800 20110618]，换句话说，它生存于一个特定的线程。这意味着，在创建时QObject保存了到当前线程的指针。当事件使用postEvent()被派发时，这个信息变得很有用。事件被放置到相应线程的事件循环中。如果QObject所依附的线程没有事件循环，该事件将永远不会被传递。
</p>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
要启动事件循环，必须在run()内调用exec()。线程关联可以通过moveToThread()来更改。
</p>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
如上所述，当从其他线程调用对象的方法时开发人员必须始终保持谨慎。线程关联不会改变这种状况。 Qt文档中将一些方法标记为线程安全。postEvent()就是一个值得注意的例子。一个线程安全的方法可以同时在不同的线程被调用。
</p>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
通常情况下并不会并发访问的一些方法，在其他线程调用对象的非线程安全的方法在出现造成意想不到行为的并发访问前数千次的访问可能都是工作正常的。编写测试代码不能完全确保线程的正确性，但它仍然是重要的。在Linux上，Valgrind和Helgrind有助于检测线程错误。
</p>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
QThread的内部结构非常有趣：
</p>
<ul style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
<li>
QThread并不生存于执行run()的新线程内。它生存于旧线程中。
</li>
<li>
QThread的大多数成员方法是线程的控制接口，并设计成从旧线程中被调用。不要使用moveToThread()将该接口移动到新创建的线程中；调用moveToThread(this)被视为不好的实践。
</li>
<li>
exec()和静态方法usleep()、msleep()、sleep()要在新创建的线程中调用。
</li>
<li>
QThread子类中定义的其他成员可在两个线程中访问。开发人员负责访问的控制。一个典型的策略是在start()被调用前设置成员变量。一旦工作线程开始运行，主线程不应该操作其他成员。当工作线程终止后，主线程可以再次访问其他成员。这是一个在线程开始前传递参数并在结束后收集结果的便捷的策略。
</li>
</ul>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
QObject必须始终和parent在同一个线程。对于在run()中生成的对象这儿有一个惊人的后果：
</p>
<pre style="white-space: pre-wrap; word-wrap: break-word; color: rgb(51, 51, 51); font-size: 14px; line-height: 26px; padding: 0.5em; font-family: courier, monospace; border: 1pt solid rgb(192, 192, 192); background-color: rgb(240, 236, 230);"> void HelloThread::run()
 {
      QObject *object1 = new QObject(this);  //error, parent must be in the same thread
      QObject object2;  // OK
      QSharedPointer &lt;QObject&gt; object3(new QObject); // OK
 }</pre>
<h3 id="A.2BT391KE6SZaWRz0.2FdYqRlcGNudoRbjGV0-" style="margin: 0px; padding: 0px 0px 0.3em; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(4, 115, 7);">
<a style="color: rgb(51, 102, 153);" name="t5" rel="nofollow"></a>使用互斥量保护数据的完整
</h3>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
互斥量是一个拥有lock()和unlock()方法并记住它是否已被锁定的对象。互斥量被设计为从多个线程调用。如果信号量未被锁定lock()将立即返回。下一次从另一个线程调用会发现该信号量处于锁定状态，然后lock()会阻塞线程直到其他线程调用unlock()。此功能可以确保代码段将在同一时间只能由一个线程执行。
</p>
<h3 id="A.2BT391KE6LTvZfqnOvljJrYmVwY254NFdP-" style="margin: 0px; padding: 0px 0px 0.3em; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(4, 115, 7);">
<a style="color: rgb(51, 102, 153);" name="t6" rel="nofollow"></a>使用事件循环防止数据破坏
</h3>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
Qt的事件循环对线程间的通信是一个非常有价值的工具。每个线程都可以有它自己的事件循环。在另一个线程中调用一个槽的一个安全的方法是将调用放置到另一个线程的事件循环中。这可以确保目标对象调用另一个的成员函数之前可以完成当前正在运行的成员函数。
</p>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
那么，如何才能把一个成员调用放于一个事件循环中？ Qt的有两种方法来做这个。一种方法是通过queued信号槽连接；另一种是使用QCoreApplication::postEvent()派发一个事件。queued的信号槽连接是异步执行的信号槽连接。内部实现是基于posted的事件。信号的参数放入事件循环后信号函数的调用将立即返回。
</p>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
连接的槽函数何时被执行依赖于事件循环其他的其他操作。
</p>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
通过事件循环通信消除了我们使用互斥量时所面临的死锁问题。这就是我们为什么推荐使用事件循环，而不是使用互斥量锁定对象的原因。
</p>
<h3 id="A.2BWQR0Bl8Ca2ViZ4hM-" style="margin: 0px; padding: 0px 0px 0.3em; color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(4, 115, 7);">
<a style="color: rgb(51, 102, 153);" name="t7" rel="nofollow"></a>处理异步执行
</h3>
<p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14px; line-height: 26px;">
一种获得一个工作线程的结果的方法是等待线程终止。在许多情况下，一个阻塞等待是不可接受的。阻塞等待的替代方法是异步的结果通过posted事件或者queued信号槽进行传递。由于操作的结果不会出现在源代码的下一行而是在位于源文件其他部分的一个槽中，这会产生一定的开销，因为，但在位于源文件中其他地方的槽。 Qt开发人员习惯于使用这种异步行为工作，因为它非常相似于GUI程序中使用的的事件驱动编程。
</p>
<wbr>
</div>
<p>本文来自：<a href="http://ferret.blog.163.com/blog/static/64423780201542092749179" title="转：Qt 线程基础(QThread、QtConcurrent等)">转：Qt 线程基础(QThread、QtConcurrent等)</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>multithread</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt使用Translation及使用资源文件</title>
    <url>/2015/03/27/F066442378020152278545404/</url>
    <content><![CDATA[<p>Qt支持多语言及资源文件的使用，以下记录使用方法： <span id="more"></span></p>
<h2 id="使用translation">1、使用Translation：</h2>
<ol type="1">
<li><p>pro文件中添加： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRANSLATIONS = $$TARGET&quot;_zh_CN.ts&quot;</span><br><span class="line"></span><br><span class="line">#注意，生成qm文件后，需要手工运行下qmake命令</span><br><span class="line">system($$shell_path(copy $$PWD/*.qm  $$OUT_PWD/))</span><br></pre></td></tr></table></figure></p></li>
<li><p>main.cpp文件中添加： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTranslator&gt;</span></span></span><br><span class="line"></span><br><span class="line">QString locale = QLocale::<span class="built_in">system</span>().<span class="built_in">name</span>();</span><br><span class="line">QTranslator translator;</span><br><span class="line">translator.<span class="built_in">load</span>(a.<span class="built_in">applicationName</span>() + <span class="string">&quot;_&quot;</span> + locale + <span class="string">&quot;.qm&quot;</span>);</span><br><span class="line">a.<span class="built_in">installTranslator</span>(&amp;translator);</span><br></pre></td></tr></table></figure> 在工程目录下会生成一个“工程名_zh_CN.ts”的文件，打开后进行翻译，程序会自动载入。</p></li>
</ol>
<h2 id="使用资源文件">2、使用资源文件：</h2>
<p>创建qrc资源文件，使用 <code>rcc -binary myresource.qrc -o myresource.rcc</code>命令，将qrc文件编译为二进制文件。 在程序中，首先包含资源头文件 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QResource&gt;</span></span></span><br></pre></td></tr></table></figure> 具体使用：</p>
<ul>
<li>使用：<code>QResource::registerResource("./myresource.rcc");</code>，载入资源；</li>
<li>使用：<code>QResource::unregisterResource("./myresource.rcc");</code>，卸载资源。</li>
</ul>
<p>qtCreator的ui编辑器里使用资源方法： 在qtCreator里加入上述qrc文件，正常使用界面编辑器制作界面，然后在pro文件中删除该qrc资源文件，将上述编译后的myresource.rcc文件复制到exe文件同路径下，图标就可以正常的出现了。</p>
<p>本文来自：<a href="http://ferret.blog.163.com/blog/static/6442378020152278545404" title="Qt使用Translation及使用资源文件">Qt使用Translation及使用资源文件</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt命令行中使用cout，cin，cerr</title>
    <url>/2015/03/08/F07644237802015283455827/</url>
    <content><![CDATA[<p>cout，cin，cerr是C++标准输入输出库函数，很多使用标准库的程序使用上述函数输出。本文记录一种在Qt中定义函数的方法，在某些情况下，可以很方便的导入第三方标准库撰写的代码。 <span id="more"></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************************</span></span><br><span class="line"><span class="comment">*说明：</span></span><br><span class="line"><span class="comment">*   如果使用cout对Qt库进行操作，可创建QTextStream对象进行，如下演示</span></span><br><span class="line"><span class="comment">*   对于Qt 5.x版本，源文件必须使用UTF-8以避免乱码</span></span><br><span class="line"><span class="comment">*       如果不使用Qt库的QTextStream对象进行输出，而使用std::cout输出中文，</span></span><br><span class="line"><span class="comment">*       那么由于Windows蛋疼的页面文件机制，源文件必须使用ANSI编码，</span></span><br><span class="line"><span class="comment">*   不足：</span></span><br><span class="line"><span class="comment">*       cout一个QString对象之后，默认是不直接输出的，需要等到cout的缓冲区满之后，</span></span><br><span class="line"><span class="comment">*       才向终端输出内部的字符串；</span></span><br><span class="line"><span class="comment">*   解决：</span></span><br><span class="line"><span class="comment">*       如果希望cout之后立即进行输出，可以在输出之后再输出一个endl，</span></span><br><span class="line"><span class="comment">*       或调用QTextStream的内部方法flush，强制清空缓冲区。</span></span><br><span class="line"><span class="comment">***********************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextStream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTime&gt;</span> </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QTextStream <span class="title">cin</span><span class="params">(stdin,  QIODevice::ReadOnly)</span></span>; </span><br><span class="line">    <span class="function">QTextStream <span class="title">cout</span><span class="params">(stdout,  QIODevice::WriteOnly)</span></span>; </span><br><span class="line">    <span class="function">QTextStream <span class="title">cerr</span><span class="params">(stderr,  QIODevice::WriteOnly)</span></span>;</span><br><span class="line">     </span><br><span class="line">    QString str = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;(<span class="built_in">QString</span>(<span class="string">&quot;当前日期：%1&quot;</span>)).<span class="built_in">arg</span>(QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>))&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;(<span class="built_in">QString</span>(<span class="string">&quot;当前时间：%1&quot;</span>)).<span class="built_in">arg</span>(QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss&quot;</span>))&lt;&lt;endl; </span><br><span class="line">     </span><br><span class="line">    cout.<span class="built_in">setFieldWidth</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">225</span> ;i++ )&#123; </span><br><span class="line">    cout&lt;&lt;i; </span><br><span class="line">    <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">15</span>==<span class="number">0</span>) </span><br><span class="line">    cout&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    cout&lt;&lt;endl; </span><br><span class="line">    cout.<span class="built_in">setFieldWidth</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文来自：<a href="http://ferret.blog.163.com/blog/static/644237802015283455827" title="Qt命令行中使用cout，cin，cerr">Qt命令行中使用cout，cin，cerr</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>5R6G5B 与 8R8G8B 的相互转换</title>
    <url>/2014/08/06/F09644237802014767482553/</url>
    <content><![CDATA[<img src="/2014/08/06/F09644237802014767482553/rgb.jpg" class="" title="5R6G5B与8R8G8B的相互转换">
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>颜色转换</tag>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊英文符号念法[转载]</title>
    <url>/2012/02/07/F29644237802012178140511/</url>
    <content><![CDATA[<p>基本涵盖了所有的英文符号。 <span id="more"></span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>Symbol 符号</strong></th>
<th style="text-align: center;"><strong>Description 说明</strong></th>
<th style="text-align: center;"><strong>Chinese 中文说法</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">~</td>
<td style="text-align: center;">Tilde</td>
<td style="text-align: center;">取代符号/毛毛虫</td>
</tr>
<tr class="even">
<td style="text-align: center;">!</td>
<td style="text-align: center;">Exclamation point</td>
<td style="text-align: center;">惊叹号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">@</td>
<td style="text-align: center;">At sign, at</td>
<td style="text-align: center;">At符号/小老鼠</td>
</tr>
<tr class="even">
<td style="text-align: center;">#</td>
<td style="text-align: center;">Number sign</td>
<td style="text-align: center;">数字符号/井号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">￡</td>
<td style="text-align: center;">Pound sign</td>
<td style="text-align: center;">英镑符号</td>
</tr>
<tr class="even">
<td style="text-align: center;">$</td>
<td style="text-align: center;">Dollar sign</td>
<td style="text-align: center;">钱符号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">%</td>
<td style="text-align: center;">Percent, percent sign</td>
<td style="text-align: center;">百分比，百分比符号</td>
</tr>
<tr class="even">
<td style="text-align: center;">^</td>
<td style="text-align: center;">Caret</td>
<td style="text-align: center;">脱字符号/小三角</td>
</tr>
<tr class="odd">
<td style="text-align: center;">&amp;</td>
<td style="text-align: center;">Ampersand</td>
<td style="text-align: center;">And符号</td>
</tr>
<tr class="even">
<td style="text-align: center;">*</td>
<td style="text-align: center;">Asterisk</td>
<td style="text-align: center;">星号/米字号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">(</td>
<td style="text-align: center;">Open parenthesis</td>
<td style="text-align: center;">左括号</td>
</tr>
<tr class="even">
<td style="text-align: center;">)</td>
<td style="text-align: center;">Close parenthesis</td>
<td style="text-align: center;">右括号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">–</td>
<td style="text-align: center;">Dash</td>
<td style="text-align: center;">破折号</td>
</tr>
<tr class="even">
<td style="text-align: center;">—</td>
<td style="text-align: center;">Double dash</td>
<td style="text-align: center;">双破折号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">_</td>
<td style="text-align: center;">Underscore</td>
<td style="text-align: center;">底线</td>
</tr>
<tr class="even">
<td style="text-align: center;">+</td>
<td style="text-align: center;">Plus, plus sign</td>
<td style="text-align: center;">加，加号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">=</td>
<td style="text-align: center;">Equals</td>
<td style="text-align: center;">等号</td>
</tr>
<tr class="even">
<td style="text-align: center;">|</td>
<td style="text-align: center;">Vertical bar</td>
<td style="text-align: center;">垂直线/直线号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">\</td>
<td style="text-align: center;">Backslash</td>
<td style="text-align: center;">反斜杠</td>
</tr>
<tr class="even">
<td style="text-align: center;">{</td>
<td style="text-align: center;">Open brace</td>
<td style="text-align: center;">左大括号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">}</td>
<td style="text-align: center;">Close brace</td>
<td style="text-align: center;">右大括号</td>
</tr>
<tr class="even">
<td style="text-align: center;">\</td>
<td style="text-align: center;">Open bracket</td>
<td style="text-align: center;">左方括号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">]</td>
<td style="text-align: center;">Close bracket</td>
<td style="text-align: center;">右方括号</td>
</tr>
<tr class="even">
<td style="text-align: center;">:</td>
<td style="text-align: center;">Colon</td>
<td style="text-align: center;">冒号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">;</td>
<td style="text-align: center;">Semicolon</td>
<td style="text-align: center;">分号</td>
</tr>
<tr class="even">
<td style="text-align: center;">"</td>
<td style="text-align: center;">Quote</td>
<td style="text-align: center;">双引号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">'</td>
<td style="text-align: center;">Single quote</td>
<td style="text-align: center;">单引号</td>
</tr>
<tr class="even">
<td style="text-align: center;">,</td>
<td style="text-align: center;">Comma</td>
<td style="text-align: center;">逗号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">.</td>
<td style="text-align: center;">Period, dot</td>
<td style="text-align: center;">句号，点</td>
</tr>
<tr class="even">
<td style="text-align: center;">&gt;</td>
<td style="text-align: center;">Greater than</td>
<td style="text-align: center;">大于</td>
</tr>
<tr class="odd">
<td style="text-align: center;">&lt;</td>
<td style="text-align: center;">Less than</td>
<td style="text-align: center;">小于</td>
</tr>
<tr class="even">
<td style="text-align: center;">?</td>
<td style="text-align: center;">Question mark</td>
<td style="text-align: center;">问号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">/</td>
<td style="text-align: center;">Slash</td>
<td style="text-align: center;">斜线</td>
</tr>
<tr class="even">
<td style="text-align: center;">//</td>
<td style="text-align: center;">Double slash</td>
<td style="text-align: center;">双斜线</td>
</tr>
<tr class="odd">
<td style="text-align: center;">…</td>
<td style="text-align: center;">Ellipsis</td>
<td style="text-align: center;">省略号/点点点</td>
</tr>
<tr class="even">
<td style="text-align: center;">-</td>
<td style="text-align: center;">Hyphen</td>
<td style="text-align: center;">连字符</td>
</tr>
</tbody>
</table>
<p>本文来自：<a href="http://ferret.blog.163.com/blog/static/644237802012178140511" title="特殊英文符号念法[转载]">特殊英文符号念法[转载]</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu的使用</title>
    <url>/2011/01/30/F7064423780201103014710258/</url>
    <content><![CDATA[<p>最近要用Ubuntu，以前用SUSE的经验貌似很少能用在这里， Ubuntu版本：10.10，内核2.6.35.24(由老内核2.6.35.22升级而来） 发这篇blog记录一下用法，顺便赞一下Ubuntu，偶笔记本的无线网卡终于可以干活了。 <span id="more"></span> 以下内容均为网上Google来，并经过测试，留存在这里，方便以后查找</p>
<h2 id="ubuntu下使用alias">1、ubuntu下使用alias</h2>
<p>把 alias 语句写入 <code>~/.bashrc</code>中即可方便使用。 命令：<code>sudo vi ~/.bashrc</code>进入即可,编辑了 <code>~/.bashrc</code> 后, 使用 <code>source ~/.bashrc</code> 即可让它立刻生效。</p>
<p>bashrc文件中有这么一段说明，貌似是将所有的alias可以定义在一个叫做.bash_aliases的文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Alias definitions.</span></span><br><span class="line"><span class="comment"># You may want to put all your additions into a separate file like</span></span><br><span class="line"><span class="comment"># ~/.bash_aliases, instead of adding them here directly.</span></span><br><span class="line"><span class="comment"># See /usr/share/doc/bash-doc/examples in the bash-doc package.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bash_aliases ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bash_aliases</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个功能不错，把自己常用的alias定义保存后，直接复制，以后到哪里都能用了。 附上几个自己用的alias： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># some more ls aliases</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -aluhp&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> lt=<span class="string">&#x27;ls -alFrSht&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> lf=<span class="string">&#x27;ls -alFrSh&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cd</span>..=<span class="string">&#x27;cd ..&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> alg=<span class="string">&#x27;arm-linux-gcc&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> alr=<span class="string">&#x27;arm-linux-readelf&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> agi=<span class="string">&#x27;apt-get install&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> agg=<span class="string">&#x27;apt-get&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#该命令是直接进入ftp文件夹，并列出该文件夹下的内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> g2ftp=<span class="string">&#x27;cd /usr/local/arm/exports/ftp &amp;&amp; ll&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#该命令将复制文件到指定的目录，这里是ftp目录</span></span><br><span class="line"><span class="comment">#用法 &quot;c2ftp 文件名&quot;即可</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cp2ftp</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cp</span> <span class="variable">$1</span> /usr/local/arm/exports/ftp/</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">alias</span> c2ftp=cp2ftp</span><br><span class="line"><span class="built_in">alias</span> lsftp=<span class="string">&#x27;ls /usr/local/arm/exports/ftp&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> llftp=<span class="string">&#x27;ll /usr/local/arm/exports/ftp&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> duu=<span class="string">&#x27;du -h --max-depth=1&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ecpath=<span class="string">&#x27;echo $PATH&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> g2armRoot=<span class="string">&#x27;cd /usr/local/arm/exports/export&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> aqmake=<span class="string">&#x27;/opt/qte-4.7.1/bin/qmake&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> g2src=<span class="string">&#x27;cd/usr/local/arm/source/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> en1=<span class="string">&#x27;export LANG=&quot;en_US:UTF-8&quot;&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> en2=<span class="string">&#x27;export LANGUAGE=&quot;en_US:en&quot;&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> tree=<span class="string">&#x27;tree -N&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ags=<span class="string">&#x27;apt-cache search&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> netreboot=<span class="string">&#x27;/etc/init.d/networking restart&#x27;</span> </span><br><span class="line"><span class="built_in">alias</span> ftpreboot=<span class="string">&#x27;service proftpd restart&#x27;</span> </span><br><span class="line"><span class="built_in">alias</span> wwwreboot=<span class="string">&#x27;service apache2 restart&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># ffstr :Find File with String of.. </span></span><br><span class="line"><span class="comment"># 在当前路径下搜索包含指定字符串的文件，并显示 </span></span><br><span class="line"><span class="comment"># grep 参数-n：列出行号，-i：不区分大小写</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">alias</span> ffstr=<span class="string">&#x27;find . -type f -print | xargs grep -n -i&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">7zaa</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    7z a <span class="variable">$1</span>.7z <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 7z压缩</span></span><br><span class="line"><span class="built_in">alias</span> 7za=<span class="string">&#x27;7zaa&#x27;</span></span><br><span class="line"><span class="comment"># 7z 将目录下所有文件和目录分别压缩</span></span><br><span class="line"><span class="built_in">alias</span> 7zz=<span class="string">&#x27;for ITEM in `ls`; do 7za $ITEM ; done&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> aip=<span class="string">&#x27;arping -A 10.3.89.122 -I eth0&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="安装ssh服务器">2、安装ssh服务器</h2>
<p>在“系统”-&gt;“系统管理”-&gt;“更新管理器”中，点击“设置”，并选中“Ubuntu软件”,将“下载自”一栏选择为“主服务器”，先修改更新服务器地址（默认安装的澳洲服务器挂了）。 然后就很简单了，使用<code>apt-get install ssh</code>安装吧.安装完成之后，<code>ps -e|grep ssh</code>，一定要看到<code>sshd</code>的进程，这就说明ssh服务器装好了，然后就很简单，可以使用putty的ssh登录搞了，</p>
<h2 id="安装cross-4.2.2">3、安装cross-4.2.2</h2>
<p>这个很easy，就是下载之后解压，命令式<code>tar jxvf cross-4.2.2-eabi.tar.bz2 -C /usr/local/arm</code>，<code>cross-4.2.2-eabi.tar.bz2</code> 下载地址：<a href="http://code.google.com/p/ldd6410/downloads/detail?name=cross-4.2.2-eabi.tar.bz2&amp;can=2&amp;q=">这里</a>，安装说明：<a href="http://code.google.com/p/ldd6410/wiki/S3C6410ToolChainBuilding">这里</a> （用Google直接搜索cross-4.2.2-eabi，直接出来的第一第二个就是上面两个链接）</p>
<p>2012年7月28日更新： 今天遇到一个奇怪的问题： 运行编译器出错，arm-linux-gcc: 没有这个文件或者目录。Google了一下，发现了这个解决方法：apt-get install lsb-core解决，原文地址在<a href="http://blog.csdn.net/zjb9605025/article/details/6412821">这里</a>。 仔细思考了一下，以前的都是32位系统，没出现这个问题，现在是64位，估计缺少依赖库。</p>
<h2 id="ubuntu-架設nfs-server">4、Ubuntu 架設nfs server</h2>
<ol type="1">
<li><p>Install <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install nfs-common</span><br><span class="line">$ sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure></p></li>
<li><p>设定 /etc/exports (For example: 將/mnt/iso share給all net使用) <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vi /etc/exports</span><br><span class="line">/mnt/iso *(ro,<span class="built_in">sync</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>启动 nfs server <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo /etc/init.d/nfs-kernel-server start</span><br></pre></td></tr></table></figure></p></li>
<li><p>检查 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ showmount -e localhost</span><br></pre></td></tr></table></figure> 成功的话应该可以看到这样的信息: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Export list <span class="keyword">for</span> localhost:</span><br><span class="line">/mnt/iso *</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="相当给力的find命令">5、相当给力的find命令：</h2>
<p>1）查找并删除某个文件(或目录)</p>
<p>这里以删除当前目录（含子目录）下所有<code>*.svn</code>目录为例 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> find . -name .svn -<span class="built_in">exec</span> <span class="built_in">rm</span> -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure> 2）将包含某文本的所有文件及其对应行显示出来。</p>
<p>如下命令，在/usr目录中查找所有包含error、并以.log结尾的文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /usr -name <span class="string">&#x27;*.log&#x27;</span> | xargs grep <span class="string">&#x27;error&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>3）批量命名文件。 如下命令，查找所有文件名包含“[www.网址111.com]”字符串的文件，并将文件名中的该字符串删除。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find -<span class="built_in">type</span> f | grep <span class="string">&#x27;\[www\.网址111\.com\]&#x27;</span> | xargs rename <span class="string">&#x27;s/&#x27;</span>\[www\.网址111\.com\]<span class="string">&#x27;//&#x27;</span></span><br></pre></td></tr></table></figure> 4) 查找文件，并将对其权限进行修改 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> $(find . -<span class="built_in">type</span> f -name <span class="string">&quot;*&quot;</span>); <span class="keyword">do</span> <span class="built_in">chmod</span> 664 <span class="variable">$l</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure> 5) 查找当前目录下（含子目录）包含指定字符串的文件名 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#该命令查找当前目录下（含子目录）包含指定字符串的文件名</span></span><br><span class="line"><span class="comment">#用法 “find_files_with_string 文件名”即可</span></span><br><span class="line"><span class="function"><span class="title">find_files_with_string</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    grep -il -R <span class="variable">$1</span> *</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">alias</span> ffwstr=find_files_with_string</span><br></pre></td></tr></table></figure></p>
<h2 id="ftp配置">6 FTP配置</h2>
<h3 id="vsftpd的配置">6.1、VsFTPd的配置</h3>
<p>搞个简易的自己用用（开通匿名账号，并且可以上传、下载、删除） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen=YES</span><br><span class="line">anonymous_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_enable=NO</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">ftpd_banner=Welcome to Ferret&#x27;s FTP service.</span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">rsa_cert_file=/etc/ssl/private/vsftpd.pem</span><br><span class="line"></span><br><span class="line">#设置匿名账号的主目录</span><br><span class="line">anon_root=/usr/local/arm/exports</span><br><span class="line">#可进行其他操作</span><br><span class="line">anon_other_write_enable=YES</span><br><span class="line"></span><br><span class="line">#这句必须加上，否则只能上传删除等不能下载</span><br><span class="line">anon_umask=022</span><br></pre></td></tr></table></figure> 注意： 上述配置文件将匿名账号的路径设为<code>/usr/local/arm/exports</code>，在Ubuntu下要该目录改为<code>root</code>所有，在其下的路径都改为ftp匿名账号所有，即可。</p>
<h3 id="proftpd的配置">6.2、ProFTPd的配置</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># /etc/proftpd/proftpd.conf -- This is a basic ProFTPD configuration file.</span><br><span class="line"># To really apply changes reload proftpd after modifications.</span><br><span class="line"># </span><br><span class="line"></span><br><span class="line"># Includes DSO modules</span><br><span class="line">Include /etc/proftpd/modules.conf</span><br><span class="line"></span><br><span class="line"># Set off to disable IPv6 support which is annoying on IPv4 on</span><br><span class="line">ly boxes.</span><br><span class="line">UseIPv6                off</span><br><span class="line"># If set on you can experience a longer connection delay in many cases.</span><br><span class="line">IdentLookups            off</span><br><span class="line"></span><br><span class="line">ServerName            &quot;Ferret&#x27;s FTP Server&quot;</span><br><span class="line">ServerType            standalone</span><br><span class="line">DeferWelcome            off</span><br><span class="line"></span><br><span class="line">MultilineRFC2228        on</span><br><span class="line">DefaultServer            on</span><br><span class="line">ShowSymlinks            on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TimeoutNoTransfer        180</span><br><span class="line">TimeoutStalled            180</span><br><span class="line">TimeoutIdle            300</span><br><span class="line"></span><br><span class="line">DisplayLogin                    .welcome.msg</span><br><span class="line">DisplayChdir                   .message true</span><br><span class="line">ListOptions                    &quot;-l&quot;</span><br><span class="line"></span><br><span class="line">DenyFilter            \*.*/</span><br><span class="line"></span><br><span class="line"># Use this to jail all users in their homes </span><br><span class="line"> DefaultRoot            /usr/ftpService</span><br><span class="line"></span><br><span class="line"># Users require a valid shell listed in /etc/shells to login.</span><br><span class="line"># Use this directive to release that constrain.</span><br><span class="line"># RequireValidShell        off</span><br><span class="line"></span><br><span class="line"># Port 21 is the standard FTP port.</span><br><span class="line">Port                21</span><br><span class="line"></span><br><span class="line"># In some cases you have to specify passive ports range to by-pass</span><br><span class="line"># firewall limitations. Ephemeral ports can be used for that, but</span><br><span class="line"># feel free to use a more narrow range.</span><br><span class="line"># PassivePorts                  49152 65534</span><br><span class="line"></span><br><span class="line"># If your host was NATted, this option is useful in order to</span><br><span class="line"># allow passive tranfers to work. You have to use your public</span><br><span class="line"># address and opening the passive ports used on your firewall as well.</span><br><span class="line"># MasqueradeAddress        1.2.3.4</span><br><span class="line"></span><br><span class="line"># This is useful for masquerading address with dynamic IPs:</span><br><span class="line"># refresh any configured MasqueradeAddress directives every 8 hours</span><br><span class="line">&lt;IfModule mod_dynmasq.c&gt;</span><br><span class="line"># DynMasqRefresh 28800</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line"># To prevent DoS attacks, set the maximum number of child processes</span><br><span class="line"># to 30.  If you need to allow more than 30 concurrent connections</span><br><span class="line"># at on</span><br><span class="line">ce, simply increase this value.  Note that this ON</span><br><span class="line">LY works</span><br><span class="line"># in standalone mode, in inetd mode you should use an inetd server</span><br><span class="line"># that allows you to limit maximum number of processes per service</span><br><span class="line"># (such as xinetd)</span><br><span class="line">MaxInstances            10</span><br><span class="line"></span><br><span class="line"># Set the user and group that the server normally runs at.</span><br><span class="line">#User                proftpd</span><br><span class="line">User                ftp</span><br><span class="line">Group                nogroup</span><br><span class="line"></span><br><span class="line"># Umask 022 is a good standard umask to prevent new files and dirs</span><br><span class="line"># (second parm) from being group and world writable.</span><br><span class="line">Umask                022  022</span><br><span class="line"># Normally, we want files to be overwriteable.</span><br><span class="line">AllowOverwrite            on</span><br><span class="line"></span><br><span class="line">AllowStoreRestart on</span><br><span class="line"></span><br><span class="line"># Uncomment this if you are using NIS or LDAP via NSS to retrieve passwords:</span><br><span class="line"># PersistentPasswd        off</span><br><span class="line"></span><br><span class="line"># This is required to use both PAM-based authentication and local passwords</span><br><span class="line"># AuthOrder            mod_auth_pam.c* mod_auth_unix.c</span><br><span class="line"></span><br><span class="line"># Be warned: use of this directive impacts CPU average load!</span><br><span class="line"># Uncomment this if you like to see progress and transfer rate with ftpwho</span><br><span class="line"># in downloads. That is not needed for uploads rates.</span><br><span class="line">#</span><br><span class="line"># UseSendFile            off</span><br><span class="line"></span><br><span class="line">TransferLog /var/log/proftpd/xferlog</span><br><span class="line">SystemLog   /var/log/proftpd/proftpd.log</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_quotatab.c&gt;</span><br><span class="line">QuotaEngine off</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_ratio.c&gt;</span><br><span class="line">Ratios off</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Delay engine reduces impact of the so-called Timing Attack described in</span><br><span class="line"># http://security.lss.hr/index.php?page=details&amp;ID=LSS-2004-10-02</span><br><span class="line"># It is on by default. </span><br><span class="line">&lt;IfModule mod_delay.c&gt;</span><br><span class="line">DelayEngine on</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_ctrls.c&gt;</span><br><span class="line">ControlsEngine        off</span><br><span class="line">ControlsMaxClients    2</span><br><span class="line">ControlsLog           /var/log/proftpd/controls.log</span><br><span class="line">ControlsInterval      5</span><br><span class="line">ControlsSocket        /var/run/proftpd/proftpd.sock</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_ctrls_admin.c&gt;</span><br><span class="line">AdminControlsEngine off</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Alternative authentication frameworks</span><br><span class="line">#</span><br><span class="line">#Include /etc/proftpd/ldap.conf</span><br><span class="line">#Include /etc/proftpd/sql.conf</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># This is used for FTPS connections</span><br><span class="line">#</span><br><span class="line">#Include /etc/proftpd/tls.conf</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Useful to keep VirtualHost/VirtualRoot directives separated</span><br><span class="line">#</span><br><span class="line">#Include /etc/proftpd/virtuals.con</span><br><span class="line"></span><br><span class="line"># A basic anonymous configuration, no upload directories.</span><br><span class="line"></span><br><span class="line">&lt;Limit SITE_CHMOD&gt;</span><br><span class="line">    DenyAll</span><br><span class="line">&lt;/Limit&gt;</span><br><span class="line"></span><br><span class="line">&lt;Directory /wd_1t/ftpService&gt;</span><br><span class="line">    &lt;Limit ALL&gt;</span><br><span class="line">        DenyAll</span><br><span class="line">    &lt;/Limit&gt;</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># &lt;Anonymous ~ftp&gt;</span><br><span class="line"> &lt;Anonymous /wd_1t/ftpService/pub&gt;</span><br><span class="line">   User                ftp</span><br><span class="line">   Group                nogroup</span><br><span class="line">#   # We want clients to be able to login with &quot;anonymous&quot; as well as &quot;ftp&quot;</span><br><span class="line">   UserAlias            anonymous ftp</span><br><span class="line">#   # Cosmetic changes, all files belongs to ftp user</span><br><span class="line">   DirFakeUser    on ftp</span><br><span class="line">   DirFakeGroup on ftp</span><br><span class="line"># </span><br><span class="line">   RequireValidShell        off</span><br><span class="line"># </span><br><span class="line">#   # Limit the maximum number of anonymous logins</span><br><span class="line">   MaxClients            10</span><br><span class="line"># </span><br><span class="line">#   # We want &#x27;welcome.msg&#x27; displayed at login, and &#x27;.message&#x27; displayed</span><br><span class="line">#   # in each newly chdired directory.</span><br><span class="line">   DisplayLogin            welcome.msg</span><br><span class="line">#   DisplayChdir        .message</span><br><span class="line"># </span><br><span class="line">#   # Limit WRITE everywhere in the anonymous chroot</span><br><span class="line">   &lt;Directory /wd_1t/ftpService/pub&gt;</span><br><span class="line">     &lt;Limit WRITE&gt;</span><br><span class="line">       DenyAll</span><br><span class="line">     &lt;/Limit&gt;</span><br><span class="line">   &lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">   &lt;Directory /wd_1t/ftpService/upload&gt;</span><br><span class="line">    &lt;Limit ALL&gt;</span><br><span class="line">        DenyAll</span><br><span class="line">    &lt;/Limit&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;Limit DIRS WRITE CMD RMD STOR&gt;</span><br><span class="line">        AllowAll</span><br><span class="line">    &lt;/Limit&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Limit DELE&gt;</span><br><span class="line">        DenyAll</span><br><span class="line">    &lt;/Limit&gt;</span><br><span class="line">    </span><br><span class="line">#        &lt;Limit WRITE&gt;</span><br><span class="line">#       AllowAll</span><br><span class="line">#    &lt;/Limit&gt; #如果不想让下载，只让上载 可以加上</span><br><span class="line">#     &lt;Limit READ&gt;</span><br><span class="line">#        DenyAll</span><br><span class="line">#    &lt;/Limit&gt;</span><br><span class="line">   &lt;/Directory&gt; #到这差不多就完了，每个目录可以写 .ftpaccess 设置权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &lt;Directory /wd_1t/ftpService/www&gt;</span><br><span class="line">     &lt;Limit ALL&gt;</span><br><span class="line">    DenyAll</span><br><span class="line">     &lt;/Limit&gt;</span><br><span class="line">   &lt;/Directory&gt; </span><br><span class="line"></span><br><span class="line"># </span><br><span class="line">#   # Uncomment this if you&#x27;re brave.</span><br><span class="line">#   # &lt;Directory incoming&gt;</span><br><span class="line">#   #   # Umask 022 is a good standard umask to prevent new files and dirs</span><br><span class="line">#   #   # (second parm) from being group and world writable.</span><br><span class="line">#   #   Umask                022  022</span><br><span class="line">#   #            &lt;Limit READ WRITE&gt;</span><br><span class="line">#   #            DenyAll</span><br><span class="line">#   #            &lt;/Limit&gt;</span><br><span class="line">#   #            &lt;Limit STOR&gt;</span><br><span class="line">#   #            AllowAll</span><br><span class="line">#   #            &lt;/Limit&gt;</span><br><span class="line">#   # &lt;/Directory&gt;</span><br><span class="line"># </span><br><span class="line"> &lt;/Anonymous&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;Anonymous /wd_1t/ftpService&gt;</span><br><span class="line">    User   ferret</span><br><span class="line">    Group   nogroup</span><br><span class="line">#    Umask 022</span><br><span class="line">     &lt;Directory *&gt;</span><br><span class="line">      &lt;Limit ALL&gt;</span><br><span class="line">       AllowAll</span><br><span class="line">      &lt;/Limit&gt;</span><br><span class="line">     &lt;/Directory&gt;     </span><br><span class="line">&lt;/Anonymous&gt;</span><br><span class="line"></span><br><span class="line">#&lt;Anonymous /usr/ftpService/www&gt;</span><br><span class="line">#      User   ferret</span><br><span class="line">#      Group   nogroup</span><br><span class="line">#  #   Umask 022</span><br><span class="line">#       &lt;Directory *&gt;</span><br><span class="line">#        &lt;Limit ALL&gt;</span><br><span class="line">#         AllowAll</span><br><span class="line">#        &lt;/Limit&gt;</span><br><span class="line">#       &lt;/Directory&gt;</span><br><span class="line"># &lt;/Anonymous&gt;</span><br><span class="line"></span><br><span class="line">&lt;Anonymous /wd_1t/ftpService/Movies&gt;</span><br><span class="line">    User xmj</span><br><span class="line">    Group nogroup</span><br><span class="line">#    Umask 022</span><br><span class="line">    &lt;Directory *&gt;</span><br><span class="line">     &lt;Limit READ DIRS CMD RMD STOR&gt;</span><br><span class="line">         AllowAll</span><br><span class="line">     &lt;/Limit&gt;</span><br><span class="line">    </span><br><span class="line">      &lt;Limit WRITE&gt;</span><br><span class="line">        DenyAll</span><br><span class="line">      &lt;/Limit&gt;</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">&lt;/Anonymous&gt;</span><br><span class="line"></span><br><span class="line">&lt;Anonymous /home/bt/rtorrent/torrents&gt;</span><br><span class="line">    User bt</span><br><span class="line">    Group nogroup</span><br><span class="line">#   Umask 022</span><br><span class="line">    &lt;Directory *&gt;</span><br><span class="line">      &lt;Limit ALL&gt;</span><br><span class="line">        AllowAll</span><br><span class="line">      &lt;/Limit&gt;</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">&lt;/Anonymous&gt;</span><br></pre></td></tr></table></figure>
<p>注：Proftpd的错误，今天将服务器有10.10升级至12.04版本，proftpd出现如下错误： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proftpd[3644]: Fatal: LoadModule: error loading module &#x27;mod_vroot.c&#x27;: 不允许的操作 on line 68 of &#x27;/etc/proftpd/modules.conf&#x27;</span><br></pre></td></tr></table></figure> 解决方法：proftpd没有安装依赖库“proftpd-mod-vroot”， <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install proftpd-mod-vroot，</span><br></pre></td></tr></table></figure> 重启ftp，OK</p>
<h2 id="ubuntu多系统启动相关">7、Ubuntu多系统启动相关</h2>
<ol type="1">
<li>更改启动顺序 登录为root权限，进入<code>/etc/grub.d</code>目录，找到<code>30_os-prober</code>这个文件，把 <code>30_os-prober</code>这个文件名的数字30改为05到10之间的数字即可(没多少可选06、07、08、09)。 比如改为<code>08_os-prober</code>，这样创建出来的<code>grub.cfg</code>内的菜单项，windows的排序就会自动在ubuntu之前;</li>
</ol>
<p>另一种方法没试验，如下： 打开<code>/boot/grub/grub.cfg</code>，各个启动项都以<code>menuentry</code>为开头，将<code>menuentry</code>中的内容copy下来,如：menuentry中的<code>"Ubuntu Live Desktop 10.04 32bit zh_TW"</code>抄起來。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menuentry &quot;Ubuntu Live Desktop 10.04 32bit zh_TW&quot; &#123;</span><br></pre></td></tr></table></figure> 然后打开<code>/etc/default/grub</code>，搜索<code>GRUB_DEFAULT=0</code>项，将后面的<code>0</code>，使用上述复制的字符串替换： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRUB_DEFAULT=&quot;Ubuntu Live Desktop 10.04 32bit zh_TW&quot;</span><br></pre></td></tr></table></figure> 最后更新下grub：<code>update-grub</code>， （如要还原成原样，使用<code>GRUB_DEFAULT=0</code>，再重新更新下<code>grub</code>即可）。</p>
<ol start="2" type="1">
<li>删除启动项中的多余项（主要是linux升级后的多个内核） 首先显示系统已安装内核： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --get-selections | grep linux-image</span><br></pre></td></tr></table></figure> 结果如下（本机）： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@njuFerret:/home/ferret<span class="comment"># dpkg --get-selections | grep linux-image</span></span><br><span class="line">linux-image-2.6.35-22-generic                   install</span><br><span class="line">linux-image-2.6.35-24-generic                   install</span><br><span class="line">linux-image-generic                             install</span><br></pre></td></tr></table></figure> 运行以下命令删除旧内核： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get remove linux-image-2.6.35-22-generic    <span class="comment">#删除旧的内核</span></span><br></pre></td></tr></table></figure> 更新grub,然后重启就可以了： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update-grub     <span class="comment"># 更新grub，（可能不需要）</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>附命令: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --get-selections [&lt;表达式&gt; ...] 把已选中的软件包列表打印到标准输出</span><br><span class="line">grep linux-image 匹配查找</span><br><span class="line"><span class="built_in">uname</span> -a 查看已安装的linux内核版本</span><br></pre></td></tr></table></figure></p>
<h2 id="shell脚本的几个技巧">8、shell脚本的几个技巧</h2>
<p>1）使用命令的返回值： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">a=$(<span class="built_in">pwd</span>)   <span class="comment">#或 a=`pwd`  &quot;`&quot;是撇号，非单引号</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$a</span>&quot;</span> = <span class="string">&quot;/root&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;you are in the root directory&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;you are in the &quot;</span><span class="variable">$a</span><span class="string">&quot; directory&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>2）判断目录是否存在    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> srcPath=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">&quot;<span class="variable">$srcPath</span>/installing...&quot;</span> ]; <span class="keyword">then</span>      </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;  ****   tslib未安装  ****  &quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;请先运行1.build_tslib安装tslib&quot;</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>3）定义函数并返回字符串 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getUbootFolder</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    fname=<span class="variable">$1</span></span><br><span class="line">    fname=<span class="variable">$&#123;fname%&quot;.7z&quot;&#125;</span>;     <span class="comment"># &quot;%&quot;表示从右侧开始将匹配的字符串删除</span></span><br><span class="line">    fname=<span class="variable">$&#123;fname%&quot;.bak&quot;&#125;</span>;</span><br><span class="line">    fname=<span class="variable">$&#123;fname%&quot;.tar.bz2&quot;&#125;</span>;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$fname</span>;</span><br><span class="line">&#125;</span><br><span class="line">ubootFolder=$(getUbootFolder <span class="string">&quot;<span class="variable">$UBOOT_SRC</span>&quot;</span>);</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ubootFolder</span>;</span><br></pre></td></tr></table></figure> 关于字符串的更多操作，详见<a href="http://www.cnblogs.com/chengmo/archive/2010/10/02/1841355.html">这里</a></p>
<p>4）case语句的一个很经典的用法 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftype=`file <span class="string">&quot;<span class="variable">$UBOOT_SRC</span>&quot;</span>`   <span class="comment"># Note &#x27; and ` is different</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$ftype</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">&quot;<span class="variable">$UBOOT_SRC</span>: 7-zip archive data&quot;</span>*)</span><br><span class="line">            fullPath=</span><br><span class="line">        　　7z x <span class="string">&quot;<span class="variable">$UBOOT_SRC</span>&quot;</span> &gt; /dev/NULL;;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$UBOOT_SRC</span>: bzip2 compressed&quot;</span>*)</span><br><span class="line">        　　 tar xvf <span class="string">&quot;<span class="variable">$UBOOT_SRC</span>&quot;</span> &gt; /dev/NULL;;</span><br><span class="line">    *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$UBOOT_SRC</span>：未知文件类型，请确认该文件为7zip或bzip2压缩&quot;</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure> 上述命令中，利用file命令来判断文件类型，并根据不同的类型选择不同的处理方法</p>
<h2 id="k6410的两个命令">9、0k6410的两个命令</h2>
<p>1)设置本机地址 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置IP地址</span></span><br><span class="line">ifconfig eth0 192.168.10.120 netmask 255.255.255.0</span><br><span class="line"><span class="comment"># 设置默认网关</span></span><br><span class="line">route delete default</span><br><span class="line">route add default gw 192.168.10.1</span><br><span class="line"><span class="comment"># 修改域名服务器</span></span><br><span class="line">将 etc/resolv.conf 文件内容修改如下：</span><br><span class="line">nameserver 192.168.10.1</span><br></pre></td></tr></table></figure></p>
<p>2)设置mount文件夹，注意-o nolock必须加上 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t nfs 10.0.242.120:/usr/local/arm/exports /tmp -o nolock</span><br></pre></td></tr></table></figure> 3）设置uboot的nfs引导 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">setenv bootargs <span class="string">&quot;root=/dev/nfs nfsroot=192.168.10.101:/usr/local/arm/exports/export ip=192.168.10.120:192.168.10.101:192.168.10.1:255.255.255.0:aaa.bbb:eth0:off console=ttySAC0,115200&quot;</span></span><br><span class="line"><span class="built_in">printenv</span>         <span class="comment"># 列出当前的环境变量</span></span><br><span class="line">saveenv          <span class="comment"># 保存环境变量</span></span><br></pre></td></tr></table></figure></p>
<h2 id="ubuntu10.10设置命令行启动与恢复">10、Ubuntu（10.10）设置命令行启动与恢复</h2>
<p>1）打开 <code>/etc/default/grub</code> ，在<code>GRUB_CMDLINE_LINUX_DEFAULT="quite splash"</code>的末尾添加<code>text</code>： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;quite splash text&quot;</span> </span><br></pre></td></tr></table></figure> 2) 执行 <code>update-grub</code> 命令，重启即可。 如果需要恢复: 1）启动后，暂时性恢复，执行命令： <code>/etc/init.d/gdm start</code> （或使用<code>alias</code>，将下句命令添加到<code>~/.bash_aliases</code>中） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> startGUI=<span class="string">&#x27;/etc/init.d/gdm start&#x27;</span></span><br></pre></td></tr></table></figure> 2）启动前暂时性恢复，在ubuntu启动，显示启动菜单时按下<code>e</code>，删除kernel命令行中的<code>text</code>即可。 3）永久性恢复：移除上面添加的<code>text</code>，然后<code>update-grub</code>，再重新启动</p>
<p>注：貌似11.10版本改了，临时性启动gui命令是<code>/etc/init.d/lightdm start</code>，我这里是10.10，没做测试。 另外，如果希望恢复桌面，可以使用<code>nxServer</code>，安装后可以通过网络使用远程桌面，很强大。</p>
<h2 id="ubuntu-server-12.04-初始化月份字符串出错的解决方法">11、Ubuntu Server 12.04 “初始化月份字符串出错”的解决方法</h2>
<p>本部分来源：<a href="http://www.asmego.com/?p=60">来源1</a>、<a href="http://blog.jiqila.com/category/0/">来源2</a> 1、修改local文件： 执行：<code>sudo vi /var/lib/locales/supported.d/local</code> 将文件内容修改如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8</span><br><span class="line">zh_CN.UTF-8 UTF-8</span><br><span class="line">zh_CN.GBK GBK</span><br><span class="line">zh_CN GB2312</span><br></pre></td></tr></table></figure> 2、更新语言：执行<code>sudo locale-gen</code> 3、编辑默认locale文件：<code>sudo vi /etc/default/locale</code>，修改文件内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANG=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LANGUAGE=&quot;zh_CN:zh&quot;</span><br><span class="line">LC_NUMERIC=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_TIME=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_MONETARY=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_PAPER=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_NAME=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_ADDRESS=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_TELEPHONE=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_MEASUREMENT=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_IDENTIFICATION=&quot;zh_CN.UTF-8&quot;</span><br></pre></td></tr></table></figure> 注意：最后一个文件中都是半角英文双引号，在上述两个来源中，均为中文全角双引号。注意修正。</p>
<h2 id="给系统打补丁的命令">12、给系统打补丁的命令</h2>
<p>下载了内核之后，进入内核源码所在位置：<code>cd /xxxx/xxx/linux-3.4.6</code> 使用下面的命令对内核打补丁： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patch -p1 -i ../patch-3.4.6 -R</span><br></pre></td></tr></table></figure> <code>-p1</code>是略过最高层，此处是<code>linux-3.4.6</code>， <code>-i</code>表示所需要打的补丁文件，<code>patch-3.4.6</code>是补丁文件； <code>-R</code>是循环命令，在命令运行时有很多需要用户确认的，此处表示循环确认。</p>
<h2 id="创建一个带有主目录和能够执行基本脚本的用户">13、创建一个带有主目录和能够执行基本脚本的用户：</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -d /home/<span class="string">&quot;username&quot;</span> -g <span class="string">&quot;gid&quot;</span> -u <span class="string">&quot;uid&quot;</span> -m -s /bin/bash <span class="string">&quot;username&quot;</span></span><br><span class="line">passwd <span class="string">&quot;username&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="解决ubuntu-12.04升级到14.04时fontconfig错误">14、解决Ubuntu 12.04升级到14.04时，fontConfig错误</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Setting up fontconfig (2.11.0-0ubuntu4.1) ...</span><br><span class="line">Regenerating fonts cache... failed.</span><br><span class="line">See /var/log/fontconfig.log <span class="keyword">for</span> more information.</span><br><span class="line">dpkg: error processing package fontconfig (--configure):</span><br><span class="line">subprocess installed post-installation script returned error <span class="built_in">exit</span> status 1</span><br><span class="line">Setting up apt-utils (1.0.1ubuntu2.6) ...</span><br><span class="line">Errors were encountered <span class="keyword">while</span> processing:</span><br><span class="line">fontconfig</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>
<p>查看日志，出现以下内容： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fontconfig warning: <span class="string">&quot;/etc/fonts/conf.d/99-language-selector-zh.conf&quot;</span>, line </span><br><span class="line">11: Having multiple values <span class="keyword">in</span> &lt;<span class="built_in">test</span>&gt; isn<span class="string">&#x27;t supported and may not work as  </span></span><br><span class="line"><span class="string">expected</span></span><br><span class="line"><span class="string">/usr/share/fonts: caching, new cache contents: 0 fonts, 1 dirs</span></span><br><span class="line"><span class="string">/usr/share/fonts/truetype: caching, new cache contents: 0 fonts, 1 dirs</span></span><br><span class="line"><span class="string">/usr/share/fonts/truetype/ttf-dejavu: caching, new cache contents: 6 fonts,     0 dirs</span></span><br><span class="line"><span class="string">/usr/X11R6/lib/X11/fonts: skipping, no such directory</span></span><br><span class="line"><span class="string">/usr/local/share/fonts: caching, new cache contents: 0 fonts, 0 dirs</span></span><br><span class="line"><span class="string">/.local/share/fonts: fc-cache: symbol lookup error: fc-cache:</span></span><br><span class="line"><span class="string">undefined symbol: FcStrListFirst</span></span><br></pre></td></tr></table></figure> 解决方法：运行<code>apt-get remove --purge fontconfig-config</code>，删除 <code>fontConfig-config</code>即可。 然后重新运行<code>apt-get upgrade</code>，直接升级，问题解决。 参考链接：<a href="http://askubuntu.com/questions/576693/failed-upgrading-12-10-14-04-error-with-fontconfig">askubuntu</a></p>
<h2 id="增加启动时执行的命令">15、增加启动时执行的命令</h2>
<p>这个网上很多，这里说的主要是为了ftp能够自动将不同硬盘的目录挂接在一起。proftpd中，利用mount命令，将第二块硬盘的一个目录，挂接到ftp的主目录下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --<span class="built_in">bind</span> /usr/ftpService/MTV /wd_1t/ftpService/Movies/MTV</span><br></pre></td></tr></table></figure> 上述命令将<code>usr</code>路径下的目录挂接到<code>wd_1t</code>目录下（<code>wd_1t/ftpService</code>是ftp的主目录），用户在访问<code>wd_1t/.../MTV</code>目录时等同访问<code>usr</code>下的<code>MTV</code>目录。 启动项的建立比较简单，以<code>#!/bin/sh</code>开头，写上要执行的命令，并给于可执行权限755就可以了。</p>
<p>1）在<code>/etc/init.d/</code>目录下新建一个脚本<code>my-start-up</code>，如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount --<span class="built_in">bind</span> /usr/ftpService/MTV /wd_1t/ftpService/Movies/MTV</span><br></pre></td></tr></table></figure> 2）执行 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update-rc.d my-start-up defaults</span><br></pre></td></tr></table></figure> 执行完成之后，系统会提示： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update-rc.d: warning: /etc/init.d/my-start-up missing LSB information</span><br></pre></td></tr></table></figure> 原因不详，如果想删除该启动脚本，执行以下命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d$ sudo update-rc.d -f my-start-up remove</span><br></pre></td></tr></table></figure> 3）<code>ubuntu 20.04</code> 需要使用<code>systemctl</code> 启用该服务, <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">/etc/init.d$ systemctl status my-start-up.service </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ● my-start-up.service - LSB: start my-start-up</span></span><br><span class="line"><span class="comment">#    Loaded: loaded (/etc/init.d/my-start-up; generated)</span></span><br><span class="line"><span class="comment">#    Active: generated  </span></span><br><span class="line"><span class="comment">#      Docs: man:systemd-sysv-generator(8)</span></span><br><span class="line"><span class="comment">#   Process: 2285 ExecStart=/etc/init.d/my-start-up start (code=exited, # status=0/SUCCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用服务</span></span><br><span class="line">/etc/init.d$ sudo systemctl <span class="built_in">enable</span> my-start-up.service</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># my-start-up.service is not a native service, redirecting to systemd-sysv-install.</span></span><br><span class="line"><span class="comment"># Executing: /lib/systemd/systemd-sysv-install enable my-start-up</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 重启即可看到效果</p>
<h2 id="安装无线网卡驱动并开机自动登录wifi">16、安装无线网卡驱动并开机自动登录WiFi</h2>
<p>老笔记本新安装了14.04服务器版Ubuntu。无线网卡是BroadCom的BCM4318（HP nx6120），安装时没有网线，也没有WiFi驱动，所有网络都不可用。网络这些东西都是必须要的，首先解决这几个问题（以下均为<strong>管理员权限</strong>下操作）。 1）插上网线，临时使用网卡。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci | grep -i eth    <span class="comment"># 查看网卡</span></span><br><span class="line">iwconfig               <span class="comment"># 列出所有的网络接口interfaces</span></span><br><span class="line">ifconfig eth0 up       <span class="comment"># 确定是eth0之后，启用eth0</span></span><br><span class="line">dhclient eth0          <span class="comment"># 开启dhcp客户端，现在应该可以了</span></span><br></pre></td></tr></table></figure> 2）能够上网之后，先更新一次（update就行，不用upgrade），然后安装BCM4318的驱动: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci | grep -i wireless     <span class="comment"># 查看无线网卡的信息</span></span><br><span class="line"><span class="comment"># 上述命令显示</span></span><br><span class="line"><span class="comment"># 02:04.0 Network controller: Broadcom Corporation BCM4318 [AirForce One 54g] 802.11g Wireless LAN Controller (rev 02)</span></span><br><span class="line"><span class="comment"># lspci | grep -i eth        # 显示以太网卡的信息</span></span><br><span class="line"></span><br><span class="line">apt-get purge bcmwl-kernel-source</span><br><span class="line">apt-get install --reinstall b43-fwcutter firmware-b43-installer</span><br></pre></td></tr></table></figure></p>
<p>安装完成之后，可以使用第一步的方法启用无线网卡，但是一般的WiFi均有密码，很烦。我这里的WiFi使用的是WEP，最简单的一种，因此可以用下面的方法解决。 3）编辑文件interfaces（注意备份），启动时自动加载网卡。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/network/interfaces</span><br></pre></td></tr></table></figure> 前两句是原来文件的内容，在这之后，添加后面的内容 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络接口名可用iwconfig查看</span></span><br><span class="line">auto wlan0</span><br><span class="line">iface wlan0 inet static</span><br><span class="line">address 192.168.10.105</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.10.1</span><br><span class="line">wireless-essid 路由的SSID</span><br><span class="line">wireless-key 路由访问密码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br></pre></td></tr></table></figure> ## 17、添加用户并将其加入sudo组中 以下命令均在root权限下执行： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduser <span class="built_in">test</span></span><br><span class="line">usermod -aG sudo <span class="built_in">test</span></span><br></pre></td></tr></table></figure> ## 18、配置nginx服务器使用https加密传输 1）准备工作： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 秘钥和crt文件位置</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> /etc/nginx/ssl</span><br><span class="line"><span class="comment"># 使用openssl创建秘钥和加密文件</span></span><br><span class="line">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/ssl/nginx.key -out /etc/nginx/ssl/nginx.crt</span><br><span class="line"><span class="comment"># 填入相应的内容</span></span><br></pre></td></tr></table></figure> 注意：Common Name是网站的域名或者IP <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Country Name (2 letter code) [AU]:CN </span><br><span class="line">State or Province Name (full name) [Some-State]:Jiangsu</span><br><span class="line">Locality Name (eg, city) []:Nanjing</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:OrganizationName</span><br><span class="line">Organizational Unit Name (eg, section) []:SectionName</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:10.3.89.127</span><br><span class="line">Email Address []:email@email.com</span><br></pre></td></tr></table></figure> 2）配置nginx <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure> 按照以下内容修改： a）设定将所有http重定向至https <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default server configuration</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server ipv6on</span><br><span class="line">ly=on;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重定向到 HTTPS</span></span><br><span class="line">    rewrite ^(.*) https://$host<span class="variable">$1</span> permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> b) 设定HTTPS的秘钥与凭证路径 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="comment"># SSL configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    listen 443 ssl default_server;</span><br><span class="line">    listen [::]:443 ssl default_server;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ssl凭证与秘钥路径</span></span><br><span class="line">    ssl_certificate /etc/nginx/ssl/nginx.crt;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/nginx.key;</span><br><span class="line">    <span class="comment"># 其他设定，保持不变</span></span><br><span class="line">    ...  </span><br></pre></td></tr></table></figure> 3）重启nginx <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service nginx resart</span><br></pre></td></tr></table></figure> 当使用 HTTPS浏览时，浏览器会发错凭证不可靠的警告，如果凭证FQDN跟服务器的FQDN不符时，也会出现浏览告警，解决方法是重新使用openssl生成一个与服务器FQDN一致的凭证。</p>
<h2 id="批量重命名文件">19、批量重命名文件</h2>
<p>总是遇到重命名的情况，这次一定要记录下来， <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rename <span class="string">&#x27;s/src_string/target_string/g&#x27;</span> *.txt</span><br></pre></td></tr></table></figure> 将所有<code>txt</code>文件中，文件名含有的<code>src_string</code>字符串替换为<code>target_string</code>，支持正则表达式。对于含有空格的可以使用<code>'s/ /_/g'</code>做替换，然后重复上述替换步骤。</p>
<p>本文来自：<a href="http://ferret.blog.163.com/blog/static/64423780201103014710258" title="ubuntu的使用">http://ferret.blog.163.com/blog/static/64423780201103014710258</a></p>
]]></content>
      <categories>
        <category>折腾</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>ok6410</tag>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt开发经验_转</title>
    <url>/2023/08/22/2023-08-22_qt/</url>
    <content><![CDATA[<blockquote>
<p>作者 飞扬青云</p>
</blockquote>
<h2 id="前言说明">0 前言说明</h2>
<ol type="1">
<li><strong>项目作品：<a href="https://qtchina.blog.csdn.net/article/details/97565652">https://qtchina.blog.csdn.net/article/details/97565652</a></strong></li>
<li><strong>视频主页：<a href="https://space.bilibili.com/687803542">https://space.bilibili.com/687803542</a></strong></li>
<li><strong>网店地址：<a href="https://shop244026315.taobao.com">https://shop244026315.taobao.com</a></strong> <span id="more"></span></li>
<li><strong>联系方式：QQ（517216493）微信（feiyangqingyun）推荐加微信。</strong></li>
<li><strong>公 众 号：Qt教程（民间） Qt软件（官方）</strong></li>
<li><strong>版本支持：所有项目已经全部支持Qt4/5/6所有版本以及后续版本。</strong></li>
<li>监控作品体验：<a href="https://pan.baidu.com/s/1d7TH_GEYl5nOecuNlWJJ7g">https://pan.baidu.com/s/1d7TH_GEYl5nOecuNlWJJ7g</a> 提取码：01jf</li>
<li>其他作品体验：<a href="https://pan.baidu.com/s/1ZxG-oyUKe286LPMPxOrO2A">https://pan.baidu.com/s/1ZxG-oyUKe286LPMPxOrO2A</a> 提取码：o05q</li>
<li>监控系统在线文档：<a href="https://feiyangqingyun.gitee.io/QWidgetDemo/video_system/">https://feiyangqingyun.gitee.io/QWidgetDemo/video_system/</a></li>
<li>大屏系统在线文档：<a href="https://feiyangqingyun.gitee.io/QWidgetDemo/bigscreen/">https://feiyangqingyun.gitee.io/QWidgetDemo/bigscreen/</a></li>
<li>物联网系统在线文档：<a href="https://feiyangqingyun.gitee.io/QWidgetDemo/iotsystem/">https://feiyangqingyun.gitee.io/QWidgetDemo/iotsystem/</a></li>
</ol>
<h2 id="开发经验">1 开发经验</h2>
<h3 id="section">01：001-010</h3>
<ol type="1">
<li><p>当编译发现大量错误的时候，从第一个看起，一个一个的解决，不要急着去看下一个错误，往往后面的错误都是由于前面的错误引起的，第一个解决后很可能都解决了。比如我们可能就写错了一行代码，编译提示几百个错误，你只要把这一行纠正了，其他错误也就没了。</p></li>
<li><p>定时器是个好东西，学会好使用它，有时候用QTimer::singleShot单次定时器和QMetaObject::invokeMethod可以解决意想不到的问题。比如在窗体初始化的时候加载一个耗时的操作，很容易卡主界面的显示，要在加载完以后才会显示界面，这就导致了体验很卡不友好的感觉，此时你可以将耗时的加载（有时候这些加载又必须在主线程，比如用QStackWidget堆栈窗体加载一些子窗体），延时或者异步进行加载，这样就会在界面显示后去执行，而不是卡住主界面。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步执行load函数</span></span><br><span class="line">QMetaObject::<span class="built_in">invokeMethod</span>(<span class="keyword">this</span>, <span class="string">&quot;load&quot;</span>, Qt::QueuedConnection);</span><br><span class="line"><span class="comment">//延时10毫秒执行load函数</span></span><br><span class="line">QTimer::<span class="built_in">singleShot</span>(<span class="number">10</span>, <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">load</span>()));</span><br></pre></td></tr></table></figure></p></li>
<li><p>默认QtCreator是单线程编译，可能设计之初考虑到尽量不过多占用系统资源，而现在的电脑都是多核心的，默认msvc编译器是多线程编译的不需要手动设置，而对于其他编译器，需要手动设置才行。</p></li>
</ol>
<ul>
<li>方法一：在每个项目的构建设置中（可以勾选一个 shadow build 的页面地方）的build步骤，make arguments增加一行 -j16 即可，此设置会保存在pro.user文件中，一旦删除就需要重新设置，不建议此方法；</li>
<li>方法二：在构建套件的环境中增加，工具-&gt;选项-&gt;构建套件(kits)-&gt;选中一个构建套件-&gt;environment-&gt;右侧change按钮-&gt;打开的输入框中填入 MAKEFLAGS=-j4 ， 这样就可以不用每次设置多线程编译，只要是应用该构件套件的项目都会加上这个编译参数；</li>
<li>注意：-j后面接的是电脑的核心数，写多了不会有效果，要自己看下电脑的参数，或者填个-j4就行，毕竟现在电脑4核心应该是最基本的；</li>
<li>大概从2019年开始的新版本的QtCreator默认已经会根据电脑的核心自动设置多线程编译，比如识别到你的电脑是16核心的就会默认设置-j16参数进行编译；</li>
<li>QtCreator8版本开始，选项配置菜单从工具移到了编辑菜单中，很多人有点不适应说怎么没有了，其实稍微鼠标划一划找一找就看到了。</li>
</ul>
<ol start="4" type="1">
<li><p>如果你想顺利用QtCreator部署安卓程序，首先你要在 Android Studio 里面配置成功，编译一个程序能够在手机上或者模拟器中跑起来，把坑全部趟平。</p></li>
<li><p>很多时候找到Qt对应封装的方法后，记得多看看该函数的重载，多个参数的，你会发现不一样的世界，有时候会恍然大悟，原来Qt已经帮我们封装好了，比如QString、QColor的重载参数极其丰富，很多你做梦都想要的功能就在里面。</p></li>
<li><p>可以在pro文件中写上版本号、程序图标、产品名称、版权所有、文件说明等信息（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件。对于早期的Qt4版本你可以手动写rc文件实现。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#程序版本</span><br><span class="line">VERSION  = <span class="number">2025.10</span><span class="number">.01</span></span><br><span class="line">#程序图标</span><br><span class="line">RC_ICONS = main.ico</span><br><span class="line">#产品名称</span><br><span class="line">QMAKE_TARGET_PRODUCT = quc</span><br><span class="line">#版权所有</span><br><span class="line">QMAKE_TARGET_COPYRIGHT = feiyangqingyun</span><br><span class="line">#文件说明</span><br><span class="line">QMAKE_TARGET_DESCRIPTION = QQ: <span class="number">517216493</span>  WX: feiyangqingyun</span><br></pre></td></tr></table></figure></p></li>
<li><p>管理员运行程序，限定在MSVC编译器，在项目pro文件中增加如下代码。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMAKE_LFLAGS += /MANIFESTUAC:<span class="string">&quot;level=&#x27;requireAdministrator&#x27; uiAccess=&#x27;false&#x27;&quot;</span> #以管理员运行</span><br><span class="line">QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,<span class="string">&quot;5.01&quot;</span> #VS2013 在XP运行</span><br></pre></td></tr></table></figure></p></li>
<li><p>运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上一行CONFIG += console，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，一般没法正常运行的程序都会打印一些提示信息缺啥之类的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TEMPLATE    = app</span><br><span class="line">MOC_DIR     = temp/moc</span><br><span class="line">RCC_DIR     = temp/rcc</span><br><span class="line">UI_DIR      = temp/ui</span><br><span class="line">OBJECTS_DIR = temp/obj</span><br><span class="line">#就是下面这行用来设置运行文件附带调试输出窗口</span><br><span class="line">CONFIG      += console</span><br></pre></td></tr></table></figure></p></li>
<li><p>绘制平铺背景QPainter::drawTiledPixmap，绘制圆角矩形QPainter::drawRoundedRect()，而不是QPainter::drawRoundRect()，这两个函数非常容易搞混。</p></li>
<li><p>指定控件移除旧的样式。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//移除原有样式</span></span><br><span class="line"><span class="built_in">style</span>()-&gt;<span class="built_in">unpolish</span>(ui-&gt;btn);</span><br><span class="line"><span class="comment">//必须要有下面这行不然还是不会卸载</span></span><br><span class="line">ui-&gt;btn-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//重新设置新的该控件的样式。</span></span><br><span class="line"><span class="built_in">style</span>()-&gt;<span class="built_in">polish</span>(ui-&gt;btn);</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="section-1">02：011-020</h3>
<ol start="11" type="1">
<li><p>获取类的属性和方法 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拿到控件元对象</span></span><br><span class="line"><span class="type">const</span> QMetaObject *metaObject = widget-&gt;<span class="built_in">metaObject</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有属性的数量</span></span><br><span class="line"><span class="type">int</span> propertyCount = metaObject-&gt;<span class="built_in">propertyCount</span>();</span><br><span class="line"><span class="comment">//propertyOffset是自定义的属性开始的位置</span></span><br><span class="line"><span class="type">int</span> propertyOffset = metaObject-&gt;<span class="built_in">propertyOffset</span>();</span><br><span class="line"><span class="comment">//循环取出控件的自定义属性, int i = 0 表示所有属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = propertyOffset; i &lt; propertyCount; ++i) &#123;</span><br><span class="line">    QMetaProperty metaProperty = metaObject-&gt;<span class="built_in">property</span>(i);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name = metaProperty.<span class="built_in">name</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *type = metaProperty.<span class="built_in">typeName</span>();</span><br><span class="line">    QVariant value = widget-&gt;<span class="built_in">property</span>(name);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; name &lt;&lt; type &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有方法的数量</span></span><br><span class="line"><span class="type">int</span> methodCount = metaObject-&gt;<span class="built_in">methodCount</span>();</span><br><span class="line"><span class="comment">//methodOffset是自定义的方法开始的位置</span></span><br><span class="line"><span class="type">int</span> methodOffset = metaObject-&gt;<span class="built_in">methodOffset</span>();</span><br><span class="line"><span class="comment">//循环取出控件的自定义方法, int i = 0 表示所有方法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = methodOffset; i &lt; methodCount; ++i) &#123;</span><br><span class="line">    QMetaMethod metaMethod = metaObject-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name = metaMethod.<span class="built_in">name</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *type = metaMethod.<span class="built_in">typeName</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; name &lt;&lt; type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt内置图标封装在QStyle中，大概七十多个图标，可以直接拿来用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SP_TitleBarMenuButton,</span><br><span class="line">SP_TitleBarMinButton,</span><br><span class="line">SP_TitleBarMaxButton,</span><br><span class="line">SP_TitleBarCloseButton,</span><br><span class="line">SP_MessageBoxInformation,</span><br><span class="line">SP_MessageBoxWarning,</span><br><span class="line">SP_MessageBoxCritical,</span><br><span class="line">SP_MessageBoxQuestion,</span><br><span class="line">...</span><br><span class="line"><span class="comment">//下面这样取出来使用就行</span></span><br><span class="line">QPixmap pixmap = <span class="keyword">this</span>-&gt;<span class="built_in">style</span>()-&gt;<span class="built_in">standardPixmap</span>(QStyle::SP_TitleBarMenuButton);</span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setPixmap</span>(pixmap);</span><br></pre></td></tr></table></figure></p></li>
<li><p>根据操作系统位数判断加载 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">win32 &#123;</span><br><span class="line">    <span class="built_in">contains</span>(DEFINES, WIN64) &#123;</span><br><span class="line">        DESTDIR = $$PWD/../bin64</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        DESTDIR = $$PWD/../bin32</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt5增强了很多安全性验证，如果出现setGeometry: Unable to set geometry，请将该控件的可见移到加入布局之后。</p></li>
<li><p>可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton *btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line">btn-&gt;<span class="built_in">resize</span>(<span class="number">30</span>, ui-&gt;lineEdit-&gt;<span class="built_in">height</span>());</span><br><span class="line">QHBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>(ui-&gt;lineEdit);</span><br><span class="line">layout-&gt;<span class="built_in">setMargin</span>(<span class="number">0</span>);</span><br><span class="line">layout-&gt;<span class="built_in">addStretch</span>();</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(btn);</span><br></pre></td></tr></table></figure></p></li>
<li><p>对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果。</p></li>
<li><p>巧妙的使用 findChildren 可以查找该控件下的所有子控件。 findChild 为查找单个。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找指定类名objectName的控件</span></span><br><span class="line">QList&lt;QWidget *&gt; widgets = fatherWidget.<span class="built_in">findChildren</span>&lt;QWidget *&gt;(<span class="string">&quot;widgetname&quot;</span>);</span><br><span class="line"><span class="comment">//查找所有QPushButton</span></span><br><span class="line">QList&lt;QPushButton *&gt; allPButtons = fatherWidget.<span class="built_in">findChildren</span>&lt;QPushButton *&gt;();</span><br><span class="line"><span class="comment">//查找一级子控件,不然会一直遍历所有子控件</span></span><br><span class="line">QList&lt;QPushButton *&gt; childButtons = fatherWidget.<span class="built_in">findChildren</span>&lt;QPushButton *&gt;(<span class="built_in">QString</span>(), Qt::FindDirectChildrenOnly);</span><br></pre></td></tr></table></figure></p></li>
<li><p>巧妙的使用inherits判断是否属于某种类。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QTimer *timer = <span class="keyword">new</span> QTimer;         <span class="comment">// QTimer inherits QObject</span></span><br><span class="line">timer-&gt;<span class="built_in">inherits</span>(<span class="string">&quot;QTimer&quot;</span>);          <span class="comment">// returns true</span></span><br><span class="line">timer-&gt;<span class="built_in">inherits</span>(<span class="string">&quot;QObject&quot;</span>);         <span class="comment">// returns true</span></span><br><span class="line">timer-&gt;<span class="built_in">inherits</span>(<span class="string">&quot;QAbstractButton&quot;</span>); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-&gt;dynamicPropertyNames()列出所有弱属性名称，然后通过widget-&gt;property("name")取出对应的弱属性的值。</p></li>
<li><p>在开发时, 无论是出于维护的便捷性, 还是节省内存资源的考虑, 都应该有一个 qss 文件来存放所有的样式表, 而不应该将 setStyleSheet 写的到处都是。如果是初学阶段或者测试阶段可以直接UI上右键设置样式表，正式项目还是建议统一到一个qss样式表文件比较好，统一管理。</p></li>
</ol>
<h3 id="section-2">03：021-030</h3>
<ol start="21" type="1">
<li><p>如果出现Z-order assignment: is not a valid widget.错误提示，用记事本打开对应的ui文件，找到<zorder></zorder>为空的地方，删除即可。</p></li>
<li><p>善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来。特别注意的是第二个参数是QVariant类型，这就不要太灵活了，意味着可以附带万能的数据比如结构体，这样就可以带一堆数据了，而不是一个数据。比如下拉框选择学号，对应元素可以附带该学生的姓名、班级、成绩等。很多人以为只能附带QString、int之类的数据，因为通常的用法也是那两种。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QStringList listVideoOpenInterval, listVideoOpenIntervalx;</span><br><span class="line">listVideoOpenInterval &lt;&lt; <span class="string">&quot;0.0 秒&quot;</span> &lt;&lt; <span class="string">&quot;0.1 秒&quot;</span> &lt;&lt; <span class="string">&quot;0.3 秒&quot;</span> &lt;&lt; <span class="string">&quot;0.5 秒&quot;</span> &lt;&lt; <span class="string">&quot;1.0 秒&quot;</span> &lt;&lt; <span class="string">&quot;2.0 秒&quot;</span>;</span><br><span class="line">listVideoOpenIntervalx &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; <span class="string">&quot;100&quot;</span> &lt;&lt; <span class="string">&quot;300&quot;</span> &lt;&lt; <span class="string">&quot;500&quot;</span> &lt;&lt; <span class="string">&quot;1000&quot;</span> &lt;&lt; <span class="string">&quot;2000&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; listVideoOpenInterval.<span class="built_in">count</span>(); ++i) &#123;</span><br><span class="line">    ui-&gt;cboxVideoOpenInterval-&gt;<span class="built_in">addItem</span>(listVideoOpenInterval.<span class="built_in">at</span>(i), listVideoOpenIntervalx.<span class="built_in">at</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出对应的值</span></span><br><span class="line"><span class="type">int</span> indexVideoOpenInterval = ui-&gt;cboxVideoOpenInterval-&gt;<span class="built_in">currentIndex</span>();</span><br><span class="line">indexVideoOpenInterval = ui-&gt;cboxVideoOpenInterval-&gt;<span class="built_in">itemData</span>(indexVideoOpenInterval).<span class="built_in">toInt</span>();</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果用了webengine模块，发布程序的时候带上QtWebEngineProcess.exe、translations文件夹、resources文件夹，不然无法正常运行。</p></li>
<li><p>在MFC程序或者VB/C#等窗体程序中，每个控件都有一个句柄，而且用句柄工具移过去会自动识别，但是在Qt程序中默认Qt是一个窗体一个句柄，如果要让每个控件都拥有独立的句柄，在main函数中要做如下设置。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    a.<span class="built_in">setAttribute</span>(Qt::AA_NativeWindows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt编写的Android程序防止程序被关闭。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(Q_OS_ANDROID)</span></span><br><span class="line"><span class="function">QAndroidService <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"><span class="keyword">return</span> a.<span class="built_in">exec</span>()</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">QApplication <span class="built_in">a</span>(argc, argv);</span><br><span class="line"><span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置， <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*::down-arrow&#123;&#125;</span><br><span class="line">*::menu-indicator&#123;&#125;</span><br><span class="line">*::up-arrow:disabled&#123;&#125;</span><br><span class="line">*::up-arrow:off&#123;&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>可以指定位置设置背景图片。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMainWindow &gt; .QWidget &#123;</span><br><span class="line">    background-color: gainsboro;</span><br><span class="line">    background-image: <span class="built_in">url</span>(:/images/xxoo.png);</span><br><span class="line">    background-position: top right;</span><br><span class="line">    background-repeat: no-repeat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>嵌入式linux运行Qt程序 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Qt4写法</span></span><br><span class="line">./HelloQt -qws &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Qt5写法 xcb 可以改成 linuxfb eglfs vnc wayland 等,有哪个就用哪个挨个测试</span></span><br><span class="line">./HelloQt --platform xcb</span><br><span class="line">./HelloQt --platform linuxfb</span><br><span class="line">./HelloQt --platform wayland</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果发现QtCreator中的构建套件不正常了或者坏了（比如不能正确识别环境中的qmake或者编译器、打开项目不能正常生成影子构建目录），请找到两个目录（C:、C:）删除即可，删除后重新打开QtCreator进行构建套件的配置就行。</p></li>
<li><p>QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV Filters安装即可（k-lite或者LAV Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer（sudo apt-get install gstreamer1.0-libav ubuntu-restricted-extras），并未完整验证，报错提示 Your GStreamer installation is missing a plug-in，需要命令安装 sudo apt-get install ubuntu-restricted-extras）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）。</p></li>
</ol>
<h3 id="section-3">04：031-040</h3>
<ol start="31" type="1">
<li><p>判断编译器类型、编译器版本、操作系统。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GCC编译器</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __GNUC__ &gt;= 3   <span class="comment">// GCC3.0  以上</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MSVC编译器</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _MSC_VER &gt;=1000 <span class="comment">// VC++4.0 以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _MSC_VER &gt;=1100 <span class="comment">// VC++5.0 以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _MSC_VER &gt;=1200 <span class="comment">// VC++6.0 以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _MSC_VER &gt;=1300 <span class="comment">// VC2003  以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _MSC_VER &gt;=1400 <span class="comment">// VC2005  以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _MSC_VER &gt;=1500 <span class="comment">// VC2008  以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _MSC_VER &gt;=1600 <span class="comment">// VC2010  以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _MSC_VER &gt;=1700 <span class="comment">// VC2012  以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _MSC_VER &gt;=1800 <span class="comment">// VC2013  以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _MSC_VER &gt;=1900 <span class="comment">// VC2015  以上</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Visual Studio版本与MSVC版本号的对应关系</span></span><br><span class="line">MSC    <span class="number">1.0</span>   _MSC_VER == <span class="number">100</span></span><br><span class="line">MSC    <span class="number">2.0</span>   _MSC_VER == <span class="number">200</span></span><br><span class="line">MSC    <span class="number">3.0</span>   _MSC_VER == <span class="number">300</span></span><br><span class="line">MSC    <span class="number">4.0</span>   _MSC_VER == <span class="number">400</span></span><br><span class="line">MSC    <span class="number">5.0</span>   _MSC_VER == <span class="number">500</span></span><br><span class="line">MSC    <span class="number">6.0</span>   _MSC_VER == <span class="number">600</span></span><br><span class="line">MSC    <span class="number">7.0</span>   _MSC_VER == <span class="number">700</span></span><br><span class="line">MSVC++ <span class="number">1.0</span>   _MSC_VER == <span class="number">800</span></span><br><span class="line">MSVC++ <span class="number">2.0</span>   _MSC_VER == <span class="number">900</span></span><br><span class="line">MSVC++ <span class="number">4.0</span>   _MSC_VER == <span class="number">1000</span> (Developer Studio <span class="number">4.0</span>)</span><br><span class="line">MSVC++ <span class="number">4.2</span>   _MSC_VER == <span class="number">1020</span> (Developer Studio <span class="number">4.2</span>)</span><br><span class="line">MSVC++ <span class="number">5.0</span>   _MSC_VER == <span class="number">1100</span> (Visual Studio <span class="number">97</span> version <span class="number">5.0</span>)</span><br><span class="line">MSVC++ <span class="number">6.0</span>   _MSC_VER == <span class="number">1200</span> (Visual Studio <span class="number">6.0</span> version <span class="number">6.0</span>)</span><br><span class="line">MSVC++ <span class="number">7.0</span>   _MSC_VER == <span class="number">1300</span> (Visual Studio .NET <span class="number">2002</span> version <span class="number">7.0</span>)</span><br><span class="line">MSVC++ <span class="number">7.1</span>   _MSC_VER == <span class="number">1310</span> (Visual Studio .NET <span class="number">2003</span> version <span class="number">7.1</span>)</span><br><span class="line">MSVC++ <span class="number">8.0</span>   _MSC_VER == <span class="number">1400</span> (Visual Studio <span class="number">2005</span> version <span class="number">8.0</span>)</span><br><span class="line">MSVC++ <span class="number">9.0</span>   _MSC_VER == <span class="number">1500</span> (Visual Studio <span class="number">2008</span> version <span class="number">9.0</span>)</span><br><span class="line">MSVC++ <span class="number">10.0</span>  _MSC_VER == <span class="number">1600</span> (Visual Studio <span class="number">2010</span> version <span class="number">10.0</span>)</span><br><span class="line">MSVC++ <span class="number">11.0</span>  _MSC_VER == <span class="number">1700</span> (Visual Studio <span class="number">2012</span> version <span class="number">11.0</span>)</span><br><span class="line">MSVC++ <span class="number">12.0</span>  _MSC_VER == <span class="number">1800</span> (Visual Studio <span class="number">2013</span> version <span class="number">12.0</span>)</span><br><span class="line">MSVC++ <span class="number">14.0</span>  _MSC_VER == <span class="number">1900</span> (Visual Studio <span class="number">2015</span> version <span class="number">14.0</span>)</span><br><span class="line">MSVC++ <span class="number">14.1</span>  _MSC_VER == <span class="number">1910</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.0</span>)</span><br><span class="line">MSVC++ <span class="number">14.11</span> _MSC_VER == <span class="number">1911</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.3</span>)</span><br><span class="line">MSVC++ <span class="number">14.12</span> _MSC_VER == <span class="number">1912</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.5</span>)</span><br><span class="line">MSVC++ <span class="number">14.13</span> _MSC_VER == <span class="number">1913</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.6</span>)</span><br><span class="line">MSVC++ <span class="number">14.14</span> _MSC_VER == <span class="number">1914</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.7</span>)</span><br><span class="line">MSVC++ <span class="number">14.15</span> _MSC_VER == <span class="number">1915</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.8</span>)</span><br><span class="line">MSVC++ <span class="number">14.16</span> _MSC_VER == <span class="number">1916</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.9</span>)</span><br><span class="line">MSVC++ <span class="number">14.2</span>  _MSC_VER == <span class="number">1920</span> (Visual Studio <span class="number">2019</span> Version <span class="number">16.0</span>)</span><br><span class="line">MSVC++ <span class="number">14.21</span> _MSC_VER == <span class="number">1921</span> (Visual Studio <span class="number">2019</span> Version <span class="number">16.1</span>)</span><br><span class="line">MSVC++ <span class="number">14.22</span> _MSC_VER == <span class="number">1922</span> (Visual Studio <span class="number">2019</span> Version <span class="number">16.2</span>)</span><br><span class="line">MSVC++ <span class="number">14.30</span> _MSC_VER == <span class="number">1930</span> (Visual Studio <span class="number">2022</span> Version <span class="number">17.0</span>)</span><br><span class="line">MSVC++ <span class="number">14.31</span> _MSC_VER == <span class="number">1931</span> (Visual Studio <span class="number">2022</span> Version <span class="number">17.1</span>)</span><br><span class="line">MSVC++ <span class="number">14.32</span> _MSC_VER == <span class="number">1932</span> (Visual Studio <span class="number">2022</span> Version <span class="number">17.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Borland C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BORLANDC__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Cygwin</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CYGWIN__</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __CYGWIN32__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mingw</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __MINGW32__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//windows</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32           <span class="comment">//32bit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64           <span class="comment">//64bit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WINDOWS         <span class="comment">//图形界面程序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _CONSOLE         <span class="comment">//控制台程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows（95/98/Me/NT/2000/XP/Vista）和Windows CE都定义了</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (WINVER &gt;= 0x030a)  <span class="comment">// Windows 3.1以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (WINVER &gt;= 0x0400)  <span class="comment">// Windows 95/NT4.0以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (WINVER &gt;= 0x0410)  <span class="comment">// Windows 98以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (WINVER &gt;= 0x0500)  <span class="comment">// Windows Me/2000以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (WINVER &gt;= 0x0501)  <span class="comment">// Windows XP以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (WINVER &gt;= 0x0600)  <span class="comment">// Windows Vista以上</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//_WIN32_WINNT 内核版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (_WIN32_WINNT &gt;= 0x0500) <span class="comment">// Windows 2000以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (_WIN32_WINNT &gt;= 0x0501) <span class="comment">// Windows XP以上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (_WIN32_WINNT &gt;= 0x0600) <span class="comment">// Windows Vista以上</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>在pro中判断Qt版本及构建套件位数 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#打印版本信息</span><br><span class="line"><span class="built_in">message</span>(qt version: $$QT_VERSION)</span><br><span class="line">#判断当前qt版本号</span><br><span class="line">QT_VERSION = $$[QT_VERSION]</span><br><span class="line">QT_VERSION = $$<span class="built_in">split</span>(QT_VERSION, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">QT_VER_MAJ = $$<span class="built_in">member</span>(QT_VERSION, <span class="number">0</span>)</span><br><span class="line">QT_VER_MIN = $$<span class="built_in">member</span>(QT_VERSION, <span class="number">1</span>)</span><br><span class="line">#下面是表示 Qt5<span class="number">.5</span>及以上版本</span><br><span class="line"><span class="built_in">greaterThan</span>(QT_VER_MAJ, <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">greaterThan</span>(QT_VER_MIN, <span class="number">4</span>) &#123;</span><br><span class="line">#自己根据需要做一些处理</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line">#QT_ARCH是Qt5新增的,在Qt4上没效果</span><br><span class="line">#打印当前Qt构建套件的信息</span><br><span class="line"><span class="built_in">message</span>($$QT_ARCH)</span><br><span class="line">#表示arm平台构建套件</span><br><span class="line"><span class="built_in">contains</span>(QT_ARCH, arm) &#123;&#125;</span><br><span class="line">#表示<span class="number">32</span>位的构建套件</span><br><span class="line"><span class="built_in">contains</span>(QT_ARCH, i386) &#123;&#125;</span><br><span class="line">#表示<span class="number">64</span>位的构建套件</span><br><span class="line"><span class="built_in">contains</span>(QT_ARCH, x86_64) &#123;&#125;</span><br><span class="line"></span><br><span class="line">#其实Qt内置了主版本号和子版本号变量</span><br><span class="line">#判断当前qt版本号</span><br><span class="line"><span class="built_in">message</span>($$QT_ARCH : $$QT_VERSION -&gt; $$QT_MAJOR_VERSION . $$QT_MINOR_VERSION)</span><br><span class="line"></span><br><span class="line">#下面的含义是如果版本 &lt; <span class="number">4.8</span></span><br><span class="line"><span class="built_in">lessThan</span>(QT_MAJOR_VERSION, <span class="number">5</span>) &#123;</span><br><span class="line"><span class="built_in">lessThan</span>(QT_MINOR_VERSION, <span class="number">8</span>) &#123;</span><br><span class="line">#这里放要做的处理</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line">#下面的含义是如果版本 &lt; <span class="number">5.12</span><span class="number">.0</span></span><br><span class="line">REQ_QT_MAJOR = <span class="number">5</span></span><br><span class="line">REQ_QT_MINOR = <span class="number">12</span></span><br><span class="line">REQ_QT_PATCH = <span class="number">0</span></span><br><span class="line"><span class="built_in">lessThan</span>(QT_MAJOR_VERSION, $$REQ_QT_MAJOR)|<span class="built_in">lessThan</span>(QT_MINOR_VERSION, $$REQ_QT_MINOR)|<span class="built_in">lessThan</span>(QT_MINOR_VERSION, $$REQ_QT_PATCH) &#123;</span><br><span class="line">#这里放要做的处理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#下面的含义是如果版本 &gt;= <span class="number">5.5</span></span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MINOR_VERSION, <span class="number">4</span>) &#123;</span><br><span class="line">#这里放要做的处理</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码中判断版本不要太简单</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="comment">//这里放要做的处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面表示 &gt;= 5.0.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> QT_VERSION &gt;= 0x050000</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面表示 &lt; 5.12.10</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> QT_VERSION &lt; 0x050C0A</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt最小化后恢复界面可能会出现假死冻结现象，加上代码 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showEvent</span><span class="params">(QShowEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setAttribute</span>(Qt::WA_Mapped);</span><br><span class="line">    QWidget::<span class="built_in">showEvent</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>获取标题栏高度：style()-&gt;pixelMetric(QStyle::PM_TitleBarHeight); PM_TitleBarHeight点进去你会发现新大陆，有一堆玩意在里面。</p></li>
<li><p>设置高分屏属性以便支持2K4K等高分辨率，尤其是手机app。必须写在main函数的QApplication a(argc, argv);的前面。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,6,0))</span></span><br><span class="line">    QGuiApplication::<span class="built_in">setAttribute</span>(Qt::AA_EnableHighDpiScaling);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果运行程序出现 Fault tolerant heap shim applied to current process. This is usually due to previous crashes. 错误。</p></li>
</ol>
<ul>
<li>第一步：输入命令 regedit 打开注册表；</li>
<li>第二步：找到节点 HKEY_LOCAL_MACHINENT；</li>
<li>第三步：选中Layers键值，从右侧列表中删除自己的那个程序路径即可。</li>
</ul>
<ol start="37" type="1">
<li><p>Qt内置了QFormLayout表单布局用于自动生成标签+输入框的组合的表单界面，设置布局用的很少，一般用的最多的是横向布局、垂直布局、表格布局。</p></li>
<li><p>qml播放视频在linux需要安装 sudo apt-get install libpulse-dev。</p></li>
<li><p>可以直接继承QSqlQueryModel实现自定义的QueryModel，比如某一列字体颜色，占位符，其他样式等，重写QVariant CustomSqlModel::data(const QModelIndex &amp;index, int role) const。</p></li>
<li><p>Qt5以后提供了类QScroller直接将控件滚动。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//禁用横向滚动条</span></span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">setHorizontalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line"><span class="comment">//禁用纵向滚动条</span></span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">setVerticalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line"><span class="comment">//设置横向按照像素值为单位滚动</span></span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">setHorizontalScrollMode</span>(QListWidget::ScrollPerPixel);</span><br><span class="line"><span class="comment">//设置纵向按照像素值为单位滚动</span></span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">setVerticalScrollMode</span>(QListWidget::ScrollPerPixel);</span><br><span class="line"><span class="comment">//设置滚动对象以及滚动方式为鼠标左键拉动滚动</span></span><br><span class="line">QScroller::<span class="built_in">grabGesture</span>(ui-&gt;listWidget, QScroller::LeftMouseButtonGesture);</span><br><span class="line"><span class="comment">//还有个QScrollerProperties可以设置滚动的一些参数</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="section-4">05：041-050</h3>
<ol start="41" type="1">
<li><p>如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);</span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;:memory:&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>清空数据表并重置自增ID，sql = truncate table table_name。</p></li>
<li><p>QtChart模块从Qt5.7开始自带，最低编译要求Qt5.4。在安装的时候记得勾选，默认不勾选。使用该模块需要引入命名空间。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QChartView&gt;</span></span></span><br><span class="line">QT_CHARTS_USE_NAMESPACE</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomChart</span> : <span class="keyword">public</span> QChartView</span><br></pre></td></tr></table></figure></p></li>
<li><p>QPushButton左对齐文字，需要设置样式表QPushButton{text-align:left;}</p></li>
<li><p>QLabel有三种设置文本的方法，掌握好Qt的属性系统，举一反三，可以做出很多效果。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常规办法</span></span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//取巧办法</span></span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setProperty</span>(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//属性大法</span></span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;qproperty-text:hello;&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QEventLoop loop;</span><br><span class="line"><span class="built_in">connect</span>(reply, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), &amp;loop, <span class="built_in">SLOT</span>(<span class="built_in">quit</span>()));</span><br><span class="line">loop.<span class="built_in">exec</span>();</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt中也支持多种预定义变量组合判断，去掉生成空的debug和release目录，在pro文件中加一行 CONFIG -= debug_and_release。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(Q_OS_ANDROID) || defined(Q_OS_IOS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(Q_OS_ANDROID) &amp;&amp; !defined(Q_OS_IOS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="comment">//windows系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//非windows系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面写法编译会报错</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> Q_OS_LINUX</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(Q_OS_WIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(Q_OS_LINUX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About Plugins。也可以设置代码检查级别，Tools》Options 》C++ 》Code Model。</p></li>
<li><p>QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据。 如果数据量很小，也可以采用如下方法： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主动加载所有数据,不然获取到的行数&lt;=256</span></span><br><span class="line"><span class="keyword">while</span>(model-&gt;<span class="built_in">canFetchMore</span>()) &#123;</span><br><span class="line">    model-&gt;<span class="built_in">fetchMore</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，比如自由拉伸边框，可以使用 setWindowFlags(Qt::CustomizeWindowHint)，这样会保留一个系统白边框。</p></li>
</ol>
<h3 id="section-5">06：051-060</h3>
<ol start="51" type="1">
<li><p>在某些http post数据的时候，如果采用的是&amp;字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString content = <span class="string">&quot;测试中文&quot;</span>;</span><br><span class="line">QString note = content.<span class="built_in">toUtf8</span>().<span class="built_in">toPercentEncoding</span>();</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启。 CONFIG += resources_big</p></li>
<li><p>Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一。</p></li>
</ol>
<ul>
<li>方法一：设置属性 this-&gt;setAttribute(Qt::WA_StyledBackground, true);</li>
<li>方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。</li>
<li>方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStyleOption option;</span><br><span class="line">    option.<span class="built_in">initFrom</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="built_in">style</span>()-&gt;<span class="built_in">drawPrimitive</span>(QStyle::PE_Widget, &amp;option, &amp;painter, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="54" type="1">
<li><p>有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的。</p></li>
<li><p>在使用QFile的过程中，不建议频繁的打开文件写入然后再关闭文件，比如间隔5ms输出日志，IO性能瓶颈很大，这种情况建议先打开文件不要关闭，等待合适的时机比如析构函数中或者日期变了需要重新变换日志文件的时候关闭文件。不然短时间内大量的打开关闭文件会很卡，文件越大越卡。</p></li>
<li><p>在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方不能立即识别或者要很久（一般至少要30s）才能识别到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = tcpSocket-&gt;<span class="built_in">socketDescriptor</span>();</span><br><span class="line"><span class="type">int</span> keepAlive = <span class="number">1</span>;      <span class="comment">//开启keepalive属性,缺省值:0(关闭)</span></span><br><span class="line"><span class="type">int</span> keepIdle = <span class="number">5</span>;       <span class="comment">//如果在5秒内没有任何数据交互,则进行探测,缺省值:7200(s)</span></span><br><span class="line"><span class="type">int</span> keepInterval = <span class="number">2</span>;   <span class="comment">//探测时发探测包的时间间隔为2秒,缺省值:75(s)</span></span><br><span class="line"><span class="type">int</span> keepCount = <span class="number">2</span>;      <span class="comment">//探测重试的次数,全部超时则认定连接失效,缺省值:9(次)</span></span><br><span class="line"><span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_KEEPALIVE, (<span class="type">void</span> *)&amp;keepAlive, <span class="built_in">sizeof</span>(keepAlive));</span><br><span class="line"><span class="built_in">setsockopt</span>(fd, SOL_TCP, TCP_KEEPIDLE, (<span class="type">void</span> *)&amp;keepIdle, <span class="built_in">sizeof</span>(keepIdle));</span><br><span class="line"><span class="built_in">setsockopt</span>(fd, SOL_TCP, TCP_KEEPINTVL, (<span class="type">void</span> *)&amp;keepInterval, <span class="built_in">sizeof</span>(keepInterval));</span><br><span class="line"><span class="built_in">setsockopt</span>(fd, SOL_TCP, TCP_KEEPCNT, (<span class="type">void</span> *)&amp;keepCount, <span class="built_in">sizeof</span>(keepCount));</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果程序打包好以后弹出提示 This application failed to start because it could not find or load the Qt platform plugin 一般都是因为platforms插件目录未打包或者打包错了的原因导致的。</p></li>
<li><p>非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的（后面发现我在刚学Qt的时候也发布了一些demo到网上也是tr包含中文的，当时就狠狠的打了自己一巴掌），tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理。</p></li>
<li><p>很多人Qt和Qt Creator傻傻分不清楚，经常问Qt什么版本结果发一个Qt Creator的版本过来，Qt Creator是使用Qt编写的集成开发环境IDE，和宇宙第一的Visual Studio一样，他可以是msvc编译器的（WIN对应的Qt集成安装环境中自带的Qt Cerator是msvc的），也可以是mingw编译的，还可以是gcc的。如果是自定义控件插件，需要集成到Qt Creator中，必须保证该插件的动态库文件（dll或者so等文件）对应的编译器和Qt版本以及位数和Qt Creator的版本完全一致才行，否则基本不大可能集成进去。特别注意的是Qt集成环境安装包中的Qt版本和Qt Creator版本未必完全一致，必须擦亮眼睛看清楚，有些是完全一致的。</p></li>
<li><p>超过两处相同处理的代码，建议单独写成函数。代码尽量规范精简，比如 if(a == 123) 要写成 if (123 == a)，值在前面，再比如 if (ok == true) 要写成 if (ok)，if (ok == false) 要写成 if (!ok)等。</p></li>
</ol>
<h3 id="section-6">07：061-070</h3>
<ol start="61" type="1">
<li><p>很多人问Qt嵌入式平台用哪个好，这里统一回答（当前时间节点2018年）：imx6+335x比较稳定，性能高就用RK3288 RK3399，便宜的话就用全志H3，玩一玩可以用树莓派香橙派。</p></li>
<li><p>对于大段的注释代码，建议用 #if 0 #endif 将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是 #if 0则只要把0改成1即可，开发效率提升很多。</p></li>
<li><p>Qt打包发布，有很多办法，Qt5以后提供了打包工具windeployqt（linux上为linuxdeployqt，mac上为macdeployqt）可以很方便的将应用程序打包，使用下来发现也不是万能的，有时候会多打包一些没有依赖的文件，有时候又会忘记打包一些插件尤其是用了qml的情况下，而且不能识别第三方库，比如程序依赖ffmpeg，则对应的库需要自行拷贝，终极大法就是将你的可执行文件复制到Qt安装目录下的bin目录，然后整个一起打包，挨个删除不大可能依赖的组件，直到删到正常运行为止。</p></li>
<li><p>Qt中的动画，底层用的是QElapsedTimer定时器来完成处理，比如产生一些指定规则算法的数据，然后对属性进行处理。</p></li>
<li><p>在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QRect <span class="title">rect</span><span class="params">(-radius, -radius, radius * <span class="number">2</span>, radius * <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">//以下两种方法二选一,其实绘制360度的圆弧=绘制无背景的圆形</span></span><br><span class="line">painter-&gt;<span class="built_in">drawArc</span>(rect, <span class="number">0</span>, <span class="number">360</span> * <span class="number">16</span>);</span><br><span class="line">painter-&gt;<span class="built_in">drawEllipse</span>(rect);</span><br></pre></td></tr></table></figure></p></li>
<li><p>不要把d指针看的很玄乎，其实就是在类的实现文件定义了一个私有类，用来存放局部变量，个人建议在做一些小项目时，没有太大必要引入这种机制，会降低代码可读性，增加复杂性，新手接受项目后会看的很懵逼。</p></li>
<li><p>很多人在绘制的时候，设置画笔以为就只可以设置个单调的颜色，其实QPen还可以设置brush，这样灵活性就提高不知道多少倍，比如设置QPen的brush以后，可以使用各种渐变，比如绘制渐变颜色的进度条和文字等，而不再是单调的一种颜色。</p></li>
<li><p>很多控件都带有viewport，比如QTextEdit/QTableWidget/QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport()设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-&gt;viewport()-&gt;setStyleSheet("background-color:transparent;");而不是scrollArea-&gt;setStyleSheet("QScrollArea{background-color:transparent;}");</p></li>
<li><p>有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置 setAttribute(Qt::WA_Hover, true);</p></li>
<li><p>Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QDateTime dateTime;</span><br><span class="line">QString dateTime_str = dateTime.<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//从字符串转换为毫秒（需完整的年月日时分秒）</span></span><br><span class="line">datetime.<span class="built_in">fromString</span>(<span class="string">&quot;2011-09-10 12:07:50:541&quot;</span>, <span class="string">&quot;yyyy-MM-dd hh:mm:ss:zzz&quot;</span>).<span class="built_in">toMSecsSinceEpoch</span>();</span><br><span class="line"><span class="comment">//从字符串转换为秒（需完整的年月日时分秒）</span></span><br><span class="line">datetime.<span class="built_in">fromString</span>(<span class="string">&quot;2011-09-10 12:07:50:541&quot;</span>, <span class="string">&quot;yyyy-MM-dd hh:mm:ss:zzz&quot;</span>).<span class="built_in">toTime_t</span>();</span><br><span class="line"><span class="comment">//从毫秒转换到年月日时分秒</span></span><br><span class="line">datetime.<span class="built_in">fromMSecsSinceEpoch</span>(<span class="number">1315193829218</span>).<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss:zzz&quot;</span>);</span><br><span class="line"><span class="comment">//从秒转换到年月日时分秒（若有zzz，则为000）</span></span><br><span class="line">datetime.<span class="built_in">fromTime_t</span>(<span class="number">1315193829</span>).<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss[:zzz]&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="section-7">08：071-080</h3>
<ol start="71" type="1">
<li><p>在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用 at() 取值而不是 [] 操作符，在官方书籍《C++ GUI Qt 4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用 at() 与使用 [] 操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用 at() 函数而不用 [] 操作符，因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而 at() 函数则不被允许出现在一个赋值的左边。</p></li>
<li><p>如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QDialog dialog;</span><br><span class="line">dialog.<span class="built_in">setWindowModality</span>(Qt::WindowModal);</span><br><span class="line">dialog.<span class="built_in">exec</span>();</span><br></pre></td></tr></table></figure></p></li>
<li><p>安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns);</p></li>
<li><p>在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制。</p></li>
<li><p>将 QApplication::style() 对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication::style()-&gt;drawControl 的第4个参数如果不设置，则绘制出来的控件不会应用样式表。</p></li>
<li><p>心中有坐标，万物皆painter，强烈建议在学习自定义控件绘制的时候，将qpainter.h头文件中的函数全部看一遍、试一遍、理解一遍，这里边包含了所有Qt内置的绘制的接口，对应的参数都试一遍，你会发现很多新大陆，会一定程度上激发你的绘制的兴趣，犹如神笔马良一般，策马崩腾遨游代码绘制的世界。</p></li>
<li><p>在使用setItemWidget或者setCellWidget的过程中，有时候会发现设置的控件没有居中显示而是默认的左对齐，而且不会自动拉伸填充，对于追求完美的程序员来说，这个可不大好看，有个终极通用办法就是，将这个控件放到一个widget的布局中，然后将widget添加到item中，这样就完美解决了，而且这样可以组合多个控件产生复杂的控件。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化进度条控件</span></span><br><span class="line">QProgressBar *progress = <span class="keyword">new</span> QProgressBar;</span><br><span class="line"><span class="comment">//增加widget+布局巧妙实现居中</span></span><br><span class="line">QWidget *widget = <span class="keyword">new</span> QWidget;</span><br><span class="line">QHBoxLayout *layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">layout-&gt;<span class="built_in">setSpacing</span>(<span class="number">0</span>);</span><br><span class="line">layout-&gt;<span class="built_in">setMargin</span>(<span class="number">0</span>);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(progress);</span><br><span class="line">widget-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setCellWidget</span>(<span class="number">0</span>, <span class="number">0</span>, widget);</span><br></pre></td></tr></table></figure></p></li>
<li><p>很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据背景色自动计算合适的前景色</span></span><br><span class="line"><span class="type">double</span> gray = (<span class="number">0.299</span> * color.<span class="built_in">red</span>() + <span class="number">0.587</span> * color.<span class="built_in">green</span>() + <span class="number">0.114</span> * color.<span class="built_in">blue</span>()) / <span class="number">255</span>;</span><br><span class="line">QColor textColor = gray &gt; <span class="number">0.5</span> ? Qt::black : Qt::white;</span><br></pre></td></tr></table></figure></p></li>
<li><p>对QTableView、QTableWidget、QTreeView、QTreeWidget禁用列拖动。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &lt; QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    ui-&gt;tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setResizeMode</span>(<span class="number">0</span>, QHeaderView::Fixed);</span><br><span class="line">    ui-&gt;treeView-&gt;<span class="built_in">header</span>()-&gt;<span class="built_in">setResizeMode</span>(<span class="number">0</span>, QHeaderView::Fixed);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ui-&gt;tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(<span class="number">0</span>, QHeaderView::Fixed);</span><br><span class="line">    ui-&gt;treeView-&gt;<span class="built_in">header</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(<span class="number">0</span>, QHeaderView::Fixed);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0</p></li>
</ol>
<h3 id="section-8">09：081-090</h3>
<ol start="81" type="1">
<li><p>Qt中的QColor对颜色封装的很完美，支持各种转换，比如rgb、hsb、cmy、hsl，对应的是toRgb、toHsv、toCmyk、toHsl，还支持透明度设置，颜色值还能转成16进制格式显示。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QColor <span class="title">color</span><span class="params">(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; color.<span class="built_in">name</span>() &lt;&lt; color.<span class="built_in">name</span>(QColor::HexArgb);</span><br><span class="line"><span class="comment">//输出 #ff0000 #64ff0000</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (variant.<span class="built_in">typeName</span>() == <span class="string">&quot;QColor&quot;</span>) &#123;</span><br><span class="line">    QColor color = variant.<span class="built_in">value</span>&lt;QColor&gt;();</span><br><span class="line">    QFont font = variant.<span class="built_in">value</span>&lt;QFont&gt;();</span><br><span class="line">    QString nodeValue = color.<span class="built_in">name</span>(QColor::HexArgb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt中的QString和const char *之间转换，最好用toStdString().c_str()而不是toLocal8Bit().constData()，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常。</p></li>
<li><p>Qt的信号槽机制非常牛逼，也是Qt的独特的核心功能之一，有时候我们在很多窗体中传递信号来实现更新或者处理，如果窗体层级比较多，比如窗体A的父类是窗体B，窗体B的父类是窗体C，窗体C有个子窗体D，如果窗体A一个信号要传递给窗体D，问题来了，必须先经过窗体B中转到窗体C再到窗体D才行，这样的话各种信号关联信号的connect会非常多而且管理起来比较乱，可以考虑增加一个全局的单例类AppEvent，公共的信号放这里，然后窗体A对应信号绑定到AppEvent，窗体D绑定AppEvent的信号到对应的槽函数即可，干净清爽整洁。</p></li>
<li><p>QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets.qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突。</p></li>
<li><p>Qt中有个全局的焦点切换信号focusChanged，可以用它做自定义的输入法。Qt4中默认会安装输入法上下文，比如在main函数打印a.inputContext会显示值，这个默认安装的输入法上下文，会拦截两个牛逼的信号QEvent::RequestSoftwareInputPanel和QEvent::CloseSoftwareInputPanel，以至于就算你安装了全局的事件过滤器依然识别不到这两个信号，你只需要在main函数执行a.setInputContext(0)即可，意思是安装输入法上下文为空。Qt5.7以后提供了内置的输入法，可以通过在main函数最前面加上 qputenv("QT_IM_MODULE", QByteArray("qtvirtualkeyboard")); 来启用。</p></li>
<li><p>在Qt5.10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-&gt;tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(0);</p></li>
<li><p>Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT += gui-private才能使用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QtGui/private/qzipreader_p.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QtGui/private/qzipwriter_p.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">QZipReader <span class="title">reader</span><span class="params">(dirPath)</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">path</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//解压文件夹到当前目录</span></span><br><span class="line">reader.<span class="built_in">extractAll</span>(path);</span><br><span class="line"><span class="comment">//文件夹名称</span></span><br><span class="line">QZipReader::FileInfo fileInfo = reader.<span class="built_in">entryInfoAt</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//解压文件</span></span><br><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(filePath)</span></span>;</span><br><span class="line">file.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line">file.<span class="built_in">write</span>(reader.<span class="built_in">fileData</span>(QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;%1&quot;</span>).<span class="built_in">arg</span>(filePath)));</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line">reader.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">QZipWriter *writer = <span class="keyword">new</span> <span class="built_in">QZipWriter</span>(dirPath);</span><br><span class="line"><span class="comment">//添加文件夹</span></span><br><span class="line">writer-&gt;<span class="built_in">addDirectory</span>(unCompress);</span><br><span class="line"><span class="comment">//添加文件</span></span><br><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(filePath)</span></span>;</span><br><span class="line">file.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">writer-&gt;<span class="built_in">addFile</span>(data, file.<span class="built_in">readAll</span>());</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line">writer-&gt;<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></p></li>
<li><p>理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理。</p></li>
<li><p>在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取。</p></li>
</ol>
<h3 id="section-9">10：091-100</h3>
<ol start="91" type="1">
<li><p>数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题。</p></li>
<li><p>新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incomingConnection</span><span class="params">(qintptr handle)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incomingConnection</span><span class="params">(<span class="type">int</span> handle)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt支持所有的界面控件比如QPushButton、QLineEdit自动关联 on_控件名_信号(参数) 信号槽，比如按钮的单击信号 on_pushButton_clicked()，然后直接实现槽函数即可。</p></li>
<li><p>QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))</span></span><br><span class="line">    <span class="comment">//下面两种方法都可以,Qt默认采用的是AA_UseDesktopOpenGL</span></span><br><span class="line">    QCoreApplication::<span class="built_in">setAttribute</span>(Qt::AA_UseOpenGLES);</span><br><span class="line">    <span class="comment">//QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br></pre></td></tr></table></figure> 另外一个方法解决 全屏+QWebEngineView控件一起会产生右键菜单无法弹出的bug,需要上移一个像素 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QRect rect = qApp-&gt;<span class="built_in">desktop</span>()-&gt;<span class="built_in">geometry</span>();</span><br><span class="line">rect.<span class="built_in">setY</span>(<span class="number">-1</span>);</span><br><span class="line">rect.<span class="built_in">setHeight</span>(rect.<span class="built_in">height</span>());</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(rect);</span><br></pre></td></tr></table></figure></p></li>
<li><p>QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QStyle::<span class="built_in">sliderValueFromPosition</span>(<span class="built_in">minimum</span>(), <span class="built_in">maximum</span>(), event-&gt;<span class="built_in">x</span>(), <span class="built_in">width</span>());</span><br></pre></td></tr></table></figure></p></li>
<li><p>用QFile读写文件的时候，推荐用QTextStream文件流的方式来读写文件，速度快很多，基本上会有30%的提升，文件越大性能区别越大。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从文件加载英文属性与中文属性对照表</span></span><br><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;:/propertyname.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file.<span class="built_in">open</span>(QFile::ReadOnly)) &#123;</span><br><span class="line">    <span class="comment">//QTextStream方法读取速度至少快百分之30</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">while</span>(!file.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">        QString line = file.<span class="built_in">readLine</span>();</span><br><span class="line">        <span class="built_in">appendName</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!in.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">        QString line = in.<span class="built_in">readLine</span>();</span><br><span class="line">        <span class="built_in">appendName</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>用QFile.readAll()读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">frmMain::initStyle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//加载样式表</span></span><br><span class="line">    QString qss;</span><br><span class="line">    <span class="comment">//QFile file(&quot;:/qss/psblack.css&quot;);</span></span><br><span class="line">    <span class="comment">//QFile file(&quot;:/qss/flatwhite.css&quot;);</span></span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;:/qss/lightblue.css&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">open</span>(QFile::ReadOnly)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        <span class="comment">//用QTextStream读取样式文件不用区分文件编码 带bom也行</span></span><br><span class="line">        QStringList list;</span><br><span class="line">        <span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        <span class="comment">//in.setCodec(&quot;utf-8&quot;);</span></span><br><span class="line">        <span class="keyword">while</span> (!in.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">            QString line;</span><br><span class="line">            in &gt;&gt; line;</span><br><span class="line">            list &lt;&lt; line;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qss = list.<span class="built_in">join</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">//用readAll读取默认支持的是ANSI格式,如果不小心用creator打开编辑过了很可能打不开</span></span><br><span class="line">        qss = <span class="built_in">QLatin1String</span>(file.<span class="built_in">readAll</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        QString paletteColor = qss.<span class="built_in">mid</span>(<span class="number">20</span>, <span class="number">7</span>);</span><br><span class="line">        qApp-&gt;<span class="built_in">setPalette</span>(<span class="built_in">QPalette</span>(<span class="built_in">QColor</span>(paletteColor)));</span><br><span class="line">        qApp-&gt;<span class="built_in">setStyleSheet</span>(qss);</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString s1, s2;</span><br><span class="line">s1 = <span class="string">&quot;666.5567124&quot;</span>;</span><br><span class="line">s2.<span class="built_in">setNum</span>(<span class="number">888.5632123</span>, <span class="string">&#x27;f&#x27;</span>, <span class="number">7</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">qSetRealNumberPrecision</span>(<span class="number">10</span>) &lt;&lt; s1.<span class="built_in">toDouble</span>() &lt;&lt; s2.<span class="built_in">toDouble</span>();</span><br></pre></td></tr></table></figure></p></li>
<li><p>用QScriptValueIterator解析数据的时候，会发现总是会多一个节点内容，并且内容为空，如果需要跳过则增加一行代码。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (it.<span class="built_in">hasNext</span>()) &#123;</span><br><span class="line">    it.<span class="built_in">next</span>();    </span><br><span class="line">    <span class="keyword">if</span> (it.<span class="built_in">flags</span>() &amp; QScriptValue::SkipInEnumeration)      </span><br><span class="line">       <span class="keyword">continue</span>;     </span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; it.<span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU。</p></li>
</ol>
<h3 id="section-10">11：101-110</h3>
<ol start="101" type="1">
<li><p>如果需要在尺寸改变的时候不重绘窗体，则设置属性即可 this-&gt;setAttribute(Qt::WA_StaticContents, true); 这样可以避免对已经显示区域的重新绘制。</p></li>
<li><p>默认程序中获取焦点以后会有虚边框，如果看着觉得碍眼不舒服可以去掉，设置样式即可：setStyleSheet("*{outline:0px;}");</p></li>
<li><p>Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QUIHelper::initTableView</span><span class="params">(QTableView *tableView, <span class="type">int</span> rowHeight, <span class="type">bool</span> headVisible, <span class="type">bool</span> edit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//奇数偶数行颜色交替</span></span><br><span class="line">    tableView-&gt;<span class="built_in">setAlternatingRowColors</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//垂直表头是否可见</span></span><br><span class="line">    tableView-&gt;<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">setVisible</span>(headVisible);</span><br><span class="line">    <span class="comment">//选中一行表头是否加粗</span></span><br><span class="line">    tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setHighlightSections</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//最后一行拉伸填充</span></span><br><span class="line">    tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setStretchLastSection</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//行标题最小宽度尺寸</span></span><br><span class="line">    tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setMinimumSectionSize</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//行标题最大高度</span></span><br><span class="line">    tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setMaximumHeight</span>(rowHeight);</span><br><span class="line">    <span class="comment">//默认行高</span></span><br><span class="line">    tableView-&gt;<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">setDefaultSectionSize</span>(rowHeight);</span><br><span class="line">    <span class="comment">//选中时一行整体选中</span></span><br><span class="line">    tableView-&gt;<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);</span><br><span class="line">    <span class="comment">//只允许选择单个</span></span><br><span class="line">    tableView-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表头不可单击</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionsClickable</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setClickable</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//鼠标按下即进入编辑模式</span></span><br><span class="line">    <span class="keyword">if</span> (edit) &#123;</span><br><span class="line">        tableView-&gt;<span class="built_in">setEditTriggers</span>(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tableView-&gt;<span class="built_in">setEditTriggers</span>(QAbstractItemView::NoEditTriggers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TEMPLATE = subdirs</span><br><span class="line">#设置ordered参数以后会依次编译 projA projB projC</span><br><span class="line">CONFIG  += ordered</span><br><span class="line">SUBDIRS += projA</span><br><span class="line">SUBDIRS += projB</span><br><span class="line">SUBDIRS += projC</span><br><span class="line">#还可以通过设置depends指定某个项目依赖 比如下面指定projB依赖projA</span><br><span class="line">projB.depends = projA</span><br><span class="line">projC.depends = projA</span><br><span class="line">projD.depends = projC</span><br></pre></td></tr></table></figure></p></li>
<li><p>MSVC编译器的选择说明</p></li>
</ol>
<ul>
<li>如果是32位的Qt则编译器选择x86开头的</li>
<li>如果是64位的Qt则编译器选择amd64开头的</li>
<li>具体是看安装的Qt构建套件版本以及目标运行平台的系统位数和架构</li>
<li>一般现在的电脑默认以64位的居多，选择amd64即可</li>
<li>如果用户需要兼容32位的系统则建议选择32位的Qt，这样即可在32位也可以在64位系统运行</li>
<li>诸葛大佬补充：x86/x64都是编译环境和运行环境相同，没有或。带下划线的就是交叉编译，前面是编译环境，后面是运行环境。</li>
</ul>
<table>
<thead>
<tr class="header">
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x86</td>
<td>32/64位系统上编译在32/64位系统上运行</td>
</tr>
<tr class="even">
<td>x86_amd64</td>
<td>32/64位系统上编译在64位系统上运行</td>
</tr>
<tr class="odd">
<td>x86_arm</td>
<td>32/64位系统上编译在arm系统上运行</td>
</tr>
<tr class="even">
<td>amd64</td>
<td>64位系统上编译在64位系统上运行</td>
</tr>
<tr class="odd">
<td>amd64_x86</td>
<td>64位系统上编译在32/64位系统上运行</td>
</tr>
<tr class="even">
<td>amd64_arm</td>
<td>64位系统上编译在arm系统上运行</td>
</tr>
</tbody>
</table>
<ol start="106" type="1">
<li><p>很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QDialog dialog;</span><br><span class="line">dialog.<span class="built_in">setWindowModality</span>(Qt::WindowModal);</span><br></pre></td></tr></table></figure></p></li>
<li><p>很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源。</p></li>
</ol>
<ul>
<li>如果你没有使用wait***函数的话，大部分的界面卡都出在数据处理和展示中，比如传过来的是一张图片的数据，你需要将这些数据转成图片，这个肯定是耗时的；</li>
<li>还有就是就收到的数据曲线绘制出来，如果过于频繁或者间隔过短，肯定会给UI造成很大的压力的，最好的办法是解决如何不要频繁绘制UI比如合并数据一起绘制等；</li>
<li>如果是因为绘制UI造成的卡，那多线程也是没啥用的，因为UI只能在主线程；</li>
<li>串口和网络的数据收发默认都是异步的，由操作系统调度的，如果数据处理复杂而且数据量大，你要做的是将数据处理放到多线程中；</li>
<li>如果没有严格的数据同步需求，根本不需要调用wait***之类的函数来立即发送和接收数据，实际需求中大部分的应用场景其实异步收发数据就足够了；</li>
<li>有严格数据同步需求的场景还是放到多线程会好一些，不然你wait***就卡在那边了；</li>
<li>多线程是需要占用系统资源的，理论上来说，如果线程数量超过了CPU的核心数量，其实多线程调度可能花费的时间更多，各位在使用过程中要权衡利弊；</li>
<li>再次强调，不要指望Qt的网络通信支持高并发，最多到1000个能正常工作就万事大吉，一般建议500以内的连接数。有大量高并发的需求请用第三方库比如swoole等。</li>
</ul>
<ol start="108" type="1">
<li><p>在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这种方式设置的无边框窗体在嵌入式设备上无法产生焦点</span></span><br><span class="line"><span class="built_in">setWindowFlags</span>(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要在show以后主动激活窗体</span></span><br><span class="line">w-&gt;<span class="built_in">show</span>();</span><br><span class="line">w-&gt;<span class="built_in">activateWindow</span>();</span><br></pre></td></tr></table></figure></p></li>
<li><p>QString的replace函数会改变原字符串，切记，他在返回替换后的新字符串的同时也会改变原字符串，我的乖乖！</p></li>
<li><p>QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所。</p></li>
</ol>
<h3 id="section-11">12：111-120</h3>
<ol start="111" type="1">
<li><p>在不同的平台上文件路径的斜杠也是不一样的，比如linux系统一般都是 / 斜杠，而在windows上都是 \ 两个反斜杠，Qt本身程序内部无论在win还是linux都支持 / 斜杠的路径，但是一些第三方库的话可能需要转换成对应系统的路径，这就需要用到斜杠转换，Qt当然内置类方法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString path = <span class="string">&quot;C:/temp/test.txt&quot;</span>;</span><br><span class="line">path = QDir::<span class="built_in">toNativeSeparators</span>(path);</span><br><span class="line"><span class="comment">//输出 C:\\temp\\test.txt</span></span><br><span class="line"></span><br><span class="line">QString path = <span class="string">&quot;C:\\temp\\test.txt&quot;</span>;</span><br><span class="line">path = QDir::<span class="built_in">toNativeSeparators</span>(path);</span><br><span class="line"><span class="comment">//输出 C:/temp/test.txt</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>巧用QMetaObject::invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, "fun", Qt::QueuedConnection); 这种方式来就可以。</p></li>
</ol>
<ul>
<li>invokeMethod函数有很多重载参数，可以传入返回值和执行方法的参数等。</li>
<li>invokeMethod函数不仅支持槽函数还支持信号，而且这逼居然是线程安全的，可以在线程中放心使用，牛逼！</li>
<li>测试下来发现只能执行signals或者slots标识的方法。</li>
<li>默认可以执行private(protected/public) slots下的函数，但是不能执行private(protected/public)下的函数。</li>
<li>毛总补充：前提必须是slots或者signals标注的函数，不是标注的函数不在元信息导致无法查找，执行之后会提示No such method。</li>
<li>2021-11-06补充：如果要执行private(protected/public)下的函数，需要函数前面加上 Q_INVOKABLE 关键字，今天又学到了，必须加鸡腿。</li>
<li>其实这样看下来，就是任何方法函数都能执行了，这就超越了private(protected/public)的权限限定了，相当于一个类的私有函数用了 Q_INVOKABLE 关键字修饰也可以被 invokeMethod 执行，哇咔咔。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件声明信号和槽函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sig_test</span><span class="params">(<span class="type">int</span> type,<span class="type">double</span> value)</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slot_test</span><span class="params">(<span class="type">int</span> type, <span class="type">double</span> value)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Q_INVOKABLE <span class="type">void</span> <span class="title">fun_test</span><span class="params">(<span class="type">int</span> type, <span class="type">double</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数关联信号槽</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">sig_test</span>(<span class="type">int</span>, <span class="type">double</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">slot_test</span>(<span class="type">int</span>, <span class="type">double</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//单击按钮触发信号和槽，这里是同时举例信号槽都可以</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMetaObject::<span class="built_in">invokeMethod</span>(<span class="keyword">this</span>, <span class="string">&quot;sig_test&quot;</span>, <span class="built_in">Q_ARG</span>(<span class="type">int</span>, <span class="number">66</span>), <span class="built_in">Q_ARG</span>(<span class="type">double</span>, <span class="number">66.66</span>));</span><br><span class="line">    QMetaObject::<span class="built_in">invokeMethod</span>(<span class="keyword">this</span>, <span class="string">&quot;slot_test&quot;</span>, <span class="built_in">Q_ARG</span>(<span class="type">int</span>, <span class="number">88</span>), <span class="built_in">Q_ARG</span>(<span class="type">double</span>, <span class="number">88.88</span>));</span><br><span class="line">    QMetaObject::<span class="built_in">invokeMethod</span>(<span class="keyword">this</span>, <span class="string">&quot;fun_test&quot;</span>, <span class="built_in">Q_ARG</span>(<span class="type">int</span>, <span class="number">99</span>), <span class="built_in">Q_ARG</span>(<span class="type">double</span>, <span class="number">99.99</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会打印 66 66.66、88 88.88</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::slot_test</span><span class="params">(<span class="type">int</span> type, <span class="type">double</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; type &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会打印 99 99.99</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::fun_test</span><span class="params">(<span class="type">int</span> type, <span class="type">double</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; type &lt;&lt; value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="113" type="1">
<li><p>Qt5中的信号是public的，可以在需要的地方直接emit即可，而在Qt4中信号是protected的，不能直接使用，需要定义一个public函数来emit。</p></li>
<li><p>Qt5.15版本开始官方不再提供安装包，只提供源码，可以自行编译或者在线安装（也可以将在线安装好的离线文件打包拷贝到电脑上使用），估计每次编译各种版本太麻烦，更多的是为了统计收集用户使用信息比如通过在线安装，后期可能会逐步加大商业化力度。</p></li>
<li><p>有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有 QT += 的方式添加的模块，可以用 contains来判断。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qtHaveModule</span>(webenginewidgets) &#123;</span><br><span class="line"><span class="built_in">message</span>(<span class="string">&quot;当前Qt库有找到 webenginewidgets 模块&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!<span class="built_in">qtHaveModule</span>(webkit) &#123;</span><br><span class="line"><span class="built_in">message</span>(<span class="string">&quot;当前Qt库没有找到 webkit 模块&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">contains</span>(QT, network) &#123;</span><br><span class="line"><span class="built_in">message</span>(<span class="string">&quot;当前项目已经引入 network 模块&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!<span class="built_in">contains</span>(QT, widgets) &#123;</span><br><span class="line"><span class="built_in">message</span>(<span class="string">&quot;当前项目没有引入 widgets 模块&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>c++11新引入了原始字符串格式，用户避免在字符串中加入转义字符，可以用于表示json字符串等场景。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString s1 = <span class="string">R&quot;(test\001.jpg)&quot;</span>;</span><br><span class="line">s1.<span class="built_in">replace</span>(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;#&quot;</span>);</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt; s1;</span><br><span class="line"><span class="comment">//结果 test#001.jpg</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>安卓上打印信息建议使用 qInfo() 而不是 qDebug() ，qInfo()才有效果。</p></li>
<li><p>Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置 setTimerType(Qt::PreciseTimer)。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用 startTimer(interval, Qt::PreciseTimer);</p></li>
</ol>
<ul>
<li>Qt::PreciseTimer 精确的定时器，尽量保持毫秒精度。</li>
<li>Qt::CoarseTimer 粗略的定时器，尽量保持精度在所需的时间间隔5%范围内。</li>
<li>Qt::VeryCoarseTimer 很粗略的定时器，只保留完整的第二精度。</li>
<li>精度再高，也依赖对应的操作系统中断，假设中断需要 5ms，则定时器精度不可能高于5毫秒。</li>
</ul>
<ol start="119" type="1">
<li><p>QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用。</p></li>
<li><p>用QSettings设置注册表，如果不是管理员身份运行会打印 QSettings: failed to set subkey "xxx" (拒绝访问。)，你需要手动鼠标右键管理员身份运行就可以。</p></li>
</ol>
<h3 id="section-12">13：121-130</h3>
<ol start="121" type="1">
<li>QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途。</li>
</ol>
<ul>
<li>限制输入只能输入IP地址。</li>
<li>限制输入范围，强烈推荐使用 QRegExpValidator 正则表达式来处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正在表达式限制输入</span></span><br><span class="line">QString str = <span class="string">&quot;\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b&quot;</span>;</span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setValidator</span>(<span class="keyword">new</span> <span class="built_in">QRegExpValidator</span>(<span class="built_in">QRegExp</span>(str)));</span><br><span class="line"><span class="comment">//用于占位</span></span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setInputMask</span>(<span class="string">&quot;000.000.000.000&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//下面代码设置浮点数范围限制失败</span></span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setValidator</span>(<span class="keyword">new</span> <span class="built_in">QDoubleValidator</span>(<span class="number">20</span>, <span class="number">50</span>, <span class="number">1</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//下面代码设置浮点数范围限制成功</span></span><br><span class="line">QDoubleValidator *validator = <span class="keyword">new</span> <span class="built_in">QDoubleValidator</span>(<span class="number">20</span>, <span class="number">50</span>, <span class="number">1</span>);</span><br><span class="line">validator-&gt;<span class="built_in">setNotation</span>(QDoubleValidator::StandardNotation);</span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setValidator</span>(validator);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//下面代码设置整数范围限制成功</span></span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setValidator</span>(<span class="keyword">new</span> <span class="built_in">QIntValidator</span>(<span class="number">10</span>, <span class="number">120</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实上面的代码缺陷很多，只能限制只输入小数，无法设定数值范围，很操蛋</span></span><br><span class="line"><span class="comment">//需要来个万能的牛逼的 QRegExpValidator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//限制浮点数输入范围为[-180,180]</span></span><br><span class="line"><span class="function">QRegExp <span class="title">regexp</span><span class="params">(<span class="string">&quot;^-?(180|1?[0-7]?\\d(\\.\\d+)?)$&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//限制浮点数输入范围为[-90,90]并限定为小数位后4位</span></span><br><span class="line"><span class="function">QRegExp <span class="title">regexp</span><span class="params">(<span class="string">&quot;^-?(90|[1-8]?\\d(\\.\\d&#123;1,4&#125;)?)$&quot;</span>)</span></span>;</span><br><span class="line">QRegExpValidator *validator = <span class="keyword">new</span> <span class="built_in">QRegExpValidator</span>(regexp, <span class="keyword">this</span>);</span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setValidator</span>(validator);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="122" type="1">
<li><p>在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5.14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串 rtmp://58.200.131.2:1935/livetv/cctv1，会显示成 rtmp://... ，而在旧版本的Qt中会显示成 rtmp://58.200.131... ，很多时候我们并不想看到烦人的省略号，可以设置取消。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消自动换行</span></span><br><span class="line">tableView-&gt;<span class="built_in">setWordWrap</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//超出文本不显示省略号</span></span><br><span class="line">tableView-&gt;<span class="built_in">setTextElideMode</span>(Qt::ElideNone);</span><br></pre></td></tr></table></figure></p></li>
<li><p>QVideoWidget播放视频，可能会遇到画面闪烁的情况，播放视频的窗体需要设置个属性。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QVideoWidget *videoWidget = <span class="keyword">new</span> QVideoWidget;</span><br><span class="line">videoWidget-&gt;<span class="built_in">setAttribute</span>(Qt::WA_OpaquePaintEvent);</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt bug成千上万，这个不用大惊小怪，也基本上遇不到，大部分都是特殊极端情况特定应用场景出现，甚至你会遇到有些是debug可以release报错，有些release可以debug却报错的情况，最神奇的还有先是debug报错，然后release正常，再返回去用debug又正常，需要用release激活一下！学习编程的路本来就是一条坑坑洼洼的路，不断填坑，尽量规避坑！很多时候很多看起来的坑其实是自己没有注意细节导致的。</p></li>
<li><p>Qt视图中默认排序是按照字符串的ASCII排序的，如果是IP地址的话会出现192.168.1.117排在192.168.1.2前面的情况，如果要规避这种情况，一种做法是取末尾的地址转成整型再比较大小，缺点是跨网段就歇菜了，又会出现192.168.2.65出现在192.168.1.70前面，终极大法是将IP地址转成整型再比较大小。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">QUIHelper::ipv4IntToString</span><span class="params">(quint32 ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString result = <span class="built_in">QString</span>(<span class="string">&quot;%1.%2.%3.%4&quot;</span>).<span class="built_in">arg</span>((ip &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>).<span class="built_in">arg</span>((ip &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>).<span class="built_in">arg</span>((ip &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>).<span class="built_in">arg</span>(ip &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">quint32 <span class="title">QUIHelper::ipv4StringToInt</span><span class="params">(<span class="type">const</span> QString &amp;ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isIP</span>(ip)) &#123;</span><br><span class="line">        QStringList list = ip.<span class="built_in">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="type">int</span> ip0 = list.<span class="built_in">at</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="type">int</span> ip1 = list.<span class="built_in">at</span>(<span class="number">1</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="type">int</span> ip2 = list.<span class="built_in">at</span>(<span class="number">2</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="type">int</span> ip3 = list.<span class="built_in">at</span>(<span class="number">3</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        result = ip3 | ip2 &lt;&lt; <span class="number">8</span> | ip1 &lt;&lt; <span class="number">16</span> | ip0 &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致。</p></li>
<li><p>Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#禁用qdebug打印输出</span><br><span class="line">DEFINES += QT_NO_DEBUG_OUTPUT</span><br></pre></td></tr></table></figure></p></li>
<li><p>在使用 QT_NO_DEBUG_OUTPUT 关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实 QT_NO_DEBUG_OUTPUT 禁用的 qdebug 的输出，Qt还有其他几种打印信息比如 qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用 qInfo 来输出信息就好。特别注意：qFatal 打印完信息程序会自动结束。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;qDebug&quot;</span>;</span><br><span class="line"><span class="built_in">qInfo</span>() &lt;&lt; <span class="string">&quot;qInfo&quot;</span>;</span><br><span class="line"><span class="built_in">qWarning</span>() &lt;&lt; <span class="string">&quot;qWarning&quot;</span>;</span><br><span class="line"><span class="built_in">qCritical</span>() &lt;&lt; <span class="string">&quot;qCritical&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>(<span class="string">&quot;qDebug&quot;</span>);</span><br><span class="line"><span class="built_in">qWarning</span>(<span class="string">&quot;qWarning&quot;</span>);</span><br><span class="line"><span class="built_in">qCritical</span>(<span class="string">&quot;qCritical&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#禁用qdebug打印输出</span><br><span class="line">DEFINES     += QT_NO_DEBUG_OUTPUT</span><br><span class="line"></span><br><span class="line">#自定义define变量 可以在整个项目中使用</span><br><span class="line"><span class="meta">#pro文件可以这样判断 contains(DEFINES, videovlc) &#123;&#125;</span></span><br><span class="line">#代码文件可以这样判断 <span class="meta">#<span class="keyword">ifdef</span> videovlc</span></span><br><span class="line">DEFINES     += videovlc1 videoffmpeg</span><br><span class="line"></span><br><span class="line">#关闭编译警告提示 眼不见为净</span><br><span class="line">CONFIG      += warn_off</span><br><span class="line"></span><br><span class="line">#指定编译生成的文件到temp目录 分门别类存储</span><br><span class="line">MOC_DIR     = temp/moc</span><br><span class="line">RCC_DIR     = temp/rcc</span><br><span class="line">UI_DIR      = temp/ui</span><br><span class="line">OBJECTS_DIR = temp/obj</span><br><span class="line"></span><br><span class="line">#指定编译生成的可执行文件到bin目录</span><br><span class="line">DESTDIR     = bin</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主窗体头文件</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">nativeEvent</span><span class="params">(<span class="type">const</span> QByteArray &amp;eventType, <span class="type">void</span> *message, <span class="type">long</span> *result)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">winEvent</span><span class="params">(MSG *message, <span class="type">long</span> *result)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主窗体实现函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">frmMain::nativeEvent</span><span class="params">(<span class="type">const</span> QByteArray &amp;eventType, <span class="type">void</span> *message, <span class="type">long</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventType == <span class="string">&quot;windows_generic_MSG&quot;</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line">        MSG *msg = <span class="built_in">static_cast</span>&lt;MSG *&gt;(message);</span><br><span class="line">        <span class="comment">//qDebug() &lt;&lt; TIMEMS &lt;&lt; msg-&gt;message;</span></span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;wParam == PBT_APMSUSPEND &amp;&amp; msg-&gt;message == WM_POWERBROADCAST) &#123;</span><br><span class="line">            <span class="comment">//系统休眠的时候自动最小化可以规避程序可能出现的问题</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">showMinimized</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;wParam == PBT_APMRESUMEAUTOMATIC) &#123;</span><br><span class="line">            <span class="comment">//休眠唤醒后自动打开</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">showNormal</span>();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == <span class="string">&quot;NSEvent&quot;</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_MACOS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">frmMain::winEvent</span><span class="params">(MSG *message, <span class="type">long</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">nativeEvent</span>(<span class="string">&quot;windows_generic_MSG&quot;</span>, message, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt的pro项目管理配置文件中也可添加各种编译前后的操作及配置，主要通过 QMAKE_POST_LINK和QMAKE_PRE_LINK，他们支持的函数以及写法，可以在QtCreator的帮助中搜索 qmake Function Reference 查看详情说明。</p></li>
</ol>
<ul>
<li>QMAKE_PRE_LINK 表示编译前执行内容</li>
<li>QMAKE_POST_LINK 表示编译后执行内容 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">srcFile1 = $$PWD/<span class="number">1.</span>txt</span><br><span class="line">srcFile2 = $$PWD/<span class="number">2.</span>txt</span><br><span class="line">dstDir = $$PWD/../bin</span><br><span class="line"><span class="meta">#windows上需要转换路径斜杠 其他系统不需要</span></span><br><span class="line">srcFile1 = $$<span class="built_in">replace</span>(srcFile1, /, \\);</span><br><span class="line">srcFile2 = $$<span class="built_in">replace</span>(srcFile2, /, \\);</span><br><span class="line">dstDir = $$<span class="built_in">replace</span>(dstDir, /, \\);</span><br><span class="line"></span><br><span class="line">#编译前执行拷贝 多个拷贝可以通过 &amp;&amp; 符号隔开</span><br><span class="line">QMAKE_PRE_LINK += copy /Y $$srcFile1 $$dstDir &amp;&amp; copy /Y $$srcFile2 $$dstDir</span><br><span class="line">#编译后执行拷贝 多个拷贝可以通过 &amp;&amp; 符号隔开</span><br><span class="line">QMAKE_POST_LINK += copy /Y $$srcFile1 $$dstDir &amp;&amp; copy /Y $$srcFile2 $$dstDir</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="section-13">14：131-140</h3>
<ol start="131" type="1">
<li><p>Qt新版本往往会带来一些头文件的更新，比如以前使用QPainter绘制，不需要额外包含QPainterPath头文件，而5.15版本开始就需要显示主动引入#include "qpainterpath.h"才行。</p></li>
<li><p>Qt6.0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件 QT += core5compat 才能用， 具体说明在https://doc.qt.io/qt-6/qtcore5-index.html。</p></li>
<li><p>qDebug输出打印信息，默认会完整打印转义字符，例如：\ " " 等，所以当你发现你明明设置了转义字符以后打印确还是转义前的字符，这就懵逼了，其实这是qdebug为了方便调试将各种字符都打印输出。无可否认，很多时候，我们极其兴奋的享受着Qt带来的各种轮子各种便利，但是偶尔，稍不留意，这些便利可能也会坑你一把。要做的就是擦亮眼睛，时刻谨慎，一步一个脚印踏踏实实码代码。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString s1 = <span class="string">R&quot;(\:device0)&quot;</span>;</span><br><span class="line"><span class="comment">//TNND居然输出的是 \\:device0</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s1;</span><br><span class="line"><span class="comment">//这次终于正确的输出 \:device0</span></span><br><span class="line"><span class="built_in">qDebug</span>().<span class="built_in">noquote</span>() &lt;&lt; s1;</span><br></pre></td></tr></table></figure></p></li>
<li><p>很多人有疑问为何qss对浏览器控件中的网页样式没法控制，其实用屁股想想也知道，那玩意是html css去控制的，和Qt一毛钱关系也没有，根本管不着，如果想要对滚动条样式设置，可以在网页代码中设置样式就行。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;style type=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line">  ::-webkit-scrollbar&#123;width:<span class="number">0.8</span>em;&#125;</span><br><span class="line">  ::-webkit-scrollbar-track&#123;background:<span class="built_in">rgb</span>(<span class="number">241</span>,<span class="number">241</span>,<span class="number">241</span>);&#125;</span><br><span class="line">  ::-webkit-scrollbar-thumb&#123;background:<span class="built_in">rgb</span>(<span class="number">188</span>,<span class="number">188</span>,<span class="number">188</span>);&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置了编码以后配置文件内容为 Company=上海物联网技术研究中心</span></span><br><span class="line"><span class="comment">//没有设置编码则配置文件内容为 Company=\xe4\xb8\x8a\xe6\xb5\xb7\xe7\x89\xa9\xe8\x81\x94\xe7\xbd\x91\xe6\x8a\x80\xe6\x9c\xaf\xe7\xa0\x94\xe7\xa9\xb6\xe4\xb8\xad\xe5\xbf\x83</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">App::readConfig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QSettings <span class="title">set</span><span class="params">(App::ConfigFile, QSettings::IniFormat)</span></span>;</span><br><span class="line">    set.<span class="built_in">setIniCodec</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set.<span class="built_in">beginGroup</span>(<span class="string">&quot;AppConfig1&quot;</span>);</span><br><span class="line">    App::Company = set.<span class="built_in">value</span>(<span class="string">&quot;Company&quot;</span>, App::Company).<span class="built_in">toString</span>();</span><br><span class="line">    set.<span class="built_in">endGroup</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">App::writeConfig</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QSettings <span class="title">set</span><span class="params">(App::ConfigFile, QSettings::IniFormat)</span></span>;</span><br><span class="line">    set.<span class="built_in">setIniCodec</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set.<span class="built_in">beginGroup</span>(<span class="string">&quot;AppConfig1&quot;</span>);</span><br><span class="line">    set.<span class="built_in">setValue</span>(<span class="string">&quot;Company&quot;</span>, App::Company);</span><br><span class="line">    set.<span class="built_in">endGroup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>用Qt做安卓开发都会遇到权限的问题，早期的安卓版本可以直接通过 AndroidManifest.xml 配置文件来添加需要的权限，这样在安装app的时候就会提示该app需要哪些权限让用户同意，现在的安卓版本都改成了动态权限，需要在app运行的时候弹出提示让用户确认再有权限，Qt迎合了这种策略内置了动态申请权限的方法 QtAndroid::requestPermissionsSync。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态设置权限</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkPermission</span><span class="params">(<span class="type">const</span> QString &amp;permission)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_ANDROID</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5, 10, 0))</span></span><br><span class="line">    QtAndroid::PermissionResult result = QtAndroid::<span class="built_in">checkPermission</span>(permission);</span><br><span class="line">    <span class="keyword">if</span> (result == QtAndroid::PermissionResult::Denied) &#123;</span><br><span class="line">        QtAndroid::<span class="built_in">requestPermissionsSync</span>(<span class="built_in">QStringList</span>() &lt;&lt; permission);</span><br><span class="line">        result = QtAndroid::<span class="built_in">checkPermission</span>(permission);</span><br><span class="line">        <span class="keyword">if</span> (result == QtAndroid::PermissionResult::Denied) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//请求权限</span></span><br><span class="line">    <span class="built_in">checkPermission</span>(<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>);</span><br><span class="line">    <span class="built_in">checkPermission</span>(<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt重载qDebug输出自定义的信息。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FunctionInfo</span> &#123;</span><br><span class="line">    QString function;</span><br><span class="line">    QString name;</span><br><span class="line">    QString groupEnabled;</span><br><span class="line">    QString action;</span><br><span class="line">    QString group;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> QDebug <span class="keyword">operator</span> &lt;&lt; (QDebug debug, <span class="type">const</span> FunctionInfo &amp;functionInfo) &#123;</span><br><span class="line">        QString info = <span class="built_in">QString</span>(<span class="string">&quot;功能: %1  名称: %2  启用: %3  方法: %4  分组: %5&quot;</span>)</span><br><span class="line">                       .<span class="built_in">arg</span>(functionInfo.function).<span class="built_in">arg</span>(functionInfo.name).<span class="built_in">arg</span>(functionInfo.groupEnabled)</span><br><span class="line">                       .<span class="built_in">arg</span>(functionInfo.action).<span class="built_in">arg</span>(functionInfo.group);</span><br><span class="line">        debug &lt;&lt; info;</span><br><span class="line">        <span class="keyword">return</span> debug;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>对高分屏不同缩放比例的自适应处理方法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1：在main函数的最前面加上下面这句 5.6版本才开始有这个函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0))</span></span><br><span class="line">    QGuiApplication::<span class="built_in">setAttribute</span>(Qt::AA_EnableHighDpiScaling);</span><br><span class="line">    <span class="comment">//开启高缩放支持以后图片可能发虚还要开启下面这个属性</span></span><br><span class="line">    QCoreApplication::<span class="built_in">setAttribute</span>(Qt::AA_UseHighDpiPixmaps);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：在可执行文件同目录下新建文件 qt.conf 填入下面内容</span></span><br><span class="line">[Platforms]</span><br><span class="line">WindowsArguments = dpiawareness=<span class="number">0</span></span><br><span class="line"><span class="comment">//下面这行用来解决Qt高DPI下文字显示有锯齿的问题</span></span><br><span class="line">WindowsArguments = fontengine=freetype</span><br><span class="line"><span class="comment">//2023-2-2 经过建波（简称JB大佬）亲测两行分开写没有效果，需要逗号分开</span></span><br><span class="line">WindowsArguments = dpiawareness=<span class="number">0</span>, fontengine=freetype</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法3：在main函数最前面设置Qt内部的环境变量</span></span><br><span class="line"><span class="built_in">qputenv</span>(<span class="string">&quot;QT_AUTO_SCREEN_SCALE_FACTOR&quot;</span>, <span class="string">&quot;1.5&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法4：新版本的Qt比如Qt5.14修正了对高分屏的处理支持不是整数的缩放</span></span><br><span class="line"><span class="built_in">qputenv</span>(<span class="string">&quot;QT_ENABLE_HIGHDPI_SCALING&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">QGuiApplication::<span class="built_in">setHighDpiScaleFactorRoundingPolicy</span>(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);</span><br><span class="line"></span><br><span class="line"><span class="comment">//禁用缩放</span></span><br><span class="line"><span class="comment">//测试发现AA_Use96Dpi属性在Qt5.9以上版本完全正常，以下版本比如5.7有部分控件在175%缩放不正常比如QTextEdit，需要外层套个widget才行。</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    QApplication::<span class="built_in">setAttribute</span>(Qt::AA_Use96Dpi);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,14,0))</span></span><br><span class="line">    QGuiApplication::<span class="built_in">setHighDpiScaleFactorRoundingPolicy</span>(Qt::HighDpiScaleFactorRoundingPolicy::Floor);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Qt6中AA_Use96Dpi没效果必须下面方式设置强制指定缩放DPI</span></span><br><span class="line"><span class="built_in">qputenv</span>(<span class="string">&quot;QT_FONT_DPI&quot;</span>, <span class="string">&quot;96&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对tabWidget设置无切换按钮</span></span><br><span class="line">ui-&gt;tabWidget-&gt;<span class="built_in">setUsesScrollButtons</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//对tabBar设置无切换按钮</span></span><br><span class="line">ui-&gt;tabWidget-&gt;<span class="built_in">tabBar</span>()-&gt;<span class="built_in">setUsesScrollButtons</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//对整个系统的选项卡设置无切换按钮</span></span><br><span class="line">QTabBar&#123;qproperty-usesScrollButtons:<span class="literal">false</span>;&#125;</span><br><span class="line"><span class="comment">//设置选项卡自动拉伸 这玩意居然之前自动计算来设置原来内置了哇咔咔</span></span><br><span class="line">QTabBar&#123;qproperty-expanding:<span class="literal">false</span>;&#125;</span><br><span class="line"><span class="comment">//设置选项卡关闭按钮可见</span></span><br><span class="line">QTabBar&#123;qproperty-tabsClosable:<span class="literal">true</span>;&#125;</span><br><span class="line"><span class="comment">//还有其他属性参见QTabBar头文件有惊喜</span></span><br><span class="line"><span class="comment">//依旧是万能大法所有可视化类的 Q_PROPERTY 包含的属性都可以这样设置</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>QMainWindow的分割线默认尺寸比较大，有时候想设置小一点或者不想要，最开始的时候以为是QSplitter，打印所有子元素找遍了也没找到影子，最后发现样式表中有对应设置的内容。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真的是做梦也没想到要这样设置</span></span><br><span class="line">QMainWindow::separator&#123;width:<span class="number">1</span>px;height:<span class="number">1</span>px;margin:<span class="number">1</span>px;padding:<span class="number">1</span>px;background:#FF0000;&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="section-14">15：141-150</h3>
<ol start="141" type="1">
<li><p>QImage支持xpm图标，查看Qt内置的QStyle风格的代码中可以发现大量的xpm图标定义，通过代码的形式来产生图标，哇咔咔好牛逼。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> imgData[] = &#123;</span><br><span class="line">    <span class="string">&quot;15 11 6 1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;   c None&quot;</span>,</span><br><span class="line">    <span class="string">&quot;+  c #979797&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@  c #C9C9C9&quot;</span>,</span><br><span class="line">    <span class="string">&quot;$  c #C1C1C1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;b  c None&quot;</span>,</span><br><span class="line">    <span class="string">&quot;d  c None&quot;</span>,</span><br><span class="line">    <span class="string">&quot; $++++++++$    &quot;</span>,</span><br><span class="line">    <span class="string">&quot;$+bbbbbbbb+$   &quot;</span>,</span><br><span class="line">    <span class="string">&quot;+b $$      +$  &quot;</span>,</span><br><span class="line">    <span class="string">&quot;+b $@       +$ &quot;</span>,</span><br><span class="line">    <span class="string">&quot;+b           +$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;+b           d+&quot;</span>,</span><br><span class="line">    <span class="string">&quot;+b          d+$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;+b $$      d+$ &quot;</span>,</span><br><span class="line">    <span class="string">&quot;+b $@     d+$  &quot;</span>,</span><br><span class="line">    <span class="string">&quot;$+dddddddd+$   &quot;</span>,</span><br><span class="line">    <span class="string">&quot; $++++++++$    &quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样就能直接显示一个箭头的图形</span></span><br><span class="line"><span class="function">QImage <span class="title">img</span><span class="params">(imgData)</span></span>;</span><br><span class="line">QLabel lab;</span><br><span class="line">lab.<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(img));</span><br><span class="line">lab.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure></p></li>
<li><p>在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//需要设置共享上下文不然停靠窗体从正常到浮动后QOpenGLWidget窗体会失效</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))</span></span><br><span class="line">    QCoreApplication::<span class="built_in">setAttribute</span>(Qt::AA_ShareOpenGLContexts);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99%以上的Qt版本的乱码问题。</p></li>
</ol>
<ul>
<li>第一步：代码文件选择用utf8编码带bom。</li>
<li>第二步：在有中文汉字的代码文件顶部加一行（一般是cpp文件） #pragma execution_character_set("utf-8") 可以考虑放在head.h中，然后需要的地方就引入head头文件就行，而不是这行代码写的到处都是；这行代码是为了告诉msvc编译器当前代码文件用utf8去编译。</li>
<li>第三步：main函数中加入设置编码的代码，以便兼容Qt4，如果没有Qt4的场景可以不用，从Qt5开始默认就是utf8编码。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QUIHelper::setCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &lt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _MSC_VER</span></span><br><span class="line">    QTextCodec *codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    QTextCodec *codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    QTextCodec::<span class="built_in">setCodecForLocale</span>(codec);</span><br><span class="line">    QTextCodec::<span class="built_in">setCodecForCStrings</span>(codec);</span><br><span class="line">    QTextCodec::<span class="built_in">setCodecForTr</span>(codec);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    QTextCodec *codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    QTextCodec::<span class="built_in">setCodecForLocale</span>(codec);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="144" type="1">
<li>关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论。</li>
</ol>
<ul>
<li>Qt在二进制兼容这块，已经做了最大的努力，通过将各种代码细节隐藏，Q指针+D指针技巧，尽量保持了接口的统一；</li>
<li>是否兼容最主要考虑编译器的因素，毕竟任何Qt版本都是需要通过编译器编译成对应的二进制文件，由他说了算。如果两个Qt版本采用的编译器版本一样，极大概率可执行文件是兼容的，比如 Qt5.10+msvc2015 32 位 和 Qt5.11+msvc2015 32位 编译出来的可执行文件，都用Qt5.11的库是可行的；</li>
<li>mingw编译器的Qt版本也是如此，就是因为Qt官方安装包集成的mingw编译器一直在更新（极少附近版本没有更新mingw编译器版本除外），比如5.7用的mingw53，5.12用的mingw73，5.15用的mingw81，因为带的Qt库也是这个编译器编译出来的，所以导致看起来全部不兼容；</li>
<li>如果想要完全兼容，还有一个注意要素，那就是对应代码使用的类的头文件接口是否变了，按道理原有的接口极少会变，一般都是新增加，或者大版本才会改变，比如Qt4-Qt5-Qt6这种肯定没法兼容的，接口和模块都变了；</li>
<li>大胆的猜测：如果Qt5.6到Qt5.15你全部用一种编译器比如mingw73或者msvc2015重新编译生成对应的Qt运行库，然后在此基础上开发程序，最后生成的可执行文件用Qt5.15的库是都可以的，这样就轻松跨越了多个版本兼容；</li>
<li>大胆的建议：在附近的几个版本统一编译器，比如5.6-5.12之间就统一用mingw53或者msvc2015,5.12-5.15统一用msvc2017，要尝鲜其他编译器的可以自行源码编译其他版本，这样最起码附近的一大段版本（大概2-3年的版本周期）默认就兼容了。</li>
<li>本人测试的是widget部分，qml未做测试，不清楚是否机制一样；</li>
</ul>
<ol start="145" type="1">
<li><p>通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4.7到5.15任意版本，通过查看对应函数的源码可以看到内部会检查是否是 'file:///' 开头，是的话则自动读取样式表文件进行设置，无需手动读取。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前都是下面的方法</span></span><br><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;:/qss/psblack.css&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file.<span class="built_in">open</span>(QFile::ReadOnly)) &#123;</span><br><span class="line">    QString qss = <span class="built_in">QLatin1String</span>(file.<span class="built_in">readAll</span>());</span><br><span class="line">    qApp-&gt;<span class="built_in">setStyleSheet</span>(qss);</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实一行代码就行</span></span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;file:///:/qss/psblack.css&quot;</span>);</span><br><span class="line"><span class="comment">//特别说明，只支持qApp-&gt;setStyleSheet 不支持其他比如widget-&gt;setStyleSheet</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板 QCalendarWidget 就是 QToolButton+QSpinBox+QTableView 等组成，妙用 findChildren 可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印子类类名集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printObjectChild</span><span class="params">(<span class="type">const</span> QObject *obj, <span class="type">int</span> spaceCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;%1%2 : %3&quot;</span>)</span><br><span class="line">             .<span class="built_in">arg</span>(<span class="string">&quot;&quot;</span>, spaceCount)</span><br><span class="line">             .<span class="built_in">arg</span>(obj-&gt;<span class="built_in">metaObject</span>()-&gt;<span class="built_in">className</span>())</span><br><span class="line">             .<span class="built_in">arg</span>(obj-&gt;<span class="built_in">objectName</span>());</span><br><span class="line"></span><br><span class="line">    QObjectList childs = obj-&gt;<span class="built_in">children</span>();</span><br><span class="line">    foreach (QObject *child, childs) &#123;</span><br><span class="line">        <span class="built_in">printObjectChild</span>(child, spaceCount + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拿到对话框进行设置和美化</span></span><br><span class="line">QFileDialog *fileDialog = <span class="keyword">new</span> <span class="built_in">QFileDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">fileDialog-&gt;<span class="built_in">setOption</span>(QFileDialog::DontUseNativeDialog, <span class="literal">true</span>);</span><br><span class="line">QLabel *lookinLabel = fileDialog-&gt;<span class="built_in">findChild</span>&lt;QLabel*&gt;(<span class="string">&quot;lookInLabel&quot;</span>);</span><br><span class="line">lookinLabel-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">fromLocal8Bit</span>(<span class="string">&quot;文件目录：&quot;</span>));</span><br><span class="line">lookinLabel-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;color:red;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置日期框默认值为空</span></span><br><span class="line">QLineEdit *edit = ui-&gt;dateEdit-&gt;<span class="built_in">findChild</span>&lt;QLineEdit *&gt;(<span class="string">&quot;qt_spinbox_lineedit&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!edit-&gt;<span class="built_in">text</span>().<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">    edit-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt内置了各种对话框，比如文件对话框-QFileDialog ，颜色对话框-QColorDialog ，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QFileDialog *fileDialog = <span class="keyword">new</span> <span class="built_in">QFileDialog</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//不设置此属性根本查找不到任何子元素,因为默认采用的系统对话框</span></span><br><span class="line">fileDialog-&gt;<span class="built_in">setOption</span>(QFileDialog::DontUseNativeDialog, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; fileDialog-&gt;<span class="built_in">findChildren</span>&lt;QLabel *&gt;();</span><br><span class="line"><span class="comment">//打印输出 QLabel(0x17e2ff68, name=&quot;lookInLabel&quot;), QLabel(0x17e35f88, name=&quot;fileNameLabel&quot;), QLabel(0x17e35e68, name=&quot;fileTypeLabel&quot;)</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>QtCreator集成开发环境，也内置了对快速添加注释的支持，比如最常用的在头文件开头添加一大段通用模板的注释，标注文件创建者、时间等信息。</p></li>
</ol>
<ul>
<li>菜单-&gt;工具-&gt;选项-&gt;文本编辑器-&gt;右侧tab页面片段(snippets)；</li>
<li>组选择C++, 可以看到这里面已经内置了不少定义比如foreach，可以依葫芦画瓢；</li>
<li>添加一个片段, 比如名字是fun, 触发种类是这个片段的简单描述；</li>
<li>当我们在代码文件中键入fun时, 会自动弹出智能提醒, 选择我们的代码片段回车, 自动填充代码；</li>
<li>按tab可以在变量间切换, 输入完成后回车, 完成编辑； <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief $name$</span></span><br><span class="line"><span class="comment">  * @param $param$</span></span><br><span class="line"><span class="comment">  * @author feiyangqingyun</span></span><br><span class="line"><span class="comment">  * @date $date$</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">$ret$ $name$($param$)</span><br><span class="line">&#123;</span><br><span class="line">    $$</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="149" type="1">
<li>Qt5时代对信号槽运行机制据说有了很大的改进。</li>
</ol>
<ul>
<li>在Qt5之前，connect一般都只能这么写connect(sender, SIGNAL(signalFunc()), receiver, SLOT(receiveFunc()))，就是说在connect的时候，必须把信号用宏SIGNAL包裹起来，把槽函数用宏SLOT包裹起来，这样才能被Qt的Moc机制识别；</li>
<li>在编译的时候即使信号或槽不存在或者参数不正确也不会报错，但是在执行的时候无效，会打印提示，对于C++这种静态语言来说，这是不友好的，不利于调试；</li>
<li>但是Qt5之后更加推荐"取地址的写法"，采用这种写法，如果编译的时候信号或槽不存在是无法编译通过的，相当于编译时检查，不容易出错；</li>
<li>如果没有历史遗留问题需要兼容Qt4的话，还是推荐用新写法，有类型检查更严格，而且支持的写法多样非常灵活；</li>
<li>一些简单的处理逻辑强烈推荐直接lambda表达式直接处理完； <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="built_in">MainWindow</span>(QWidget *parent = <span class="number">0</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_fun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test_slot</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//早期写法,通用Qt所有版本,只支持定义了slots关键字的函数</span></span><br><span class="line">    <span class="comment">//connect(ui-&gt;pushButton, SIGNAL(clicked()), this, SLOT(test_fun()));</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">test_slot</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新写法,支持Qt5及后期所有版本,支持所有函数,无需定义slots关键字也行</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::test_fun);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::test_slot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另类写法,支持lambda表达式,直接执行代码</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, [<span class="keyword">this</span>] &#123;<span class="built_in">test_fun</span>();&#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, [<span class="keyword">this</span>] &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;hello lambda&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lambda带参数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, [&amp;] (<span class="type">bool</span> isCheck) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;hello lambda&quot;</span> &lt;&lt; isCheck;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头文件 signals:void sig_test(int i);</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MainWindow::sig_test, [] (<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;hello lambda&quot;</span> &lt;&lt; i;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function">emit <span class="title">sig_test</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::test_fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;test_fun&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::test_slot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;test_slot&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="150" type="1">
<li>Qt样式表有多种运行机制，主要是考虑到各种需求场景，继承自QWidget的类和qApp类都支持setStyleSheet方法，还可以统一将样式表放在文件，或者将样式文件加入到资源文件。</li>
</ol>
<ul>
<li>斗气：qss内容写得到处都是，哪里需要就写在哪里，各种控件调用 setStyleSheet方法传入样式表内容，或者直接对应控件鼠标右键弹出菜单选择改变样式表填入内容；</li>
<li>斗者：qss内容放在文件，读取文件内容设置样式表，程序发布的时候带上qss文件；</li>
<li>斗师：qss文件作为资源文件放到qrc文件，直接编译到可执行文件中，防止篡改；</li>
<li>斗灵：在qss文件中自定义一些标志充当变量使用，读取以后替换对应的变量为颜色值，类似动态换肤；</li>
<li>斗王：放在文件容易被篡改，集成到可执行文件不够灵活，一旦样式表更新需要重新编译文件，如何做到既能只更新样式表文件，又不需要重新编译可执行文件，又能防止被篡改：采用rcc命令将资源文件编译生成二进制，只需要替换该二进制文件即可；</li>
<li>斗皇：继承qstyle类自己实现完成所有样式接口，统一整体风格，大名鼎鼎的UOS系统默认规则就是如此，不允许用样式表，全部painter绘制；</li>
</ul>
<h3 id="section-15">16：151-160</h3>
<ol start="151" type="1">
<li><p>当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Qt中使用二进制资源文件方法如下</span></span><br><span class="line"><span class="comment">//将qrc编译为二进制文件rcc，在控制台执行下列命令 </span></span><br><span class="line">rcc -binary main.qrc -o main.rcc</span><br><span class="line"><span class="comment">//在应用程序中注册资源，一般在main函数启动后就注册</span></span><br><span class="line">QResource::<span class="built_in">registerResource</span>(qApp-&gt;<span class="built_in">applicationDirPath</span>() + <span class="string">&quot;/main.rcc&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设窗体中有子控件，默认字体12px，父类类型是QWidget，父类类名是Widget</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面几种方法只会设置主窗体的字体，子控件不会应用，需要按个调用setFont</span></span><br><span class="line">QFont font;</span><br><span class="line">font.<span class="built_in">setPixelSize</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;&#123;font:26px;&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QWidget&#123;font:26px;&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;Widget&#123;font:26px;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面才是通过样式表设置整个控件+子控件的字体</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;font:26px;&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;*&#123;font:26px;&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QWidget&gt;*&#123;font:26px;&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;Widget&gt;*&#123;font:26px;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面设置全局字体</span></span><br><span class="line">qApp-&gt;<span class="built_in">setFont</span>(font);</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format_ARGB32或者Format_RGBA8888。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pixel      函数获取像素点的颜色 setPixel      函数设置像素点的颜色 此函数任意Qt版本都有</span></span><br><span class="line"><span class="comment">//pixelColor 函数获取像素点的颜色 setPixelColor 函数设置像素点的颜色 此函数Qt5.6以后才有</span></span><br><span class="line"><span class="comment">//pixel函数取出来的是QRgb格式需要用 qRed qGreen qBlue qAlpha 进行转换</span></span><br><span class="line"><span class="function">QImage <span class="title">image</span><span class="params">(<span class="string">&quot;1.png&quot;</span>)</span></span>;</span><br><span class="line">image = image.<span class="built_in">convertToFormat</span>(QImage::Format_ARGB32);</span><br><span class="line"><span class="type">int</span> width = image.<span class="built_in">width</span>();</span><br><span class="line"><span class="type">int</span> height = image.<span class="built_in">height</span>();</span><br><span class="line"><span class="comment">//遍历图像的每一个像素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; width; ++x) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; height; ++y) &#123;</span><br><span class="line">        QString name = image.<span class="built_in">pixelColor</span>(x, y).<span class="built_in">name</span>();</span><br><span class="line">        <span class="comment">//将白色以外的颜色全部替换成红色</span></span><br><span class="line">        <span class="keyword">if</span> (name != <span class="string">&quot;#ffffff&quot;</span>) &#123;</span><br><span class="line">            image.<span class="built_in">setPixelColor</span>(x, y, Qt::red);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存文件</span></span><br><span class="line">image.<span class="built_in">save</span>(<span class="string">&quot;2.png&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论。</p></li>
</ol>
<ul>
<li>Qt天生内置了sqlite数据库，只需要发布的时候带上插件就行（可以看到插件动态库文件比其他几种都要大，那是因为直接将数据库的源码都编译进去了，而其他只编译了中间通信交互的插件源码），其他数据库要么还要带上动态库，要么还需要创建数据源；</li>
<li>速度上，绝对无与伦比的出类拔萃，同样的数据库结构（表结构、索引等完全一致），查询速度和批量更新速度、数据库事务等，速度都是其他几种的至少3倍以上，而且随着数据量的增大对比越发明显；</li>
<li>几千万的数据量完全没问题，而且速度和性能都还可以，不要以讹传讹网上部分菜鸡说的不支持百万以上的数据量，本人亲测亿级别，数据量建议千万级别以下，着重注意数据库表和索引的设计；</li>
<li>其他数据库还要注意版本的区别，ODBC数据源形式还容易出错和执行失败；</li>
<li>sqlite数据库也有几个重大缺点：不支持加密，不支持网络访问，不支持部分数据库高级特性，不支持海量数据（亿级别以上），但是对于绝大部分Qt项目还是足够；</li>
<li>数据库支持友好度大致是 sqlite &gt; postgresql &gt; mysql &gt; odbc ;</li>
<li>如果采用的odbc数据源模式连接数据库，只需要设置数据库名称为对应新建的数据源名字，然后设置用户名和密码就行，不需要设置主机名称和端口，因为数据源那边已经设置过的，这里只需要再次验证用户信息就行。</li>
<li>ODBC数据源分32/64位之分，在数据源管理器中，如果添加的数据源对应平台显示的只有32或者只有64位，那你的Qt程序也只能是对应位数的才能连接成功。如果显示的是64位，你用32位的程序去连接会失败。</li>
<li>32位的Qt程序，带对应32位的libmysql动态库，可以访问32/64位的mysql数据库，64位的也是一样可以访问32/64位的mysql数据库，只需要带上对应位数的动态库就行。查看mysql是32位还是64位命令 mysql.exe -V。</li>
<li>在mysql驱动可用且正常的情况下，如果还是提示Driver not loaded Driver not loaded，则很可能是拷贝的libmysql动态库版本不对或者位数不对导致的。</li>
<li>以上都是在Qt环境中个人测试得出的结论，结果未必正确，作为参考即可，其他编程环境比如C#、JAVA请忽略，也许差别可能在中间通信的效率造成的；</li>
</ul>
<ol start="155" type="1">
<li><p>Qt5.10以后提供了新的类 QRandomGenerator QRandomGenerator64 管理随机数，使用更方便，尤其是取某个区间的随机数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//早期处理办法 先初始化随机数种子然后取随机数</span></span><br><span class="line"><span class="built_in">qsrand</span>(QTime::<span class="built_in">currentTime</span>().<span class="built_in">msec</span>());</span><br><span class="line"><span class="comment">//取 0-10 之间的随机数</span></span><br><span class="line"><span class="built_in">qrand</span>() % <span class="number">10</span>;</span><br><span class="line"><span class="comment">//取 0-1 之间的浮点数</span></span><br><span class="line"><span class="built_in">qrand</span>() / <span class="built_in">double</span>(RAND_MAX);</span><br><span class="line"></span><br><span class="line"><span class="comment">//新版处理办法 支持5.10以后的所有版本包括qt6</span></span><br><span class="line">QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">10</span>);      <span class="comment">//生成一个0和10之间的整数</span></span><br><span class="line">QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">10.123</span>);  <span class="comment">//生成一个0和10.123之间的浮点数</span></span><br><span class="line">QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">10</span>, <span class="number">15</span>);  <span class="comment">//生成一个10和15之间的整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//兼容qt4-qt6及以后所有版本的方法 就是用标准c++的随机数函数</span></span><br><span class="line"><span class="built_in">srand</span>(QTime::<span class="built_in">currentTime</span>().<span class="built_in">msec</span>());</span><br><span class="line"><span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line"><span class="built_in">rand</span>() / <span class="built_in">double</span>(RAND_MAX);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用公式 a是起始值,n是整数的范围</span></span><br><span class="line"><span class="type">int</span> value = a + <span class="built_in">rand</span>() % n;</span><br><span class="line"><span class="comment">//(min, max)的随机数</span></span><br><span class="line"><span class="type">int</span> value = min + <span class="number">1</span> + (<span class="built_in">rand</span>() % (max - min - <span class="number">1</span>));</span><br><span class="line"><span class="comment">//(min, max]的随机数</span></span><br><span class="line"><span class="type">int</span> value = min + <span class="number">1</span> + (<span class="built_in">rand</span>() % (max - min + <span class="number">0</span>));</span><br><span class="line"><span class="comment">//[min, max)的随机数</span></span><br><span class="line"><span class="type">int</span> value = min + <span class="number">0</span> + (<span class="built_in">rand</span>() % (max - min + <span class="number">0</span>));</span><br><span class="line"><span class="comment">//[min, max]的随机数</span></span><br><span class="line"><span class="type">int</span> value = min + <span class="number">0</span> + (<span class="built_in">rand</span>() % (max - min + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在线程中取随机数，线程启动的时间几乎一样，很可能出现取到的随机数一样的问题，就算设置随机数为当前时间啥的也没用，电脑太快很可能还是一样的时间，同一个毫秒。</span></span><br><span class="line"><span class="comment">//取巧办法就是在run函数之前最前面将当前线程的id作为种子设置。时间不可靠，线程的id才是唯一的。</span></span><br><span class="line"><span class="comment">//切记 void * 转换到数值必须用 long long，在32位是可以int但是在64位必须long，确保万一直接用quint64最大</span></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">long</span> <span class="type">long</span>)<span class="built_in">currentThreadId</span>());</span><br><span class="line"><span class="built_in">qrand</span>((<span class="type">long</span> <span class="type">long</span>)<span class="built_in">currentThreadId</span>());</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">frmMain::on_btnMenu_Max_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大化以后有个BUG,悬停样式没有取消掉,需要主动模拟鼠标动一下    </span></span><br><span class="line">    <span class="function">QEvent <span class="title">event</span><span class="params">(QEvent::Leave)</span></span>;</span><br><span class="line">    QApplication::<span class="built_in">sendEvent</span>(ui-&gt;btnMenu_Max, &amp;event);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>项目中启用c++11语法支持。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">4</span>): CONFIG += c++<span class="number">11</span></span><br><span class="line"><span class="built_in">lessThan</span>(QT_MAJOR_VERSION, <span class="number">5</span>): QMAKE_CXXFLAGS += -std=c++<span class="number">11</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ui-&gt;textEdit-&gt;<span class="built_in">setUndoRedoEnabled</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>其他几点常规小经验，本人在这几个地方摔跤过很多次。</p></li>
</ol>
<ul>
<li>有返回值的函数，一定要主动return返回值，有部分编译器在没有返回值的情况下也能正常编译通过，但是运行的时候会出问题，得不到想要的结果，因为没有return对应的值。</li>
<li>定义的局部变量，主动给定个初始值，是个必须养成的好习惯，不然编译器给的初始值很可能不是你想要的，比如int变量默认0，有时候随机变成一个很大的数值，bool变量的初始值不同编译器不同值，有些是true有些是false，主动给一个初始值更可靠。</li>
<li>某些函数参数很多，而且后期可能还会修改和增加，这就导致了源头修改以后，关联信号槽的地方也要修改，参数类型和位置必须保持完全一致，对应槽函数处理也要修改等，改动的工作量非常大而且极不友好，所以对于非固定参数的函数，建议用结构体，这样非常容易增加其他的参数，而且不用修改信号槽关联和信号槽函数定义等，比如学生信息表、商品信息表作为参数传输，最佳方案就是结构体。</li>
</ul>
<ol start="160" type="1">
<li>QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充， <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1：字符串空格填充</span></span><br><span class="line">ui-&gt;tabWidget-&gt;<span class="built_in">addTab</span>(httpClient1, <span class="string">&quot;测    试&quot;</span>);</span><br><span class="line">ui-&gt;tabWidget-&gt;<span class="built_in">addTab</span>(httpClient1, <span class="string">&quot;人员管理&quot;</span>);</span><br><span class="line">ui-&gt;tabWidget-&gt;<span class="built_in">addTab</span>(httpClient1, <span class="string">&quot;系统设置&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：识别尺寸改变事件自动设置最小宽度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::resizeEvent</span><span class="params">(QResizeEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = ui-&gt;tabWidget-&gt;<span class="built_in">tabBar</span>()-&gt;<span class="built_in">count</span>();</span><br><span class="line">    <span class="type">int</span> width = <span class="keyword">this</span>-&gt;<span class="built_in">width</span>() - <span class="number">30</span>;</span><br><span class="line">    QString qss = <span class="built_in">QString</span>(<span class="string">&quot;QTabBar::tab&#123;min-width:%1px;&#125;&quot;</span>).<span class="built_in">arg</span>(width / count);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(qss);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法3：设置全局样式，不同选项卡个数的设置不同的宽度</span></span><br><span class="line">QStringList list;</span><br><span class="line">list &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;QTabWidget[tabCount=\&quot;2\&quot;]&gt;QTabBar::tab&#123;min-width:%1px;&#125;&quot;</span>).<span class="built_in">arg</span>(<span class="number">100</span>);</span><br><span class="line">list &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;QTabWidget[tabCount=\&quot;3\&quot;]&gt;QTabBar::tab&#123;min-width:%1px;&#125;&quot;</span>).<span class="built_in">arg</span>(<span class="number">70</span>);</span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(list.<span class="built_in">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">//设置了tabCount弱属性自动去找对应的宽度设置</span></span><br><span class="line">ui-&gt;tabWidget-&gt;<span class="built_in">setProperty</span>(<span class="string">&quot;tabCount&quot;</span>, <span class="number">2</span>);</span><br><span class="line">ui-&gt;tabWidget-&gt;<span class="built_in">setProperty</span>(<span class="string">&quot;tabCount&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法4：强烈推荐-》使用内置的方法 setExpanding setDocumentMode 两个属性都必须设置</span></span><br><span class="line"><span class="comment">//Qt4的tabBar()是propected的，所以建议还是通过样式表设置</span></span><br><span class="line">ui-&gt;tabWidget-&gt;<span class="built_in">tabBar</span>()-&gt;<span class="built_in">setDocumentMode</span>(<span class="literal">true</span>);</span><br><span class="line">ui-&gt;tabWidget-&gt;<span class="built_in">tabBar</span>()-&gt;<span class="built_in">setExpanding</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//样式表一步到位不用每个都单独设置</span></span><br><span class="line"><span class="built_in">QString</span>(<span class="string">&quot;QTabBar&#123;qproperty-usesScrollButtons:false;qproperty-documentMode:true;qproperty-expanding:true;&#125;&quot;</span>);</span><br><span class="line"><span class="comment">//在5.9以前开启这个设置后，貌似选项卡个数按照真实个数+1计算宽度，也就是永远会留空一个tab的占位。</span></span><br><span class="line"><span class="comment">//5.9以后貌似修复了这个BUG，按照理想中的拉伸填充等分设置tab的宽度。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="section-16">17：161-170</h3>
<ol start="161" type="1">
<li><p>经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条。</p></li>
<li><p>Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5.9以前需要拿到原有的窗体属性做运算，后面可以用新的方法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加一个无边框属性</span></span><br><span class="line"><span class="built_in">setWindowFlags</span>(<span class="built_in">windowFlags</span>() | Qt::FramelessWindowHint);</span><br><span class="line"><span class="comment">//移除无边框属性</span></span><br><span class="line"><span class="built_in">setWindowFlags</span>(<span class="built_in">windowFlags</span>() &amp; ~Qt::FramelessWindowHint);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是5.9以后新增的方法</span></span><br><span class="line"><span class="comment">//增加一个无边框属性到窗体属性链表</span></span><br><span class="line"><span class="built_in">setWindowFlag</span>(Qt::FramelessWindowHint, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//从窗体属性链表中移除无边框属性</span></span><br><span class="line"><span class="built_in">setWindowFlag</span>(Qt::FramelessWindowHint, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setMinimumSize</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setMaximumSize</span>(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-&gt;mouseButtons()，全局的鼠标坐标可以用QCursor::pos()。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在鼠标右键的地方弹出菜单，如果菜单是QMenu而不是QAction则只能通过下面的方式弹出</span></span><br><span class="line"><span class="keyword">if</span> (qApp-&gt;<span class="built_in">mouseButtons</span>() == Qt::RightButton) &#123;</span><br><span class="line">    videoMenu-&gt;<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局剪切板</span></span><br><span class="line">qApp-&gt;<span class="built_in">clipboard</span>();</span><br><span class="line"><span class="comment">//顶层控件对象集合</span></span><br><span class="line">qApp-&gt;<span class="built_in">topLevelWidgets</span>()</span><br><span class="line"><span class="comment">//当前焦点所在控件</span></span><br><span class="line">qApp-&gt;<span class="built_in">focusWidget</span>()</span><br><span class="line"><span class="comment">//当前平台名称</span></span><br><span class="line">qApp-&gt;<span class="built_in">platformName</span>()</span><br><span class="line"><span class="comment">//调用系统蜂鸣器</span></span><br><span class="line">qApp-&gt;<span class="built_in">beep</span>()</span><br><span class="line"><span class="comment">//打印当前Qt版本信息</span></span><br><span class="line">qApp-&gt;<span class="built_in">aboutQt</span>()</span><br><span class="line"><span class="comment">//设置全局的鼠标样式</span></span><br><span class="line">qApp-&gt;<span class="built_in">setOverrideCursor</span>()</span><br><span class="line"><span class="comment">//不使用系统的标准颜色字体等</span></span><br><span class="line">QGuiApplication::<span class="built_in">setDesktopSettingsAware</span>(<span class="type">bool</span> on);</span><br><span class="line"><span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更多的全局对象属性等可以查阅 qguiapplication.h 头文件，你会发现新大陆。</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt对区分不同的编译器也做了非常细致的处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pro文件可以这样判断</span></span><br><span class="line">msvc &#123;</span><br><span class="line"><span class="comment">//要做的处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mingw &#123;</span><br><span class="line"><span class="comment">//要做的处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码中可以这样判断</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_CC_MINGW</span></span><br><span class="line"><span class="comment">//mingw编译器</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> Q_CC_MSVC</span></span><br><span class="line"><span class="comment">//msvc编译器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断编译器和编译器版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined Q_CC_MSVC &amp;&amp; _MSC_VER &lt; 1300</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(Q_CC_GNU) &amp;&amp; (__GNUC__ &lt; 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码中判断ARM平台</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> QT_ARCH_ARM</span></span><br><span class="line"><span class="comment">//多个条件判断</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE)</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用 blockSignals 方法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1：先 disconnect 掉信号，处理好以后再 connect 信号，缺点很明显，很傻，如果信号很多，每个型号都要这么来一次。</span></span><br><span class="line"><span class="built_in">disconnect</span>(ui-&gt;cbox, <span class="built_in">SIGNAL</span>(<span class="built_in">currentIndexChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">on_cbox_currentIndexChanged</span>(<span class="type">int</span>)));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    ui-&gt;cbox-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;cbox, <span class="built_in">SIGNAL</span>(<span class="built_in">currentIndexChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">on_cbox_currentIndexChanged</span>(<span class="type">int</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：先调用 blockSignals(true) 阻塞信号，处理号以后再调用 blockSignals(false) 恢复所有信号。</span></span><br><span class="line"><span class="comment">//如果需要指定某个信号进行断开那就只能用 disconnect 来处理。</span></span><br><span class="line">ui-&gt;cbox-&gt;<span class="built_in">blockSignals</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    ui-&gt;cbox-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(i));</span><br><span class="line">&#125;</span><br><span class="line">ui-&gt;cbox-&gt;<span class="built_in">blockSignals</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1：pro文件直接全部引入，而不是每个都添加一次，省心省力。</span></span><br><span class="line">HEADERS += *.h</span><br><span class="line">SOURCES += *.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：分模块文件夹存放，不同模块用pri包含代码文件，比如界面可以放在ui文件夹，下面搞个ui.pri，然后pro项目文件只需要引入这个pri文件即可。</span></span><br><span class="line"><span class="built_in">include</span>($$PWD/ui/ui.pri)</span><br><span class="line"><span class="comment">//还可以加上一句包含路径这样可以省去在使用代码的时候不用写文件夹</span></span><br><span class="line">INCLUDEPATH += $$PWD/ui</span><br><span class="line"><span class="comment">//加上上面这行，在使用头文件的时候可以直接 include &quot;form.h&quot;，没有加则需要 include &quot;ui/form.h&quot;。</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农民工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tcp客户端</span></span><br><span class="line">QTcpSocket *socket = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//断开所有连接和操作</span></span><br><span class="line">socket-&gt;<span class="built_in">abort</span>();</span><br><span class="line"><span class="comment">//绑定网卡和端口</span></span><br><span class="line">socket-&gt;<span class="built_in">bind</span>(<span class="built_in">QHostAddress</span>(<span class="string">&quot;192.168.1.2&quot;</span>), <span class="number">6005</span>);</span><br><span class="line"><span class="comment">//连接服务器</span></span><br><span class="line">socket-&gt;<span class="built_in">connectToHost</span>(<span class="string">&quot;192.168.1.3&quot;</span>, <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印通信用的本地绑定地址和端口</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; socket-&gt;<span class="built_in">localAddress</span>() &lt;&lt; socket-&gt;<span class="built_in">localPort</span>();</span><br><span class="line"><span class="comment">//打印通信服务器对方的地址和端口</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; socket-&gt;<span class="built_in">peerAddress</span>() &lt;&lt; socket-&gt;<span class="built_in">peerPort</span>() &lt;&lt; socket-&gt;<span class="built_in">peerName</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//udp客户端</span></span><br><span class="line">QUdpSocket *socket = <span class="keyword">new</span> <span class="built_in">QUdpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//绑定网卡和端口,没有绑定过才需要绑定</span></span><br><span class="line"><span class="comment">//采用端口是否一样来判断是为了方便可以直接动态绑定切换端口</span></span><br><span class="line"><span class="keyword">if</span> (socket-&gt;<span class="built_in">localPort</span>() != <span class="number">6005</span>) &#123;</span><br><span class="line">    socket-&gt;<span class="built_in">abort</span>();</span><br><span class="line">    socket-&gt;<span class="built_in">bind</span>(<span class="built_in">QHostAddress</span>(<span class="string">&quot;192.168.1.2&quot;</span>), <span class="number">6005</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定地址和端口发送数据</span></span><br><span class="line">socket-&gt;<span class="built_in">writeDatagram</span>(buffer, <span class="built_in">QHostAddress</span>(<span class="string">&quot;192.168.1.3&quot;</span>), <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面是Qt5可以使用bind，Qt4中的QTcpSocket的对应接口是protected的没法直接使用，需要继承类重新实现把接口放出来。</span></span><br><span class="line"><span class="comment">//Qt4中的QUdpSocket有bind函数是开放的，奇怪了，为何Qt4中独独QTcpSocket不开放。</span></span><br><span class="line">TcpSocket *socket = <span class="keyword">new</span> <span class="built_in">TcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line">socket-&gt;<span class="built_in">setLocalAddress</span>(<span class="built_in">QHostAddress</span>(<span class="string">&quot;192.168.1.2&quot;</span>));</span><br><span class="line">socket-&gt;<span class="built_in">setLocalPort</span>(<span class="number">6005</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>关于网络通信，tcp和udp是两种不同的底层的网络通信协议，两者监听和通信的端口互不相干的，不同的协议或者不同的网卡IP地址可以用相同的端口。之前有个人说他的电脑居然可以监听一样的端口进行通信，颠覆了他以前的认知，书上说的明明是不可以相同端口的，后面远程一看原来选择的不同的网卡IP地址，当然可以的咯。</p></li>
</ol>
<ul>
<li>tcp对网卡1监听了端口6000，还可以对网卡2监听端口6000。</li>
<li>tcp对网卡1监听了端口6000，udp对网卡1还可以继续监听端口6000。</li>
<li>tcp对网卡1监听了端口6000，在网卡1上其他tcp只能监听6000以外的端口。</li>
<li>udp协议也是上面的逻辑。</li>
</ul>
<ol start="170" type="1">
<li>开源的图表控件QCustomPlot很经典，作者至少是八星斗圣级别，在曲线数据展示这块性能彪悍，总结了一些容易忽略的经验要点。</li>
</ol>
<ul>
<li>可以将XY轴对调，然后形成横向的效果，无论是曲线图还是柱状图，分组图、堆积图等，都支持这个特性。</li>
<li>不需要的提示图例可以调用 legend-&gt;removeItem 进行移除。</li>
<li>两条曲线可以调用 setChannelFillGraph 设置合并为一个面积区域。</li>
<li>可以关闭抗锯齿 setAntialiased 加快绘制速度。</li>
<li>可以设置不同的线条样式（setLineStyle）、数据样式（setScatterStyle）。</li>
<li>坐标轴的箭头样式可更换 setUpperEnding。</li>
<li>可以用 QCPBarsGroup 实现柱状分组图，这个类在官方demo中没有，所以非常容易忽略。</li>
<li>V2.0开始支持数据排序设置，默认是交给QCustomPlot排序，也可以设置setData第三个参数为true表示已经排序过，这样可以绘制往回走的曲线。</li>
<li>频繁绘制数据可以设置排队绘制参数 replot(QCustomPlot::rpQueuedReplot)，可以避免重复的replot和提高性能。如果不开启很可能绘制出错。</li>
<li>可以将多个plot图表合并到一个QCustomPlot控件中，极大提升绘制效率，而不是实例化多个QCustomPlot控件。合并后也是分开对应不同的坐标轴不同位置排列显示，和多个QCustomPlot控件效果一样并且极大提升性能。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对调XY轴，在最前面设置</span></span><br><span class="line">QCPAxis *yAxis = customPlot-&gt;yAxis;</span><br><span class="line">QCPAxis *xAxis = customPlot-&gt;xAxis;</span><br><span class="line">customPlot-&gt;xAxis = yAxis;</span><br><span class="line">customPlot-&gt;yAxis = xAxis;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除图例</span></span><br><span class="line">customPlot-&gt;legend-&gt;<span class="built_in">removeItem</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个曲线画布形成封闭区域</span></span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>(<span class="number">0</span>)-&gt;<span class="built_in">setChannelFillGraph</span>(customPlot-&gt;<span class="built_in">graph</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭抗锯齿以及设置拖动的时候不启用抗锯齿</span></span><br><span class="line">customPlot-&gt;<span class="built_in">setNoAntialiasingOnDrag</span>(<span class="literal">true</span>);</span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>()-&gt;<span class="built_in">setAntialiased</span>(<span class="literal">false</span>);</span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>()-&gt;<span class="built_in">setAntialiasedFill</span>(<span class="literal">false</span>);</span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>()-&gt;<span class="built_in">setAntialiasedScatters</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//设置快速绘制可以大大加快画笔宽度大于1的线条</span></span><br><span class="line">customPlot-&gt;<span class="built_in">setPlottingHint</span>(QCP::phFastPolylines);</span><br><span class="line"></span><br><span class="line"><span class="comment">//多种设置数据的方法</span></span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>(<span class="number">0</span>)-&gt;<span class="built_in">setData</span>();</span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>(<span class="number">0</span>)-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置不同的线条样式、数据样式</span></span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>()-&gt;<span class="built_in">setLineStyle</span>(QCPGraph::lsLine);</span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>()-&gt;<span class="built_in">setScatterStyle</span>(QCPScatterStyle::ssDot);</span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>()-&gt;<span class="built_in">setScatterStyle</span>(<span class="built_in">QCPScatterStyle</span>(shapes.<span class="built_in">at</span>(i), <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以设置为图片或者自定义形状</span></span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>()-&gt;<span class="built_in">setScatterStyle</span>(<span class="built_in">QCPScatterStyle</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;./sun.png&quot;</span>)));</span><br><span class="line">QPainterPath customScatterPath;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    customScatterPath.<span class="built_in">cubicTo</span>(<span class="built_in">qCos</span>(<span class="number">2</span> * M_PI * i / <span class="number">3.0</span>) * <span class="number">9</span>, <span class="built_in">qSin</span>(<span class="number">2</span> * M_PI * i / <span class="number">3.0</span>) * <span class="number">9</span>, <span class="built_in">qCos</span>(<span class="number">2</span> * M_PI * (i + <span class="number">0.9</span>) / <span class="number">3.0</span>) * <span class="number">9</span>, <span class="built_in">qSin</span>(<span class="number">2</span> * M_PI * (i + <span class="number">0.9</span>) / <span class="number">3.0</span>) * <span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>()-&gt;<span class="built_in">setScatterStyle</span>(<span class="built_in">QCPScatterStyle</span>(customScatterPath, <span class="built_in">QPen</span>(Qt::black, <span class="number">0</span>), <span class="built_in">QColor</span>(<span class="number">40</span>, <span class="number">70</span>, <span class="number">255</span>, <span class="number">50</span>), <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//更换坐标轴的箭头样式</span></span><br><span class="line">customPlot-&gt;xAxis-&gt;<span class="built_in">setUpperEnding</span>(QCPLineEnding::esSpikeArrow);</span><br><span class="line">customPlot-&gt;yAxis-&gt;<span class="built_in">setUpperEnding</span>(QCPLineEnding::esSpikeArrow);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置背景图片</span></span><br><span class="line">customPlot-&gt;<span class="built_in">axisRect</span>()-&gt;<span class="built_in">setBackground</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;./solarpanels.jpg&quot;</span>));</span><br><span class="line"><span class="comment">//画布也可以设置背景图片</span></span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>(<span class="number">0</span>)-&gt;<span class="built_in">setBrush</span>(<span class="built_in">QBrush</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;./balboa.jpg&quot;</span>)));</span><br><span class="line"><span class="comment">//整体可以设置填充颜色或者图片</span></span><br><span class="line">customPlot-&gt;<span class="built_in">setBackground</span>(<span class="built_in">QBrush</span>(gradient));</span><br><span class="line"><span class="comment">//设置零点线条颜色</span></span><br><span class="line">customPlot-&gt;xAxis-&gt;<span class="built_in">grid</span>()-&gt;<span class="built_in">setZeroLinePen</span>(Qt::NoPen);</span><br><span class="line"><span class="comment">//控制是否鼠标滚轮缩放拖动等交互形式</span></span><br><span class="line">customPlot-&gt;<span class="built_in">setInteractions</span>(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);</span><br><span class="line"></span><br><span class="line"><span class="comment">//柱状分组图</span></span><br><span class="line">QCPBarsGroup *group = <span class="keyword">new</span> <span class="built_in">QCPBarsGroup</span>(customPlot);</span><br><span class="line">QList&lt;QCPBars*&gt; bars;</span><br><span class="line">bars &lt;&lt; fossil &lt;&lt; nuclear &lt;&lt; regen;</span><br><span class="line">foreach (QCPBars *bar, bars) &#123;</span><br><span class="line">    <span class="comment">//设置柱状图的宽度大小</span></span><br><span class="line">    bar-&gt;<span class="built_in">setWidth</span>(bar-&gt;<span class="built_in">width</span>() / bars.<span class="built_in">size</span>());</span><br><span class="line">    group-&gt;<span class="built_in">append</span>(bar);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置分组之间的间隔</span></span><br><span class="line">group-&gt;<span class="built_in">setSpacing</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制往回走的曲线</span></span><br><span class="line">QVector&lt;<span class="type">double</span>&gt; keys, values;</span><br><span class="line">keys &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">values &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="number">6</span> &lt;&lt; <span class="number">7</span> &lt;&lt; <span class="number">7</span> &lt;&lt; <span class="number">6</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">customPlot-&gt;<span class="built_in">graph</span>(<span class="number">0</span>)-&gt;<span class="built_in">setData</span>(keys, values, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//频繁绘制数据开启排队绘制可以提高性能</span></span><br><span class="line">customPlot-&gt;<span class="built_in">replot</span>(QCustomPlot::rpQueuedReplot);</span><br><span class="line"></span><br><span class="line">QCPAxis *axis = customPlot-&gt;xAxis;</span><br><span class="line"><span class="type">double</span> lower = axis-&gt;<span class="built_in">range</span>().lower;</span><br><span class="line"><span class="type">double</span> upper = axis-&gt;<span class="built_in">range</span>().upper;</span><br><span class="line"><span class="type">double</span> origin = (upper - lower) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//设置刻度线按照设置优先而不是可读性优先</span></span><br><span class="line">axis-&gt;<span class="built_in">ticker</span>()-&gt;<span class="built_in">setTickStepStrategy</span>(QCPAxisTicker::tssMeetTickCount);</span><br><span class="line"><span class="comment">//设置原点值为范围值的中心点</span></span><br><span class="line">axis-&gt;<span class="built_in">ticker</span>()-&gt;<span class="built_in">setTickOrigin</span>(origin);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面演示如何在一个控件中多个不同的曲线对应不同坐标轴</span></span><br><span class="line"><span class="comment">//拿到图表布局对象</span></span><br><span class="line">QCPLayoutGrid *layout = customPlot-&gt;<span class="built_in">plotLayout</span>();</span><br><span class="line"><span class="comment">//实例化坐标轴区域</span></span><br><span class="line">QCPAxisRect *axisRect = <span class="keyword">new</span> <span class="built_in">QCPAxisRect</span>(customPlot);</span><br><span class="line"><span class="comment">//拿到XY坐标轴对象</span></span><br><span class="line">QCPAxis *xAxis = axisRect-&gt;<span class="built_in">axis</span>(QCPAxis::atBottom);</span><br><span class="line">QCPAxis *yAxis = axisRect-&gt;<span class="built_in">axis</span>(QCPAxis::atLeft);</span><br><span class="line"><span class="comment">//将坐标轴指定行列位置添加到布局中</span></span><br><span class="line">layout-&gt;<span class="built_in">addElement</span>(i, <span class="number">0</span>, axisRect);</span><br><span class="line"><span class="comment">//添加对应的画布到指定坐标轴</span></span><br><span class="line">QCPGraph *graph = customPlot-&gt;<span class="built_in">addGraph</span>(xAxis, yAxis);</span><br></pre></td></tr></table></figure>
<h3 id="section-17">18：171-180</h3>
<ol start="171" type="1">
<li><p>在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen_s函数，比如fmod中也是这个情况。这个时候就需要转码处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString fileName = <span class="string">&quot;c:/测试目录/1.txt&quot;</span>;</span><br><span class="line"><span class="comment">//如果应用程序main函数中没有设置编码则默认采用系统的编码，可以直接通过toLocal8Bit转成正确的数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name = fileName.<span class="built_in">toLocal8Bit</span>().<span class="built_in">constData</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果设置过了下面两句则需要主动转码</span></span><br><span class="line">QTextCodec *codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">QTextCodec::<span class="built_in">setCodecForLocale</span>(codec);</span><br><span class="line"></span><br><span class="line">QTextCodec *code = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name = code-&gt;<span class="built_in">fromUnicode</span>(fileName).<span class="built_in">constData</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐方式2以防万一保证绝对的正确，哪怕是设置过主程序的编码</span></span><br><span class="line"><span class="comment">//切记一旦设置过QTextCodec::setCodecForLocale会影响toLocal8Bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有时候可能还有下面这种情况</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1400)</span></span><br><span class="line">    QTextCodec *code = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    QTextCodec *code = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name = code-&gt;<span class="built_in">fromUnicode</span>(fileName).<span class="built_in">constData</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name = fileName.<span class="built_in">toUtf8</span>().<span class="built_in">constData</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>在查阅和学习Qt源码的过程中，发现了一些趋势和改变。</p></li>
</ol>
<ul>
<li>数据类型这块尽量用Qt内部的数据类型，哪怕是重定义过的比如quint8其实unsigned char，qreal就是double，以前翻看源码的时候可能还有些是double，现在慢慢改成了qreal。</li>
<li>循环结构用 for(;;) 替代 while(1)，因为转成汇编指令后 for(;;) 只有一条指令而 while(1) 确有4条，指令少不占用寄存器而且不用跳转，理论上速度要更快。</li>
<li>其实Qt中就重定义了 forever 关键字表示 for(;;) ，我的乖乖，想的真周到。</li>
<li>自动c++11以及后续的标准都支持auto万能数据类型，发现Qt的源码中也慢慢的改成了auto，这样加快了编写代码的效率，不用自己去指定数据类型而是让编译器自己推导数据类型。而且其实也不影响编译器编译的速度，因为无论指定和没有指定数据类型，编译器都要推导右侧的数据类型进行判断。不过有个缺点就是影响了阅读代码的成本，很多时候需要自己去理解推导。</li>
<li></li>
</ul>
<ol start="173" type="1">
<li><p>Qt中设置或者打开加载本地文件需要用到QUrl类，本地文件建议加上 file:/// 前缀。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString url = <span class="string">&quot;file:///c:/1.html&quot;</span>;</span><br><span class="line"><span class="comment">//浏览器控件打开本地网页文件</span></span><br><span class="line">webView-&gt;<span class="built_in">setUrl</span>(<span class="built_in">QUrl</span>(url));</span><br><span class="line"><span class="comment">//打开本地网页文件，下面两种方法都可以</span></span><br><span class="line">QDesktopServices::<span class="built_in">openUrl</span>(QUrl::<span class="built_in">fromLocalFile</span>(url));</span><br><span class="line">QDesktopServices::<span class="built_in">openUrl</span>(<span class="built_in">QUrl</span>(url, QUrl::TolerantMode));</span><br></pre></td></tr></table></figure></p></li>
<li><p>在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5.15开始内置了setTransferTimeout来设置超时时间，非常好用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部的事件循环,不卡主界面</span></span><br><span class="line">QEventLoop eventLoop;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置超时 5.15开始自带了超时时间函数 默认30秒</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,15,0))</span></span><br><span class="line">manager-&gt;<span class="built_in">setTransferTimeout</span>(timeout);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">QTimer timer;</span><br><span class="line"><span class="built_in">connect</span>(&amp;timer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), &amp;eventLoop, <span class="built_in">SLOT</span>(<span class="built_in">quit</span>()));</span><br><span class="line">timer.<span class="built_in">setSingleShot</span>(<span class="literal">true</span>);</span><br><span class="line">timer.<span class="built_in">start</span>(timeout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">QNetworkReply *reply = manager-&gt;<span class="built_in">get</span>(<span class="built_in">QNetworkRequest</span>(<span class="built_in">QUrl</span>(url)));</span><br><span class="line"><span class="built_in">connect</span>(reply, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), &amp;eventLoop, <span class="built_in">SLOT</span>(<span class="built_in">quit</span>()));</span><br><span class="line">eventLoop.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (reply-&gt;<span class="built_in">bytesAvailable</span>() &gt; <span class="number">0</span> &amp;&amp; reply-&gt;<span class="built_in">error</span>() == QNetworkReply::NoError) &#123;</span><br><span class="line">    <span class="comment">//读取所有数据保存成文件</span></span><br><span class="line">    QByteArray data = reply-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(dirName + fileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">open</span>(QFile::WriteOnly | QFile::Truncate)) &#123;</span><br><span class="line">        file.<span class="built_in">write</span>(data);</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick/qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果是控制台程序则下面的QApplication换成QCoreApplication</span></span><br><span class="line"><span class="comment">//如果是quick/qml程序则下面的QApplication换成QGuiApplication</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//可以用下面这行测试Qt自带的输入法 qtvirtualkeyboard</span></span><br><span class="line">    <span class="built_in">qputenv</span>(<span class="string">&quot;QT_IM_MODULE&quot;</span>, <span class="built_in">QByteArray</span>(<span class="string">&quot;qtvirtualkeyboard&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置不应用操作系统设置比如字体</span></span><br><span class="line">    QApplication::<span class="built_in">setDesktopSettingsAware</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    <span class="comment">//设置高分屏缩放舍入策略</span></span><br><span class="line">    QApplication::<span class="built_in">setHighDpiScaleFactorRoundingPolicy</span>(Qt::HighDpiScaleFactorRoundingPolicy::Floor);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0))</span></span><br><span class="line">    <span class="comment">//设置启用高分屏缩放支持</span></span><br><span class="line">    <span class="comment">//要注意开启后计算到的控件或界面宽度高度可能都不对,全部需要用缩放比例运算下</span></span><br><span class="line">    QApplication::<span class="built_in">setAttribute</span>(Qt::AA_EnableHighDpiScaling);</span><br><span class="line">    <span class="comment">//设置启用高分屏图片支持</span></span><br><span class="line">    QApplication::<span class="built_in">setAttribute</span>(Qt::AA_UseHighDpiPixmaps);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))</span></span><br><span class="line">    <span class="comment">//设置opengl模式 AA_UseDesktopOpenGL(默认) AA_UseOpenGLES AA_UseSoftwareOpenGL</span></span><br><span class="line">    <span class="comment">//在一些很旧的设备上或者对opengl支持很低的设备上需要使用AA_UseOpenGLES表示禁用硬件加速</span></span><br><span class="line">    <span class="comment">//如果开启的是AA_UseOpenGLES则无法使用硬件加速比如ffmpeg的dxva2</span></span><br><span class="line">    <span class="comment">//QApplication::setAttribute(Qt::AA_UseOpenGLES);</span></span><br><span class="line">    <span class="comment">//设置opengl共享上下文</span></span><br><span class="line">    QApplication::<span class="built_in">setAttribute</span>(Qt::AA_ShareOpenGLContexts);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QWidget w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>QCamera中获取设备的配置参数比如支持的分辨率集合等，需要先调用load后才能正确获取，或者关联stateChanged信号中判断状态是否是ActiveState，然后再读取。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1：调用load后获取</span></span><br><span class="line">camera = <span class="keyword">new</span> <span class="built_in">QCamera</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//先需要载入才能获取到对应参数</span></span><br><span class="line">camera-&gt;<span class="built_in">load</span>();</span><br><span class="line"><span class="comment">//输出当前设备支持的分辨率</span></span><br><span class="line">QList&lt;QSize&gt; sizes = camera-&gt;<span class="built_in">supportedViewfinderResolutions</span>();</span><br><span class="line"><span class="function">emit <span class="title">resolutions</span><span class="params">(sizes)</span></span>;</span><br><span class="line"><span class="comment">//重新设置分辨率</span></span><br><span class="line">QCameraViewfinderSettings set;</span><br><span class="line">set.<span class="built_in">setResolution</span>(cameraWidth, cameraHeight);</span><br><span class="line">camera-&gt;<span class="built_in">setViewfinderSettings</span>(set);</span><br><span class="line"><span class="comment">//获取完成后卸载</span></span><br><span class="line">camera-&gt;<span class="built_in">unload</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：通过事件信号获取</span></span><br><span class="line">camera = <span class="keyword">new</span> <span class="built_in">QCamera</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(camera, <span class="built_in">SIGNAL</span>(<span class="built_in">stateChanged</span>(QCamera::State)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">stateChanged</span>(QCamera::State)));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CameraThread::stateChanged</span><span class="params">(QCamera::State state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == QCamera::ActiveState) &#123;</span><br><span class="line">        <span class="comment">//输出当前设备支持的分辨率</span></span><br><span class="line">        QList&lt;QSize&gt; sizes = camera-&gt;<span class="built_in">supportedViewfinderResolutions</span>();</span><br><span class="line">        <span class="function">emit <span class="title">resolutions</span><span class="params">(sizes)</span></span>;</span><br><span class="line">        <span class="comment">//重新设置分辨率</span></span><br><span class="line">        QCameraViewfinderSettings set;</span><br><span class="line">        set.<span class="built_in">setResolution</span>(cameraWidth, cameraHeight);</span><br><span class="line">        camera-&gt;<span class="built_in">setViewfinderSettings</span>(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//QCamera没有指定设备名称的时候则采用默认的摄像机</span></span><br><span class="line">camera = <span class="keyword">new</span> <span class="built_in">QCamera</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//cameraName = @device:pnp:\\\\?\\usb#vid_046d&amp;pid_0825&amp;mi_00#6&amp;212eebd3&amp;0&amp;0000#&#123;65e8773d-8f56-11d0-a3b9-00a0c9223196&#125;\\global</span></span><br><span class="line"><span class="comment">//可以通过设备描述符来查找设备名称(唯一标识)</span></span><br><span class="line">camera = <span class="keyword">new</span> <span class="built_in">QCamera</span>(cameraName.<span class="built_in">toUtf8</span>(), <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>很多时候需要在窗体首次显示的时候加载一些东西，而且只加载一次，当窗体再次显示的时候不加载。为什么不是在构造函数呢？因为很多玩意都是要在显示后才能确定，比如控件的尺寸，部分样式表的应用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::showEvent</span><span class="params">(QShowEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里为了演示代码方便直接写的static，如果new多个窗体则需要定义在头文件中。</span></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isLoad = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isLoad) &#123;</span><br><span class="line">        isLoad = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//执行对应的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt获取当前所用的Qt版本、编译器、位数等信息。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//详细的Qt版本+编译器+位数</span></span><br><span class="line">QString compilerString = <span class="string">&quot;&lt;unknown&gt;&quot;</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(Q_CC_CLANG)</span></span><br><span class="line">    QString isAppleString;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__apple_build_version__)</span></span><br><span class="line">    isAppleString = <span class="built_in">QLatin1String</span>(<span class="string">&quot; (Apple)&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    compilerString = <span class="built_in">QLatin1String</span>(<span class="string">&quot;Clang &quot;</span>) + QString::<span class="built_in">number</span>(__clang_major__) + <span class="built_in">QLatin1Char</span>(<span class="string">&#x27;.&#x27;</span>) + QString::<span class="built_in">number</span>(__clang_minor__) + isAppleString;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(Q_CC_GNU)</span></span><br><span class="line">    compilerString = <span class="built_in">QLatin1String</span>(<span class="string">&quot;GCC &quot;</span>) + <span class="built_in">QLatin1String</span>(__VERSION__);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(Q_CC_MSVC)</span></span><br><span class="line">    <span class="keyword">if</span> (_MSC_VER &gt; <span class="number">1999</span>) &#123;</span><br><span class="line">        compilerString = <span class="built_in">QLatin1String</span>(<span class="string">&quot;MSVC &lt;unknown&gt;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_MSC_VER &gt;= <span class="number">1930</span>) &#123;</span><br><span class="line">        compilerString = <span class="built_in">QLatin1String</span>(<span class="string">&quot;MSVC 2022&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_MSC_VER &gt;= <span class="number">1920</span>) &#123;</span><br><span class="line">        compilerString = <span class="built_in">QLatin1String</span>(<span class="string">&quot;MSVC 2019&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_MSC_VER &gt;= <span class="number">1910</span>) &#123;</span><br><span class="line">        compilerString = <span class="built_in">QLatin1String</span>(<span class="string">&quot;MSVC 2017&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_MSC_VER &gt;= <span class="number">1900</span>) &#123;</span><br><span class="line">        compilerString = <span class="built_in">QLatin1String</span>(<span class="string">&quot;MSVC 2015&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_MSC_VER &gt;= <span class="number">1800</span>) &#123;</span><br><span class="line">        compilerString = <span class="built_in">QLatin1String</span>(<span class="string">&quot;MSVC 2013&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_MSC_VER &gt;= <span class="number">1700</span>) &#123;</span><br><span class="line">        compilerString = <span class="built_in">QLatin1String</span>(<span class="string">&quot;MSVC 2012&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_MSC_VER &gt;= <span class="number">1600</span>) &#123;</span><br><span class="line">        compilerString = <span class="built_in">QLatin1String</span>(<span class="string">&quot;MSVC 2010&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compilerString = <span class="built_in">QLatin1String</span>(<span class="string">&quot;MSVC &lt;old&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展知识 查看 QSysInfo 类下面有很多好东西</span></span><br><span class="line"><span class="comment">// qVersion() = QT_VERSION_STR</span></span><br><span class="line">QString version = <span class="built_in">QString</span>(<span class="string">&quot;%1 %2 %3&quot;</span>).<span class="built_in">arg</span>(<span class="built_in">qVersion</span>()).<span class="built_in">arg</span>(compilerString).<span class="built_in">arg</span>(QString::<span class="built_in">number</span>(QSysInfo::WordSize));</span><br></pre></td></tr></table></figure></p></li>
<li><p>QDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如 ddd = 周二 Tue dddd = 星期二 Tuesday ，此时如果只想永远是中文就需要用到QLocale进行转换。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式化输出受到本地操作系统语言的影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//英文操作系统</span></span><br><span class="line"><span class="comment">//这样获取到的是Mon到Sun，英文星期的3个字母的缩写。</span></span><br><span class="line">QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"><span class="comment">//这样获取到的是Monday到Sunday，英文星期完整单词。</span></span><br><span class="line">QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//中文操作系统</span></span><br><span class="line"><span class="comment">//这样获取到的是周一到周日。</span></span><br><span class="line">QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"><span class="comment">//这样获取到的是星期一到星期日。</span></span><br><span class="line">QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">&quot;dddd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主动指定语言转换</span></span><br><span class="line"><span class="comment">//如果没有指定本地语言则默认采用系统的语言环境。</span></span><br><span class="line">QLocale locale;</span><br><span class="line"><span class="comment">//QLocale locale = QLocale::Chinese;</span></span><br><span class="line"><span class="comment">//QLocale locale = QLocale::English;</span></span><br><span class="line"><span class="comment">//QLocale locale = QLocale::Japanese;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面永远输出中文的周一到周日</span></span><br><span class="line">locale.<span class="built_in">toString</span>(QDateTime::<span class="built_in">currentDateTime</span>(), <span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"><span class="comment">//下面永远输出中文的星期一到星期日</span></span><br><span class="line">locale.<span class="built_in">toString</span>(QDateTime::<span class="built_in">currentDateTime</span>(), <span class="string">&quot;dddd&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>QSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化数据库表模型</span></span><br><span class="line">QSqlTableModel *model = <span class="keyword">new</span> <span class="built_in">QSqlTableModel</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//指定表名</span></span><br><span class="line">model-&gt;<span class="built_in">setTable</span>(<span class="string">&quot;table&quot;</span>);</span><br><span class="line"><span class="comment">//设置列排序</span></span><br><span class="line">model-&gt;<span class="built_in">setSort</span>(<span class="number">0</span>, Qt::AscendingOrder);</span><br><span class="line"><span class="comment">//设置提交模式</span></span><br><span class="line">model-&gt;<span class="built_in">setEditStrategy</span>(QSqlTableModel::OnManualSubmit);</span><br><span class="line"><span class="comment">//立即查询一次</span></span><br><span class="line">model-&gt;<span class="built_in">select</span>();</span><br><span class="line"><span class="comment">//将数据库表模型设置到表格上</span></span><br><span class="line">ui-&gt;tableView-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试发现过滤条件中除了可以带where语句还可以带排序及limit等</span></span><br><span class="line">model-&gt;<span class="built_in">setFilter</span>(<span class="string">&quot;1=1 order by id desc limit 100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在过滤条件中设置了排序语句则不可以再使用setSort方法</span></span><br><span class="line"><span class="comment">//下面的代码结果是执行出错，可能因为setSort又重新增加了order by语句导致多个order by语句冲突了。</span></span><br><span class="line">model-&gt;<span class="built_in">setSort</span>(<span class="number">0</span>, Qt::AscendingOrder);</span><br><span class="line">model-&gt;<span class="built_in">setFilter</span>(<span class="string">&quot;1=1 order by id desc limit 100&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过setFilter设置单纯的where语句可以不用加1=1</span></span><br><span class="line">model-&gt;<span class="built_in">setFilter</span>(<span class="string">&quot;name=&#x27;张三&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">//如果还有其他语句比如排序或者limit等则需要最前面加上1=1</span></span><br><span class="line"><span class="comment">//下面表示按照id升序排序，查询结果显示第5-15条记录。</span></span><br><span class="line">model-&gt;<span class="built_in">setFilter</span>(<span class="string">&quot;1=1 order by id asc limit 5,10&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个条件用and连接</span></span><br><span class="line"><span class="comment">//建议任何时候用了setFilter则最前面写1=1最末尾加上 ; 防止有些地方无法正确执行。</span></span><br><span class="line">model-&gt;<span class="built_in">setFilter</span>(<span class="string">&quot;1=1 and name=&#x27;张三&#x27; and result&gt;=70;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面表示查询姓名是张三的记录，按照id字段降序排序，结果从第10条开始100条，相当于从第10条到110条记录。</span></span><br><span class="line">model-&gt;<span class="built_in">setFilter</span>(<span class="string">&quot;1=1 and name=&#x27;张三&#x27; order by id desc limit 10,100;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第3行开始添加一条记录</span></span><br><span class="line">model-&gt;<span class="built_in">insertRow</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//立即填充刚刚新增加的行，默认为空需要用户手动在表格中输入。</span></span><br><span class="line">model-&gt;<span class="built_in">setData</span>(model-&gt;<span class="built_in">index</span>(<span class="number">2</span>, <span class="number">0</span>), <span class="number">100</span>);</span><br><span class="line">model-&gt;<span class="built_in">setData</span>(model-&gt;<span class="built_in">index</span>(<span class="number">2</span>, <span class="number">1</span>), <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//提交更新</span></span><br><span class="line">model-&gt;<span class="built_in">submitAll</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第4行</span></span><br><span class="line">model-&gt;<span class="built_in">removeRow</span>(<span class="number">3</span>);</span><br><span class="line">model-&gt;<span class="built_in">submitAll</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//总之有增删改操作后都需要调用model-&gt;submitAll();来真正执行，否则仅仅是数据模型更新了数据，并不会更新到数据库中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//撤销更改</span></span><br><span class="line">model-&gt;<span class="built_in">revertAll</span>();</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="section-18">19：181-190</h3>
<ol start="181" type="1">
<li>Qt天生就是linux的，从linux开始发展起来的，所以不少Qt程序员经常的开发环境是linux，比如常用的ubuntu等系统，整理了一点常用的linux命令。</li>
</ol>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">命令</th>
<th style="text-align: left;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">sudo -s</td>
<td style="text-align: left;">切换到管理员，如果是 sudo -i 切换后会改变当前目录。</td>
</tr>
<tr class="even">
<td style="text-align: left;">apt install g++</td>
<td style="text-align: left;">安装软件包（要管理员权限），另一个派系的是 yum install。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">cd /home</td>
<td style="text-align: left;">进入home目录。</td>
</tr>
<tr class="even">
<td style="text-align: left;">ls</td>
<td style="text-align: left;">罗列当前所在目录所有目录和文件。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ifconfig</td>
<td style="text-align: left;">查看网卡信息包括IP地址，windows上是 ipconfig。</td>
</tr>
<tr class="even">
<td style="text-align: left;">tar -zxvf bin.tar.gz</td>
<td style="text-align: left;">解压文件到当前目录。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">tar -jxvf bin.tar.xz</td>
<td style="text-align: left;">解压文件到当前目录。</td>
</tr>
<tr class="even">
<td style="text-align: left;">tar -zxvf bin.tar.gz -C /home</td>
<td style="text-align: left;">解压文件到/home目录，记住是大写的C。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">tar -zcvf bin.tar.gz bin</td>
<td style="text-align: left;">将bin目录压缩成tar.gz格式文件（压缩比一般）。</td>
</tr>
<tr class="even">
<td style="text-align: left;">tar -jcvf bin.tar.xz bin</td>
<td style="text-align: left;">将bin目录压缩成tar.xz格式文件（压缩比高，推荐）。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">tar -...</td>
<td style="text-align: left;">j z 表示不同的压缩方法，x表示解压，c表示压缩。</td>
</tr>
<tr class="even">
<td style="text-align: left;">gedit 1.txt</td>
<td style="text-align: left;">用记事本打开文本文件。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">vim 1.txt</td>
<td style="text-align: left;">用vim打开文件，很多时候可以缩写用vi。</td>
</tr>
<tr class="even">
<td style="text-align: left;">./configure make -j4 make install</td>
<td style="text-align: left;">通用编译源码命令，第一步./configure执行配置脚本，第二步make -j4启用多线程编译，第三步make install安装编译好的文件。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">./configure -prefix /home/liu/Qt-5.9.3-static -static -sql-sqlite -qt-zlib -qt-xcb -qt-libpng -qt-libjpeg -fontconfig -system-freetype -iconv -nomake tests -nomake examples -skip qt3d -skip qtdoc</td>
<td style="text-align: left;">Qt通用编译命令。</td>
</tr>
<tr class="even">
<td style="text-align: left;">./configure -static -release -fontconfig -system-freetype -qt-xcb -qt-sql-sqlite -qt-zlib -qt-libpng -qt-libjpeg -nomake tests -nomake examples -prefix /home/liu/qt/Qt5.6.3</td>
<td style="text-align: left;">Qt静态带中文。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">./configure -prefix /home/liu/Qt-5.9.3-static -static -release -nomake examples -nomake tests -skip qt3d</td>
<td style="text-align: left;">精简编译命令。</td>
</tr>
<tr class="even">
<td style="text-align: left;">./configure --prefix=host --enable-static --disable-shared --disable-doc</td>
<td style="text-align: left;">ffmpeg编译命令。</td>
</tr>
</tbody>
</table>
<ol start="182" type="1">
<li><p>Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Qt5开始提供了日志上下文信息输出，比如输出当前打印消息所在的代码文件、行号、函数名等。</span></span><br><span class="line"><span class="comment">//如果是release还需要在pro中加上 DEFINES += QT_MESSAGELOGCONTEXT 才能输出上下文，默认release关闭的。</span></span><br><span class="line"><span class="comment">//切记不要在日志钩子函数中再写qdebug之类的，那样就死循环了。</span></span><br><span class="line"><span class="comment">//日志重定向一般就三种处理</span></span><br><span class="line"><span class="comment">//1: 输出到日志文件比如txt文本文件。</span></span><br><span class="line"><span class="comment">//2: 存储到数据库，可以分类存储，以便相关人员查询分析。</span></span><br><span class="line"><span class="comment">//3: 重定向到网络，对方用小工具连接程序后，所有打印信息通过tcp发过去。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//日志重定向</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(QtMsgType type, <span class="type">const</span> QMessageLogContext &amp;context, <span class="type">const</span> QString &amp;msg)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">else</span></span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(QtMsgType type, <span class="type">const</span> <span class="type">char</span> *msg)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//加锁,防止多线程中qdebug太频繁导致崩溃</span></span><br><span class="line">    <span class="type">static</span> QMutex mutex;</span><br><span class="line">    <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    QString content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里可以根据不同的类型加上不同的头部用于区分</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> QtDebugMsg:</span><br><span class="line">            content = <span class="built_in">QString</span>(<span class="string">&quot;%1&quot;</span>).<span class="built_in">arg</span>(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> QtWarningMsg:</span><br><span class="line">            content = <span class="built_in">QString</span>(<span class="string">&quot;%1&quot;</span>).<span class="built_in">arg</span>(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> QtCriticalMsg:</span><br><span class="line">            content = <span class="built_in">QString</span>(<span class="string">&quot;%1&quot;</span>).<span class="built_in">arg</span>(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> QtFatalMsg:</span><br><span class="line">            content = <span class="built_in">QString</span>(<span class="string">&quot;%1&quot;</span>).<span class="built_in">arg</span>(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加上打印代码所在代码文件、行号、函数名</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    <span class="keyword">if</span> (SaveLog::<span class="built_in">Instance</span>()-&gt;<span class="built_in">getUseContext</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> line = context.line;</span><br><span class="line">        QString file = context.file;</span><br><span class="line">        QString function = context.function;</span><br><span class="line">        <span class="keyword">if</span> (line &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            content = <span class="built_in">QString</span>(<span class="string">&quot;行号: %1  文件: %2  函数: %3\n%4&quot;</span>).<span class="built_in">arg</span>(line).<span class="built_in">arg</span>(file).<span class="built_in">arg</span>(function).<span class="built_in">arg</span>(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将内容传给函数进行处理</span></span><br><span class="line">    SaveLog::<span class="built_in">Instance</span>()-&gt;<span class="built_in">save</span>(content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装日志钩子,输出调试信息到文件,便于调试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SaveLog::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    <span class="built_in">qInstallMessageHandler</span>(Log);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">qInstallMsgHandler</span>(Log);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载日志钩子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SaveLog::stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    <span class="built_in">qInstallMessageHandler</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">qInstallMsgHandler</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>自从c++11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记。</p></li>
</ol>
<ul>
<li>代码格式：<a href="parameters">capture</a> mutable -&gt;return-type {statement}</li>
<li>[capture]：捕捉列表，捕捉列表总是出现在Lambda函数的开始处，实际上，[]是Lambda引出符，编译器根据该引出符判断接下来的代码是否是Lambda函数，捕捉列表能够捕捉上下文中的变量以供Lambda函数使用。</li>
<li>(parameters)：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以连同括号 () 一起省略。</li>
<li>mutable：mutable修饰符，默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</li>
<li>-&gt;return-type：返回类型，用追踪返回类型形式声明函数的返回类型，我们可以在不需要返回值的时候也可以连同符号 -&gt; 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</li>
<li>{statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</li>
</ul>
<p>捕捉列表有以下几种形式： - [var]表示值传递方式捕捉变量var。 - [=]表示值传递方式捕捉所有父作用域的变量（包括this）。 - [&amp;var]表示引用传递捕捉变量var。 - [&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）。 - [this]表示值传递方式捕捉当前的this指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按钮单击不带参数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, [] &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;hello lambda&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按钮单击带参数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::clicked, [] (<span class="type">bool</span> isCheck) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;hello lambda&quot;</span> &lt;&lt; isCheck;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义信号带参数</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MainWindow::sig_test, [] (<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;hello lambda&quot;</span> &lt;&lt; i &lt;&lt; j;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function">emit <span class="title">sig_test</span><span class="params">(<span class="number">5</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="184" type="1">
<li><p>由于Qt版本众多，有时候为了兼容多个版本甚至跨度Qt4/Qt5/Qt6的兼容，有些头文件或者类名等变了或者新增了，需要用到Qt版本的判断。需要注意的是如果在头文件中使用 QT_VERSION_CHECK 需要先引入#include "qglobal.h"不然编译失败，因为 QT_VERSION_CHECK 这个函数在 qglobal.h 头文件中。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//至少要包含 qglobal.h，理论上Qt所有的类都包含了这个头文件，所以你引入Qt的其他头文件也行比如 qobject.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qglobal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qscreen.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qdesktopwidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>在使用QString转换到char <em>或者const char </em>的时候，务必记得分两步来完成，血的教训，在一个场景中，就因为没有分两步走，现象是msvc的debug异常release正常，mingw和gcc的debug和release都正常，这就很无语了，找问题找半天，对比法排除法按道理要么都有问题才对。</p></li>
</ol>
<ul>
<li>转换前QString的内容无关中文还是英文，要出问题都一样。</li>
<li>转换中QByteArray无关具体类型，toUtf8、toLatin1、toLocal8Bit、toStdString等方法，要出问题都一样。</li>
<li>转换后无关char <em>还是const char </em>，要出问题都一样。</li>
<li>出问题的随机性的，概率出现，理论上debug的概率更大。</li>
<li>根据酷码大佬分析可能的原因(不确定)是msvc为了方便调试，debug会在内存释放后做填充，release则不会。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString text = <span class="string">&quot;xxxxx&quot;</span>;</span><br><span class="line"><span class="comment">//下面这样转换很可能会有问题</span></span><br><span class="line"><span class="type">char</span> *data = text.<span class="built_in">toUtf8</span>().<span class="built_in">data</span>();</span><br><span class="line"><span class="comment">//分两步转换肯定不会有问题</span></span><br><span class="line">QByteArray buffer = text.<span class="built_in">toUtf8</span>();</span><br><span class="line"><span class="type">char</span> *data = buffer.<span class="built_in">data</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *data = buffer.<span class="built_in">constData</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="186" type="1">
<li>关于是使用QList还是QVector的问题，一直是众多Qter的选择问题，主要是这两个玩意提供的的接口函数基本一致，比如插入、删除、取值等。</li>
</ol>
<ul>
<li>大多数情况下可以用QList。像append、prepend、insert这种操作，通常QList比QVector快的多。</li>
<li>QList是基于index标签存储它的元素项在内存中，比那种依赖iterator迭代的更快捷，而且你的代码也更少。</li>
<li>如果你需要一个真正的连接着的list，且需要保证一个固定插入耗时。那就用迭代器，而不是标签。使用QLinkedList()。</li>
<li>如果你需要开辟连续的内存空间存储，或者你的元素远比一个指针大，这时你需要避免个别插入操作，出现堆栈溢出，这时候用QVector。</li>
<li>如果更在意取值的速度则用QVector，QCustomPlot用的就是QVector，需要频繁大量的取出数据进行绘制。</li>
<li>如果更在意更新数据（添加、删除等）的速度则用QList（对应操作是[]=值），但是因为QChart主要用的是QList访问数据（对应操作是at()），也是导致大数据量卡顿的原因之一，一直被诟病。</li>
<li>曲线图表这类的基本上绝大部分时间都是在访问数据，拿到设置好的数据进行绘制。</li>
<li>总之：QList更新（插入、追加等）数据速度快，QVector取数据速度快。</li>
<li>在数据量很小的情况下两者几乎没啥性能区别。</li>
<li>貌似Qt6对这两个类合并了（选择困难症的Qter解放了），QVector=QList即QVector是QList的别名，可能底层改了代码以便发挥两者的优势。</li>
</ul>
<ol start="187" type="1">
<li>关于mouseTracking鼠标追踪和tabletTracking平板追踪的几点官方说明。</li>
</ol>
<ul>
<li>mouseTracking属性用于保存是否启用鼠标跟踪，缺省情况是不启用的。</li>
<li>没启用的情况下，对应部件只接收在鼠标移动同时至少一个鼠标按键按下时的鼠标移动事件。</li>
<li>启用鼠标跟踪的情况下，任何鼠标移动事件部件都会接收。</li>
<li>部件方法hasMouseTracking()用于返回当前是否启用鼠标跟踪。</li>
<li>setMouseTracking(bool enable)用于设置是否启用鼠标跟踪。</li>
<li>与鼠标跟踪相关的函数主要是mouseMoveEvent()。</li>
<li>tabletTracking属性保存是否启用部件的平板跟踪，缺省是不起用的。</li>
<li>没有启用平板跟踪的情况下，部件仅接收触控笔与平板接触或至少有个触控笔按键按下时的触控笔移动事件。</li>
<li>如果部件启用了平板跟踪功能，部件能接收触控笔靠近但未真正接触平板时的触控笔移动事件。</li>
<li>这可以用于监视操作位置以及部件的辅助操作功能（如旋转和倾斜），并为图形界面提供这些操作的信息接口。</li>
<li>部件方法hasTabletTracking()用于返回当前是否启用平板跟踪。</li>
<li>setTabletTracking(bool enable)用于设置是否启用平板跟踪。</li>
<li>与平板跟踪相关的函数主要是tabletEvent()。</li>
</ul>
<ol start="188" type="1">
<li><p>关于QTableWidget等控件调用自带的removeRow、clearContents、clear函数删除了里面的item和内容，会自动调用item或者cellwidget的析构函数进行资源释放，不用自己手动再去释放。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次调用 clearContents 都会自动清理之前的item</span></span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">clearContents</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(i, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;aaa&quot;</span>));</span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(i, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setCellWidget</span>(i, <span class="number">2</span>, <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;ccc&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QCheckBox::indicator,QGroupBox::indicator,QTreeWidget::indicator,QListWidget::indicator&#123;</span><br><span class="line">width:<span class="number">13</span>px;</span><br><span class="line">height:<span class="number">13</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QCheckBox::indicator:unchecked,QGroupBox::indicator:unchecked,QTreeWidget::indicator:unchecked,QListWidget::indicator:unchecked&#123;</span><br><span class="line">image:<span class="built_in">url</span>(:/qss/flatwhite/checkbox_unchecked.png);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QCheckBox::indicator:unchecked:disabled,QGroupBox::indicator:unchecked:disabled,QTreeWidget::indicator:unchecked:disabled,QListWidget::indicator:disabled&#123;</span><br><span class="line">image:<span class="built_in">url</span>(:/qss/flatwhite/checkbox_unchecked_disable.png);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QCheckBox::indicator:checked,QGroupBox::indicator:checked,QTreeWidget::indicator:checked,QListWidget::indicator:checked&#123;</span><br><span class="line">image:<span class="built_in">url</span>(:/qss/flatwhite/checkbox_checked.png);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QCheckBox::indicator:checked:disabled,QGroupBox::indicator:checked:disabled,QTreeWidget::indicator:checked:disabled,QListWidget::indicator:checked:disabled&#123;</span><br><span class="line">image:<span class="built_in">url</span>(:/qss/flatwhite/checkbox_checked_disable.png);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QCheckBox::indicator:indeterminate,QGroupBox::indicator:indeterminate,QTreeWidget::indicator:indeterminate,QListWidget::indicator:indeterminate&#123;</span><br><span class="line">image:<span class="built_in">url</span>(:/qss/flatwhite/checkbox_parcial.png);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QCheckBox::indicator:indeterminate:disabled,QGroupBox::indicator:indeterminate:disabled,QTreeWidget::indicator:indeterminate:disabled,QListWidget::indicator:indeterminate:disabled&#123;</span><br><span class="line">image:<span class="built_in">url</span>(:/qss/flatwhite/checkbox_parcial_disable.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">frmSimple::initForm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实例化数据模型</span></span><br><span class="line">    model = <span class="keyword">new</span> <span class="built_in">QStandardItemModel</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置行数列数</span></span><br><span class="line">    row = <span class="number">100</span>;</span><br><span class="line">    column = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//设置列名列宽</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; column; ++i) &#123;</span><br><span class="line">        columnNames &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;列%1&quot;</span>).<span class="built_in">arg</span>(i + <span class="number">1</span>);</span><br><span class="line">        columnWidths &lt;&lt; <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">frmSimple::on_btnLoad1_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先设置数据模型,否则 setColumnWidth 不起作用</span></span><br><span class="line">    ui-&gt;tableView-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置列数及列标题和列宽</span></span><br><span class="line">    model-&gt;<span class="built_in">setColumnCount</span>(column);</span><br><span class="line">    <span class="comment">//简便方法设置列标题集合</span></span><br><span class="line">    model-&gt;<span class="built_in">setHorizontalHeaderLabels</span>(columnNames);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; column; ++i) &#123;</span><br><span class="line">        ui-&gt;tableView-&gt;<span class="built_in">setColumnWidth</span>(i, columnWidths.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环添加行数据</span></span><br><span class="line">    QDateTime now = QDateTime::<span class="built_in">currentDateTime</span>();</span><br><span class="line">    model-&gt;<span class="built_in">setRowCount</span>(row);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; column; ++j) &#123;</span><br><span class="line">            QStandardItem *item = <span class="keyword">new</span> QStandardItem;</span><br><span class="line">            <span class="comment">//最后一列显示时间区别开来</span></span><br><span class="line">            <span class="keyword">if</span> (j == column - <span class="number">1</span>) &#123;</span><br><span class="line">                item-&gt;<span class="built_in">setText</span>(now.<span class="built_in">addSecs</span>(i).<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                item-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;%1_%2&quot;</span>).<span class="built_in">arg</span>(i + <span class="number">1</span>).<span class="built_in">arg</span>(j + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            model-&gt;<span class="built_in">setItem</span>(i, j, item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">frmSimple::on_btnLoad2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置列标题和列数及列宽</span></span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setColumnCount</span>(column);</span><br><span class="line">    <span class="comment">//简便方法设置列标题集合</span></span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setHorizontalHeaderLabels</span>(columnNames);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; column; ++i) &#123;</span><br><span class="line">        ui-&gt;tableWidget-&gt;<span class="built_in">setColumnWidth</span>(i, columnWidths.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据</span></span><br><span class="line">    QDateTime now = QDateTime::<span class="built_in">currentDateTime</span>();</span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setRowCount</span>(row);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; column; ++j) &#123;</span><br><span class="line">            QTableWidgetItem *item = <span class="keyword">new</span> QTableWidgetItem;</span><br><span class="line">            <span class="comment">//最后一列显示时间区别开来</span></span><br><span class="line">            <span class="keyword">if</span> (j == column - <span class="number">1</span>) &#123;</span><br><span class="line">                item-&gt;<span class="built_in">setText</span>(now.<span class="built_in">addSecs</span>(i).<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                item-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;%1_%2&quot;</span>).<span class="built_in">arg</span>(i + <span class="number">1</span>).<span class="built_in">arg</span>(j + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(i, j, item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="section-19">20：191-200</h3>
<ol start="191" type="1">
<li><p>关于QList队列的处理中，我们最常用的就是调用append函数添加item，往前插入item很多人第一印象就是调用insert(0,xxx)来插入，其实QList完全提供了往前追加item的函数prepend、push_front。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QStringList list;</span><br><span class="line">list &lt;&lt; <span class="string">&quot;aaa&quot;</span> &lt;&lt; <span class="string">&quot;bbb&quot;</span> &lt;&lt; <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往后追加 等价于 append</span></span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"><span class="comment">//往前追加 等价于 prepend</span></span><br><span class="line">list.<span class="built_in">push_front</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//往后追加</span></span><br><span class="line">list.<span class="built_in">append</span>(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"><span class="comment">//往前追加</span></span><br><span class="line">list.<span class="built_in">prepend</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定第一个位置插入 等价于 prepend</span></span><br><span class="line">list.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 QList(&quot;xxx&quot;, &quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;)</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; list;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//qwindowdefs.h</span></span><br><span class="line"><span class="keyword">typedef</span> QList&lt;QWidget *&gt; QWidgetList;</span><br><span class="line"><span class="keyword">typedef</span> QList&lt;QWindow *&gt; QWindowList;</span><br><span class="line"><span class="keyword">typedef</span> QHash&lt;WId, QWidget *&gt; QWidgetMapper;</span><br><span class="line"><span class="keyword">typedef</span> QSet&lt;QWidget *&gt; QWidgetSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//qmetatype.h</span></span><br><span class="line"><span class="keyword">typedef</span> QList&lt;QVariant&gt; QVariantList;</span><br><span class="line"><span class="keyword">typedef</span> QMap&lt;QString, QVariant&gt; QVariantMap;</span><br><span class="line"><span class="keyword">typedef</span> QHash&lt;QString, QVariant&gt; QVariantHash;</span><br><span class="line"><span class="keyword">typedef</span> QList&lt;QByteArray&gt; QByteArrayList;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值。</p></li>
<li><p>Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5.6开始提供了 AA_EnableHighDpiScaling 的属性设置开启高分屏，到了5.14以后还可以指定缩放的策略 HighDpiScaleFactorRoundingPolicy 比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了 AA_EnableHighDpiScaling 属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//永远不应用高分屏及缩放</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    QApplication::<span class="built_in">setAttribute</span>(Qt::AA_Use96Dpi);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,14,0))</span></span><br><span class="line">    QApplication::<span class="built_in">setHighDpiScaleFactorRoundingPolicy</span>(Qt::HighDpiScaleFactorRoundingPolicy::Floor);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动应用高分屏及缩放</span></span><br><span class="line"><span class="comment">//方法很多，综合对比下来还是采用配置文件指定缩放策略最适中。</span></span><br><span class="line"><span class="comment">//新建qt.conf文件放到可执行文件同一目录</span></span><br><span class="line">[Platforms]</span><br><span class="line">WindowsArguments = dpiawareness=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有时候想让用户去选择何种策略，需要开启高分屏的之后只需要将qt.conf文件放到可执行文件同一目录即可，就算代码中设置了不应用高分屏及缩放，也无效，也是优先取qt.conf文件的策略。</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>关于QSS要注意的坑。</p></li>
</ol>
<ul>
<li>qss源自css，相当于css的一个子集，主要支持的是css2标准，很多网上的css3的标准的写法在qss这里是不生效的，所以不要大惊小怪。</li>
<li>qss也不是完全支持所有的css2，比如text-align官方文档就有说明，只支持 QPushButton and QProgressBar，务必看清楚。</li>
<li>有时候偷懒直接来一句 *{xxx}，你会发现大部分是应用了，也有小部分或者极个别没有应用，你可能需要在对应的窗体中 this-&gt;setStyleSheet() 来设置。</li>
<li>qss的执行是有优先级的，如果没有指定父对象，则对所有的应用，比如在窗体widget中 {color:#ff0000;} 这样会对widget以及widget的所有子对象应用该样式，这种问题各大群每周都有人问，你会发现各种奇奇怪怪的异样不正常，怎么办呢，你需要指定类名或者对象名，比如 #widget{color:#ff0000;} 这样就只会对widget对象应用该样式，另一种写法 QWidget#widget{color:#ff0000;}，只想对窗体本身而不是子控件按钮标签等 .QWidget{color:#ff0000;} ，具体详细规则参见官方说明。</li>
<li>qss整体来说还是可以的，解析速度性能在Qt5高版本后期比Qt4好很多，尤其是修复了不少qss中的解析绘制BUG。尽管有这样那样的BUG，怀着包容的心对待它。</li>
<li>qss官方学习地址1：<a href="http://47.100.39.100/qtwidgets/stylesheet-reference.html">http://47.100.39.100/qtwidgets/stylesheet-reference.html</a></li>
<li>qss官方学习地址2：<a href="http://47.100.39.100/qtwidgets/stylesheet-examples.html">http://47.100.39.100/qtwidgets/stylesheet-examples.html</a></li>
</ul>
<ol start="196" type="1">
<li><p>关于Qt延时的几种方法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QUIHelperCore::sleep</span><span class="params">(<span class="type">int</span> msec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msec &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">//非阻塞方式延时,现在很多人推荐的方法</span></span><br><span class="line">    QEventLoop loop;</span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(msec, &amp;loop, <span class="built_in">SLOT</span>(<span class="built_in">quit</span>()));</span><br><span class="line">    loop.<span class="built_in">exec</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    <span class="comment">//阻塞方式延时,如果在主线程会卡住主界面</span></span><br><span class="line">    QThread::<span class="built_in">msleep</span>(msec);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//非阻塞方式延时,不会卡住主界面,据说可能有问题</span></span><br><span class="line">    QTime endTime = QTime::<span class="built_in">currentTime</span>().<span class="built_in">addMSecs</span>(msec);</span><br><span class="line">    <span class="keyword">while</span> (QTime::<span class="built_in">currentTime</span>() &lt; endTime) &#123;</span><br><span class="line">        QCoreApplication::<span class="built_in">processEvents</span>(QEventLoop::AllEvents, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>随着国产化的兴起，各种国产系统和国产数据库等逐渐进入开发者的世界，罗列几个要点。</p></li>
</ol>
<ul>
<li>中标麒麟neokylin基于centos。</li>
<li>银河麒麟kylin早期版本比如V2基于freebsd，新版本V4、V10基于ubuntu。</li>
<li>优麒麟ubuntukylin就是ubuntu的汉化版本，加了点农历控件啥的。</li>
<li>deepin基于debian。</li>
<li>uos基于deepin或者说是deepin的商业分支。</li>
<li>ubuntu基于debian。</li>
<li>linux界主要分两种发行版本，debian（ubuntu、deepin、uos、银河麒麟kylin等）和redhat（fedora、centos、中标麒麟neokylin、中兴新支点newstart等），分别对应apt-get和yum安装命令。绝大部分的linux系统都基于或者衍生自这两种发行版本。</li>
<li>理论上基于同一种系统内核的，在其上编译的程序可以换到另外的系统运行，前提是编译器版本一致，比如都是gcc4.9，在ubuntu14.04 64位用gcc4.9编译的Qt程序，是能够在uos 64位上运行的。</li>
<li>高版本编译器的系统一般能够兼容低版本的，比如你用gcc4.9编译的程序是能够在gcc7.0上运行，反过来不行。</li>
<li>意味着如果你想尽可能兼容更多的系统，尽量用低版本的编译器编译你的程序，当然要你的程序代码语法支持，比如c++11就要从gcc4.7开始才支持，如果你的代码用了c++11则必须至少选择gcc4.7版本及以上。</li>
<li>用Qt编写linux程序为了发布后的可执行文件可以兼容各种linux系统，只要在这两种内核（debian、redhat）的系统上用低版本的编译器比如gcc4.7编译qt程序发布即可。</li>
<li>2022-01-27补充：根据Qt官方安装包（关于对话框），发现基于redhat和gcc4.9（后面Qt5.14/5.15带的qtc采用gcc5.3）编译器发布的，通用各种linux系统（亲测ubuntu各个版本、fedora、centos、deepin、uos、银河麒麟kylin、中标麒麟neokylin、中兴新支点newstart等），自己按照这个版本也亲测打包发布了，亲测可用，我擦，redhat系统的也可以在debian系统跑。</li>
<li>2022-02-10补充：debian上静态编译的程序也可以在redhat系统跑，可能静态编译去掉了很多依赖吧。</li>
<li>2022-03-01补充：低调大佬补充，如果没有特定的依赖关系，高版本的编译器编译的程序也可以在低版本编译器的系统运行，比如alpine Linux下用gcc11/clang13编译生成的可执行二进制，依然可以在cenos5/ubuntu10上运行。并不是编译器版本的问题，也不是C++11特性的问题，这个问题涉及到太多，内核版本、gnu libc、ABI兼容等等，两句话说不清。</li>
<li>按照QtCreator软件采用的编译器环境规则，一般来说就是低版本的可以在高版本运行，比如Qt5可以在ubuntu14/16/18/20运行，但是高版本编译器编译的就无法在低版本编译器系统运行，会提示缺少GLBC、LIBCXX、symbol xxxxxx等，比如Qt6可以在ubuntu20运行而无法在ubuntu18/16/14等运行。</li>
<li>在uos上做开发，建议采用系统自带的Qt库环境开发，以及命令行安装开发环境，不建议使用Qt官方的安装包搭建环境，因为uos的Qt是魔改过的，用Qt官方的标准安装包的环境开发出来的程序，打包发布很可能会有依赖问题而无法运行，而用系统自带的就不存在这个问题。</li>
<li>国产人大金仓数据库用的是postgresql数据库改的，意味着你在Qt中用postgresql数据库插件也是能够连接到人大金仓数据库的。</li>
<li>以上未必完全正确，欢迎各位指正。</li>
</ul>
<ol start="198" type="1">
<li><p>纵观Qt的发展历史，也几乎经历着合久必分、分久必合的逻辑，比如最开始QPushButton等UI控件类都是在QtGui模块中，后面越发臃肿不方便管理和升级迭代，又分离出一个QtWidgets模块；到Qt6又将QList和QVector合并了成了一个类，搞得像分久必合；而且一些数学函数以及封装的c++标准函数库的方法，逐渐放弃了Qt自己的封装改用c++标准函数库，从开始的分到现在的合统一。</p></li>
<li><p>Qt一直在持续升级迭代，尽管新增加的代码质量明显不如诺基亚时代，但最起码有行动，慢慢完善。目前主要的升级改善在qml模块，底层也有完善，毕竟无论是widget还是qml都是公用一套底层逻辑类，底层基础一定要扎实稳固，个人这几年一直对比测试过不同Qt版本（从旧版本到新版本）很多类和函数的性能，发现官网列出来的新版本对应类和方法的性能提升改善，确实没有说谎，至于提升了多少这块有没有吹牛逼那就不清楚。</p></li>
</ol>
<ul>
<li>base64算法性能提升很大。</li>
<li>QStringList等凡是使用了QList相关的类，性能提升巨大。</li>
<li>对比测试大概从5.12版本开始QStringList和QMap性能相当。</li>
<li>早期版本QStringList如果查找的值先插入则时间越短，QMap则没有这个区别。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QStringList list1, list2;</span><br><span class="line">QMap&lt;QString, QString&gt; map;</span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        QString s1 = <span class="built_in">QString</span>(<span class="string">&quot;%1&quot;</span>).<span class="built_in">arg</span>(i);</span><br><span class="line">        QString s2 = <span class="built_in">QString</span>(<span class="string">&quot;A%1&quot;</span>).<span class="built_in">arg</span>(i);</span><br><span class="line">        list1 &lt;&lt; s1;</span><br><span class="line">        list2 &lt;&lt; s2;</span><br><span class="line">        map.<span class="built_in">insert</span>(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;111&quot;</span> &lt;&lt; time.<span class="built_in">nsecsElapsed</span>() &lt;&lt; list2.<span class="built_in">at</span>(list1.<span class="built_in">indexOf</span>(<span class="string">&quot;9999&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;222&quot;</span> &lt;&lt; time.<span class="built_in">nsecsElapsed</span>() &lt;&lt; map.<span class="built_in">value</span>(<span class="string">&quot;9999&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="200" type="1">
<li>关于QtCreator中三种不同编译版本 debug、release、profile 的区别。</li>
</ol>
<ul>
<li>debug调试模式，编译后的可执行文件很大，带了很多调试符号信息等，方便开发阶段调试的时候进入具体的堆栈查看值。会打开所有的断言，运行阶段性能差速度慢，可能会有卡顿感觉。</li>
<li>release发布模式，编译后的可执行文件很小，不带任何调试符号信息，一般用于打包发布程序。由于经过了各种优化，会关闭所有断言，运行阶段性能最好，如果有卡顿那肯定是你的程序问题。</li>
<li>profile概述模式，编译后的可执行文件比debug小很多比release大一点，带有部分调试符号信息，在debug和release之间取一个平衡，兼顾性能和调试，性能更优但是又方便调试。</li>
<li>使用Qt5.7版本对应三种模式编译的空白窗体程序大小：debug（1319kb）、release（24kb）、profile（90kb）。</li>
<li>debug链接的库是带d结尾的，release和profile链接的库是不带d结尾的，很多人以为profile链接的是带d结尾的其实是错误的。</li>
<li>新的Qt在线安装程序在安装的时候，可以勾选是否安装debug调试库（对应lib目录下一堆带d结尾的文件），以前的版本是默认都安装，现在可选安装以便减少体积。</li>
<li>无论是否安装了debug调试库，你都可以选择debug模式生成对应debug的文件，这个不知道怎么做到的。</li>
<li>无论是哪种模式，都可以在程序中开启日志钩子输出日志信息，方便收集运行阶段的各种信息反馈给开发人员查看问题。</li>
<li>最初的开发工具一般是具有debug和release两种模式，随着用户需求的增加和场景的需要，部分开发工具衍生出了profile模式，更有甚者比如flutter还有第四种test模式。</li>
</ul>
<h3 id="section-20">21：201-210</h3>
<ol start="201" type="1">
<li><p>编译生成debug版本动态库，文件末尾自动加上d结尾。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CONFIG</span>(debug, debug|release) &#123;</span><br><span class="line">    win32:      TARGET = $$<span class="built_in">join</span>(TARGET,,,d)</span><br><span class="line">    mac:        TARGET = $$<span class="built_in">join</span>(TARGET,,,_debug)</span><br><span class="line">    unix:!mac:  TARGET = $$<span class="built_in">join</span>(TARGET,,,d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>QtCreator中pro项目文件格式说明。</p></li>
</ol>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">名称</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">QT += core gui</td>
<td style="text-align: left;">添加本项目中需要的模块，影响后面代码文件include的时候自动弹出下拉选择，如果pro文件没有引入该模块则无法自动语法提示，一般打包发布的时候对应动态库文件比如 Qt5Core.dll。</td>
</tr>
<tr class="even">
<td style="text-align: left;">TARGET = xxx</td>
<td style="text-align: left;">生成最后目标文件的名字，可以是可执行文件或者库文件。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TEMPLATE = app</td>
<td style="text-align: left;">项目程序的生成模式，默认是app表示生成可执行文件程序，如果是动态库项目就是 TEMPLATE = lib。</td>
</tr>
<tr class="even">
<td style="text-align: left;">CONFIG += qaxcontainer</td>
<td style="text-align: left;">引入一些配置，在Qt4的时候还用来引入一些模块，其中有部分改成了QT += 方式引入，比如Qt5引入本地activex控件支持改成了QT += qaxcontainer。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DEFINES += xxx</td>
<td style="text-align: left;">项目中自定义的一些定义，可以在代码文件中识别，通常用来定义一些不同平台的处理，根据项目需要自己定义任何标识。</td>
</tr>
<tr class="even">
<td style="text-align: left;">HEADERS += head.h</td>
<td style="text-align: left;">项目中用到的头文件，一般拓展名是.h，可以写在一行也可以分行写，分行要用  斜杠结束。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SOURCES += main.cpp</td>
<td style="text-align: left;">项目中用到的实现文件，一般拓展名是.cpp，可以写在一行也可以分行写，分行要用  斜杠结束。</td>
</tr>
<tr class="even">
<td style="text-align: left;">FORMS += Form.ui</td>
<td style="text-align: left;">项目中用到的UI文件，一般拓展名是.ui，可以写在一行也可以分行写，分行要用  斜杠结束。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">RESOURCES += main.qrc</td>
<td style="text-align: left;">项目中用到的资源文件，可以多个，写代码使用对应资源文件中的文件时候务必记得资源文件中的前缀。</td>
</tr>
<tr class="even">
<td style="text-align: left;">LIBS += -L<span class="math display">\[PWD/ -lavformat -lavcodec|项目中编译时候链接依赖的库，一般是 .lib .a .dylib 文件，可以写在一行，省略文件名的lib打头部分，也可以分多行绝对路径和全名称。|
|DESTDIR += \]</span>PWD/bin</td>
<td style="text-align: left;">目标生成路径，<span class="math display">\[PWD表示当前目录，一般建议生成的最终文件重定向到另外目录存放，好找，不然一堆临时文件在里面有时候文件太多好难找。|
|INCLUDEPATH += \]</span>PWD/include</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DEPENDPATH +=</td>
<td style="text-align: left;">工程的依赖路径，用的比较少，一般涉及到引入链接库的时候可能需要。</td>
</tr>
<tr class="even">
<td style="text-align: left;">include($$PWD/3rd.pri)</td>
<td style="text-align: left;">引入pri模块文件，pri最大的好处就是分目录管理文件，通用的轮子模块可以放到一个目录下，然后用pri统一管理，可以给多个项目公用。</td>
</tr>
</tbody>
</table>
<p><strong>官方详细地址<a href="https://doc.qt.io/qt-5/qmake-variable-reference.html">https://doc.qt.io/qt-5/qmake-variable-reference.html</a></strong></p>
<ol start="203" type="1">
<li><p>如果发现之前编译正常，突然之间再编译就一直死循环的样子，停留在一行提示并疯狂不停的打印，或者提示文件时间在未来，这说明你很可能改过开发环境的时间（比如测试某个授权文件失效），导致有修改过文件的保存时间在未来，你只需要将时间调整回来，将最后更新时间不正确的代码文件重新保存下就行。Qt的增量编译是根据文件的最后修改时间来判定的，最后的修改时间比上一次的修改时间还要新则认为该文件被修改过，需要重新编译该文件。</p></li>
<li><p>Qt的构建套件一般是在安装Qt开发环境的时候自动设置的，当然也可以手动设置，手动设置的时候千万要注意编译器和Qt库必须一致，否则该构建套件是有问题的，千万不能乱设置，尤其是对构建套件命名的时候最好标明qt版本和编译器版本，最好也要一致，不要说名称叫msvc而编译器选择的确是mingw，这样尽管能正常使用该构建套件，但是会造成一种误解，还以为该套件是msvc的，其实里面是mingw的。有个qter说他的qt坏了，死活编译失败，远程一看，尼玛，构建套件名称写的qt_msvc2019 编译器选择的msvc2015（他电脑只安装了vs2015），qt库选择的mingw！差点狂扇自己八个耳光，太离谱了！</p></li>
<li><p>当你编译Qt程序发现编译通不过提示报错，而且报错提示在Qt的头文件的时候，不要去尝试着修改Qt头文件来编译通过，那样没用的，你使用的Qt的库是已经根据原始的头文件编译好的。如果报错提示在编译生成的临时的moc等文件，你也不要尝试去修改他，那个是临时文件，这次你改好了也许编译通过了，你重新编一下又覆盖了还是旧的错误。总之你要从源头（你的代码）找问题。</p></li>
<li><p>有时候需要对文本进行分散对齐显示，相当于无论文字多少，尽可能占满整个空间平摊占位宽度，但是在对支持对齐方式的控件比如QLabel调用 setAlignment(Qt::AlignJustify | Qt::AlignVCenter) 设置分散对齐会发现没有任何效果，这个时候就要考虑另外的方式比如通过控制字体的间距来实现分散对齐效果。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString text = <span class="string">&quot;测试分散对齐内容&quot;</span>;</span><br><span class="line"><span class="comment">//计算当前文本在当前字体下占用的宽度</span></span><br><span class="line">QFont font = ui-&gt;label-&gt;<span class="built_in">font</span>();</span><br><span class="line"><span class="type">int</span> textWidth = ui-&gt;label-&gt;<span class="built_in">fontMetrics</span>().<span class="built_in">width</span>(text);</span><br><span class="line"><span class="comment">//显示文本的区域宽度=标签的宽度-两边的边距</span></span><br><span class="line"><span class="type">int</span> width = ui-&gt;label-&gt;<span class="built_in">width</span>() - <span class="number">12</span>;</span><br><span class="line"><span class="comment">//需要-1相当于中间有几个间隔</span></span><br><span class="line"><span class="type">int</span> count = text.<span class="built_in">count</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//计算每个间距多少</span></span><br><span class="line">qreal space = <span class="built_in">qreal</span>(width - textWidth) / count;</span><br><span class="line"><span class="comment">//设置固定间距</span></span><br><span class="line">font.<span class="built_in">setLetterSpacing</span>(QFont::AbsoluteSpacing, space);</span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setText</span>(text);</span><br></pre></td></tr></table></figure></p></li>
<li><p>随着需求的不断增加，程序不断变大，用到的动态库也越来越多，到了发布程序的时候你会发现和可执行文件同一目录下文件数量真多，此时可能会考虑如何将一些库文件分门别类的存放，这样方便管理。</p></li>
</ol>
<ul>
<li>Qt提供的设置动态库路径的方法setLibraryPaths是用来搜索插件动态库的，而不是程序直接依赖的动态库。</li>
<li>很多人以为这个可以设置Qt的库或者程序中依赖的第三方库的路径，其实想想也知道，因为程序依赖这个库，找不到的话根本跑不起来，程序跑不起来怎么应用执行这个代码呢？</li>
<li>Qt默认是可用通过setLibraryPaths的方式设置Qt插件的动态库目录位置，比如数据库插件sqldrivers，因为这些库文件是真正在Qt程序跑起来以后通过插件形式去加载的。</li>
<li>还可以通过qt.conf文件设置 Plugins="config" 指定所有插件在可执行文件下的config目录下。</li>
<li>要想设置程序直接依赖的动态库在其他目录，找遍全宇宙也只有一个办法，那就是设置环境变量，除此别无他法。</li>
<li>至于如何设置环境变量方式很多，比如手动在电脑上设置，或者搞个批处理文件执行命令行，在程序安装的时候自动执行，或者程序打包目录下用户手动运行这个批处理。</li>
<li>大神补充：设置插件的目录还可以通过在main函数最前面写 qputenv("PATH", QString("%1;%2").arg(qgetenv("PATH"), pluginFileInfo.path()).toLocal8Bit()); 来实现。</li>
<li>网友补充：最终找插件的路径其实就是这个 QT_PLUGIN_PATH 环境变量。</li>
</ul>
<ol start="208" type="1">
<li><p>进度条控件如果设置的垂直方向，就算你设置了文本可见，会发现根本看不到进度文本，经过多方百折不挠的试探，以及和酷码大佬深入的探讨，发现只要设置下border样式（border:1px solid #ff0000、border:none、border-style:solid、border-radius:0px 任意一种）就行，就可以把文本显示出来，这TM就不知道Qt为什么总是不统一规则，这个BUG通用于任何版本，这个可能是因为边框的solid样式冲突了导致无法继续绘制，确切的说这必须是BUG，这个锅Qt必须背。</p></li>
<li><p>我们在使用QFileDialog::getOpenFileName、QFileDialog::getExistingDirectory等方法时，有时候会发现首次打开很卡，尤其是在默认目录很多文件的时候，此时你可以考虑设置这些函数最末尾的参数为QFileDialog::DontUseNativeDialog，表示不采用本地系统对话框，这样的话会采用Qt的对话框，速度快很多，估计系统的对话框在打开的时候会做很多初始化加载处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, QFileDialog::DontUseNativeDialog);</span><br><span class="line">QFileDialog::<span class="built_in">getExistingDirectory</span>(<span class="keyword">this</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, QFileDialog::DontUseNativeDialog);</span><br></pre></td></tr></table></figure></p></li>
<li><p>滑块控件QSlider，如果设置的垂直样式，其进度颜色和剩余颜色，刚好和横向样式的颜色相反的，不确定这个是否是Qt的BUG，Qt456都是这个现象。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QSlider::groove:horizontal&#123;</span><br><span class="line">height:<span class="number">8</span>px;</span><br><span class="line">background:#FF0000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QSlider::add-page:horizontal&#123;</span><br><span class="line">height:<span class="number">8</span>px;</span><br><span class="line">background:#FF0000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QSlider::sub-page:horizontal&#123;</span><br><span class="line">height:<span class="number">8</span>px;</span><br><span class="line">background:#<span class="number">00F</span>F00;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QSlider::handle:horizontal&#123;</span><br><span class="line">width:<span class="number">10</span>px;</span><br><span class="line">background:#<span class="number">0000F</span>F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QSlider::groove:vertical&#123;</span><br><span class="line">width:<span class="number">8</span>px;</span><br><span class="line">background:#FF0000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QSlider::add-page:vertical&#123;</span><br><span class="line">width:<span class="number">8</span>px;</span><br><span class="line">background:#<span class="number">00F</span>F00;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QSlider::sub-page:vertical&#123;</span><br><span class="line">width:<span class="number">8</span>px;</span><br><span class="line">background:#FF0000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QSlider::handle:vertical&#123;</span><br><span class="line">height:<span class="number">10</span>px;</span><br><span class="line">background:#<span class="number">0000F</span>F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="section-21">22：211-220</h3>
<ol start="211" type="1">
<li><p>QMainWindow 在对停靠窗体进行排列的时候，有些不常用的设置容易遗忘，建议将 QMainWindow 的头文件函数过一遍一目了然。详细介绍各种停靠参数文章参见 <a href="https://zhuanlan.zhihu.com/p/388544168">https://zhuanlan.zhihu.com/p/388544168</a>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置允许各种嵌套比如上下排列左右排列非常灵活</span></span><br><span class="line"><span class="comment">//此设置会和下面的 setDockOptions 中的参数覆盖所以要注意顺序</span></span><br><span class="line"><span class="comment">//this-&gt;setDockNestingEnabled(true);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置停靠参数,不允许重叠,只允许拖动和嵌套</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setDockOptions</span>(AnimatedDocks | AllowNestedDocks);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将底部左侧作为左侧区域，底部右侧作为右侧区域，否则底部区域会填充拉伸</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setCorner</span>(Qt::BottomLeftCorner, Qt::LeftDockWidgetArea);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setCorner</span>(Qt::BottomRightCorner, Qt::RightDockWidgetArea);</span><br></pre></td></tr></table></figure></p></li>
<li><p>当我们在对QModelIndex取数据的时候，常规的角色的数据（QVariant类型支持to的比如toString、toInt、toDouble等）可以很方便的取出来，特定的数据类型需要用的万能取值模板函数 T value() 取出来。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示文本</span></span><br><span class="line">QString text = index.<span class="built_in">data</span>(Qt::DisplayRole).<span class="built_in">toString</span>();</span><br><span class="line"><span class="comment">//文本对齐</span></span><br><span class="line"><span class="type">int</span> align = index.<span class="built_in">data</span>(Qt::TextAlignmentRole).<span class="built_in">toInt</span>();</span><br><span class="line"><span class="comment">//文字字体</span></span><br><span class="line">QFont font = index.<span class="built_in">data</span>(Qt::FontRole).<span class="built_in">value</span>&lt;QFont&gt;();</span><br><span class="line"><span class="comment">//前景色</span></span><br><span class="line">QColor color = index.<span class="built_in">data</span>(Qt::ForegroundRole).<span class="built_in">value</span>&lt;QColor&gt;();</span><br><span class="line"><span class="comment">//背景色</span></span><br><span class="line">QColor color = index.<span class="built_in">data</span>(Qt::BackgroundRole).<span class="built_in">value</span>&lt;QColor&gt;();</span><br></pre></td></tr></table></figure></p></li>
<li><p>很多人以为拖曳只要在dropEvent事件就可以了，其实不行的，没有效果的，需要先在dragEnterEvent事件中执行event-&gt;accept()才行，不然根本没有效果，很多人尤其是初学者都挂在这里，我就是在这里摔了一跤，好疼！ <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">frmMain::dropEvent</span><span class="params">(QDropEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QList&lt;QUrl&gt; urls = event-&gt;<span class="built_in">mimeData</span>()-&gt;<span class="built_in">urls</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">frmMain::dragEnterEvent</span><span class="params">(QDragEnterEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">mimeData</span>()-&gt;<span class="built_in">hasFormat</span>(<span class="string">&quot;application/x-qabstractitemmodeldatalist&quot;</span>)) &#123;</span><br><span class="line">        event-&gt;<span class="built_in">setDropAction</span>(Qt::MoveAction);</span><br><span class="line">        event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt5.6以后内置的是webengine浏览器内核，如果需要做web交互的话必须用到 qwebchannel.js 这个文件，此文件是Qt官方提供的，所以不建议去改动其中的源码，要注意的是，由于官方对webengine的支持在不断更新，所以官方提供的对应Qt版本的 qwebchannel.js 文件也不同，意味着你要用对应提供的版本的 qwebchannel.js 文件才ok，该文件默认在 C:.11.11目录下。经过几十个Qt版本的测试发现，用高版本的 qwebchannel.js 放到低版本运行不行，低版本放到高版本可以，为了万无一失还是建议直接用对应版本的。</p></li>
<li><p>对于QString去除空格，有多种场景，可能需要去除左侧、右侧、所有等位置的空格。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串去空格 -1=移除左侧空格 0=移除所有空格 1=移除右侧空格 2=移除首尾空格 3=首尾清除中间留一个空格</span></span><br><span class="line"><span class="function">QString <span class="title">QUIHelperData::trimmed</span><span class="params">(<span class="type">const</span> QString &amp;text, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString temp = text;</span><br><span class="line">    QString pattern;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">-1</span>) &#123;</span><br><span class="line">        pattern = <span class="string">&quot;^ +\\s*&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">        pattern = <span class="string">&quot;\\s&quot;</span>;</span><br><span class="line">        <span class="comment">//temp.replace(&quot; &quot;, &quot;&quot;);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">        pattern = <span class="string">&quot;\\s* +$&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">        temp = temp.<span class="built_in">trimmed</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>) &#123;</span><br><span class="line">        temp = temp.<span class="built_in">simplified</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用正则表达式移除空格</span></span><br><span class="line">    <span class="keyword">if</span> (!pattern.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">        temp.<span class="built_in">remove</span>(<span class="built_in">QRegularExpression</span>(pattern));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        temp.<span class="built_in">remove</span>(<span class="built_in">QRegExp</span>(pattern));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">QString text = <span class="string">&quot;  a  b  c d  &quot;</span>;</span><br><span class="line"><span class="comment">//结果：a  b  c d  </span></span><br><span class="line">QUIHelper::<span class="built_in">trimmed</span>(text, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">//结果：abcd  </span></span><br><span class="line">QUIHelper::<span class="built_in">trimmed</span>(text, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//结果：  a  b  c d</span></span><br><span class="line">QUIHelper::<span class="built_in">trimmed</span>(text, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//结果：a  b  c d</span></span><br><span class="line">QUIHelper::<span class="built_in">trimmed</span>(text, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//结果：a b c d</span></span><br><span class="line">QUIHelper::<span class="built_in">trimmed</span>(text, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt的网络库支持udp广播搜索和组播搜索，其中组播搜索可以跨网段搜索，有时候你会发现失灵，此时你可以尝试把本地的虚拟机的网卡禁用试试，估计就好了。还有就是在本地开启了代理啥的，先关掉试试。近期在使用tcpsocket连接的时候，发现在Qt4和Qt5中正常的程序，到了Qt6中就不行了，报错提示 The proxy type is invalid for this operation ，原来是本地设置了代理导致的，可能在Qt6以前会默认跳过去不处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//也可以通过代码设置跳过代理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QNetworkProxy&gt;</span></span></span><br><span class="line">QNetworkProxyFactory::<span class="built_in">setUseSystemConfiguration</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//下面这样每次设置也可以</span></span><br><span class="line">tcpSocket-&gt;<span class="built_in">setProxy</span>(QNetworkProxy::NoProxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查阅到文章 https://www.cnblogs.com/cppskill/p/11730452.html</span></span><br><span class="line"><span class="comment">//从5.8开始socket默认代理类型是DefaultProxy而不是NoProxy，不知道出于什么考虑。</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>关于交叉编译，对于初学者来说是个极难跨过去的砍（一旦跨过去了，以后遇到需要交叉编译的时候都是顺水推舟、信手拈来。），因为需要搭建交叉编译环境，好在现在厂家提供的板子基本上都是测试好的环境，尤其是提供的编译器，不用自己再去折腾，按照官方手册来基本上不会有啥的的问题。</p></li>
</ol>
<ul>
<li>在linux系统上编译ffmpeg和qt都是非常简单的事情，初学者也会，前提只要本地的gcc g++编译器正常。</li>
<li>任何编译器包括嵌入式编译器，为了确保环境正常，你可以先查看对应的编译器版本是否ok，g++ -v arm-linux-g++ -v。</li>
<li>交叉编译器查看版本 /opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux-g++ -v 。</li>
<li>编译器位数和操作系统位数有关，一般32位的编译器要在32位的系统上做交叉编译，虽然32位也可以在安装依赖后，在64位系统做交叉编译，但是个人不建议，可能会出问题。64位的编译器只能在64位的系统。</li>
<li>设置了环境变量则可以省略掉长长的路径，直接打可执行文件名称即可，没有设置环境变量则需要打完整路径。</li>
<li>设置环境变量只是为了编译的时候让自动寻找编译器，其实也完全可以不用设置环境变量，使用绝对路径指定编译器位置即可。</li>
<li>在linux上编译，无论是ffmpeg还是qt还是其他，都是通用的步骤，第一步：./configure 第二步：make 第三步：make install 。</li>
<li>至于具体configure后面有哪些参数，参照对应源码包的手册就行，搜索也一大堆。当然你用默认的就不带任何参数一般也可以，自动采用默认参数进行编译。</li>
<li>交叉编译ffmpeg命令：./configure --prefix=host --enable-static --disable-shared --disable-doc --cross-prefix=/opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux- --arch=arm --target-os=linux</li>
<li>交叉编译qt前提：修改mkspecs/qws/linux-arm-g++下面的qmake.conf，如果没有设置环境变量则设置对应编译器的绝对路径，并将编译器的名字改成你需要的。</li>
<li>比如修改gcc编译器：QMAKE_CC = /opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux-gcc</li>
<li>交叉编译qt4.8.5命令：./configure -prefix host -embedded arm -xplatform qws/linux-arm-g++ -release -opensource -confirm-license -qt-sql-sqlite -qt-gfx-linuxfb -plugin-sql-sqlit -no-qt3support -no-phonon -no-svg -no-webkit -no-javascript-jit -no-script -no-scripttools -no-declarative -no-declarative-debug -qt-zlib -no-gif -qt-libtiff -qt-libpng -no-libmng -qt-libjpeg -no-rpath -no-pch -no-3dnow -no-avx -no-neon -no-openssl -no-nis -no-cups -no-dbus -little-endian -qt-freetype -no-opengl -no-glib -nomake demos -nomake examples -nomake docs -nomake tools</li>
<li>交叉编译qt5.9.8命令：./configure -prefix host -xplatform linux-arm-g++ -recheck-all -opensource -confirm-license -optimized-qmake -release -no-separate-debug-info -strip -shared -static -c++std c++1z -no-sse2 -pch -compile-examples -gui -widgets -no-dbus -no-openssl -no-cups -no-opengl -linuxfb -qt-zlib -qt-libpng -qt-libjpeg -qt-freetype</li>
<li>综上所述交叉编译和常规的编译就一个区别，需要手动指定交叉编译器路径。ffmpeg是通过--cross-prefix=指定，qt比较庞大是通过更改配置文件最后通过-xplatform指定配置文件名称。</li>
<li>Qt6的编译比较繁琐，默认用cmake编译，在linux上先用cmake3.19以上版本的源码，用make编译生成cmake，然后再用cmake编译qt生成qmake，最后调用qmake来编译你的qt项目。</li>
<li>编译Qt其实只是想用其中的库，至于demo、doc、tool、example等统统不用，费时费力。所以强烈建议编译的时候去掉，大大加快编译速度。</li>
<li>编译建议用普通用户编译即可，包括解压源码，因为这样编译出来的库普通用户就能用，如果是root管理员编译的则以后都需要管理员权限才行。</li>
<li>很多系统都提供了直接鼠标右键解压，其实也是可以的，就是速度慢，建议用命令行解压和删除目录。</li>
<li>Qt的编译参数每个版本都可能有出入，毕竟一直在更新代码，甚至有些分类描述变了，比如之前-qt-xcb到了5.15改成了-xcb，之前-qt-sql-sqlite改成了-qt-sqlite，一定要看源码下的readme，里面约定了编译环境要求的最低版本，后面qt5开始具体的配置参数有哪些放到了qtbase目录下的config说明。</li>
<li>编译完成使用如果遇到提示 GL/gl.h 错误，需要安装 apt install libgl1-mesa-dev libglu1-mesa-dev 或者 yum install mesa-libGL-devel mesa-libGLU-devel 。</li>
<li>编译参数说明可参考 <a href="https://blog.csdn.net/xi_gua_gua/article/details/53413930">https://blog.csdn.net/xi_gua_gua/article/details/53413930</a>。</li>
</ul>
<ol start="218" type="1">
<li><p>在Qt中设置图片有时候会发现不成功，很可能是因为文件的拓展名不正确导致的，比如jpg的图片拓展名是png，bmp的图片拓展名改成了jpg，QImage、QPixmap传入文件路径加载图片，是通过拓展名去调用对应的图片解析算法，比较傻，但是速度快，不用经过分析具体内部是何种图片格式。如果想要不管拓展名都能保证加载成功，则必须读取图片文件数据加载的方式处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以是资源文件中的图片也可以是本地文件</span></span><br><span class="line">QString fileName = <span class="string">&quot;:/test.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此方式按照拓展名来区分具体格式不准确</span></span><br><span class="line"><span class="comment">//如果拓展名不正确就无法加载成功</span></span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(fileName));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过直接读取图片数据加载保证成功</span></span><br><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">file.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">QByteArray data = file.<span class="built_in">readAll</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 QImage 处理</span></span><br><span class="line">QImage img;</span><br><span class="line">img.<span class="built_in">loadFromData</span>(data);</span><br><span class="line"><span class="comment">//下面这种方式也行</span></span><br><span class="line"><span class="comment">//QImage img = QImage::fromData(data);</span></span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(img));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 QPixmap 处理</span></span><br><span class="line">QPixmap pix;</span><br><span class="line">pix.<span class="built_in">loadFromData</span>(data);</span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setPixmap</span>(pix);</span><br></pre></td></tr></table></figure></p></li>
<li><p>总结几个Qt版本的冷知识。</p></li>
</ol>
<ul>
<li>Qt4.8.7是Qt4的终结版本，是Qt4系列版本中最稳定最经典的（很多嵌入式板子还是用Qt4.8），其实该版本是和Qt5.5差不多时间发布的。参考链接 <a href="https://www.qt.io/blog/2015/05/26/qt-4-8-7-released">https://www.qt.io/blog/2015/05/26/qt-4-8-7-released</a> <a href="https://blog.qt.io/blog/2015/07/01/qt-5-5-released/">https://blog.qt.io/blog/2015/07/01/qt-5-5-released/</a></li>
<li>Qt5.6.3最最后支持xp系统的长期支持版本，Qt5.7.0是最后支持xp系统的非长期支持版本（有可能有极少数函数不支持，个人没遇到过）。</li>
<li>Qt5.12.3是最后提供mysql数据库插件的版本，往后的版本需要自行编译对应的mysql数据库插件，官方安装包不再提供。</li>
<li>Qt5.12.5是最后样式表性能最高的版本，经过酷码大佬查阅代码发现此后版本的样式表源码中为了修复一个bug做了循环嵌套设置，导致性能急剧下降，界面越多性能暴降10倍以上。</li>
<li>Qt5.14.2是最后提供二进制安装包的版本，后面的版本都需要在线安装。</li>
<li>Qt5.15系列是最后支持win7的版本，后面的Qt6系列版本需要更改源码编译才能支持win7，这对于小白来说难于上青天。</li>
<li>Qt6.0/6.1版本其实也是支持win7的，但是因为缺失太多模块，而且BUG成山，大佬说了狗都不用，所以使用此版本没意义。</li>
<li>Qt6不支持win7，是说开发阶段和运行阶段都不支持，无论开发阶段还是运行阶段你都需要Qt的库，只要是Qt的库不支持，到哪里也不支持。</li>
<li>新版的qtc7由于采用Qt6编译，所以也只能在win10及以上运行，意味着你要用新的qtc7+Qt5做开发也必须用win10及以上。</li>
<li>欢迎各位补充，比如哪个版本以后商用需要收费之类的，貌似用Qt4，在不更改Qt本身源码，动态库发布程序，法律风险小一些？</li>
</ul>
<ol start="220" type="1">
<li>Qt官方除了Qt库一直在升级外，对应的集成开发环境也在更新升级，一般会选用最新的Qt库编译新版本，要注意的是，有些人安装的旧版本的qtc，加载比较高版本的Qt库，很容易出现报错提示 Project ERROR: Cannot run compiler 'g++'. Maybe you forgot to setup the environment? 之类的，一般是版本跨度过大，比如用Qt5.5附带的qtc加载Qt5.9的库，导致有些环境识别不到，可能是qtc在新版本中对某些识别处理规则有变动。所以一般建议可以用新的qtc加载旧的Qt库，不建议旧的qtc加载新的Qt库。</li>
</ol>
<h3 id="section-22">23：221-230</h3>
<ol start="221" type="1">
<li><p>在对表格数据模型操作的时候，经常遇到一种场景就是，删除某条记录后，希望重新选中某一行。QTableView、QTableWidget本身就支持多选全选等操作，比如批量删除可以多选。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拿到表格数据模型</span></span><br><span class="line">QAbstractItemModel *model = ui-&gt;tableView-&gt;<span class="built_in">model</span>();</span><br><span class="line"><span class="comment">//主动定位到第三行</span></span><br><span class="line">ui-&gt;tableView-&gt;<span class="built_in">setCurrentIndex</span>(model-&gt;<span class="built_in">index</span>(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//主动定位到最后一行</span></span><br><span class="line">ui-&gt;tableView-&gt;<span class="built_in">setCurrentIndex</span>(model-&gt;<span class="built_in">index</span>(model-&gt;<span class="built_in">rowCount</span>() - <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置选择模式支持多选，其他几个枚举值自行查阅文档。</span></span><br><span class="line">ui-&gt;tableView-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::MultiSelection);</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择全部</span></span><br><span class="line">ui-&gt;tableView-&gt;<span class="built_in">selectAll</span>();</span><br><span class="line"><span class="comment">//取消所有选中</span></span><br><span class="line">ui-&gt;tableView-&gt;<span class="built_in">clearSelection</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//选中行，注意如果该行选中则执行后取消选中，如此往复。这个设计很巧妙，掌声。</span></span><br><span class="line">ui-&gt;tableView-&gt;<span class="built_in">selectRow</span>(row);</span><br><span class="line"><span class="comment">//选中列，注意如果该列选中则执行后取消选中，如此往复。这个设计很巧妙，掌声。</span></span><br><span class="line">ui-&gt;tableView-&gt;<span class="built_in">selectColumn</span>(column);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取选中行的内容</span></span><br><span class="line">QItemSelectionModel *selections = ui-&gt;tableView-&gt;<span class="built_in">selectionModel</span>();</span><br><span class="line">QModelIndexList selected = selections-&gt;<span class="built_in">selectedIndexes</span>();</span><br><span class="line">foreach (QModelIndex index, selected) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; index.<span class="built_in">row</span>() &lt;&lt; index.<span class="built_in">column</span>() &lt;&lt; index.<span class="built_in">data</span>();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>在读取文本文件的时候，有时候会发现读取出来的中文乱码，这个时候就需要识别文件编码格式，然后主动设置对应的编码去读取就不会乱码。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查文件编码 0=ANSI 1=UTF-16LE 2=UTF-16BE 3=UTF-8 4=UTF-8BOM</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DataCsv::findCode</span><span class="params">(<span class="type">const</span> QString &amp;fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//假定默认编码utf8</span></span><br><span class="line">    <span class="type">int</span> code = <span class="number">3</span>;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">open</span>(QIODevice::ReadOnly)) &#123;</span><br><span class="line">        <span class="comment">//读取3字节用于判断</span></span><br><span class="line">        QByteArray buffer = file.<span class="built_in">read</span>(<span class="number">3</span>);</span><br><span class="line">        quint8 b1 = buffer.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">        quint8 b2 = buffer.<span class="built_in">at</span>(<span class="number">1</span>);</span><br><span class="line">        quint8 b3 = buffer.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (b1 == <span class="number">0xFF</span> &amp;&amp; b2 == <span class="number">0xFE</span>) &#123;</span><br><span class="line">            code = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b1 == <span class="number">0xFE</span> &amp;&amp; b2 == <span class="number">0xFF</span>) &#123;</span><br><span class="line">            code = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b1 == <span class="number">0xEF</span> &amp;&amp; b2 == <span class="number">0xBB</span> &amp;&amp; b3 == <span class="number">0xBF</span>) &#123;</span><br><span class="line">            code = <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//尝试用utf8转换,如果可用字符数大于0,则表示是ansi编码</span></span><br><span class="line">            QTextCodec::ConverterState state;</span><br><span class="line">            QTextCodec *codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            codec-&gt;<span class="built_in">toUnicode</span>(buffer.<span class="built_in">constData</span>(), buffer.<span class="built_in">size</span>(), &amp;state);</span><br><span class="line">            <span class="keyword">if</span> (state.invalidChars &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                code = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>在连接远程数据库进行查询数据的时候，有时候会发现很慢，尤其是表数据量越多越慢，本地的话同等数据量快很多，可以尝试开启只前进属性，query.setForwardOnly(true);这样的话只会缓存一次的数据，大大提高远程数据库的查询效率，据说可以提高几十倍百倍的速度。当然前提是对查询的数据之前向前取数据的需求，如果还要往后取数据或者在数据模型QSqlQueryModel中使用，则不能开启此属性。原因在每次利用QSqlQuery获取下一条记录时，若不开启isForwardOnly属性（很遗憾默认就是不开启），则每次都开辟新的内存空间，来存储已经访问及未访问的记录，这样，每次都会浪费好多存储空间。</p></li>
<li><p>Qt中的painter绘制非常灵活强大，接口丰富，但是对于很多初学者来说还是有一定的难度，尤其是各种奇奇怪怪的复杂格式，而这些格式用html确很好描述，比如控制行间距、字符间距等，此时可以用QTextDocument传入html格式内容交给QPainter绘制，非常完美、简单、强大，包括一些数学公式啥的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Form::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    QTextDocument doc;</span><br><span class="line">    doc.<span class="built_in">setHtml</span>(html);</span><br><span class="line">    <span class="comment">//设置文本宽度</span></span><br><span class="line">    doc.<span class="built_in">setTextWidth</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="comment">//指定绘制区域</span></span><br><span class="line">    doc.<span class="built_in">drawContents</span>(&amp;painter, <span class="built_in">QRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">70</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt中样式表对选中颜色和悬停颜色是有优先级的，根据对操作系统默认样式的观察，当处于选中状态+悬停状态的时候，默认取悬停状态，也就是鼠标移动到选中的列表item上，颜色取悬停状态颜色。而Qt中如果两种颜色都设置了，根据设置的顺序来，取最后的为准，如果最后设置的选中状态颜色，则当item处于选中状态+悬停状态的时候，取选中状态颜色而不是悬停状态颜色，切记！ <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面这样设置则当鼠标停留在选中的item上时背景颜色=#00FF00</span></span><br><span class="line">QTableView::item:selected&#123;background:#FF0000;&#125;</span><br><span class="line">QTableView::item:hover&#123;background:#<span class="number">00F</span>F00;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这样设置则当鼠标停留在选中的item上时背景颜色=#FF0000</span></span><br><span class="line">QTableView::item:hover&#123;background:#<span class="number">00F</span>F00;&#125;</span><br><span class="line">QTableView::item:selected&#123;background:#FF0000;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左上角样式很容易忽略</span></span><br><span class="line">QTableCornerButton:section&#123;background:#FF0000;&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>qtc开发工具内置了不少的函数，可以很方便的进行一些判断和处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最小版本要求</span></span><br><span class="line">!<span class="built_in">minQtVersion</span>(<span class="number">5</span>, <span class="number">15</span>, <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">message</span>(<span class="string">&quot;Cannot build Qt Installer Framework with Qt version $$&#123;QT_VERSION&#125;.&quot;</span>)</span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;Use at least Qt 5.15.2.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>有时候文本框中的内容过长，而文本框默认光标在尾部，所以要主动设置下将光标移到最前面 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种方法都可以</span></span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setSelection</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ui-&gt;lineEdit-&gt;<span class="built_in">setCursorPosition</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//样式表方式</span></span><br><span class="line"><span class="string">&quot;QLineEdit&#123;qproperty-cursorPosition:0;&#125;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>关于Qt浏览器模块的几点说明。</p></li>
</ol>
<ul>
<li>Qt5.6以前用的是webkit，Qt5.6版本以后分两种情况，一种是mingw编译器（windows系统）对应的Qt库不再提供浏览器模块。</li>
<li>Qt5.6以后的版本在linux系统和mac等系统，都不存在没有浏览器控件的情况，都使用的是webengine。</li>
<li>仅仅是windows上的mingw编译器的Qt版本没有，其他系统其实都有的。很多人在这个地方都有疑问，都以为只有msvc编译器有浏览器控件，其实确切的说是在windows上msvc的Qt库带浏览器控件。</li>
<li>安装Qt的时候webengine模块默认不勾选，需要主动勾选才会安装。</li>
<li>也不是所有的msvc的Qt版本都有webengine浏览器模块，哪怕你勾选了也没用，有些版本官方并没有编译，需要自行编译。需要到对应的Qt安装目录查看是否有 Qt5WebEngine.dll 文件。</li>
<li>如果仅仅是为了弥补mingw版本缺失浏览器模块的遗憾，推荐用miniblink。</li>
<li>如果为了统一兼容各种版本和系统，推荐用cef。</li>
<li>如果没有历史包袱，推荐用webengine，与Qt的集成度高。</li>
<li>webkit和miniblink默认都不支持gpu，webengine默认走gpu。</li>
<li>qwebengine默认不支持MP4，需要自己重新编译。</li>
</ul>
<ol start="229" type="1">
<li>关于编译数据库插件的几个经验总结。</li>
</ol>
<ul>
<li>安装对应的数据库，安装后会有include头文件和lib链接库文件，这是基本的前提，编译数据库插件必须要有这两个东西。务必注意，32位的Qt必须安装32位的数据库才能正常编译成功，位数要一致。</li>
<li>准备好数据库插件源码，比如qt-everywhere-src-5.14.2，可以在安装Qt的时候勾选src，或者后期直接官网重新下载源码解压出来。</li>
<li>打开你要编译的数据库插件源码，比如mysql就打开mysql.pro，oracle就打开oci.pro。</li>
<li>在pro中注释掉一行 #QMAKE_USE += mysql，如果是oci项目则是#QMAKE_USE += oci。</li>
<li>qsqldriverbase.pri文件中注释掉 #include(..shadowed(..PWD)/qtsqldrivers-config.pri)。</li>
<li>mysql.pro文件内容下面加上如下代码。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">path = C:/Qt/mysql<span class="number">-5.7</span><span class="number">.30</span>-winx64</span><br><span class="line">INCLUDEPATH += $$path/include</span><br><span class="line">win32:LIBS += -L$$path/lib -llibmysql</span><br></pre></td></tr></table></figure></li>
<li>oci.pro文件内容下面加上如下代码。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">path = C:/app/Administrator/product/<span class="number">11.2</span><span class="number">.0</span>/client_1</span><br><span class="line">INCLUDEPATH += $$path/oci/include</span><br><span class="line">win32:LIBS += -L$$path/oci/lib/msvc -loci</span><br></pre></td></tr></table></figure></li>
<li>psql.pro文件内容下面加上如下代码。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">path = <span class="string">&quot;C:/Program Files/PostgreSQL/13&quot;</span></span><br><span class="line">INCLUDEPATH += $$path/include</span><br><span class="line">win32:LIBS += -L$$path/lib -llibpq</span><br></pre></td></tr></table></figure></li>
<li>以上写法同时支持mingw和msvc，其他系统编译过程也是类似。编译完成后默认会在你当前源码所在盘符的根目录下，会出现plugins目录，里面sqldrivers目录下就是对应编译生成好的插件动态库。</li>
<li>默认oracle的插件驱动代码是按照oracle12的函数写的，如果链接的是oracle11，则需要改动两行代码才能编译成功。打开qsql_oci.cpp文件大概在1559行代码左右，有个OCIBindByPos2函数改成OCIBindByPos，下面还有一行bindColumn.lengths改成(ub2*)bindColumn.lengths。</li>
</ul>
<ol start="230" type="1">
<li>关于Qt数据库开发的一些冷知识。</li>
</ol>
<ul>
<li>Qt即支持库的形式直接和数据库通信，也支持ODBC数据源的形式和各种数据库通信，这样就涵盖了所有的情况。</li>
<li>Qt数据库程序打包发布，所有前提：注意区分32/64位，你的程序是32位的就必须带上32位的库，64位的必须带上64位的库，这点Qt的库也是这个要求。mysql发布最简单，带上一个mysql的动态库文件就行（windows上的是libmysql.dll），非常简单。sqlserver不用带，因为是微软的亲儿子，一般操作系统自带。postgres需要带上libpq.dll、libintl-8.dll、libiconv-2.dll、libeay32.dll、ssleay32.dll这几个文件就行。oracle需要带上oci.dll、oraociei11.dll（这个文件很大有130MB+），如果不行建议直接安装个oracle client客户端软件，然后对应bin目录设置到环境变量就好。</li>
<li>打包发布后测试下来，发现32位的程序也可以正常连接64位的mysql，64位的程序也可以正常连接32位的mysql，因此判断只要和程序的库的位数一致就行（编译的时候也是这个规则，32位的Qt程序编译数据库插件也要用32位的数据库链接库。），不需要和具体的数据库的位数一致，测试过mysql、sqlserver、postgresql数据库都是类似规则。</li>
<li>大量测试对比下来，通过odbc数据源的方式和直连数据库的方式批量插入大量数据记录，直连方式速度更快，约5%左右，所以建议尽量采用此方式，是在没有此方式的环境才采用odbc数据源的方式，Qt默认自带odbc数据库插件。</li>
<li>不同数据库在执行sql脚本的时候，会自动将表名或者字段名转成大写或小写，mysql会将表名转成小写、postgresql会将表名和字段名转成小写、oracle会将表名和字段名转成大写。这就导致使用QSqlTableModel调用setTable设置数据库表名的时候，一定要和数据库中的表名一致，区分大小写，所以就是在对postgresql和oracle数据库的时候一定要注意，本人就是在这里卡了很久，差点要把这巨大的屎盆扣在Qt的BUG上。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DbHelper::bindTable</span><span class="params">(<span class="type">const</span> QString &amp;dbType, QSqlTableModel *model, <span class="type">const</span> QString &amp;table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//postgresql全部小写,oracle全部大写,这两个数据库严格区分表名字段名的大小写卧槽</span></span><br><span class="line">    QString flag = dbType.<span class="built_in">toUpper</span>();</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="string">&quot;POSTGRESQL&quot;</span>) &#123;</span><br><span class="line">        model-&gt;<span class="built_in">setTable</span>(table.<span class="built_in">toLower</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="string">&quot;ORACLE&quot;</span>) &#123;</span><br><span class="line">        model-&gt;<span class="built_in">setTable</span>(table.<span class="built_in">toUpper</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model-&gt;<span class="built_in">setTable</span>(table);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Qt支持不指定数据库名打开数据库，因为有时候是要在连接数据库服务器后，执行sql语句创建数据库。数据库都还没存在怎么连接呢，测试发现sqlite、mysql、sqlserver、postgresql都支持这个特性。在删除和创建数据库的前提是该数据库没有被其他程序占用，比如其他程序已经打开了该数据库则会执行失败。这里我就折磨过很多次，为什么执行失败呢？后面发现第三方数据库工具已经打开了该数据库，把工具关掉就ok了。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QSqlDatabase database = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);</span><br><span class="line"><span class="comment">//database.setDatabaseName(&quot;dbtool&quot;);</span></span><br><span class="line">database.<span class="built_in">setHostName</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPort</span>(<span class="number">3306</span>);</span><br><span class="line">database.<span class="built_in">setUserName</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPassword</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (database.<span class="built_in">open</span>()) &#123;</span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(database)</span></span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除数据库&quot;</span> &lt;&lt; query.<span class="built_in">exec</span>(<span class="string">&quot;drop database dbtool&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;创建数据库&quot;</span> &lt;&lt; query.<span class="built_in">exec</span>(<span class="string">&quot;create database dbtool&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (query.<span class="built_in">exec</span>(<span class="string">&quot;select * from userinfo&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (query.<span class="built_in">next</span>()) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;查询数据库&quot;</span> &lt;&lt; query.<span class="built_in">value</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;打开数据库&quot;</span> &lt;&lt; database.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用QSqlQueryModel+QTableView显示数据，int类型的数据，如果超过100万，会变成科学计数显示，这就很恼火了，肯定不是自己想要的结果。找遍网络搜索，终于找到一个同样问题的哥们，需要对这一列加个空的委托就行。后面发现空委托也不行，超过1000万条又屌样了，需要终极大法重载数据模型显示。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ui-&gt;tableView-&gt;<span class="built_in">setItemDelegateForColumn</span>(<span class="number">0</span>, <span class="keyword">new</span> QItemDelegate);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是终极大法</span></span><br><span class="line"><span class="function">QVariant <span class="title">SqlQueryModel::data</span><span class="params">(<span class="type">const</span> QModelIndex &amp;index, <span class="type">int</span> role)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVariant value = QSqlQueryModel::<span class="built_in">data</span>(index, role);</span><br><span class="line">    <span class="comment">//超过100万的数值会被科学计数显示需要这里转成字符串显示</span></span><br><span class="line">    <span class="keyword">if</span> (role == Qt::DisplayRole) &#123;</span><br><span class="line">        <span class="type">int</span> result = value.<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="keyword">if</span> (result &gt;= <span class="number">1000000</span>) &#123;</span><br><span class="line">            value = QString::<span class="built_in">number</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>mysql数据库有多种数据库引擎，其中MyIsam不支持数据库事务，默认一般是这个引擎，所以当你使用Qt中的transaction方法后commit提交时候，会发现不成功，其实事实上又是成功的，去数据库里面查看对应的结果又是正确的。有两个办法，第一就是将数据库引擎改成InnoDB，第二就是在提交后做个错误判断 if (database.commit() || !database.lastError().isValid()) ，错误不可用也说明是成功的。</li>
<li>如果采用odbc数据源通信，则只需设置数据库名称setDatabaseName、设置用户名称setUserName、设置用户密码setPassword这三个参数即可，因为数据源配置的时候就已经设置好对应的主机地址和端口以及关联的数据库名称，所以在用odbc数据源通信的时候只需要再次验证用户信息即可。这里特别要注意的是setDatabaseName设置数据库名称要填写数据源配置的名称。</li>
<li>经过大量的对比测试，包括插入、删除、批量、查询、分页等操作，千万量级数据，在Qt数据库部分响应速度这块，友好度排名依次是 sqlite &gt; postgresql &gt; oracle &gt; mysql &gt; odbc 。千万量级以上是 postgresql &gt; oracle &gt; mysql &gt; sqlite &gt; odbc 。亿级别以上是 oracle &gt; postgresql &gt; 其他。以上测试均建立在初学者水平基础上，至于分库分表、联合查询、缓存、内存数据库等各种高级知识点没用上。</li>
<li>mysql主要有两个版本，mysql5.7和mysql8，官方说是8比5要快很多，个人测试下来，5.7比8要快很多，无论是查询，还是批量插入数据，不知道为何，网上搜索的也是这个结果（<a href="https://www.coder4.com/archives/7596">https://www.coder4.com/archives/7596</a>），大家都说8慢了很多。</li>
<li>mysql有个分支叫mariadb，比mysql更纯正，据说各方面都吊打mysql（<a href="https://blog.csdn.net/x275920/article/details/123847792">https://blog.csdn.net/x275920/article/details/123847792</a>），个人对比测试下来也是确实批量插入和查询性能要好不少，并且完全兼容mysql，甚至库文件直接重命名也可以直接使用，比如将libmariadb.dll改成libmysql.dll可以直接使用，而且体积还小了八倍，这个好，发布的时候又少了好几兆。</li>
<li>如果是Qt+mysql程序，发布的时候带的库版本要和插件对应数据库版本一致，否则可能没有数据库事务特性，database.driver()-&gt;hasFeature(QSqlDriver::Transactions)为假。</li>
<li>QSqlTableModel封装的非常好，并不会一次性加载所有数据，而是随着滚动条的拉动加载需要的数据，测试一亿条的表，速度非常快，和几千条的表速度一样。</li>
<li>在连接网络数据库的时候，如果你本地网络设置了代理，比如使用了代理上github等网站，就会发现Qt的数据库程序连不上，你需要设置下不使用本地代理设置 QNetworkProxyFactory::setUseSystemConfiguration(false) 。这个地方如果不仔细会找问题找到你怀疑人生。</li>
</ul>
<h3 id="section-23">24：231-240</h3>
<ol start="231" type="1">
<li>关于c++中继承多态virtual和override的几点总结。</li>
</ol>
<ul>
<li>子类可以直接使用基类中的protected下的变量和函数。</li>
<li>基类函数没加virtual，子类有相同函数，实现的是覆盖。用基类指针调用时，调用到的是基类的函数；用子类指针调用时，调用到的是子类的函数。</li>
<li>基类函数加了virtual，子类有相同函数，实现的是重写。用基类指针或子类指针调用时，调用到的都是子类的函数。</li>
<li>函数加上override，强制要求子类相同函数需要是虚函数，而且必须重新实现，否则会编译报错。</li>
<li>子类的virtual可加可不加，建议加override不加virtual。</li>
<li>基类中的纯虚函数（virtual void play() = 0;）在基类中无需在cpp中实现，但是必须在子类实现，否则编译报错。</li>
<li>继承多态最大的好处就是提炼共性，将通用的变量和方法信号等，全部放在基类，子类负责实现自己需要的特殊的部分即可。</li>
</ul>
<ol start="232" type="1">
<li>关于 QTableView、QTableWidget 悬停整行选中效果，网上大多数都是针对 QTableWidget 的实现，针对 QTableView 的也都是通过委托或者重新painter实现。</li>
</ol>
<ul>
<li>前提：设置选中单元格自动选中整行，tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);</li>
<li>安装事件过滤器，识别到当前坐标处的数据模型，然后设置当前模型为鼠标悬停处的模型即可。这个取巧的办法可以节省大量的工作。</li>
<li>无论 QTableView、QTableWidget 都用此方法都可以。</li>
</ul>
<ol start="233" type="1">
<li>Qt中如何避免和第三方的signals、slots等关键字冲突。</li>
</ol>
<ul>
<li>第一步：在pro中加上 CONFIG += no_keywords 。</li>
<li>第二步：项目中之前所有的 signals 改成 Q_SIGNALS，slots 改成 Q_SLOTS 等。</li>
<li>第三步：彻底重新编译项目，这样就关键字不冲突了。</li>
</ul>
<ol start="234" type="1">
<li><p>pro中区分不同的操作系统及硬件平台。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">win32 &#123;&#125;</span><br><span class="line">unix &#123;&#125;</span><br><span class="line"><span class="comment">//Qt5可以直接用 linux&#123;&#125; Qt4切记需要用 unix:!maxc&#123;&#125;</span></span><br><span class="line">unix:!maxc&#123;&#125;</span><br><span class="line">linux &#123;&#125;</span><br><span class="line">maxc &#123;&#125;</span><br><span class="line">android &#123;&#125;</span><br><span class="line">wasm &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示64位平台</span></span><br><span class="line"><span class="built_in">contains</span>(QT_ARCH, x86_64) &#123;&#125;</span><br><span class="line"><span class="comment">//表示arm平台</span></span><br><span class="line"><span class="built_in">contains</span>(QT_ARCH, arm) || <span class="built_in">contains</span>(QT_ARCH, arm64) &#123;&#125;</span><br><span class="line"><span class="comment">//万能办法直接切换到套件打印下 QT_ARCH 看下什么字符</span></span><br><span class="line"><span class="built_in">message</span>($$QT_ARCH)</span><br></pre></td></tr></table></figure></p></li>
<li><p>在显示视频画面位置的时候，一般会有三种机制作为参考，自动模式(超过则等比例缩放否则原图)、普通模式(任何尺寸都等比例缩放)、填充模式(任何尺寸都拉伸填充)。Qt中图片类QImage都提供了缩放策略的参数设置，比如Qt::KeepAspectRatio表示等比例缩放，但很多时候我们需要的是设置控件的大小，其实QSize类就提供了对应的方法scale专门解决这个问题，这个方法很容易被忽视。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缩放显示模式</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ScaleMode</span> &#123;</span><br><span class="line">    <span class="comment">//自动模式(超过则等比例缩放否则原图)</span></span><br><span class="line">    ScaleMode_auto = <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//普通模式(任何尺寸都等比例缩放)</span></span><br><span class="line">    ScaleMode_normal = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//填充模式(任何尺寸都拉伸填充)</span></span><br><span class="line">    ScaleMode_fill = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入图片尺寸和窗体区域及边框大小返回居中区域</span></span><br><span class="line"><span class="function"><span class="type">static</span> QRect <span class="title">getCenterRect</span><span class="params">(<span class="type">const</span> QSize &amp;imageSize, <span class="type">const</span> QRect &amp;widgetRect, <span class="type">int</span> borderWidth = <span class="number">2</span>, <span class="type">const</span> ScaleMode &amp;scaleMode = ScaleMode_auto)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSize newSize = imageSize;</span><br><span class="line">    QSize widgetSize = widgetRect.<span class="built_in">size</span>() - <span class="built_in">QSize</span>(borderWidth * <span class="number">2</span>, borderWidth * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scaleMode == ScaleMode_auto) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newSize.<span class="built_in">width</span>() &gt; widgetSize.<span class="built_in">width</span>() || newSize.<span class="built_in">height</span>() &gt; widgetSize.<span class="built_in">height</span>()) &#123;</span><br><span class="line">            newSize.<span class="built_in">scale</span>(widgetSize, Qt::KeepAspectRatio);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scaleMode == ScaleMode_normal) &#123;</span><br><span class="line">        newSize.<span class="built_in">scale</span>(widgetSize, Qt::KeepAspectRatio);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newSize = widgetSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = widgetRect.<span class="built_in">center</span>().<span class="built_in">x</span>() - newSize.<span class="built_in">width</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> y = widgetRect.<span class="built_in">center</span>().<span class="built_in">y</span>() - newSize.<span class="built_in">height</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QRect</span>(x, y, newSize.<span class="built_in">width</span>(), newSize.<span class="built_in">height</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入图片尺寸和窗体尺寸及缩放策略返回合适尺寸的图片</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">getScaledImage</span><span class="params">(QImage &amp;image, <span class="type">const</span> QSize &amp;widgetSize, <span class="type">const</span> ScaleMode &amp;scaleMode = ScaleMode_auto, <span class="type">bool</span> fast = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Qt::TransformationMode mode = fast ? Qt::FastTransformation : Qt::SmoothTransformation;</span><br><span class="line">    <span class="keyword">if</span> (scaleMode == ScaleMode_auto) &#123;</span><br><span class="line">        <span class="keyword">if</span> (image.<span class="built_in">width</span>() &gt; widgetSize.<span class="built_in">width</span>() || image.<span class="built_in">height</span>() &gt; widgetSize.<span class="built_in">height</span>()) &#123;</span><br><span class="line">            image = image.<span class="built_in">scaled</span>(widgetSize, Qt::KeepAspectRatio, mode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scaleMode == ScaleMode_normal) &#123;</span><br><span class="line">        image = image.<span class="built_in">scaled</span>(widgetSize, Qt::KeepAspectRatio, mode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        image = image.<span class="built_in">scaled</span>(widgetSize, Qt::IgnoreAspectRatio, mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>关于在头文件中定义函数使用static关键字的血的教训。</p></li>
</ol>
<ul>
<li>有时候我们需要将一些常用函数写在一个文件中供很多地方调用，如果写的是 int doxxx{} 这种，在你多个地方引用的时候，肯定会编译报错提示 “重复定义” 的错误。</li>
<li>此时你需要在函数前面加上static关键字，变成 static int doxxx{} 这种，能够正常编译和运行，以为一切万事大吉，还是我太年轻。</li>
<li>如果仅仅是一个类中在使用，或者函数中没有静态变量，也不会出问题，问题就在static修饰的函数在每个引入头文件的时候都会拷贝一份，导致函数里面的static静态变量会重复初始化，这样就不正确了。</li>
<li>为了解决这个问题，终极办法就是在外面套个类，所有的函数和变量放到类中，完美，再也不会睡不着了，真香。</li>
<li>关于C/C++ 中的static关键字，建议大家参考这篇文章写得 https://zhuanlan.zhihu.com/p/37439983，醍醐灌顶。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件名 test.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这个函数 编译报错提示 “重复定义”</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面4个函数在每个引入头文件的时候都会被拷贝一份</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证没问题的写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tt</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="237" type="1">
<li>在数据库查询中，一般会建立索引以便加快查询速度，比如常用的条件字段作为索引字段。但是有些时候如果查询语句没写好，就算where中有索引字段也会引起全表扫描，也就是说根本没用上索引，这点要积极的避免。</li>
</ol>
<ul>
<li>模糊查询like，全模糊 like '%...%' 和左模糊 like '%...' 无法直接使用索引，右模糊查询 like '...%' 会使用索引。</li>
<li>查询条件中含有is null的select语句执行慢，is not null 时永远不会使用索引，一般数据量大的表不要用is null查询。</li>
<li>不等于操作符 &lt;&gt; 和 != 会限制索引，引起全表扫描，即使比较的字段上有索引。</li>
<li>where子句中比较的两个条件，一个有索引，一个没索引，使用or则会引起全表扫描。</li>
<li>select count(*) from table 这样不带任何条件的count会引起全表扫描。</li>
<li>in 和 not in 也要慎用，否则会导致全表扫描，能用 between 就不要用 in。</li>
<li>用 &gt;= 替代 &gt;，比如 高效写法：select * from table where id &gt;= 4，低效写法：select * from table where id &gt; 3。</li>
<li>如果表数据量很小，比如就几千行，请忽略上述警告，加不加索引问题不大，甚至某些时候加索引反而大大增加了数据库文件的体积，影响更新数据库的速度。</li>
</ul>
<ol start="238" type="1">
<li><p>由于Qt在不断的更新换代，各种组件轮子也在增加、拆分、调整等，所以我们在编写项目的时候，如果有版本兼容的问题，就需要在pro项目文件和代码文件中做对应的判断处理。根据多年的经验总结，一个万能的办法就是在pro中增加一个DEFINES标识，然后根据这个DEFINES标识引入对应模块，最后在代码中通过#ifdef判断标识执行对应代码。经过这样倒腾几下你的代码可以在低版本和高版本编译运行。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pro pri 文件</span></span><br><span class="line"><span class="comment">//下面表示主版本&gt;4子版本&gt;6 即版本&gt;=5.7</span></span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MINOR_VERSION, <span class="number">6</span>) &#123;</span><br><span class="line">DEFINES += qchart</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于Qt6的发布以及以后Qt7、Qt8等，光有上面这个判断是不够的的</span></span><br><span class="line"><span class="comment">//下面表示Qt主版本&gt;5 即版本&gt;=6.0</span></span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">5</span>) &#123;</span><br><span class="line">DEFINES += qchart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断有定义则导入对应模块</span></span><br><span class="line"><span class="built_in">contains</span>(DEFINES, qchart) &#123;</span><br><span class="line">QT += charts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> qchart</span></span><br><span class="line"><span class="comment">//要执行的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>在使用QChart图表控件的时候，你会发现默认的边距好大，很多时候我们希望能显示更多的信息，紧凑型的界面，所以需要设置边距。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置背景区域圆角角度</span></span><br><span class="line">chart-&gt;<span class="built_in">setBackgroundRoundness</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置内边界边距</span></span><br><span class="line">chart-&gt;<span class="built_in">setMargins</span>(<span class="built_in">QMargins</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//设置外边界边距</span></span><br><span class="line">chart-&gt;<span class="built_in">layout</span>()-&gt;<span class="built_in">setContentsMargins</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt内置了数据压缩和解压的功能，如果遇到图片、音频数据、文件等转base64传输这种，采用qCompress压缩后大概可以节省30%的数据传输量，压缩性能可观。前提是双方都是Qt程序，因为收到数据的时候还要用qUncompress解压出来，成对出现的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送的时候压缩下数据</span></span><br><span class="line">QByteArray buffer = <span class="string">&quot;...&quot;</span>;</span><br><span class="line">buffer = <span class="built_in">qCompress</span>(buffer);</span><br><span class="line">socket-&gt;<span class="built_in">write</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到数据后务必记得先解压再使用</span></span><br><span class="line">QByteArray data = socket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">data = <span class="built_in">qUncompress</span>(data);</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="section-24">25：241-250</h3>
<ol start="241" type="1">
<li><p>QString类是我个人认为Qt所有类中的精华，封装的无可挑剔。内置了各种进制数据的转换，比如将数据转成10进制、16进制显示，或者将10进制、16进制数据转成字符串显示。这里很容易忽略的一点就是，很多人以为就是支持2进制、10进制、16进制之类的，其实不是的，里面实现了 2-36 之间的任意进制转换，可以自行翻阅源码查看实现。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> data[<span class="number">2</span>];</span><br><span class="line">data[<span class="number">0</span>] = <span class="number">0x10</span>;</span><br><span class="line">data[<span class="number">1</span>] = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 2进制显示 &quot;10000&quot; &quot;11001&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;2进制显示&quot;</span> &lt;&lt; QString::<span class="built_in">number</span>(data[<span class="number">0</span>], <span class="number">2</span>) &lt;&lt; QString::<span class="built_in">number</span>(data[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line"><span class="comment">//输出 5进制显示 &quot;31&quot; &quot;100&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;5进制显示&quot;</span> &lt;&lt; QString::<span class="built_in">number</span>(data[<span class="number">0</span>], <span class="number">5</span>) &lt;&lt; QString::<span class="built_in">number</span>(data[<span class="number">1</span>], <span class="number">5</span>);</span><br><span class="line"><span class="comment">//输出 10进制显示 &quot;16&quot; &quot;25&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;10进制显示&quot;</span> &lt;&lt; QString::<span class="built_in">number</span>(data[<span class="number">0</span>]) &lt;&lt; QString::<span class="built_in">number</span>(data[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//输出 16进制显示 &quot;10&quot; &quot;19&quot;</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;16进制显示&quot;</span> &lt;&lt; QString::<span class="built_in">number</span>(data[<span class="number">0</span>], <span class="number">16</span>) &lt;&lt; QString::<span class="built_in">number</span>(data[<span class="number">1</span>], <span class="number">16</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>QtSql模块封装了各种数据库操作，使得Qt操作各种数据库非常的简单，支持各种各样的数据库，最基础的ODBC方式也支持连接到各种数据库。有个很容易忽视的要点就是在连接sqlserver数据库的时候，你会发现第三方的数据库工具也没有配置数据库，但是可以连接成功，而在Qt中的常规数据库连接写法却不行，那是因为你代码写错了，要用另外一种写法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连接sqlite数据库</span></span><br><span class="line">QSqlDatabase database = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);</span><br><span class="line"><span class="comment">//只需要指定数据库文件的绝对路径即可</span></span><br><span class="line">database.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;d:/test.db&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接mysql数据库</span></span><br><span class="line">QSqlDatabase database = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);</span><br><span class="line">database.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">database.<span class="built_in">setHostName</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPort</span>(<span class="number">3306</span>);</span><br><span class="line">database.<span class="built_in">setUserName</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPassword</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接到sqlserver数据库</span></span><br><span class="line"><span class="comment">//方式一通过odbc数据源，前提是必须配置好数据源。</span></span><br><span class="line">QSqlDatabase database = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QODBC&quot;</span>);</span><br><span class="line">database.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;数据源名称&quot;</span>);</span><br><span class="line">database.<span class="built_in">setUserName</span>(<span class="string">&quot;sa&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPassword</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二通过驱动字符串，无需配置数据源。设置数据库名称就带了主机地址端口和用户信息所有后面这些设置不需要，强烈建议推荐此方法。</span></span><br><span class="line">QSqlDatabase database = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QODBC&quot;</span>);</span><br><span class="line">QStringList list;</span><br><span class="line">list &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;DRIVER=&#123;%1&#125;&quot;</span>).<span class="built_in">arg</span>(<span class="string">&quot;SQL SERVER&quot;</span>);</span><br><span class="line">list &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;SERVER=%1,%2&quot;</span>).<span class="built_in">arg</span>(<span class="string">&quot;127.0.0.1&quot;</span>).<span class="built_in">arg</span>(<span class="number">1433</span>);</span><br><span class="line">list &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;DATABASE=%1&quot;</span>).<span class="built_in">arg</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">list &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;UID=%1&quot;</span>).<span class="built_in">arg</span>(<span class="string">&quot;sa&quot;</span>);</span><br><span class="line">list &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;PWD=%1&quot;</span>).<span class="built_in">arg</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">database.<span class="built_in">setDatabaseName</span>(list.<span class="built_in">join</span>(<span class="string">&quot;;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接到postgresql数据库</span></span><br><span class="line">QSqlDatabase database = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QPSQL&quot;</span>);</span><br><span class="line">database.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">database.<span class="built_in">setHostName</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPort</span>(<span class="number">5432</span>);</span><br><span class="line">database.<span class="built_in">setUserName</span>(<span class="string">&quot;postgres&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPassword</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接到oracle数据库</span></span><br><span class="line">QSqlDatabase database = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QOCI&quot;</span>);</span><br><span class="line">database.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">database.<span class="built_in">setHostName</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPort</span>(<span class="number">1521</span>);</span><br><span class="line">database.<span class="built_in">setUserName</span>(<span class="string">&quot;system&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPassword</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接到人大金仓kingbase数据库（内核就是postgresql）</span></span><br><span class="line">QSqlDatabase database = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QPSQL&quot;</span>);</span><br><span class="line">database.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">database.<span class="built_in">setHostName</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPort</span>(<span class="number">54321</span>);</span><br><span class="line">database.<span class="built_in">setUserName</span>(<span class="string">&quot;SYSTEM&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPassword</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过odbc数据源连接到各种数据库，前提是必须配置好数据源，只需要设置数据库名称为数据源的名称，填写用户名和密码就行，其他的主机地址和端口不需要。</span></span><br><span class="line">QSqlDatabase database = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QODBC&quot;</span>);</span><br><span class="line">database.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;数据源名称&quot;</span>);</span><br><span class="line">database.<span class="built_in">setUserName</span>(<span class="string">&quot;system&quot;</span>);</span><br><span class="line">database.<span class="built_in">setPassword</span>(<span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果信号槽关联函数 connect(obj, SIGNAL(), this, SLOT()); 执行多次则会重复关联（意味着会执行多次），而取消信号槽关联函数 disconnect(obj, SIGNAL(), this, SLOT()); 只需要执行一次就可以将之前关联的（哪怕是重复关联过）全部清除。很多初学者会遇到为什么点一下居然执行多次的原因就在这里，很可能代码中写了 on_objName_clicked(); 这种Qt内置自动生成关联的槽函数，然后自己又在代码中调用 connect 绑定了一次，导致重复绑定。提个建议：其实Qt可以过滤下如果是完全一样的绑定则认为是一个而不是多个。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了保证永远只有一个关联可以在关联前面执行一次取消关联</span></span><br><span class="line"><span class="built_in">disconnect</span>(obj, <span class="built_in">SIGNAL</span>(), <span class="keyword">this</span>, <span class="built_in">SLOT</span>());</span><br><span class="line"><span class="built_in">connect</span>(obj, <span class="built_in">SIGNAL</span>(), <span class="keyword">this</span>, <span class="built_in">SLOT</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过群里大佬提示，原来connect第五个参数填 UniqueConnection 就可以避免这个问题，按照官方文档说明这个参数会过滤重复的信号。</span></span><br><span class="line"><span class="built_in">connect</span>(obj, <span class="built_in">SIGNAL</span>(), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(), Qt::UniqueConnection);</span><br></pre></td></tr></table></figure></p></li>
<li><p>通过对Qt自带Examples的源码研究你会发现，越往后的版本，越喜欢用智能指针QScopedPointer来定义对象，这样有个好处就是用的地方只管new就行，一直new下去，不用担心资源释放问题，智能指针会给你在合适的时机释放，相当于可以少些一行代码 xxx-&gt;deleteLater(); ，而且避免不必要的麻烦，不然很多地方你要判断 if (!xxx) 看下对象是否ok。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QWidget *widget;</span><br><span class="line"><span class="comment">//用的地方先new</span></span><br><span class="line">widget = <span class="keyword">new</span> QWidget;</span><br><span class="line"><span class="comment">//用完释放对象</span></span><br><span class="line">widget-&gt;<span class="built_in">deleteLater</span>();  </span><br><span class="line">    </span><br><span class="line"><span class="comment">//智能指针写法</span></span><br><span class="line">QScopedPointer&lt;QWidget&gt; widget;</span><br><span class="line"><span class="comment">//只管new尽管new不用管释放</span></span><br><span class="line">widget.<span class="built_in">reset</span>(<span class="keyword">new</span> QWidget);</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果控件中存在布局，在调用setLayout重新设置布局的时候，会提示 QWidget::setLayout: Attempting to set QLayout ... 之类的信息，说是已经存在了布局，需要删除之前的布局才能重新设置布局，按道理Qt推荐的是调用 layout()-&gt;deleteLater() 方法去删除对象，更安全，但是在这里不起作用，你需要用 delete layout() 来删除，着实奇怪。</p></li>
<li><p>在编写类中有时候需要对变量进行赋值和取值，这时候一般用 setxxx、getxxx 之类的函数进行处理，而且往往里面就一行代码，这时候你可能会思考为何不直接将变量改成public暴露出来使用，还可以省两个函数几行代码。其实用set get这样处理主要还是为了拓展性，比如后期如果需要对赋值进行过滤处理，或者该变量只允许读写中的一个，如果之前是直接使用的变量外，则使用的地方都要去修改规则，反而变得很糟糕。 参考文章 <a href="https://blog.csdn.net/ChineseSoftware/article/details/122923485">https://blog.csdn.net/ChineseSoftware/article/details/122923485</a> 。</p></li>
<li><p>关于如何快速结束线程，调用terminate暴力结束容易出问题。一般来说我们都是采用标志位来结束线程，但是如果执行过程中的函数很耗时，或者在run中msleep休息的时间过久，容易导致要很长一段时间才能正确停止，此时可以考虑一个策略就是分割线程执行体，如果是函数体耗时可以在耗时的函数体中增加停止标志位的判断，使其快速跳出；如果是延时时间过久可以将延时时间拆分成多个小的时间轮片，每个小的休息间隔都判断停止标志位，这样也可以大大加快线程正常退出的速度而不用等待太久。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">        <span class="built_in">doTask</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面这个延时太久导致退出很慢</span></span><br><span class="line">        <span class="comment">//msleep(3000);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//特意每次做个小延时每次都去判断标志位等可以大大加快关闭速度</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">            <span class="built_in">msleep</span>(<span class="number">100</span>);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//如果到了30次=30*100=3000毫秒也跳出</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;     </span><br><span class="line">    stopped = <span class="literal">false</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::doTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stopped) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">doTask1</span>();</span><br><span class="line">        <span class="built_in">doTask2</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt中如果指定了同一个父类窗体，则控件都会覆盖在该父类窗体中，这就需要设置窗口小部件覆盖遮挡与层叠顺序。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Qt对有共同父类窗体的控件优化到了极致，下面生成了1000个widget才新增不到3mb的内存。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    QWidget *w = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    w-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    w-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QWidget *w1, *w2, *w3;</span><br><span class="line"><span class="comment">//将w1控件移到最前面相当于在该父窗体中置顶</span></span><br><span class="line">w1-&gt;<span class="built_in">raise</span>();</span><br><span class="line"><span class="comment">//将w1控件移到最后面相当于在该父窗体中置底</span></span><br><span class="line">w1-&gt;<span class="built_in">lower</span>();</span><br><span class="line"><span class="comment">//将w1控件移到w2控件下面</span></span><br><span class="line">w1-&gt;<span class="built_in">stackUnder</span>(w2);</span><br></pre></td></tr></table></figure></p></li>
<li><p>当我们关闭窗体的时候，按道理来说都会执行对应窗体的析构函数 ~MainWindow() 之类的，这是理想状态，当你的窗体还弹出了子窗体，就算你关闭了主窗体，会发现子窗体依然在，而且根本没有去析构主窗体，对应的子窗体也没有设置 setParent ，通常情况下，我们都是希望关闭了主窗体，对应子窗体自动关闭，这个时候怎么办呢？你需要重载 closeEvent 拿到关闭消息，主动去把子窗体释放。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="number">0</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QLabel *lab;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) : <span class="built_in">QMainWindow</span>(parent), <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    lab = <span class="keyword">new</span> QLabel;</span><br><span class="line">    lab-&gt;<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先把子窗体释放</span></span><br><span class="line">    lab-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lab-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>关于Qt中 sendEvent 和 postEvent 主动模拟发送鼠标键盘事件的几点说明。</p></li>
</ol>
<ul>
<li>sendEvent是阻塞式，代码会立即执行，支持栈空间和堆空间事件对象的发送（局部对象和new分配的对象）。</li>
<li>postEvent是非阻塞式，会发送到事件队列中等待处理，只支持栈堆空间事件对象的发送（new分配的对象）。</li>
<li>new分配的事件对象被处理后，会由Qt内部自动摧毁，不用担心。</li>
<li>短时间内密集频繁的调用，推荐用postEvent，放入事件队列非常安全。否则用sendEvent很容易导致崩溃。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面这个会立即执行</span></span><br><span class="line"><span class="function">QResizeEvent <span class="title">event</span><span class="params">(size(), size())</span></span>;</span><br><span class="line">QApplication::<span class="built_in">sendEvent</span>(<span class="keyword">this</span>, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这个会立即执行</span></span><br><span class="line">QResizeEvent *event = <span class="keyword">new</span> <span class="built_in">QResizeEvent</span>(<span class="built_in">size</span>(), <span class="built_in">size</span>());</span><br><span class="line">QApplication::<span class="built_in">sendEvent</span>(<span class="keyword">this</span>, event);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这个不会报错但是也不会执行因为事件对象是局部变量</span></span><br><span class="line"><span class="function">QResizeEvent <span class="title">event</span><span class="params">(size(), size())</span></span>;</span><br><span class="line">QApplication::<span class="built_in">postEvent</span>(<span class="keyword">this</span>, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的方式非常安全</span></span><br><span class="line">QResizeEvent *event = <span class="keyword">new</span> <span class="built_in">QResizeEvent</span>(<span class="built_in">size</span>(), <span class="built_in">size</span>());</span><br><span class="line">QApplication::<span class="built_in">postEvent</span>(<span class="keyword">this</span>, event);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="section-25">26：251-260</h3>
<ol start="251" type="1">
<li><p>今天在一个头文件中，发现 #ifdef Q_OS_WIN #ifdef Q_CC_MSVC 之类的都失效了，搞得差点怀疑人生了。经历过之前类似的教训后，排查原来是没有提前引入 qglobal.h 头文件导致的。切记如果要使用Qt的东西，哪怕是最基础的标识宏定义 Q_OS_WIN 之类的，都要保证该前面至少包含了 qglobal.h ，否则都是失败的。很多人和我一样天真的以为编译器会自动处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//必须要先引入这个头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qglobal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_CC_MSVC</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> execution_character_set(<span class="string">&quot;utf-8&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>有一个场景经常遇到，那就是在符合某个条件下，延时一段时间去执行一段代码，如果短时间内触发多次又不需要频繁执行，只需要执行一次就行。如果选择用QTimer::singleShot无法终止已经触发的，这个时候就要主动实例化一个单次定时器，每次调用前都停止之前的（只要是还没执行都会取消），完美解决。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//QTimer::singleShot(1000, thread, SLOT(xxx()));</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> QTimer *timer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">    timer = <span class="keyword">new</span> QTimer;</span><br><span class="line">    QObject::<span class="built_in">connect</span>(timer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()), thread, <span class="built_in">SLOT</span>(<span class="built_in">xxx</span>()));</span><br><span class="line">    timer-&gt;<span class="built_in">setSingleShot</span>(<span class="literal">true</span>);</span><br><span class="line">    timer-&gt;<span class="built_in">setInterval</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">timer-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></table></figure></p></li>
<li><p>有时候我们发现控件设置透明后背景变成黑色，你可以尝试设置透明度值1而不是完全透明0，这样看起来是透明的但是又保留了窗体的特性。如果想要不应用系统阴影边框可以设置属性 w.setWindowFlags(w.windowFlags() | Qt::NoDropShadowWindowHint);</p></li>
<li><p>Qt中的事件过滤器相当于万能大法（终极秘密武器），尤其是对整个应用程序安装事件过滤器，则可以拿到所有的事件。比如可以拿到系统标题栏鼠标按下松开，对所有需要移动的无边框窗体统一拦截进行移动处理。个人建议不到万不得已不建议使用，有一定性能损耗，毕竟这个是从最初源头拦截事件，意味着所有的事件都会到这里过一遍。如果你在收到对应事件后还做了一定耗时的处理，很容易就卡主了UI主线程。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppInit::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qApp-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AppInit::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::NonClientAreaMouseButtonPress) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;系统标题栏按下&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::NonClientAreaMouseButtonRelease) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;系统标题栏松开&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    QWidget *w = (QWidget *)watched;</span><br><span class="line">    <span class="keyword">if</span> (!w-&gt;<span class="built_in">property</span>(<span class="string">&quot;canMove&quot;</span>).<span class="built_in">toBool</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> QObject::<span class="built_in">eventFilter</span>(watched, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> QPoint mousePoint;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> mousePressed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    QMouseEvent *mouseEvent = <span class="built_in">static_cast</span>&lt;QMouseEvent *&gt;(event);</span><br><span class="line">    <span class="keyword">if</span> (mouseEvent-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mouseEvent-&gt;<span class="built_in">button</span>() == Qt::LeftButton) &#123;</span><br><span class="line">            mousePressed = <span class="literal">true</span>;</span><br><span class="line">            mousePoint = mouseEvent-&gt;<span class="built_in">globalPos</span>() - w-&gt;<span class="built_in">pos</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mouseEvent-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonRelease) &#123;</span><br><span class="line">        mousePressed = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mouseEvent-&gt;<span class="built_in">type</span>() == QEvent::MouseMove) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mousePressed) &#123;</span><br><span class="line">            w-&gt;<span class="built_in">move</span>(mouseEvent-&gt;<span class="built_in">globalPos</span>() - mousePoint);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> QObject::<span class="built_in">eventFilter</span>(watched, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>linux上可执行文件默认从系统环境变量查找动态库，而windows上默认是从可执行文件所在目录查找，所以有时候为了统一，希望动态库就指定放在可执行文件同一目录下或者相对目录比如lib文件夹，这就需要编译的时候做特殊设置，在pro项目文件中指定rpath（也可以用命令或者第三方工具进行设置），指定好以后默认先从指定的rpath查找动态库是否在，不在然后再去环境变量中的路径查找。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">linux &#123;</span><br><span class="line">QMAKE_LFLAGS += <span class="string">&quot;-Wl,-rpath,\&#x27;\$$ORIGIN\&#x27;&quot;</span></span><br><span class="line">QMAKE_LFLAGS += <span class="string">&quot;-Wl,-rpath,\&#x27;\$$ORIGIN/lib\&#x27;&quot;</span></span><br><span class="line">QMAKE_LFLAGS += <span class="string">&quot;-Wl,-rpath,\&#x27;\$$ORIGIN/../lib\&#x27;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>默认QDialog窗体右下角有个拉伸尺寸的手柄，通过它可以对窗体拉伸大小，这个控件很容易被遗忘但是又经常可以看到，他的名字叫QSizeGrip，可以通过setSizeGripEnabled来启用或者禁用，也可以用qss对外观进行设置。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QSizeGrip &#123;</span><br><span class="line">	image:<span class="built_in">url</span>(:/image/sizegrip.png);</span><br><span class="line">	width:<span class="number">10</span>px;</span><br><span class="line">	height:<span class="number">10</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>在有些没有opengl环境的Qt开发中，比如一些嵌入式板子为了节省资源没有编译opengl所以不会有opengl相关的头文件，在编译项目过程中可能遇到提示 GLES3/gl3.h: No such file or directory，尽管你的项目中也没有用到opengl的任何东西，那是因为你包含了一个大模块 #include "QtWidgets" ，而这个大模块中包含了 #include "qopenglwidget.h" ，你需要做的是在引入大模块前面加一行。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面两个定义看具体需求调整</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QT_NO_OPENGL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QT_NO_OPENGL_ES_3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>可以通过设置过滤机制，将代码中的部分打印类别屏蔽掉，比如只保留qdebug打印的信息，也可以将Qt内部类的警告信息屏蔽，只保留自己程序写的打印信息。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码写在main函数最前面</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QLoggingCategory::<span class="built_in">setFilterRules</span>(<span class="string">&quot;*.critical=false&quot;</span>);</span><br><span class="line">	<span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面表示将所有的debug打印信息屏蔽</span></span><br><span class="line">QLoggingCategory::<span class="built_in">setFilterRules</span>(<span class="string">&quot;*.debug=false&quot;</span>);</span><br><span class="line"><span class="comment">//下面最终打印 222</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;111&quot;</span>;</span><br><span class="line"><span class="built_in">qInfo</span>() &lt;&lt; <span class="string">&quot;222&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面表示将所有的打印信息屏蔽</span></span><br><span class="line">QLoggingCategory::<span class="built_in">setFilterRules</span>(<span class="string">&quot;*=false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面可以将所有警告提示屏蔽(Qt内部类中出现的警告信息都用的这个qErrnoWarning对应的就是critical)</span></span><br><span class="line">QLoggingCategory::<span class="built_in">setFilterRules</span>(<span class="string">&quot;*.critical=false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持多个规则写法(有部分警告信息用的qWarning所以也要加进去)</span></span><br><span class="line">QLoggingCategory::<span class="built_in">setFilterRules</span>(<span class="string">&quot;*.critical=false\n*.warning=false&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>官方的Qt安装包基本上都带了各种高级模块比如浏览器模块webengine以及多媒体模块q，有些嵌入式的环境或者厂家提供好的Qt环境，未必有这些模块，需要单独打命令安装。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果找不到音频输入输出设备需要执行下面这个命令</span></span><br><span class="line">sudo apt-get install libqt5multimedia5-plugins</span><br><span class="line"><span class="comment">//安装浏览器模块</span></span><br><span class="line">sudo apt-get install libqt5web*</span><br><span class="line"><span class="comment">//也可以一次性安装所有</span></span><br><span class="line">sudo apt-get install libqt5*</span><br></pre></td></tr></table></figure></p></li>
<li><p>项目大了以后，经常需要将某些类做成单例类，在整个项目中唯一存在，供多个地方使用，如果一个就一个类需要写成单例模式，那直接写在那个类中即可，如果类多了的话，会发现都是一些重复的定义代码，此时可以考虑用个宏定义，传入类名即可，代码量虽然少了可能绩效低了，但是水平提升了。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUISINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUISINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScopedPointer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLETON_DECL(Class) \</span></span><br><span class="line"><span class="meta">    public: \</span></span><br><span class="line"><span class="meta">        static Class *Instance(); \</span></span><br><span class="line"><span class="meta">    private: \</span></span><br><span class="line"><span class="meta">        Q_DISABLE_COPY(Class) \</span></span><br><span class="line"><span class="meta">        static QScopedPointer<span class="string">&lt;Class&gt;</span> self;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLETON_IMPL(Class) \</span></span><br><span class="line"><span class="meta">    QScopedPointer<span class="string">&lt;Class&gt;</span> Class::self; \</span></span><br><span class="line"><span class="meta">    Class *Class::Instance() &#123; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (self.isNull()) &#123; \</span></span><br><span class="line"><span class="meta">            static QMutex mutex; \</span></span><br><span class="line"><span class="meta">            QMutexLocker locker(&amp;mutex); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (self.isNull()) &#123; \</span></span><br><span class="line"><span class="meta">                self.reset(new Class); \</span></span><br><span class="line"><span class="meta">            &#125; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">        return self.data(); \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// QUISINGLETON_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用的时候在头文件和实现文件各加一行代码即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quisingleton.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Form</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Q_OBJECT <span class="title">SINGLETON_DECL</span><span class="params">(Form)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">SINGLETON_IMPL</span><span class="params">(Form)</span></span></span><br><span class="line"><span class="function"><span class="title">Form::Form</span><span class="params">(QWidget *parent)</span> : QWidget(parent), ui(new Ui::Form)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="section-26">27：261-270</h3>
<ol start="261" type="1">
<li><p>代码中判断当前Qt库是32位还是64位，用QSysInfo::WordSize=32/64。</p></li>
<li><p>QTreeView控件设置左侧branch 图标大小，无法通过qss设置，万能大法查看源码得知控制宽度最后取决于indentation参数，indentation的默认值根据系统环境不同而不同，比如1080P分辨率下是20，你要放大可以通过 setIndentation(30) 来设置。</p></li>
<li><p>在对选项卡控件QTabWidget设置样式表的时候，很多人希望能做成类似浏览器或者资源管理器中上面选项卡的样子，就是选中的tab上边左右两边有加粗线条，底部空白的和面板形成一体，有很多方法，方法一就是把底边宽度为0，方法二将底边颜色设置成和面板颜色一样，方法三将tab的底边边距设置成边框的负数（margin-bottom:-3px），这样看起来就是和面板融为一体了。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面几种分别对应选项卡不同位置的效果</span></span><br><span class="line"><span class="comment">//注意Qt5.12版本后tabbar选项卡左右反过来的</span></span><br><span class="line">QTabWidget::pane:top&#123;top:<span class="number">-1</span>px;&#125;</span><br><span class="line">QTabWidget::pane:bottom&#123;bottom:<span class="number">-1</span>px;&#125;</span><br><span class="line">QTabWidget::pane:left&#123;right:<span class="number">-1</span>px;&#125;</span><br><span class="line">QTabWidget::pane:right&#123;left:<span class="number">-1</span>px;&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>在linux上编译动态库文件，可能会生成一堆软连接文件（图标上有个小箭头/libuntitled.so/libuntitled.so.1/libuntitled.so.1.0libuntitled.so.1.0.0），很多时候看起来很烦，习惯了windows上就生成一个文件，你只需要在你的pro或者pri中加上一行 CONFIG += plugin 即可，这样只会生成一个libuntitled.so文件。2023-4-2补充：还可以使用 CONFIG += unversioned_libname unversioned_soname 来实现，unversioned_libname用来去掉lib的各个版本号，unversioned_soname用来去掉链接里的版本号（不加这个的话尽管生成的是libuntitled.so，但是链接编译的时候还会报错提示依赖带版本号的）。具体文章可以参考 <a href="https://blog.csdn.net/gongjianbo1992/article/details/129889588">https://blog.csdn.net/gongjianbo1992/article/details/129889588</a> 。</p></li>
<li><p>关于Qt在线安装过程中出现报错提示：下载“http://mirrors.aliyun.com...“时出现网络错误 的解决方法，打开命令行运行安装程序，比如C:&gt;D:.exe，后面主动加上参数 --mirror https://mirrors.cloud.tencent.com/qt，完整命令行是 C:&gt;D:.exe --mirror https://mirrors.cloud.tencent.com/qt，回车运行即可。同理也可以换成国内其他的镜像地址（腾讯云 https://mirrors.cloud.tencent.com/qt /阿里云 https://mirrors.aliyun.com/qt），有时候镜像的更新要慢一些，可以进入到目录 https://mirrors.aliyun.com/qt/online/qtsdkrepository/ 看下有没有对应的版本。</p></li>
<li><p>从Qt6.4版本开始多媒体模块提供了ffmpeg作为后端解码使用（6.5版本默认就是ffmpeg），可以通过设置环境变量来更改使用哪种后端解码，在main函数的第一行 qputenv("QT_MEDIA_BACKEND", "ffmpeg"); 目前已知的问题是如果选用ffmpeg则暂时不支持中文目录以及中文名称（在6.5.1修复了），如果一定要支持中文则需要改成windows。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置后端解码为ffmpeg/所有系统都支持</span></span><br><span class="line"><span class="built_in">qputenv</span>(<span class="string">&quot;QT_MEDIA_BACKEND&quot;</span>, <span class="string">&quot;ffmpeg&quot;</span>);</span><br><span class="line"><span class="comment">//windows系统专用</span></span><br><span class="line"><span class="built_in">qputenv</span>(<span class="string">&quot;QT_MEDIA_BACKEND&quot;</span>, <span class="string">&quot;windows&quot;</span>);</span><br><span class="line"><span class="comment">//linux系统专用</span></span><br><span class="line"><span class="built_in">qputenv</span>(<span class="string">&quot;QT_MEDIA_BACKEND&quot;</span>, <span class="string">&quot;gstreamer&quot;</span>);</span><br><span class="line"><span class="comment">//mac系统专用</span></span><br><span class="line"><span class="built_in">qputenv</span>(<span class="string">&quot;QT_MEDIA_BACKEND&quot;</span>, <span class="string">&quot;darwin&quot;</span>);</span><br><span class="line"><span class="comment">//android系统专用</span></span><br><span class="line"><span class="built_in">qputenv</span>(<span class="string">&quot;QT_MEDIA_BACKEND&quot;</span>, <span class="string">&quot;android&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>下拉框控件QComboBox默认会根据item的字符宽度调整下拉框的宽度，比如其中某个item文本很长，则下拉框会变的很宽，甚至把整个界面撑大看起来变形的感觉，有时候我们不希望是这样，有多个方法可以去掉，方法一就是设置下拉框的拉伸策略为QSizePolicy::Ignored，然后将下拉框放到一个容器中，保证容器布局中的其他控件都是有固定尺寸或者fix填充尺寸，这样下拉框就是默认自动拉伸的而且保证不会跟着item的宽度变宽。这个方法并不友好，因为需要调整容器布局中其他控件的拉伸策略，最佳方法就是设置 ui-&gt;comboBox-&gt;setSizeAdjustPolicy(QComboBox::AdjustToMinimumContentsLengthWithIcon); ，当item宽度超过的时候中间部分会自动省略号显示，要的就是这个效果，为了使得整个全局都能应用，可以样式表设置 qApp-&gt;setStyleSheet("QComboBox{qproperty-sizeAdjustPolicy:AdjustToMinimumContentsLengthWithIcon}"); 即可，整个项目中所有下拉框都会自动应用这个策略。</p></li>
<li><p>用QSettings类保存float类型的时候，内容会变成 <span class="citation" data-cites="Variant">@Variant</span> 开头的一个值，后面根本看不懂什么值，比如 1.0 = <span class="citation" data-cites="Variant">@Variant</span>(\0\0\0?\0\0) 一个非常奇怪的值，这样的话如果想直接修改配置文件来更改参数就无从下手。有两个办法解决问题，办法一就是在写入值的时候强制转换成QString类型数据即可，set.setValue("SaveVideoRatio", QString::number(SaveVideoRatio));，办法二就是将float参数类型改成double，比如 float SaveVideoRatio 改成 double SaveVideoRatio，推荐方法一，不用更改数据类型，就改动一行即可，而且double数据类型的精度不一样，比如 float i = 0.1 会变成 double i = 0.10000000149011612 。<strong>在Qt6中彻底修复了这个问题，不需要转换。</strong></p></li>
<li><p>大概从Qt5.12开始，新增了平台外观插件platformthemes，意味着打包发布的时候需要带上他才能应用系统层风格的外观样式，如果不带，在win上可能是windows2000风格的古老外观，看起来非常诧异。</p></li>
<li><p>有时候我们设置开机运行程序后，如果该程序用又用QProcess等方式调用了程序B，而程序B又需要读取目录下的配置文件，此时你会发现根本读取不到，因为开机后的默认目录不在可执行文件所在目录（如果我们是双击程序运行的那就不存在这个问题，会自动将可执行文件所在目录作为当前目录。）所以我们需要执行代码 QDir::setCurrent(qApp-&gt;applicationDirPath()); 主动设置当前目录在哪，告诉操作系统。QProcess中有个setWorkingDirectory本人也各种对比测试过，对开启启动后的程序调用QProcess无效，必须用QDir::setCurrent。</p></li>
</ol>
<h3 id="section-27">28：271-280</h3>
<ol start="271" type="1">
<li><p>编程的过程中经常遇到需要将QString转成char <em>或者const char </em>的情况，在转换成QByteArray后调用.data()或者.constData()函数进行转换，这里需要注意的是，如果转换类型是const char *尽管用data()不会出错，会给你自动转换，但是还是不建议，因为深拷贝了一份，理论上增加了内存开销，如果字符串长度小还好，一旦很长，这个开销挺大，这是个好的编程习惯。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查阅代码得知data函数有两个重载</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">detach</span>(); <span class="keyword">return</span> d-&gt;<span class="built_in">data</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">QByteArray::data</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> d-&gt;<span class="built_in">data</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">QByteArray::constData</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> d-&gt;<span class="built_in">data</span>(); &#125;</span><br><span class="line"></span><br><span class="line">QByteArray data = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="type">char</span> *d1 = data.<span class="built_in">data</span>();</span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *d2 = data.<span class="built_in">data</span>();</span><br><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *d3 = data.<span class="built_in">constData</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="built_in">test</span>(data.<span class="built_in">data</span>());</span><br><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="built_in">test</span>(data.<span class="built_in">constData</span>());</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//至于什么时候调用.data()会浅拷贝，酷码大佬说是当QByteArray被const修饰的时候</span></span><br><span class="line"><span class="type">const</span> QByteArray data;</span><br><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *d = data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//酷码大佬补充：自Qt 5.7版本以来，引入了qAsConst函数，专用于无脑转换。</span></span><br><span class="line"><span class="comment">//这个函数实现了C++17标准中的std::as_const()函数的功能，将一个非常量的左值转为常量的左值。</span></span><br><span class="line"><span class="comment">//增加qAsConst函数是为了Qt自己的非const 的容器能实现C++11标准的基于范围的循环。</span></span><br><span class="line"><span class="comment">//该函数主要用于qt容器在隐式共享中不被detach。</span></span><br><span class="line">QString s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">//下面会深拷贝引起性能损失</span></span><br><span class="line"><span class="keyword">for</span> (QChar ch : s)</span><br><span class="line"><span class="comment">//不会深拷贝</span></span><br><span class="line"><span class="keyword">for</span> (QChar ch : <span class="built_in">qAsConst</span>(s))</span><br><span class="line"><span class="comment">//下面也是浅拷贝，但是在编程时、在现实中，声明为const往往不容易做到。</span></span><br><span class="line"><span class="type">const</span> QString s;</span><br><span class="line"><span class="keyword">for</span> (QChar ch : s)</span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：对Qt自己实现的容器如：QVector、QMap、 QHash、QLinkedList、QList等，如果一定要用基于for（var : container）范围的循环，则请用如下形式：</span></span><br><span class="line"><span class="keyword">for</span> (var : <span class="built_in">qAsConst</span>(container))</span><br></pre></td></tr></table></figure></p></li>
<li><p>新版的Qt6.5在ubuntu上编译运行程序后会提示 qt.qpa.plugin: Could not load the Qt platform plugin "xcb" in "" even though it was found. ，无法正常弹出窗体程序，你需要主动安装xcb的相关库。sudo apt install libxcb*</p></li>
<li><p>有些场景下我们需要在 QApplication a(argc, argv); 前面执行一些处理，比如 QApplication::setAttribute 就必须在最前面执行，而很多时候这个设置的参数不能改写死，毕竟现场的环境千差万别，希望通过配置文件来配置，那么问题来了，读取配置文件一般需要指定路径才能正常读取到，如果是 ./ 这种，很可能未必是应用程序的当前路径，如果你是双击运行的程序，那肯定是应用程序的当前路径，不是双击运行那就是系统环境中的当前路径，意味着你开机启动或者用system、QProcess等方式在开机后调用启动的话，就未必正确了。为了保证这个路径的正确，必须从main函数的 argv 第一个值获取，通过查阅Qt自身代码中获取路径，也是从这个参数获取。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序最前面获取应用程序路径和名称</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">getCurrentInfo</span><span class="params">(<span class="type">char</span> *argv[], QString &amp;path, QString &amp;name)</span></span>;</span><br><span class="line"><span class="comment">//程序最前面读取配置文件节点的值</span></span><br><span class="line"><span class="function"><span class="type">static</span> QString <span class="title">getIniValue</span><span class="params">(<span class="type">const</span> QString &amp;fileName, <span class="type">const</span> QString &amp;key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> QString <span class="title">getIniValue</span><span class="params">(<span class="type">char</span> *argv[], <span class="type">const</span> QString &amp;key, <span class="type">const</span> QString &amp;dir = QString())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QUIHelper::getCurrentInfo</span><span class="params">(<span class="type">char</span> *argv[], QString &amp;path, QString &amp;name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//必须用fromLocal8Bit保证中文路径正常</span></span><br><span class="line">    QString argv0 = QString::<span class="built_in">fromLocal8Bit</span>(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="function">QFileInfo <span class="title">file</span><span class="params">(argv0)</span></span>;</span><br><span class="line">    path = file.<span class="built_in">path</span>();</span><br><span class="line">    name = file.<span class="built_in">baseName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">QUIHelper::getIniValue</span><span class="params">(<span class="type">const</span> QString &amp;fileName, <span class="type">const</span> QString &amp;key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString value;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">open</span>(QFile::ReadOnly | QFile::Text)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!file.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">            QString line = file.<span class="built_in">readLine</span>();</span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">startsWith</span>(key)) &#123;</span><br><span class="line">                line = line.<span class="built_in">replace</span>(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                line = line.<span class="built_in">trimmed</span>();</span><br><span class="line">                value = line.<span class="built_in">split</span>(<span class="string">&quot;=&quot;</span>).<span class="built_in">last</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">QUIHelper::getIniValue</span><span class="params">(<span class="type">char</span> *argv[], <span class="type">const</span> QString &amp;key, <span class="type">const</span> QString &amp;dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString path, name;</span><br><span class="line">    QUIHelper::<span class="built_in">getCurrentInfo</span>(argv, path, name);</span><br><span class="line">    QString fileName = <span class="built_in">QString</span>(<span class="string">&quot;%1/%2%3.ini&quot;</span>).<span class="built_in">arg</span>(path).<span class="built_in">arg</span>(dir).<span class="built_in">arg</span>(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getIniValue</span>(fileName, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> openGLType = QUIHelper::<span class="built_in">getIniValue</span>(argv, <span class="string">&quot;OpenGLType&quot;</span>).<span class="built_in">toInt</span>();</span><br><span class="line">    QUIHelper::<span class="built_in">initOpenGL</span>(openGLType);</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>当我们对QTableView/QTreeView/QTableWidget/QTreeWidget某行选中后，会发现某些单元格设置的前景色被覆盖了，比如设置的红色，一旦选中就变成了白色，这肯定不是我们想要的，需要用自定义委托将其去掉。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ItemDelegate</span> : <span class="keyword">public</span> QItemDelegate</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ItemDelegate</span><span class="params">(QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionViewItem &amp;option, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;itemdelegate.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ItemDelegate::<span class="built_in">ItemDelegate</span>(QObject *parent) : <span class="built_in">QItemDelegate</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ItemDelegate::paint</span><span class="params">(QPainter *painter, <span class="type">const</span> QStyleOptionViewItem &amp;option, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStyleOptionViewItem option2 = option;</span><br><span class="line">    QColor color = index.<span class="built_in">data</span>(Qt::ForegroundRole).<span class="built_in">value</span>&lt;QColor&gt;();</span><br><span class="line">    <span class="keyword">if</span> (color.<span class="built_in">isValid</span>() &amp;&amp; color != option.palette.<span class="built_in">color</span>(QPalette::WindowText)) &#123;</span><br><span class="line">        option2.palette.<span class="built_in">setColor</span>(QPalette::HighlightedText, color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QItemDelegate::<span class="built_in">paint</span>(painter, option2, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对所有单元格设置该委托</span></span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setItemDelegate</span>(<span class="keyword">new</span> ItemDelegate);</span><br></pre></td></tr></table></figure></p></li>
<li><p>有些时候我们需要在项目文件比如pro/pri中识别当前Qt套件是否存在某个模块以及是否引入过某个模块，存在则引入，同时也希望代码中也能识别是否引入过某个模块比如sql模块，判断后再进行对应的处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//项目文件中判断</span></span><br><span class="line"><span class="comment">//如果当前套件中有multimedia模块则引入multimedia模块</span></span><br><span class="line"><span class="built_in">qtHaveModule</span>(multimedia) &#123;QT += multimedia&#125;</span><br><span class="line"><span class="comment">//在项目文件中已经通过 QT += multimedia 引入过模块</span></span><br><span class="line"><span class="built_in">contains</span>(QT, multimedia) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码文件判断</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> QT_MULTIMEDIA_LIB</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;multimedia module is enabled&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;multimedia module is not enabled&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>对MDI窗体区域设置背景颜色透明，会发现 QMdiArea{background:transparent;} 无效，哪怕是指定颜色 QMdiArea{background:#ff0000;} 或者 QMdiArea{background-color:#ff0000;} 都不行，这就很无语了，原来要用弱属性机制才行。QMdiArea{qproperty-background:transparent;}</p></li>
<li><p>当样式中启用了禁用样式 *:disabled{xxx} 的时候，会发现MDI子窗体无法拉伸了，这应该是Qt内部的BUG，怎么解决呢，只需要重新设置MDI这个类别的禁用样式的边框样式即可。QMdiSubWindow:disabled{border:8px solid rgba(0,0,0,0);}</p></li>
<li><p>用QProcess执行命令或者启动可执行文件，默认写法不支持带空格的路径，比如 Program Files ，需要在这个路径前后加上双引号才行，估计可能内部会用空格分割字符串导致解析失败。普通路径加上引号也能正常执行，所以为了确保以防万一，统一加上引号即可。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString cmd = <span class="string">&quot;c:/Program Files/a.exe&quot;</span>;</span><br><span class="line"><span class="comment">//下面这个会执行失败</span></span><br><span class="line">QProcess::<span class="built_in">startDetached</span>(cmd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//前后加上引号就可以正常执行</span></span><br><span class="line">cmd = <span class="string">&quot;\&quot;&quot;</span> + cmd + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">QProcess::<span class="built_in">startDetached</span>(cmd);</span><br></pre></td></tr></table></figure></p></li>
<li><p>在循环中取值，临时变量的定义尽量在循环外层定义，每次在循环里层定义会增加开销，特别是复杂类型比如QString(基础类型比如int/bool差别不大)，循环次数越多，性能差别越大。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QElapsedTimer timer;</span><br><span class="line">    timer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    QString s;</span><br><span class="line">    QString text = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        s = text.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;方式1&quot;</span> &lt;&lt; timer.<span class="built_in">nsecsElapsed</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QElapsedTimer timer;</span><br><span class="line">    timer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    QString text = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        QString s = text.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;方式2&quot;</span> &lt;&lt; timer.<span class="built_in">nsecsElapsed</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//debug模式下方式1比方式2快6倍+</span></span><br><span class="line"><span class="comment">//release模式下方式1比方式2快30倍+</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt的属性机制非常强大，除了可以用来控制样式表，也可以很方便的用来传值，比如qml中的值传递，有时候我们写了一个通用类，希望这个类可以做很多事情，但是又希望其中有一些特殊变量存取值，一种办法是直接定义私有变量，提供get/set接口函数，还有一种偷懒的办法就是用属性setProperty/property，然Qt内部从元对象数据层面自己管理，这样不用在类中写对应的变量和get/set函数。但是肯定有性能损耗，性能上肯定比变量低，所以要看具体的实际需求，如果不是非常频繁的调用setProperty/property，通用性优先的话，那用属性机制会更方便。个人推荐方式三，继承通用类，在子类中增加set/get。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QElapsedTimer timer;</span><br><span class="line">    timer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        Test *t = <span class="keyword">new</span> Test;</span><br><span class="line">        <span class="comment">//t-&gt;setId(i);</span></span><br><span class="line">        <span class="comment">//t-&gt;setName(&quot;test&quot;);</span></span><br><span class="line">        t-&gt;<span class="built_in">getName</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;方式1&quot;</span> &lt;&lt; timer.<span class="built_in">nsecsElapsed</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QElapsedTimer timer;</span><br><span class="line">    timer.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        Test *t = <span class="keyword">new</span> Test;</span><br><span class="line">        <span class="comment">//t-&gt;setProperty(&quot;id&quot;, i);</span></span><br><span class="line">        <span class="comment">//t-&gt;setProperty(&quot;name&quot;, &quot;test&quot;);</span></span><br><span class="line">        t-&gt;<span class="built_in">property</span>(<span class="string">&quot;name&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;方式2&quot;</span> &lt;&lt; timer.<span class="built_in">nsecsElapsed</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对比测试和具体的变量类型无关/int和QString类型产生的性能差别一样</span></span><br><span class="line"><span class="comment">//setProperty比setxxx方式性能差3倍+</span></span><br><span class="line"><span class="comment">//property比getxxx方式性能差1.3倍</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="section-28">29：281-290</h3>
<ol start="281" type="1">
<li><p>悬停窗体QDockWidget默认在标题栏右键会弹出悬停模块的显示隐藏菜单，如果需要去掉，会发现设置Qt::NoContextMenu或者事件过滤器拦截都是无效的，必须设置 dockWidget-&gt;setContextMenuPolicy(Qt::PreventContextMenu); 。</p></li>
<li><p>Qt中的布局有个默认的margin边距值和spacing间距值，在没有设置该值的情况下，会根据运行的环境自动设置该值，比如1080P分辨率和2k分辨率的电脑，该值的默认值不一样，并不是你在UI设计的时候属性栏中看到的值，这个要特别注意，你看到的7可能在目标平台运行的时候是11，如果一定要按照你想要的值来运行，可以重新设置即可，设置过哪一个就该值按照设定的来。如果不想一个个设置调整布局中的间距边距，你需要用到万能大法样式代理，继承QProxyStyle类然后重新设置样式即可。该方式也是属于斗皇级别的UI外观控制策略，最终所有的qss样式也是要通过该样式去绘制的，意味着这里你可以重新定义和控制所有控件的外观样式，非常的强大。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//也可以继承Qt内置的样式比如 QFusionStyle/QCleanlooksStyle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QCustomStyle</span> : <span class="keyword">public</span> QProxyStyle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pixelMetric</span><span class="params">(PixelMetric metric, <span class="type">const</span> QStyleOption *option = <span class="number">0</span>, <span class="type">const</span> QWidget *widget = <span class="number">0</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (metric == QStyle::PM_LayoutHorizontalSpacing || metric == QStyle::PM_LayoutVerticalSpacing) &#123;</span><br><span class="line">            <span class="comment">//将布局中的横向和垂直间距设置成10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric == QStyle::PM_ButtonMargin) &#123;</span><br><span class="line">            <span class="comment">//将所有按钮的margin边距设置成20</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QProxyStyle::<span class="built_in">pixelMetric</span>(metric, option, widget);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">qApp-&gt;<span class="built_in">setStyle</span>(<span class="keyword">new</span> QCustomStyle);</span><br></pre></td></tr></table></figure></p></li>
<li><p>养成良好的编程习惯至关重要，尤其是对变量的初始化，包括一些类对象的定义后也务必记得初始化，否则在不初始化的时候，默认值飘忽不定，比如int默认值在debug/release下以及不同编译器下默认值都不一样，甚至在头文件定义以及函数中定义都可能不同的默认值，下面表格中整理的测试的值，对应的int值飘忽不定的。常见的默认初始化定义建议 int i = 0; bool b = false; class a = NULL;</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">版本</th>
<th style="text-align: left;">定义位置</th>
<th style="text-align: left;">debug/release</th>
<th style="text-align: left;">int</th>
<th style="text-align: left;">bool</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Qt4.7/mingw</td>
<td style="text-align: left;">头文件</td>
<td style="text-align: left;">debug</td>
<td style="text-align: left;">7077464</td>
<td style="text-align: left;">true</td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt4.7/mingw</td>
<td style="text-align: left;">头文件</td>
<td style="text-align: left;">release</td>
<td style="text-align: left;">48</td>
<td style="text-align: left;">true</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Qt4.7/mingw</td>
<td style="text-align: left;">函数中</td>
<td style="text-align: left;">debug</td>
<td style="text-align: left;">2162216</td>
<td style="text-align: left;">false</td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt4.7/mingw</td>
<td style="text-align: left;">函数中</td>
<td style="text-align: left;">release</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">false</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Qt5.7/msvc</td>
<td style="text-align: left;">头文件</td>
<td style="text-align: left;">debug</td>
<td style="text-align: left;">-1</td>
<td style="text-align: left;">true</td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt5.7/msvc</td>
<td style="text-align: left;">头文件</td>
<td style="text-align: left;">release</td>
<td style="text-align: left;">-1</td>
<td style="text-align: left;">true</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Qt5.7/msvc</td>
<td style="text-align: left;">函数中</td>
<td style="text-align: left;">debug</td>
<td style="text-align: left;">1898108572</td>
<td style="text-align: left;">false</td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt5.7/msvc</td>
<td style="text-align: left;">函数中</td>
<td style="text-align: left;">release</td>
<td style="text-align: left;">18872512</td>
<td style="text-align: left;">true</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Qt6.5/mingw</td>
<td style="text-align: left;">头文件</td>
<td style="text-align: left;">debug</td>
<td style="text-align: left;">-1305540880</td>
<td style="text-align: left;">true</td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt6.5/mingw</td>
<td style="text-align: left;">头文件</td>
<td style="text-align: left;">release</td>
<td style="text-align: left;">-1124044992</td>
<td style="text-align: left;">true</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Qt6.5/mingw</td>
<td style="text-align: left;">函数中</td>
<td style="text-align: left;">debug</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">false</td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt6.5/mingw</td>
<td style="text-align: left;">函数中</td>
<td style="text-align: left;">release</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">false</td>
</tr>
</tbody>
</table>
<h2 id="升级到qt6">2 升级到Qt6</h2>
<h3 id="直观总结">00：直观总结</h3>
<ol type="1">
<li>增加了很多轮子，同时原有模块拆分的也更细致，估计为了方便拓展个管理。</li>
<li>把一些过度封装的东西移除了（比如同样的功能有多个函数），保证了只有一个函数执行该功能。</li>
<li>把一些Qt5中兼容Qt4的方法废弃了，必须用Qt5中对应的新的函数。</li>
<li>跟随时代脚步，增加了不少新特性以满足日益增长的客户需求。</li>
<li>对某些模块和类型及处理进行了革命性的重写，运行效率提高不少。</li>
<li>有参数类型的变化，比如 long * 到 qintptr * 等，更加适应后续的拓展以及同时对32 64位不同系统的兼容。</li>
<li>源码中的double数据类型全部换成了qreal，和Qt内部数据类型高度一致和统一。</li>
<li>我测试的都是QWidget部分，quick部分没有测试，估计quick部分更新可能会更多。</li>
<li>强烈建议暂时不要用Qt6.0到Qt6.2之间的版本，一些模块还缺失，相对来说BUG也比较多，推荐6.2.2版本开始正式迁移。</li>
</ol>
<h3 id="section-29">01：01-10</h3>
<ol type="1">
<li><p>万能方法：安装5.15版本，定位到报错的函数，切换到源码头文件，可以看到对应提示字样 QT_DEPRECATED_X("Use sizeInBytes") 和新函数。按照这个提示类修改就没错，一些函数是从Qt5.7 5.9 5.10等版本新增加的，可能你的项目还用的Qt4的方法，但是Qt6以前都兼容这些旧方法，到了Qt6就彻底需要用新方法了。<strong>PS：如果本身就是Qt6新增的功能函数则此方法无效</strong></p></li>
<li><p>Qt6对core这个核心类进行了拆分，多出来core5compat，因此你需要在pro增加对应的模块已经代码中引入对应的头文件。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pro文件引入模块</span></span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets</span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">5</span>): QT += core5compat</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码中引入头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore5Compat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>默认Qt6开启了高分屏支持，界面会变得很大，甚至字体发虚，很多人会不习惯，因为这种模式如果程序很多坐标计算没有采用devicePixelRatio进行运算的话，100%会出现奇奇怪怪的问题，因为坐标不准确了。要取消这种效果可以设置高分屏缩放因子。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    QGuiApplication::<span class="built_in">setHighDpiScaleFactorRoundingPolicy</span>(Qt::HighDpiScaleFactorRoundingPolicy::Floor);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>原有的随机数函数提示用QRandomGenerator替代，为了兼容所有qt版本，改动最小的办法是直接用c++中的随机数，比如qsrand函数换成srand，qrand函数换成rand，查看过源代码，其实封装的就是c++中的随机数，很多类似的封装比如qSin封装的sin。</p></li>
<li><p>QColor的 light 改成 lighter ，dark 改成 darker，其实 lighter、darker 这两个方法以前一直有。</p></li>
<li><p>QFontMetricsF 中的 fm.width 换成 fm.horizontalAdvance ，从5.11开始用新函数。</p></li>
<li><p>QPalette调色板枚举值，Foreground = WindowText, Background = Window，其中 Foreground 和 Background 没有了，要用 WindowText 和 Window 替代，以前就有。类似的还有 setTextColor 改成了 setForeground 。</p></li>
<li><p>QWheelEvent的 delta() 改成 angleDelta().y()，pos() 改成 position() 。</p></li>
<li><p>svg模块拆分出来了svgwidgets，如果用到了该模块则需要在pro增加 QT += svgwidgets ，同理opengl模块拆分出来了openglwidgets。</p></li>
<li><p>qlayout中的 margin() 函数换成 contentsMargins().left()，查看源码得知以前的 margin() 返回的就是 contentsMargins().left()，在四个数值一样的时候，默认四个数值就是一样。类似的还有setMargin移除了，统统用setContentsMargins。</p></li>
</ol>
<h3 id="section-30">02：11-20</h3>
<ol start="11" type="1">
<li><p>之前 QChar c = 0xf105 全部要改成强制转换 QChar c = (QChar)0xf105，不再有隐式转换，不然编译报错提示error: conversion from 'int' to 'QChar' is ambiguous 。</p></li>
<li><p>qSort等一些函数用回c++的 std::sort 。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    std::<span class="built_in">sort</span>(ipv4s.<span class="built_in">begin</span>(), ipv4s.<span class="built_in">end</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">qSort</span>(ipv4s);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt::WA_NoBackground 改成 Qt::WA_OpaquePaintEvent 。</p></li>
<li><p>QMatrix 类废弃了没有了，换成 QTransform ，函数功能基本一致，QTransform 类在Qt4就一直有。</p></li>
<li><p>QTime 计时去掉了，需要改成 QElapsedTimer ，QElapsedTimer 类在Qt4就一直有。</p></li>
<li><p>QApplication::desktop()废弃了， 换成了 QApplication::primaryScreen()。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qscreen.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deskGeometry qApp-&gt;primaryScreen()-&gt;geometry()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deskGeometry2 qApp-&gt;primaryScreen()-&gt;availableGeometry()</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qdesktopwidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deskGeometry qApp-&gt;desktop()-&gt;geometry()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deskGeometry2 qApp-&gt;desktop()-&gt;availableGeometry()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>获取当前屏幕索引以及尺寸需要分别处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前屏幕索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QUIHelper::getScreenIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//需要对多个屏幕进行处理</span></span><br><span class="line">    <span class="type">int</span> screenIndex = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    <span class="type">int</span> screenCount = qApp-&gt;<span class="built_in">screens</span>().<span class="built_in">count</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> screenCount = qApp-&gt;<span class="built_in">desktop</span>()-&gt;<span class="built_in">screenCount</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (screenCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//找到当前鼠标所在屏幕</span></span><br><span class="line">        QPoint pos = QCursor::<span class="built_in">pos</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; screenCount; ++i) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">            <span class="keyword">if</span> (qApp-&gt;<span class="built_in">screens</span>().<span class="built_in">at</span>(i)-&gt;<span class="built_in">geometry</span>().<span class="built_in">contains</span>(pos)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="keyword">if</span> (qApp-&gt;<span class="built_in">desktop</span>()-&gt;<span class="built_in">screenGeometry</span>(i).<span class="built_in">contains</span>(pos)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                screenIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> screenIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前屏幕尺寸区域</span></span><br><span class="line"><span class="function">QRect <span class="title">QUIHelper::getScreenRect</span><span class="params">(<span class="type">bool</span> available)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QRect rect;</span><br><span class="line">    <span class="type">int</span> screenIndex = QUIHelper::<span class="built_in">getScreenIndex</span>();</span><br><span class="line">    <span class="keyword">if</span> (available) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">        rect = qApp-&gt;<span class="built_in">screens</span>().<span class="built_in">at</span>(screenIndex)-&gt;<span class="built_in">availableGeometry</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        rect = qApp-&gt;<span class="built_in">desktop</span>()-&gt;<span class="built_in">availableGeometry</span>(screenIndex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">        rect = qApp-&gt;<span class="built_in">screens</span>().<span class="built_in">at</span>(screenIndex)-&gt;<span class="built_in">geometry</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        rect = qApp-&gt;<span class="built_in">desktop</span>()-&gt;<span class="built_in">screenGeometry</span>(screenIndex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>QRegExp类移到了core5compat模块，需要主动引入头文件 #include "QRegExp"。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//设置限制只能输入数字+小数位</span></span><br><span class="line">    QString pattern = <span class="string">&quot;^-?[0-9]+([.]&#123;1&#125;[0-9]+)&#123;0,1&#125;$&quot;</span>;</span><br><span class="line">    <span class="comment">//设置IP地址校验过滤</span></span><br><span class="line">    QString pattern = <span class="string">&quot;(2[0-5]&#123;2&#125;|2[0-4][0-9]|1?[0-9]&#123;1,2&#125;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确切的说 QRegularExpression QRegularExpressionValidator 从5.0 5.1开始就有</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    <span class="function">QRegularExpression <span class="title">regExp</span><span class="params">(pattern)</span></span>;</span><br><span class="line">    QRegularExpressionValidator *validator = <span class="keyword">new</span> <span class="built_in">QRegularExpressionValidator</span>(regExp, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function">QRegExp <span class="title">regExp</span><span class="params">(pattern)</span></span>;</span><br><span class="line">    QRegExpValidator *validator = <span class="keyword">new</span> <span class="built_in">QRegExpValidator</span>(regExp, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    lineEdit-&gt;<span class="built_in">setValidator</span>(validator);</span><br></pre></td></tr></table></figure></p></li>
<li><p>QWheelEvent构造参数和对应的计算方位函数变了。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟鼠标滚轮</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &lt; QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="function">QWheelEvent <span class="title">wheelEvent</span><span class="params">(QPoint(<span class="number">0</span>, <span class="number">0</span>), -scal, Qt::LeftButton, Qt::NoModifier)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function">QWheelEvent <span class="title">wheelEvent</span><span class="params">(QPointF(<span class="number">0</span>, <span class="number">0</span>), QPointF(<span class="number">0</span>, <span class="number">0</span>), QPoint(<span class="number">0</span>, <span class="number">0</span>), QPoint(<span class="number">0</span>, -scal), Qt::LeftButton, Qt::NoModifier, Qt::ScrollBegin, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">QApplication::<span class="built_in">sendEvent</span>(widget, &amp;wheelEvent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标滚轮直接修改值</span></span><br><span class="line">QWheelEvent *whellEvent = (QWheelEvent *)event;</span><br><span class="line"><span class="comment">//滚动的角度,*8就是鼠标滚动的距离</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &lt; QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="type">int</span> degrees = whellEvent-&gt;<span class="built_in">delta</span>() / <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> degrees = whellEvent-&gt;<span class="built_in">angleDelta</span>().<span class="built_in">x</span>() / <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//滚动的步数,*15就是鼠标滚动的角度</span></span><br><span class="line"><span class="type">int</span> steps = degrees / <span class="number">15</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>qVariantValue 改成 qvariant_cast ，qVariantSetValue(v, value) 改成了 v.setValue(val)。相当于退回到最原始的方法，查看qVariantValue源码封装的就是qvariant_cast。</p></li>
</ol>
<h3 id="section-31">03：21-30</h3>
<ol start="21" type="1">
<li><p>QStyleOption的init改成了initFrom。</p></li>
<li><p>QVariant::Type 换成了 QMetaType::Type ，本身以前的 QVariant::Type 封装的就是 QMetaType::Type 。</p></li>
<li><p>QStyleOptionViewItemV2 V3 V4 之类的全部没有了，暂时可以用 QStyleOptionViewItem 替代。</p></li>
<li><p>QFont的 resolve 的一个重载函数换成了 resolveMask。</p></li>
<li><p>QSettings的 setIniCodec 方法移除了，默认就是utf8，不需要设置。</p></li>
<li><p>qcombobox 的 activated(QString) 和 currentIndexChanged(QString) 信号删除了，用int索引参数的那个，然后自己通过索引获取值。个人觉得这个没必要删除。</p></li>
<li><p>qtscript模块彻底没有了，尽管从Qt5时代的后期版本就提示为废弃模块，一致坚持到Qt6才正式废弃，各种json数据解析全部换成qjson类解析。</p></li>
<li><p>QByteArray 的 append indexOf lastIndexOf 等众多方法的QString参数重载函数废弃了，要直接传 QByteArray，就在原来参数基础上加上 .toUtf8() 。查看源码也看得到以前的QString参数也是转成.toUtf8()再去比较。</p></li>
<li><p>QDateTime的时间转换函数 toTime_t + setTime_t 名字改了，对应改成了 toSecsSinceEpoch + setSecsSinceEpoch ，这两个方法在Qt5.8时候新增加的。</p></li>
<li><p>QLabel的 pixmap 函数之前是指针 *pixmap() 现在换成了引用 pixmap()。</p></li>
</ol>
<h3 id="section-32">04：31-40</h3>
<ol start="31" type="1">
<li><p>QTableWidget的 sortByColumn 方法移除了默认升序的方法，必须要填入第二个参数表示升序还是降序。</p></li>
<li><p>qtnetwork模块中（TCP/UDP相关的socket）的错误信号error换成了errorOccurred，就改了个名字，注意websocket那块居然没统一改过来依然是叫error。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    <span class="built_in">connect</span>(udpSocket, <span class="built_in">SIGNAL</span>(<span class="built_in">errorOccurred</span>(QAbstractSocket::SocketError)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">error</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(tcpSocket, <span class="built_in">SIGNAL</span>(<span class="built_in">errorOccurred</span>(QAbstractSocket::SocketError)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">error</span>()));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">connect</span>(udpSocket, <span class="built_in">SIGNAL</span>(<span class="built_in">error</span>(QAbstractSocket::SocketError)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">error</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(tcpSocket, <span class="built_in">SIGNAL</span>(<span class="built_in">error</span>(QAbstractSocket::SocketError)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">error</span>()));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特别注意websocket中依然还是用error</span></span><br><span class="line"><span class="built_in">connect</span>(webSocket, <span class="built_in">SIGNAL</span>(<span class="built_in">error</span>(QAbstractSocket::SocketError)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">error</span>()));</span><br></pre></td></tr></table></figure></p></li>
<li><p>XmlPatterns模块木有了，全部用xml模块重新解析。</p></li>
<li><p>nativeEvent的参数类型变了。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">nativeEvent</span><span class="params">(<span class="type">const</span> QByteArray &amp;eventType, <span class="type">void</span> *message, qintptr *result)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">nativeEvent</span><span class="params">(<span class="type">const</span> QByteArray &amp;eventType, <span class="type">void</span> *message, <span class="type">long</span> *result)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>QButtonGroup的buttonClicked信号中int参数的函数全部改名字叫idClicked。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    QButtonGroup *btnGroup = <span class="keyword">new</span> <span class="built_in">QButtonGroup</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    <span class="built_in">connect</span>(btnGroup, <span class="built_in">SIGNAL</span>(<span class="built_in">idClicked</span>(<span class="type">int</span>)), ui-&gt;xstackWidget, <span class="built_in">SLOT</span>(<span class="built_in">setCurrentIndex</span>(<span class="type">int</span>)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">connect</span>(btnGroup, <span class="built_in">SIGNAL</span>(<span class="built_in">buttonClicked</span>(<span class="type">int</span>)), ui-&gt;xstackWidget, <span class="built_in">SLOT</span>(<span class="built_in">setCurrentIndex</span>(<span class="type">int</span>)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>QWebEngineSettings之前是QWebEngineSettings::defaultSettings();现在改成了QWebEngineProfile::defaultProfile()-&gt;settings();通过查看之前的源码得知QWebEngineSettings::defaultSettings();封装的就是QWebEngineProfile::defaultProfile()-&gt;settings();因为Qt6去除了N多过度封装的函数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    QWebEngineSettings *webSetting = QWebEngineProfile::<span class="built_in">defaultProfile</span>()-&gt;<span class="built_in">settings</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    QWebEngineSettings *webSetting = QWebEngineSettings::<span class="built_in">defaultSettings</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt6将enterEvent的参数QEvent改成了QEnterEvent也不打个招呼。这种改变编译也不会提示的。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEnterEvent *)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEvent *)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后面经过JasonWong大佬的指点，从父类重新实现的virtual修饰的函数，建议都加上override关键字。</span></span><br><span class="line"><span class="comment">//这样的话一旦父类的函数或者参数变了则会提示编译报错，而不是编译通过但是运行不正常会一脸懵逼茫然，从而把锅扣给Qt。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是父类函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEvent *event)</span></span>;</span><br><span class="line"><span class="comment">//子类建议加上override</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt6中多个类进行了合并，比如现在QVector就成了QList的别名，意味着这两个类是同一个类没有任何区别，可能Qt内部对两种的优点都集中在一起，并尽量重写算法或者其他处理规避缺点。同理QStringList现在也成了 QList&lt;QString&gt; 的别名，是同一个类，没有单独的类。</p></li>
<li><p>在Qt4时代默认QWidget构造函数父类是0，到了Qt5变成了Q_NULLPTR，到了Qt6居然用的是默认的c++标准中的nullptr而不是Qt自定义定义的Q_NULLPTR（同样的还有Q_DECL_OVERRIDE换成了用override等），可能是为了彻底抛弃历史包袱拥抱未来。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面依次是Qt4/5/6的写法</span></span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="number">0</span>);</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = Q_NULLPTR);</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查阅Qt源码查看Q_NULLPTR原来是根据编译器定义来选择</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_COMPILER_NULLPTR</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> Q_NULLPTR         nullptr</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> Q_NULLPTR         NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Qt高版本兼容低版本写法比如Qt5/6都支持 *parent = 0 这种写法。</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>对于委托的进度条样式QStyleOptionProgressBar类的属性，在Qt4的时候不能设置横向还是垂直样式，默认横向样式，要设置orientation需要用另外的QStyleOptionProgressBarV2。从Qt5开始新增了orientation和bottomToTop属性设置。在Qt6的时候彻底移除了orientation属性，只有bottomToTop属性，而且默认进度是垂直的，很操蛋，理论上默认应该是横向的才对，绝大部分进度条场景都是横向的。这个时候怎么办呢，原来现在的处理逻辑改了，默认垂直的，如果要设置横向的直接设置 styleOption.state |= QStyle::State_Horizontal 这种方式设置才行，而Qt6以前默认方向是通过 orientation 值取得，这个State_Horizontal从Qt4就一直有，Qt6以后要主动设置下才是横向的就是。</p></li>
</ol>
<h3 id="section-33">05：41-50</h3>
<ol start="41" type="1">
<li><p>Qt6.2版本开始增加了对多媒体模块的支持，但是在mingw编译器下还是有问题，直到6.2.2才修复这个问题，官网解释是因为mingw编译器版本不支持，到6.2.2采用了新的mingw900_64，这个编译器版本才支持。所以理论上推荐从6.2.2开始使用新的Qt6。</p></li>
<li><p>QTextStream中的setCodec方法改成了setEncoding，参数变了，功能更强大。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QTextStream <span class="title">stream</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &lt; QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">stream.<span class="built_in">setCodec</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">stream.<span class="built_in">setCodec</span>(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">stream.<span class="built_in">setEncoding</span>(QStringConverter::Utf8);</span><br><span class="line">stream.<span class="built_in">setEncoding</span>(QStringConverter::System);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>QModelIndex的查找子节点child函数去掉了，但是查找父节点parent函数保留，查阅代码得知之前的child函数就是封装的model-&gt;index(row, column, QModelIndex)函数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面两个函数等价 如果要兼容Qt456则用下面这个方法</span></span><br><span class="line">QModelIndex index = indexParent.<span class="built_in">child</span>(i, <span class="number">0</span>);</span><br><span class="line">QModelIndex index = model-&gt;<span class="built_in">index</span>(i, <span class="number">0</span>, indexParent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个函数等价 如果要兼容Qt456则用下面这个方法</span></span><br><span class="line">QModelIndex indexChild = index.<span class="built_in">child</span>(i, <span class="number">0</span>);</span><br><span class="line">QModelIndex indexChild = model-&gt;<span class="built_in">index</span>(i, <span class="number">0</span>, index);</span><br></pre></td></tr></table></figure></p></li>
<li><p>之前QPixmap类中的静态函数grabWindow和grabWidget彻底废弃了，改成了用QApplication::primaryScreen()-&gt;grabWindow，其实这个从Qt5开始就建议用这个。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    QPixmap pixmap = QApplication::<span class="built_in">primaryScreen</span>()-&gt;<span class="built_in">grabWindow</span>(widget-&gt;<span class="built_in">winId</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    QPixmap pixmap = QPixmap::<span class="built_in">grabWidget</span>(widget-&gt;<span class="built_in">winId</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>QProcess中的start方法以前直接支持传入完整的命令，到了Qt6严格要求必须拆分后面的参数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Qt6以前支持执行完整命令</span></span><br><span class="line">QProcess p;</span><br><span class="line">p.<span class="built_in">start</span>(<span class="string">&quot;wmic cpu get Name&quot;</span>);</span><br><span class="line"><span class="comment">//Qt6需要改成下面的方法，此方法也兼容Qt4、5、6</span></span><br><span class="line">p.<span class="built_in">start</span>(<span class="string">&quot;wmic&quot;</span>, <span class="built_in">QStringList</span>() &lt;&lt; <span class="string">&quot;cpu&quot;</span> &lt;&lt; <span class="string">&quot;get&quot;</span> &lt;&lt; <span class="string">&quot;Name&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>在qss中对属性的枚举值写法到了Qt6换成了数值表示（需要翻阅枚举值的定义找到对应的值），这个改动挺大，切记需要切换过来，而且这种写法不兼容Qt5。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Qt4/5 通过样式表设置标签右上角对齐</span></span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;qproperty-alignment:AlignRight;&quot;</span>);</span><br><span class="line"><span class="comment">//Qt4/5 通过样式表设置标签居中对齐</span></span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;qproperty-alignment:AlignHCenter|AlignVCenter;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Qt6 通过样式表设置标签右上角对齐 翻阅 AlignRight 的枚举值=2</span></span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;qproperty-alignment:2;&quot;</span>);</span><br><span class="line"><span class="comment">//Qt6 通过样式表设置标签居中对齐 翻阅 AlignHCenter|AlignVCenter 的枚举值=0x04|0x80=0x84=132</span></span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;qproperty-alignment:132;&quot;</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt6中多媒体模块的类做了巨大调整改动，有些是类名的变化，比如音频输出（也叫播放）之前是 QAudioOutput 现在是 QAudioSink ，音频输入（也叫录音）之前是 QAudioInput 现在是 QAudioSource ，默认音频输入输出设备集合之前是 QAudioDeviceInfo::defaultInputDevice()、QAudioDeviceInfo::defaultOutputDevice()，现在是 QMediaDevices::defaultAudioInput()、QMediaDevices::defaultAudioOutput()。感觉这个名字改的没有以前贴切。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,2,0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AudioInput QAudioSource</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AudioOutput QAudioSink</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AudioInput QAudioInput</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AudioOutput QAudioOutput</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//使用的时候只需要new就行</span></span><br><span class="line">AudioInput *input = <span class="keyword">new</span> <span class="built_in">AudioInput</span>(format, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,2,0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QAudioInput QAudioSource</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QAudioOutput QAudioSink</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//使用的时候只需要new就行</span></span><br><span class="line">QAudioInput *input = <span class="keyword">new</span> <span class="built_in">QAudioInput</span>(format, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>Qt6开始默认用cmake，所以现在新版的qtcreator在新建项目的时候默认选择的就是cmake，很多初学者首次用的时候会发现，怎么突然之间生成的项目，结构都不一样，突然之间懵逼了，所以要在新建项目的过程中选择qmake，选择一次以后就默认qmake了。</p></li>
<li><p>Qt6.4开始对应类QString/QByteArray的count函数废弃了，改用size/length函数，估计可能描述更准确吧。</p></li>
<li><p>Qt6.4.1新增了N多BUG，强烈不建议使用，比如QAudioSink播放声音没有声音 <a href="https://bugreports.qt.io/browse/QTBUG-108383">https://bugreports.qt.io/browse/QTBUG-108383</a>，DPI缩放严重变形 <a href="https://bugreports.qt.io/browse/QTBUG-108593">https://bugreports.qt.io/browse/QTBUG-108593</a>。这些BUG在6.4.0/6.5.0是不存在的，KPI害死人啊。</p></li>
<li><p>Qt6.5版本开始取消了QVariant的默认构造函数，之前return QVariant() 现在必须改成 QVariant(QVariant::Invalid) 才不会有警告提示。通过打印值发现QVariant()本身就=QVariant(QVariant::Invalid)，所以统一写成QVariant(QVariant::Invalid)兼容Qt456。</p></li>
</ol>
<h2 id="qt安卓经验">3 Qt安卓经验</h2>
<h3 id="section-34">01：01-05</h3>
<ol type="1">
<li>pro中引入安卓拓展模块 QT += androidextras 。</li>
<li>pro中指定安卓打包目录 ANDROID_PACKAGE_SOURCE_DIR = $$PWD/android 指定引入安卓特定目录比如程序图标、变量、颜色、java代码文件、jar库文件等。</li>
</ol>
<ul>
<li>AndroidManifest.xml 每个程序唯一的一个全局配置文件，里面xml格式的数据，标明支持的安卓版本、图标位置、横屏竖屏、权限等。这个文件是最关键的，如果没有这个文件则Qt会默认生成一个。</li>
<li>android/res/drawable-hdpi drawable-xxxhdpi 等目录下存放的是应用程序图标。</li>
<li>android/res/layout 目录下存放的布局文件。</li>
<li>android/res/values/libs.xml 存储的一些变量值。</li>
<li>android/libs 目录下存放的jar库文件。</li>
<li>android/src 目录下存放的java代码文件，可以是根据包名建立的一层层子目录，也可以直接在src目录下。</li>
<li>其他目录自行搜索安卓目录规范。</li>
<li>后面的说明统一用的android目录举例，其实你可以改成任意目录，比如你的代码目录下是xxoo存放的安卓相关的打包文件，你就写成 ANDROID_PACKAGE_SOURCE_DIR = $$PWD/xxoo 。</li>
</ul>
<ol start="3" type="1">
<li>java类名必须和文件名完全一致，区分大小写。</li>
<li>java类必须在android/src目录下不然不会打包到apk文件，可以是子目录比如 android/src/com/qt 。</li>
<li>Qt代码中的QAndroidJniObject指定传入的java包名，必须严格和java文件package完全一致，不然程序执行到此处会因为找不到而崩溃。</li>
</ol>
<ul>
<li>android/scr/MainActivity.java 顶部 没有 package 则代码中必须是 QAndroidJniObject javaClass("MainActivity");</li>
<li>android/scr/MainActivity.java 顶部 package com.qandroid; 则代码中必须是 QAndroidJniObject javaClass("com/qandroid/MainActivity");</li>
<li>android/scr/com/example/MainActivity.java 顶部 package com.qandroid; 则代码中必须是 QAndroidJniObject javaClass("com/qandroid/MainActivity");</li>
<li>android/scr/com/example/MainActivity.java 顶部 package com.example.qandroid; 则代码中必须是 QAndroidJniObject javaClass("com/qandroid/example/MainActivity");</li>
<li>总之这个包名是和代码中的package后面一段吻合，而不是目录路径。为了统一管理方便查找文件，建议包名和目录路径一致。</li>
</ul>
<h3 id="section-35">02：06-10</h3>
<ol start="6" type="1">
<li>Qt只能干Qt内部类的事情，做一些简单的UI交互还是非常方便，如果涉及到底层操作，还是需要熟悉java会如虎添翼，一般的做法就是写好java文件调试好，提供静态方法给Qt调用，这样通过QAndroidJniObject这个万能胶水可以做到Qt程序调用java中的函数并拿到执行结果，也可以接收java中的函数。</li>
<li>pro中通过 OTHER_FILES += android/AndroidManifest.xml OTHER_FILES += android/src/JniMessenger.java 引入文件其实对整个程序的编译打包没有任何影响，就是为了方便在QtCreator中查看和编辑。</li>
<li>在Qt中与安卓的java文件交互都是用万能的QAndroidJniObject，可以执行java类中的普通函数、静态函数，可以传类对象jclass、类名className、方法methodName、参数，也可以拿到执行结果返回值。 (I)V括号中的是参数类型，括号后面的是返回值类型，void返回值对应V，由于String在java中不是数据类型而是类，所以要用Ljava/lang/String;表示，其他类作为参数也是这样处理。</li>
</ol>
<ul>
<li>调用实例方法：callMethod、callObjectMethod。</li>
<li>调用静态方法：callStaticMethod、callStaticObjectMethod。</li>
<li>不带Object的函数名用来执行无返回值或者常规返回值int、float等的方法。</li>
<li>如果返回值是String或者类则需要用带Object的函数名来执行，返回QAndroidJniObject类型再转换处理拿到结果，比如toString拿到字符串。</li>
</ul>
<ol start="9" type="1">
<li>各种参数和返回值示例。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.qt;</span><br><span class="line"><span class="keyword">import</span> org.qt.QtAndroidData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QtAndroidTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//需要通过实例来调用 测试发现不论 private public 或者不写都可以调用 我擦</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printText</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;printText&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMsg</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;printMsg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printValue</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;printValue:&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">float</span> value1, <span class="type">double</span> value2, <span class="type">char</span> value3)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value1:&quot;</span> + value1 + <span class="string">&quot; value2:&quot;</span> + value2 + <span class="string">&quot; value3:&quot;</span> + value3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">65536</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setMsg:&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMsg</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello from java&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setText</span><span class="params">(<span class="type">int</span> value1, <span class="type">float</span> value2, <span class="type">boolean</span> value3, String message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value1:&quot;</span> + value1 + <span class="string">&quot; value2:&quot;</span> + value2 + <span class="string">&quot; value3:&quot;</span> + value3 + <span class="string">&quot; message:&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getText</span><span class="params">(<span class="type">int</span> value1, <span class="type">float</span> value2, <span class="type">boolean</span> value3, String message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//同时演示触发静态函数发给Qt</span></span><br><span class="line">        QtAndroidData.receiveData(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;你好啊 java&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面两种办法都可以拼字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;value1:&quot;</span> + value1 + <span class="string">&quot; value2:&quot;</span> + value2 + <span class="string">&quot; value3:&quot;</span> + value3 + <span class="string">&quot; message:&quot;</span> + message;</span><br><span class="line">        <span class="comment">//return &quot;value1:&quot; + String.valueOf(value1) + &quot; value2:&quot; + String.valueOf(value2) + &quot; value3:&quot; + String.valueOf(value3) + &quot; message:&quot; + message;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;androidtest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//java类对应的包名+类名</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> className <span class="string">&quot;org/qt/QtAndroidTest&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidTest::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jint a = <span class="number">12</span>;</span><br><span class="line">    jint b = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//可以直接调用java内置类中的方法</span></span><br><span class="line">    jint max = QAndroidJniObject::<span class="built_in">callStaticMethod</span>&lt;jint&gt;(<span class="string">&quot;java/lang/Math&quot;</span>, <span class="string">&quot;max&quot;</span>, <span class="string">&quot;(II)I&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//jclass javaMathClass = &quot;java/lang/Math&quot;;</span></span><br><span class="line">    jdouble value = QAndroidJniObject::<span class="built_in">callStaticMethod</span>&lt;jdouble&gt;(<span class="string">&quot;java/lang/Math&quot;</span>, <span class="string">&quot;random&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;111&quot;</span> &lt;&lt; max &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidTest::printText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QAndroidJniEnvironment env;</span><br><span class="line">    jclass clazz = env.<span class="built_in">findClass</span>(className);</span><br><span class="line">    <span class="function">QAndroidJniObject <span class="title">obj</span><span class="params">(clazz)</span></span>;</span><br><span class="line">    obj.<span class="built_in">callMethod</span>&lt;<span class="type">void</span>&gt;(<span class="string">&quot;printText&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidTest::printMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">//查看源码得知不传入jclass类的函数中内部会自动根据类名查找jclass</span></span><br><span class="line">    QAndroidJniEnvironment env;</span><br><span class="line">    jclass clazz = env.<span class="built_in">findClass</span>(className);</span><br><span class="line">    QAndroidJniObject::<span class="built_in">callStaticMethod</span>&lt;<span class="type">void</span>&gt;(clazz, <span class="string">&quot;printMsg&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//没有参数和返回值可以忽略第三个参数</span></span><br><span class="line">    QAndroidJniObject::<span class="built_in">callStaticMethod</span>&lt;<span class="type">void</span>&gt;(className, <span class="string">&quot;printMsg&quot;</span>);</span><br><span class="line">    <span class="comment">//QAndroidJniObject::callStaticMethod&lt;void&gt;(classNameTest, &quot;printMsg&quot;, &quot;()V&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidTest::printValue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QAndroidJniObject::<span class="built_in">callStaticMethod</span>&lt;jint&gt;(className, <span class="string">&quot;printValue&quot;</span>, <span class="string">&quot;(I)I&quot;</span>, (jint)value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidTest::setValue</span><span class="params">(<span class="type">float</span> value1, <span class="type">double</span> value2, <span class="type">char</span> value3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QAndroidJniObject::<span class="built_in">callStaticMethod</span>&lt;<span class="type">void</span>&gt;(className, <span class="string">&quot;setValue&quot;</span>, <span class="string">&quot;(FDC)V&quot;</span>, (jfloat)value1, (jdouble)value2, (jchar)value3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">AndroidTest::getValue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//java类中有两个 getValue 函数 一个需要传参数</span></span><br><span class="line">    <span class="comment">//jint result = QAndroidJniObject::callStaticMethod&lt;jint&gt;(className, &quot;getValue&quot;);</span></span><br><span class="line">    jint result = QAndroidJniObject::<span class="built_in">callStaticMethod</span>&lt;jint&gt;(className, <span class="string">&quot;getValue&quot;</span>, <span class="string">&quot;(I)I&quot;</span>, (jint)value);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidTest::setMsg</span><span class="params">(<span class="type">const</span> QString &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QAndroidJniObject jmsg = QAndroidJniObject::<span class="built_in">fromString</span>(msg);</span><br><span class="line">    QAndroidJniObject::<span class="built_in">callStaticMethod</span>&lt;<span class="type">void</span>&gt;(className, <span class="string">&quot;setMsg&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, jmsg.<span class="built_in">object</span>&lt;jstring&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">AndroidTest::getMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QAndroidJniObject result = QAndroidJniObject::<span class="built_in">callStaticObjectMethod</span>(className, <span class="string">&quot;getMsg&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidTest::setText</span><span class="params">(<span class="type">int</span> value1, <span class="type">float</span> value2, <span class="type">bool</span> value3, <span class="type">const</span> QString &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QAndroidJniObject jmsg = QAndroidJniObject::<span class="built_in">fromString</span>(msg);</span><br><span class="line">    QAndroidJniObject::<span class="built_in">callStaticMethod</span>&lt;<span class="type">void</span>&gt;(className, <span class="string">&quot;setText&quot;</span>, <span class="string">&quot;(IFZLjava/lang/String;)V&quot;</span>, (jint)value1, (jfloat)value2, (jboolean)value3, jmsg.<span class="built_in">object</span>&lt;jstring&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QString <span class="title">AndroidTest::getText</span><span class="params">(<span class="type">int</span> value1, <span class="type">float</span> value2, <span class="type">bool</span> value3, <span class="type">const</span> QString &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QAndroidJniObject jmsg = QAndroidJniObject::<span class="built_in">fromString</span>(msg);</span><br><span class="line">    QAndroidJniObject result = QAndroidJniObject::<span class="built_in">callStaticObjectMethod</span>(className, <span class="string">&quot;getText&quot;</span>, <span class="string">&quot;(IFZLjava/lang/String;)Ljava/lang/String;&quot;</span>, (jint)value1, (jfloat)value2, (jboolean)value3, jmsg.<span class="built_in">object</span>&lt;jstring&gt;());</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="10" type="1">
<li>在原生Android开发中，不同页面会定义不同的Activity。但使用Qt Quick、Flutter等采用Direct UI方式实现的第三方开发框架则只定义了一个Activity。里面不同页面实际都是使用OpenGL等直接绘制的。https://blog.csdn.net/LCSENs/article/details/100182235</li>
</ol>
<h3 id="section-36">03：11-15</h3>
<ol start="11" type="1">
<li><p>安卓中一个界面窗体对应一个Activity，多个界面就有多个Activity，而在Qt安卓程序中，Qt这边只有一个Activity那就是QtActivity（包名全路径 org.qtproject.qt5.android.bindings.QtActivity），这个QtActivity是固定的写好的，整个Qt程序都是在这个QtActivity界面中。你打开AndroidManifest.xml文件可以看到对应节点有个name=org.qtproject.qt5.android.bindings.QtActivity，所以如果要让Qt程序能够更方便通畅的与对应的java类进行交互（需要上下文传递Activity的，比如震动，消息提示等），建议新建一个java类，继承自QtActivity即可，这样相当于默认Qt启动的就是你java类中定义的Activity，可以很好的控制和交互。</p></li>
<li><p>由于AndroidManifest.xml文件每个程序都可能不一样，为了做成通用的组件，这就要求可能不能带上AndroidManifest.xml文件，这样的话每个Qt安卓程序都启动默认内置的Activity，如果依赖Activity上下文的执行函数需要传入Qt的Activity才行，这里切记Qt的Activity包名是 Lorg/qtproject/qt5/android/bindings/QtActivity; 之前顺手想当然的写的 Landroid/app/Activity; 发现死活不行，原来是包名错了。</p></li>
<li><p>一个Qt安卓程序中可以有多个Java类，包括继承自Activity的类（这样的Activity可以通过QtAndroid::startActivity函数来调用），但是只能有一个通过AndroidManifest.xml文件指定的Activity，不指定会默认一个。如果java类中不需要拿到Qt的Activity进行处理的，可以不需要继承任何Activity，比如全部是运算的静态函数。</p></li>
<li><p>在java类中如果上面没有主动引入包名，则下面需要写全路径，引入了则不需要全路径可以直接用（包括枚举值都可以直接写，比如 VIBRATOR_SERVICE 这种枚举值引入了包名后不需要写android.content.Context.VIBRATOR_SERVICE），建议引入包名，比如上面写了 import org.qtproject.qt5.android.bindings.QtActivity; 则下面继承类可以直接写 public class QtAndroidActivity extends QtActivity，如果没有引入则需要写成 public class QtAndroidActivity extends org.qtproject.qt5.android.bindings.QtActivity 。</p></li>
<li><p>建议搭配 android studio 工具开发，因为在 android studio 中写代码都有自动语法提示，包名会提示自动引入，可以查看有那些函数方法等，还可以校验代码是否正确，而如果在QtCreator中手写有时候可能会写错，尤其是某个字母写错，当然这种错误是编译通不过的，会提示错误在哪行。</p></li>
</ol>
<h3 id="section-37">04：16-20</h3>
<ol start="16" type="1">
<li><p>用Qt做安卓开发最大难点两个，第一个就是传参数这些奇奇怪怪的字符（Ljava/lang/String;）啥意思，如何对应，这也不是Qt故意为难初学者啥的，因为这套定义机制是安卓系统底层要求的，系统层面定义的一套规范，其实这个在帮助文档中写的很清楚，都有数据类型对照表，用熟悉了几次就很简单了。第二个难点就是用java写对应的类，如果是会安卓开发的人来说那不要太简单，尤其是搜索那么方便一大堆，没有搞过安卓开发的人来说就需要学习下，这个没有捷径，只是希望Qt能够尽可能最大化的封装一些可以直接使用的类，比如后期版本就提供了权限申请的类 QtAndroid::requestPermissionsSync 之类的，用起来就非常的爽，不用自己写个java类调来调去的。</p></li>
<li><p>理论上来说按照Qt提供的万能大法类QAndroidJniObject，可以不用写java类也能执行各种处理，拿到安卓库中的属性和执行方法，就是写起来太绕太费劲，在java类中一行代码，这里起码三行，所以终极大法就是熟悉安卓开发，直接封装好java类进行调用。</p></li>
<li><p>测试发现GetStringUTFChars方法对应的数据字符串中不能带有temp字样，否则解析有问题，不知什么原因。</p></li>
<li><p>数据类型参数和返回值类型必须完全一致，否则执行会提示找不到对应的函数，有返回值一定要写上返回值。</p></li>
<li><p>jar文件对包名的命名没有要求，只要放在android/libs目录下即可，安卓底层是通过包名去查找，而不是通过文件名，你甚至可以将原来的包名重新改成也可以正常使用，比如classes.jar改成test.jar也能正常使用。</p></li>
</ol>
<h3 id="section-38">05：21-25</h3>
<ol start="21" type="1">
<li><p>关于权限设置，在早期的安卓版本，所有权限都写在全局配置文件AndroidManifest.xml中，这种叫安装时权限，就是安装的时候告诉安卓系统当前app需要哪些权限。大概从安卓6开始，部分权限需要动态申请，这种叫动态权限，这种申请到的权限也可以动态撤销，就是要求程序再次执行代码去向系统申请权限，比如拍照、存储读写等。也不是所有的权限都改成了动态申请，意味着兼容安卓6以上的系统你既要在AndroidManifest.xml中写上要求的权限，也要通过checkPermission申请你需要的权限。</p></li>
<li><p>android studio 新建并生产jar包步骤。</p></li>
</ol>
<ul>
<li>第一步：文件（File）-》新建（new）-》项目（new project）-》空白窗体（empty activity）。</li>
<li>第二步：刚才新建好的项目鼠标右键新建（new）-》模块（new module）-》安卓库（android library）。</li>
<li>说明：如果选择的不是安卓库（android library）而是java库（Java Library），则直接编译出来的就是jar文件，默认包名 com.example.lib.MyClass。推荐选择java库，编译后不用去一堆文件中找jar文件。</li>
<li>第三步：写好库名字，根据项目需要选择好最低sdk版本-》完成。</li>
<li>第四步：在刚才新建好的库项目mylibrary，依次找到子节点src/main/java/com.example.mylibrary上鼠标右键新建-》class类。切记是这个节点不是java节点或者其他节点。</li>
<li>第五步：写好你的类方法函数等。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">package com.example.mylibrary;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第六步：选中库项目mylibrary，菜单执行编译（build）-》编译库（make module xxx）。</li>
<li>第七步：此时在mylibrary/build目录下有outputs目录和intermediates目录，其中outputs/aar目录下是生成的Android库项目的二进制归档文件，包含所有资源，class以及res资源文件全部包含。有时候我们仅仅需要jar文件，只包含了class文件与清单文件 ，不包含资源文件，如图片等所有res中的文件。需要到intermediates/aar_main_jar/debug目录下，可以看到classes.jar，将这个拷贝出来使用即可。当然你也可以对刚才的aar文件用解压缩软件解压出来也能看到classes.jar，是同一个文件。</li>
<li>其他：调用jar包非常简单，只需要将jar文件放在你的项目的libs目录下即可，对应的包名和函数一般jar包提供者会提供，没有提供的话，可以在android studio中新建空白项目，切换到project视图，找到libs目录，鼠标右键最下面作为包动态库添加到项目，导入包完成以后会自动在libs目录列出，双击刚刚导入的包然后就自动列出对应的类和函数。</li>
</ul>
<ol start="23" type="1">
<li>Qt安卓使用jar包步骤。</li>
</ol>
<ul>
<li>第一步：将classes.jar放到android/libs目录下，为啥是这个目录？因为这是安卓的规则约定，这个目录就是放库文件，放在这个目录下的文件会自动打包编译到apk文件中。</li>
<li>第二步：调用jar文件之前，前提是你知道jar文件中的函数详细信息，这个一般jar提供者会提供好手册，如果代码没有混肴的话，你可以在android studio中双击打开查阅具体的函数。</li>
<li>第三步：如果jar文件中的函数简单，直接拿到结果不需要绕来绕去，可以直接写Qt类来调用；如果还是很复杂，建议再去新建java类处理完再交给Qt，当然也可以让jar的作者尽可能封装函数的时候就做好，尽量提供最简单的接口返回需要的数据。比如返回图片数据可以做成jar内部存储好图片，然后返回图片路径即可，不然有些数据转换也挺烦。</li>
<li>第四步：编写最终的调用函数。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">AndroidJar::add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_ANDROID</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *className = <span class="string">&quot;com/example/mylibrary/Test&quot;</span>;</span><br><span class="line">    jint result = QAndroidJniObject::<span class="built_in">callStaticMethod</span>&lt;jint&gt;(className, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;(II)I&quot;</span>, (jint)a, (jint)b);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="24" type="1">
<li>Qt6中对安卓支持部分做了大的改动，目前还不完善，如果是不涉及到与java交互的纯Qt项目，可以正常移植，涉及到的暂时不建议移植到Qt6，等所有类完善了再说。</li>
</ol>
<ul>
<li>移除了安卓插件androidextras，将其中部分功能类移到core模块中，不需要额外引入。</li>
<li>类名发生了变化，比如QAndroidJniObject改成了QJniObject、QAndroidJniEnvironment改成了QJniEnvironment，可能是为了统一移动开发平台类，弱化安卓的影响。</li>
<li>对应的安卓jdk要用jdk11而不是jdk1.8，Qt5.15两个都支持，建议就统一用jdk11。</li>
<li>对应封装的java类包名去掉了qt5标识，org.qtproject.qt5.android.bindings.QtActivity改成了org.qtproject.qt.android.bindings.QtActivity、org.qtproject.qt5.android.bindings.QtApplication改成了org.qtproject.qt.android.bindings.QtApplication。</li>
<li>对安卓最低sdk有要求，所以建议在配置AndroidManifest.xml文件的时候不要带上最低版本要求。</li>
<li>对AndroidManifest.xml文件内容有要求，之前Qt5安卓的不能在Qt6安卓下使用，具体内容参见示例下的文件。</li>
<li>对应示例demo在 C:.0目录下，之前是 C:.2，目前就一个示例，可能因为其他类还没有移植好。</li>
<li>Qt6中安卓模块介绍在这里 https://doc.qt.io/qt-6/qtandroidprivate.html</li>
</ul>
<ol start="25" type="1">
<li>如果想要安卓全屏遮挡住顶部状态栏，可以在main函数中将show改成showFullScreen即可，当然也可以采用java的方式在onCreate函数中加一行 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);</li>
</ol>
<h3 id="section-39">06：25-30</h3>
<ol start="26" type="1">
<li><p>横竖屏切换的识别，在Qt中会同时反映到resizeEvent事件中，你可以在这个是尺寸变化后读取下当前屏幕是横屏还是竖屏，然后界面上做出调整，比如上下排列改成左右排列。</p></li>
<li><p>由于不同Qt版本对应的安卓配置文件 AndroidManifest.xml 内容格式不一样，高版本和低版本模板格式互不兼容，所以建议使用自己的Qt版本创建的 AndroidManifest.xml 文件，创建好以后如果使用的是自己重新定义的java文件的启动窗体则需要将 AndroidManifest.xml 文件中的 android:name="org.qtproject.qt5.android.bindings.QtActivity" 换掉就行。</p></li>
<li><p>如果自己用android studio编译的jar文件放到Qt项目的libs目录下，导致编译通不过，提示 com.android.dx.cf.iface.ParseException: bad class file magic 之类的，那是因为jdk版本不一致导致的，你可能需要在android studio项目中找到模块编jdk版本设置的地方降低版本，比如你用的ndk是r14，则需要选择jdk1.6或者jdk1.7。一般来说高版本兼容低版本，因为ndk版本太低无法兼容jdk1.8。后面发现如果直接新建的是java库（Java Library）则不存在这个问题，如果选择的是安卓库（android library）就可能有这个问题。</p></li>
<li><p>安卓项目配置文件是固定的名字 AndroidManifest.xml ，改成其他名字就不认识，不要想当然改成其他名字导致无法正常识别。</p></li>
<li><p>AndroidManifest.xml文件中的package="org.qtproject.example"是包名，也是整个apk程序的内部唯一标识，如果多个apk这个包名一样，则会覆盖，所以一定要注意不同的程序记得把这个包名改成你自己的。这个包名也决定了java文件中需要使用资源文件时候的引入包名 import org.qtproject.example.R; 如果包名不一样则编译都通不过。</p></li>
</ol>
<h2 id="qt设计模式">4 Qt设计模式</h2>
<p><strong>读《c++ Qt设计模式》书籍整理的一点经验。此书和官方的《C++ GUI Qt4编程》一起的。</strong> 1. 通常而言，好的做法是在包含了Qt头文件之后再包含非Qt头文件，由于Qt（为编译器和预处理器）定义了许多符号，这使得避免名称冲突变得更容易，也更容易找到文件。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;frminput2019.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_frminput2019.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qdatetime.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qdebug.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;input2019.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inputnumber.h&quot;</span></span></span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p>一种好的编程实践是在代码中使用const实体而不是嵌入数字型常量（有时称他们为“幻数”）。如果以后需要修改他的值时，就可以获得这种灵活性。一般而言，将常量“孤立”出来，可提高程序的可维护性。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不推荐写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐下面的写法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> count = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>内存管理使程序员获得了强大的能力，但是，“权力越大，责任越大”。</p></li>
<li><p>只要有可能，就应当使用列表而不是数组，比如应该使用 QList<int> 代替 int [] ，在c++中数组被看成是“邪恶的”。</p></li>
<li><p>在利用Qt编写程序的过程中，因为Qt的父子所有权继承关系，很少会用到智能指针，因为需要调用delete的情况很少。任何时候只要我们需要调用delete，或者是需要将某个指针设定为0时，应该考虑使用一个智能指针。</p></li>
<li><p>实际上，我们不能完全确定使用多线程就一定能够真正改善程序的性能，例如，如果增加使用线程的数量，使他与系统可用的内核数量成正比，这样做或许还会降低程序的性能，因为所获得的收益会因线程竞争的剧增而消失殆尽。有时候，单线程中最有效的算法在多线程中却不一定有效。因此，如果真的是想改进程序的性能，理想的做法是，使用不同的实现方法，并与他们的性能进行比较后加以分类，当然测试对比的前提是使用完全相同的硬件和软件配置环境。</p></li>
<li><p>在源代码中关于文件路径，使用 / 会更方便一些，因为无论是在何种平台上，Qt都能理解他，不需要对他进行转换。但是，当我们想为用户显示路径时，最好还是根据应用程序所在平台的正确形式来显示他。</p></li>
<li><p>当我们有很多项数据需要处理时，比如成千上万或者更多，那么为每个处理都创建一个线程可能导致大量的开销，这样来依次处理数据或许更快些。一种解决办法就是创建少量的辅助线程，并让每个线程只处理一组数据。</p></li>
<li></li>
</ol>
<h2 id="qt大佬专区">5 Qt大佬专区</h2>
<h3 id="酷码大佬">5.1 酷码大佬</h3>
<p><strong>微信：Kuma-NPC</strong> 1. 关于Qt事件传递的一个说明： - 通常写win32程序，鼠标消息应该是直接发给指定窗口句柄的，指定窗口没有处理就会转化成透传消息，交给父窗口处理。你在一个普通文字label上点击，父窗口也能收到鼠标事件。 - Qt应该是所有消息都发给了顶层窗口，所以事件分发逻辑是自己处理，主窗口收到鼠标事件然后Qt自己分发给指定子控件，QEvent会有ignore或者accept表示自己处理了没有，例如鼠标点击事件，事件分发器发现没有被处理，数据重新计算然后分发给父窗口。这样父窗口收到的事件坐标就是基于自己窗口内的。用eventFilter就需要自己计算坐标。 - 再比如，当使用QDialog，放一个QLineEdit并设置焦点，按Esc时QDialog也会自动关闭，本质上就是因为QLineEdit并不处理Esc的按键事件，透传给了QDialog。</p>
<h3 id="小豆君">5.2 小豆君</h3>
<ol type="1">
<li><p>无论你是学Qt，Java，Python或其它，都需要明白一个道理：摒弃掉你的好奇心，千万不要去追求第三方类或工具是怎么实现的，这往往会让你收效甚微，其实，你只需要熟练掌握它的接口，知道类的目的即可，不可犯面向过程的毛病，刨根问底。记住，你的目标是让其它工具为你服务，你要踩在巨人的肩膀上创造世界。</p></li>
<li><p>Qt真正的核心：元对象系统、属性系统、对象模型、对象树、信号槽。往死里啃这五大特性，在你的项目中，逐渐的设法加入这些特性，多多练习使用它们，长此以往你会收获意想不到的效果。</p></li>
<li><p>一边请教别人，一边多多重构，其实编码这条路虽然有人给你指路，但真正走下去的是你自己，当你真正走完时，你的编码水平一定会有非常大的提升。也许别人1000行的代码，在你这里几十行就搞定了，这也正事Qt的魅力。</p></li>
<li><p>在阅读Qt的帮助文档时，要静下心来，不要放过每一句，记住在文档中没有废话，尤其是每段的开头。</p></li>
</ol>
<h2 id="其他经验">6 其他经验</h2>
<ol type="1">
<li><p>Qt界的中文乱码问题，版本众多导致的如何选择安装包问题，如何打包发布程序的问题，堪称Qt界的三座大山！</p></li>
<li><p>在Qt的学习过程中，学会查看对应类的头文件是一个好习惯，如果在该类的头文件没有找到对应的函数，可以去他的父类中找找，实在不行还有爷爷类，肯定能找到的。通过头文件你会发现很多函数接口其实Qt已经帮我们封装好了，有空还可以阅读下他的实现代码。</p></li>
<li><p>Qt安装目录下的Examples目录下的例子，看完学完，月薪20K起步；Qt常用类的头文件的函数看完学完使用一遍并加以融会贯通，月薪30K起步。</p></li>
<li><p>Qt在开发阶段不支持中文目录（运行阶段可以，比如打包发布的程序放到中文目录运行是ok的），切记，这是无数人可能犯的错误，在安装Qt集成开发环境以及编译器的时候，务必记得目录必须英文，Qt项目源码也必须是英文目录，否则很可能不正常，建议尽量用默认的安装位置。</p></li>
<li><p>如果出现崩溃和段错误，80%都是因为要么越界，要么未初始化，死扣这两点，80%的问题解决了。</p></li>
<li><p>Qt一共有几百个版本，关于如何选择Qt版本的问题，我一般保留四个版本，为了兼容Qt4用4.8.7，最后的支持XP的版本5.7.0，最新的长期支持版本比如5.15，最高的新版本比如5.15.2。强烈不建议使用4.7以前和5.0到5.3之间的版本（Qt6.0到Qt6.2之间、不含6.2的版本也不建议，很多模块还没有集成），太多bug和坑，稳定性和兼容性相比于之后的版本相当差，能换就换，不能换睡服领导也要换。如果没有历史包袱建议用5.15.2，目前新推出的6.0版本也强烈不建议使用，官方还在整合当中，好多类和模块暂时没有整合，需要等到6.2.2版本再用。考虑到qss性能以及自带mysql驱动的因素，最终Qt5选用5.12.3，Qt4选用4.8.7，Qt6选用6.5.x。</p></li>
<li><p>Qt和msvc编译器常见搭配是Qt5.7+VS2013、Qt5.9+VS2015、Qt5.12+VS2017、Qt5.15+VS2019、Qt6.2+VS2019，按照这些搭配来，基本上常用的模块都会有，比如webengine模块，如果选用的Qt5.12+msvc2015，则很可能官方没有编译这个模块，只是编译了Qt5.12+msvc2017的，如果一定要用msvc2015不想换msvc2017则只能选择Qt5.9+msvc2015套件，或者自行源码重新编译（这个难度超大，初学者绕过）。</p></li>
<li><p>Qt默认有对应VS版本，在下载对应VS插件的时候心里要有个数，官方默认提供的是原配的插件，如果想要Qt4.8+VS2015的插件，需要自行编译。一般来说是Qt4.8原配VS2010，Qt5.6原配VS2013，Qt5.9原配VS2015，Qt5.12原配VS2017，Qt5.15原配VS2019，切记：原配最好。</p></li>
<li><p>用Qt做开发机器建议用win10，尤其是2021年以后新发布的Qt版本，比如Qt5.12.12、Qt5.15.2、Qt6.2.2等，因为很可能自带的QtCreator用的最新的版本，Qt6开始不再支持win7，或者由于其他的原因，对win7的支持不友好，会出现奇奇怪怪的问题等，所以又是没得选必须用win10。建议各位拥抱新时代的变化，这世上唯一不变的只有变化。</p></li>
<li><p>新版本Qt安装包安装的时候需要填写注册信息，如果不想填写，先禁用网卡，在运行安装包，可以直接跳过这一步进行安装。<strong>从Qt5.15开始不再提供离线安装包，意味着必须使用在线安装器安装Qt的后续版本，必须填写用户信息，没得选。</strong></p></li>
<li><p>终极秘籍：如果遇到问题搜索Qt方面找不到答案，试着将关键字用JAVA C# android打头，你会发现别有一番天地，其他人其他语言其他领域很可能做过！</p></li>
<li><p>如果Qt能从下面几个方面努力，相信会更有发展前景。</p></li>
</ol>
<ul>
<li>QWidget支持CSS3，具有诸多的牛逼的效果，目前支持的是CSS2。</li>
<li>QWidget支持GPU绘制，可选切换CPU或者GPU，提升绘制效率，利用现在强大的硬件。</li>
<li>Qml无缝支持js，可以利用现在各种js轮子，指数级提升qml的项目范围。</li>
<li>支持将程序转成web运行，比如转成cgi之类的程序，目前Qt for WebAssembly很鸡肋，功能极其有限，sql/network/本地访问等都不支持，首次加载速度超慢，大部分Qt类还不支持。</li>
</ul>
<ol start="13" type="1">
<li>Qt自从4.7以后引入的QML。从此以后，Qt开发就分成了两种流派，一者使用原来的C++ 语言进行开发，另外一种使用QML语言进行开发。这下搞得嘞，经常吵吵不亦乐乎，在Qt界从此就有两大阵营产生激烈的纷争，那就是选用qml还是widget好，大量初学者也会问这个问题，有以下几点总结。</li>
</ol>
<ul>
<li>widget属于传统界面开发，和VB/VC/Delphi等拖曳控件开发类似，走CPU绘制，能最大化的兼容现有的硬件和过去的相对偏低性能的硬件。</li>
<li>qml属于新时代的产物，大概从2010年开始，和flutter/Electron等web开发框架及移动开发框架类似，为了适应各种移动端开发及动画流畅性触摸丝滑体验、充分利用和“榨干”现在的GPU性能，把CPU留出来给用户最大化发挥。</li>
<li>硬件性能越好，GPU越是强劲，qml的综合性能越是完爆widget，反之对比也是指数级的。除了极其省成本的嵌入式硬件领域或者国产CPU等，其他领域的硬件性能都是暴增。</li>
<li>widget主要集中在金融、军工、安防、航天、船舶、教育等领域，qml主要集中在汽车仪表、车机、直播等领域。</li>
<li>目前国内widget多于qml，国外可能偏向qml，这个不难看出，流行的移动端开发框架都是国外开发者居多。</li>
<li>可预见的十年内，这两者将长期并存，官方基本不再更新widget而是主推qml，意味着将来对qml的性能优化只增不减，未来趋势是qml。</li>
<li>没有编程经验的新手qml学习成本更低，而从VB/VC等传统软件开发转过来的从业者更适合学习widget。</li>
<li>有的时候不禁要问，既生widget何生qml，学习成本和选择又多了，其实这正是和这个世界的哲学一样：世界是简单的又是复杂的。为了适应各种需求和满足需要。</li>
<li>总之，无论qml还是widget，和找老婆一样，适合自己的就是最好的，自己擅长哪个就用哪个。</li>
<li>如果还不知道擅长哪个，有空就两个都学，学习过程中自己就会有切身感受和对比，能者多劳多多益善。能够顺利的最快的完成老板的任务给老板赚钱才是王道。</li>
<li>网友补充：如果你的软件最终是手指操作的多，就用qml，如果是鼠标操作的多，就选择widget。</li>
</ul>
<ol start="14" type="1">
<li><p>写程序过程中发现问题，比如有些问题是极端特殊情况下出现，最好找到问题的根源，有时候肯定多多少少会怀疑是不是Qt本身的问题，怀疑是对的，但是99.9%的问题最终证实下来还是自己的代码写的不够好导致的，如果为了赶时间老板催的急，实在不行再用重启或者复位大法，比如搞个定时器、线程、网络通信啥的去检测程序是否正常，程序中某个模块或者功能是否正常，不正常就复位程序或者重启程序，在嵌入式上还可以更暴力一点就是系统重启和断电重启。</p></li>
<li><p>写程序过程中尤其要注意32位的库和64位的库互不兼容，比如32位的程序引用64位的库，64位的程序引用32位的库，都是编译通不过的，而在windows64位系统中是能够运行32位程序的，因为64位的系统提供了32位的运行环境，一般目录在Program Files(x86)，32位的程序在64位的环境中最终引用的还是32位的库。关于如何判断自己的Qt库是多少位，有个误区就是很多人要么看成了QtCreator的关于信息中列出的位数，要么以为自己是64位的系统就认为是64位的Qt，最终要在Qt构建套件中查看具体位数，大概从Qt5.14开始基本上很少提供32位的库，尤其是Qt6.0以后基本上默认就是只有64位的库了，这也是顺应时代潮流，毕竟不久的将来（个人预计2030年以前）基本上32位的系统占比不超过1%，放心大胆的用64位的库吧，抛弃烦人的32位以及XP系统。</p></li>
<li><p>关于程序中动态和静态的一点个人理解：</p></li>
</ol>
<ul>
<li>在Qt程序中，分动态库版本的Qt和静态库版本的Qt。</li>
<li>官方默认提供的二进制包就是动态库版本的Qt，如果自行编译则编译的时候对应参数 -shared。</li>
<li>静态库版本的Qt需要自行编译，编译的时候对应参数 -static，（理论上无论商业非商业使用Qt静态库需要收费，因为静态编译后都看不到Qt的相关库文件）。</li>
<li>使用动态库的Qt支持编译生成动态库和静态库（CONFIG += staticlib）的程序。</li>
<li>使用动态库的Qt程序支持动态库的引用（引用的时候 LIB += ，运行的时候需要动态库文件比如 .dll .so 文件支持）。</li>
<li>使用动态库的Qt程序支持静态库的引用（引用的时候 LIB += ，运行的时候无需库文件支持，可以理解为该文件已经和可执行文件合二为一，缺点是可执行文件体积变大）。</li>
<li>通过生成文件的个数和大小可以发现，静态库相当于把运行时需要的文件也一并合并到一个文件了，而动态库是拆分成两个文件，一个用于编译，一个用于运行。</li>
<li>上述动态库的规则也通用于静态库。</li>
<li>此规则应该是通用于其他语言框架。</li>
<li>很多人有个误区包括几年前的我，以为要用Qt编写静态库就必须用静态的Qt库，其实动态库的Qt也可以编写静态的库，只是该库不会生成动态库文件。</li>
<li>如果要将Qt程序编译成静态的可执行文件（单个文件无依赖），前提是所用的Qt库必须静态的。</li>
</ul>
<ol start="17" type="1">
<li><p>后期的Qt版本，大致从5.15开始，就不在提供离线版本下载，需要自行通过在线安装器安装，由于默认服务器在国外，很多人反映下载的时候很慢，或者选择晚上的时候下载要快很多，为了解决这个烦人的问题，不至于时间都浪费在没有意义的等待上，有个极其简单的方法可以将速度提升几万倍，甚至冲坏你的硬盘。先下载 Fiddler5（尽量选择中文版本不然小白看不懂），双击打开程序后（可能win10自带的杀毒软件会报毒删除，临时停用杀毒软件或者恢复可信任文件即可），在底部的输入栏中输入 urlreplace download.qt.io mirrors.ustc.edu.cn/qtproject/ 回车应用，然后再去打开安装器在线安装，世界突然变得非常美好。</p></li>
<li><p>Qt绝对是个非常牛逼的项目，源码非常庞大，而且分模块设计，对于有足够精力的可以花时间学习源码中的具体实现，如果时间不多，个人推荐看 QObject、QWidget、QPainter、QString、QColor、QList、QVariant、QAbstractButton、QAbstractItemModel、qnamespace.h（整个Qt中所有的全局的枚举值）、这些类的源码即可，看看他们有哪些方法和属性，对自己的编程会有莫大的帮助。</p></li>
<li><p>最后一条：珍爱生命，远离编程。祝大家头发浓密，睡眠良好，情绪稳定，财富自由！</p></li>
</ol>
<h2 id="杂七杂八">7 杂七杂八</h2>
<h3 id="推荐开源主页">7.1 推荐开源主页</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">名称</th>
<th style="text-align: left;">网址</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Qt/C++学习高级群</td>
<td style="text-align: left;">751439350</td>
</tr>
<tr class="even">
<td style="text-align: left;">QtWidget开源demo集合</td>
<td style="text-align: left;"><a href="https://gitee.com/feiyangqingyun/QWidgetDemo">https://gitee.com/feiyangqingyun/QWidgetDemo</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">QtQuick/Qml开源demo集合</td>
<td style="text-align: left;"><a href="https://gitee.com/jaredtao/TaoQuick">https://gitee.com/jaredtao/TaoQuick</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">QtQuick/Qml开源demo集合</td>
<td style="text-align: left;"><a href="https://gitee.com/zhengtianzuo/QtQuickExamples">https://gitee.com/zhengtianzuo/QtQuickExamples</a></td>
</tr>
</tbody>
</table>
<h3 id="推荐网站主页">7.2 推荐网站主页</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">名称</th>
<th style="text-align: left;">网址</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">qtcn</td>
<td style="text-align: left;"><a href="http://www.qtcn.org">http://www.qtcn.org</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">豆子的空间</td>
<td style="text-align: left;"><a href="https://www.devbean.net">https://www.devbean.net</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">yafeilinux</td>
<td style="text-align: left;"><a href="http://www.qter.org">http://www.qter.org</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">feiyangqingyun</td>
<td style="text-align: left;"><a href="https://blog.csdn.net/feiyangqingyun">https://blog.csdn.net/feiyangqingyun</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Qt作品大全</strong></td>
<td style="text-align: left;"><a href="https://qtchina.blog.csdn.net/article/details/97565652">https://qtchina.blog.csdn.net/article/details/97565652</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">龚建波</td>
<td style="text-align: left;"><a href="https://gongjianbo1992.blog.csdn.net/">https://gongjianbo1992.blog.csdn.net/</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">乌托邦2号</td>
<td style="text-align: left;"><a href="http://blog.csdn.net/taiyang1987912">http://blog.csdn.net/taiyang1987912</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">foruok</td>
<td style="text-align: left;"><a href="http://blog.csdn.net/foruok">http://blog.csdn.net/foruok</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">jason</td>
<td style="text-align: left;"><a href="http://blog.csdn.net/wsj18808050">http://blog.csdn.net/wsj18808050</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">朝十晚八</td>
<td style="text-align: left;"><a href="http://www.cnblogs.com/swarmbees">http://www.cnblogs.com/swarmbees</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">BIG_C_GOD</td>
<td style="text-align: left;"><a href="http://blog.csdn.net/big_c_god">http://blog.csdn.net/big_c_god</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">公孙二狗</td>
<td style="text-align: left;"><a href="https://qtdebug.com/qtbook">https://qtdebug.com/qtbook</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">雨田哥</td>
<td style="text-align: left;"><a href="https://blog.csdn.net/ly305750665">https://blog.csdn.net/ly305750665</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">郑天佐</td>
<td style="text-align: left;"><a href="https://blog.csdn.net/zhengtianzuo06">https://blog.csdn.net/zhengtianzuo06</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">寒山-居士</td>
<td style="text-align: left;"><a href="https://blog.csdn.net/esonpo">https://blog.csdn.net/esonpo</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">前行中小猪</td>
<td style="text-align: left;"><a href="http://blog.csdn.net/goforwardtostep">http://blog.csdn.net/goforwardtostep</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">涛哥的知乎专栏</td>
<td style="text-align: left;"><a href="https://zhuanlan.zhihu.com/TaoQt">https://zhuanlan.zhihu.com/TaoQt</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt君</td>
<td style="text-align: left;"><a href="https://blog.csdn.net/nicai_xiaoqinxi">https://blog.csdn.net/nicai_xiaoqinxi</a></td>
</tr>
</tbody>
</table>
<h3 id="推荐学习网站">7.3 推荐学习网站</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">名称</th>
<th style="text-align: left;">网址</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Qt老外视频教程</td>
<td style="text-align: left;"><a href="http://space.bilibili.com/2592237/#!/index">http://space.bilibili.com/2592237/#!/index</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt维基补充文档</td>
<td style="text-align: left;"><a href="https://wiki.qt.io/Main">https://wiki.qt.io/Main</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Qt源码查看网站</td>
<td style="text-align: left;"><a href="https://code.woboq.org/qt5">https://code.woboq.org/qt5</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt官方下载地址</td>
<td style="text-align: left;"><a href="https://download.qt.io">https://download.qt.io</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Qt官方下载新地址</td>
<td style="text-align: left;"><a href="https://download.qt.io/new_archive/qt/">https://download.qt.io/new_archive/qt/</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt国内镜像下载地址</td>
<td style="text-align: left;"><a href="https://mirrors.cloud.tencent.com/qt">https://mirrors.cloud.tencent.com/qt</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Qt安装包下载地址</td>
<td style="text-align: left;"><a href="http://qthub.com/download/">http://qthub.com/download/</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt最新版二进制包</td>
<td style="text-align: left;"><a href="https://fsu0413.gitee.io/qtcompile/">https://fsu0413.gitee.io/qtcompile/</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Qt版本更新内容</td>
<td style="text-align: left;"><a href="https://doc-snapshots.qt.io/qt6-6.2/whatsnew62.html">https://doc-snapshots.qt.io/qt6-6.2/whatsnew62.html</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">Qt中qmake变量说明</td>
<td style="text-align: left;"><a href="https://doc.qt.io/qt-5/qmake-variable-reference.html">https://doc.qt.io/qt-5/qmake-variable-reference.html</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Qt入门最简单教程</td>
<td style="text-align: left;"><a href="http://c.biancheng.net/qt/">http://c.biancheng.net/qt/</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">qss学习地址1</td>
<td style="text-align: left;"><a href="http://47.100.39.100/qtwidgets/stylesheet-reference.html">http://47.100.39.100/qtwidgets/stylesheet-reference.html</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">qss学习地址2</td>
<td style="text-align: left;"><a href="http://47.100.39.100/qtwidgets/stylesheet-examples.html">http://47.100.39.100/qtwidgets/stylesheet-examples.html</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">qss学习地址3</td>
<td style="text-align: left;"><a href="https://doc.qt.io/qt-6/qstyle.html">https://doc.qt.io/qt-6/qstyle.html</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">精美图表控件QWT</td>
<td style="text-align: left;"><a href="http://qwt.sourceforge.net/">http://qwt.sourceforge.net/</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">精美图表控件QCustomPlot</td>
<td style="text-align: left;"><a href="https://www.qcustomplot.com/">https://www.qcustomplot.com/</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">免费图标下载</td>
<td style="text-align: left;"><a href="http://www.easyicon.net/">http://www.easyicon.net/</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">图形字体下载</td>
<td style="text-align: left;"><a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">漂亮界面网站</td>
<td style="text-align: left;"><a href="https://www.ui.cn/">https://www.ui.cn/</a></td>
</tr>
</tbody>
</table>
<h2 id="书籍推荐">8 书籍推荐</h2>
<ol type="1">
<li>C++入门书籍推荐《C++ primer plus》，进阶书籍推荐《C++ primer》。</li>
<li>Qt入门书籍推荐霍亚飞的《Qt Creator快速入门》，Qt进阶书籍推荐官方的《C++ GUI Qt4编程》，qml书籍推荐《Qt5编程入门》，Qt电子书强烈推荐《Qt5.10 GUI完全参考手册》。</li>
<li>强烈推荐程序员自我提升、修养、规划系列书《走出软件作坊》《大话程序员》《程序员的成长课》《解忧程序员》，受益匪浅，受益终生！</li>
</ol>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：线性回归与梯度下降法</title>
    <url>/2017/08/24/Gradient-Descent/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>　　这篇文章的关注点在于<strong>线性回归问题</strong>，重点是求解线性回归问题的<strong>梯度下降法(Gradient Descent)</strong>，之前在学习<a href="http://zhouyichu.com/machine-learning/Statistical-Learning-Perceptron/" title="感知机模型">感知机模型</a>的时候，使用过这个算法，并且还<a href="http://zhouyichu.com/machine-learning/Perceptron-Implementation/" title="实现">实现</a>了它。可是那只是仅仅停留在使用的层面上，这次是要充分理解<strong>梯度下降法</strong>的原理及其计算方法。</p>
<span id="more"></span>
<h1 id="线性回归问题">线性回归问题</h1>
<p>　　从数学上说，<strong>回归问题</strong>其实就是函数拟合问题:给定一些点的集合，然后用一个曲线或方程去拟合，使得集合中的所有点都大致符合给出的曲线或方程。当拟合的曲线是一条直线的时候，就称为是<strong>线性回归问题</strong>。</p>
<p>　　回归问题的意义在于，它使得我们能够在已知数据的基础上对未知数据进行预测:通过对已知数据进行回归分析，得到一个曲线，我们就能够利用这个曲线对未知的数据进行很好的预测。其实，我们在初高中就遇到过这种问题了，只是我们当时被没有意识到这是一个回归问题。</p>
<p>　　例如给定两个点<span class="math inline">\((x_1,y_1)\)</span>，<span class="math inline">\((x_2,y_2)\)</span>,求过这两个点的直线。当然，现在我们的问题复杂得多，而且不仅仅局限在二维平面，很多时候都是处理高维数据。</p>
<p>　　举个例子，现在我们有如下的数据:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Living area</th>
<th style="text-align: center;">bedrooms</th>
<th style="text-align: center;">Price</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">2104</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">400</td>
</tr>
<tr class="even">
<td style="text-align: center;">1600</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">330</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2400</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">369</td>
</tr>
<tr class="even">
<td style="text-align: center;">1416</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">232</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3000</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">540</td>
</tr>
</tbody>
</table>
<p>　　现在的问题是，给定一个组新的Living area 和 bedrooms数据，能否预测正确的Price是多少？这里的数据是三维的，但是更多时候是多维的，影响房价的因素还包括很多，如有浴室的数目、有没有壁炉等。这里的输入是Living area和beadrooms，输出则是Price。</p>
<p>　　在统计机器学习中，影响输出的因素被称为是<strong>特征(features)</strong>，输入数据称为<strong>训练集(training set)</strong>或<strong>训练数据</strong>(training data)，训练数据的维度称为<strong>特征的个数</strong>。</p>
<p>　　因为我们的重点是线性回归问题，所以这里我们简单地假设能够拟合的方程是:</p>
<p><span class="math display">\[\begin{equation} h_\theta(x)=\theta_0 +
\theta_1x_1+\theta_2x_2 \end{equation}\]</span></p>
<p>　　这里<span class="math inline">\(\theta_i\)</span>称为参数(也称作是权重)，这里的变量是<span class="math inline">\(x_1\)</span>和<span class="math inline">\(x_2\)</span>，在我们的例子中分别代表Living area和bedrooms，<span class="math inline">\(h_\theta(x)\)</span>就是输出值，这里是就是Price。现在任务很明确，就是根据已知的数据计算出相应的<span class="math inline">\(\theta_i\)</span>参数。整个过程可以用下图表示:</p>
<img src="/2017/08/24/Gradient-Descent/learning-flow.png" class="" title="学习流程图">
<p>　　上图是整个统计机器学习的流程，不仅仅局限于回归问题。</p>
<p>　　为了一般化我们的公式，可以引入一个常量<span class="math inline">\(x_0=1\)</span>，这样我们的公式就可以表示为:</p>
<p><span class="math display">\[ \begin{equation} h_{\theta}(x_{n\times
1})=\sum_{i=0}^{n}\theta_ix_i=\theta_{n\times
1}^{T}x_{n\times 1}\label{origin} \end{equation} \]</span></p>
<p>　　注意，这里有几个贯穿全文的约定:</p>
<ul>
<li><span class="math inline">\(n\)</span>代表的是特征的个数，也就是输入数据的维度</li>
<li><span class="math inline">\(m\)</span>代表的是训练数据的数目</li>
<li><span class="math inline">\(x^{(i)}\)</span>代表第i个训练数据</li>
<li><span class="math inline">\(x_{i}\)</span>代表第i个特征</li>
<li>因为后面有很多公式都是向量的或矩阵的运算，为了区别开来，我会在所有表示向量或矩阵的变量的下标中注明维度。如果没有下表，则表示一个实数。</li>
</ul>
<p>　　现在我们已经有了一个假设的函数了，那么我们该如何衡量这个函数的好坏呢？这就要引入<strong>损失函数(cost function)</strong>，这个函数用来衡量我们的预测值和真实值之间的差距。它是这样定义的:</p>
<p><span class="math display">\[\begin{equation} J(\theta_{n\times 1}) = \frac{1}{2}
\sum_{i=1}^m(h_\theta(x_{n\times 1}^{(i)})-y^{(i)})^2
\end{equation}\]</span></p>
<p>　　这个函数很好理解，它是关于参数<span class="math inline">\(\theta_{n\times 1}\)</span>的函数，直观上就是(预测值-真实值)的平方，然后对每一组训练数据进行累加，用这个累加和来衡量我们学习到的函数<span class="math inline">\(\eqref{origin}\)</span>。这里的<span class="math inline">\(\displaystyle \frac{1}{2}\)</span>其实并不是必须的，只是为了简化后面的推导而人为的乘上一个系数，这对结果不影响。如果搞过数模的话，就知道，这其实就是<a href="http://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95" title="最小二乘法">最小二乘法</a>的思想。</p>
<h1 id="梯度下降法">梯度下降法</h1>
<p>　　现在我们的问题就转化为一个求最小值的问题了:</p>
<p><span class="math display">\[\begin{align} &amp; J(\theta_{n\times 1}) = \frac{1}{2}
\sum_{i=1}^m(h_\theta(x_{n\times 1}^{(i)})-y^{(i)})^2 \\ &amp;
\min_{\theta}J_{\theta} \end{align}\]</span></p>
<p>　　如何求解这个问题呢？这里我们就要引入<strong>最小梯度法</strong>了。还记得当年学高数，在学到梯度的时候，记得老师曾经说过，负梯度方向是函数下降最快的方向。最小梯度法就是利用这个性质。具体的思路是:</p>
<ol type="1">
<li>对<span class="math inline">\(\theta_{n\times 1}\)</span>进行赋值，这个值可以是随机的，但通常都赋值为一个全零的向量。</li>
<li>不停迭代，每次迭代都改变<span class="math inline">\(\theta_{n\times 1}\)</span>，使得<span class="math inline">\(J(\theta_{n\times 1})\)</span>按梯度下降的方向进行减少。</li>
</ol>
<p>　　上面的比较数学化的说法，其实比较直观的说法是这样的:想象你站在一座高山上，你想要用最短的时间下山，但是你每次只能走一步。那你需要做的就是查看你周围360度的范围，找到一个最陡峭的(下降的最快的)方向，然后转移到那个点上；转移到新的位置之后，重复相应的步骤，环顾360度，找到最陡峭的(下降的最快的)方向，然后转移过去，这样每次都是选择最陡峭的方向走，那么很快就能到达山下了。</p>
<p>　　这就是梯度下降法的基本思路，其中对陡峭的方向就是负梯度的方向。</p>
<p>　　为了更加易于理解，给出下图:</p>
<img src="/2017/08/24/Gradient-Descent/gradient-descent.png" class="" title="梯度下降">
<p>　　我们<span class="math inline">\(\theta_{n\times 1}\)</span>按照梯度下降的方向进行调整，就会使得<span class="math inline">\(J(\theta_{n\times 1})\)</span>往更低的方向进行变化，如上图所示，算法的结束将是在<span class="math inline">\(\theta_{n\times 1}\)</span>下降到无法继续下降为止。</p>
<p>　　其中，梯度方向由<span class="math inline">\(J(\theta)\)</span>对<span class="math inline">\(\theta\)</span>的偏导数确定。用公式来表达就是:</p>
<p><span class="math display">\[ \begin{equation} \theta_j = \theta_j -
\alpha\frac{\partial}{\partial\theta_{j}}J(\theta_{n\times 1})
\end{equation} \]</span></p>
<p>　　其中<span class="math inline">\(\alpha\)</span>称为<strong>学习率(learning rate)</strong>，直观的意义是，在函数向极小值方向前进时每步所走的步长。太大一般会错过极小值，太小会导致迭代次数过多。</p>
<p>　　具体的梯度方向是(<em>此处为了方便计算，假设只有一组数据</em>):</p>
<p><span class="math display">\[ \begin{split}
\frac{\partial}{\partial\theta_j}J(\theta_{n\times1})&amp;=\frac{\partial}{\partial\theta_j}\frac{1}{2}(h_{\theta}(x_{n\times 1})-y)^2\\ 
&amp;=2 \cdot \frac{1}{2}(h_{\theta}(x_{n\times 1})-y)\cdot\frac{\partial}{\partial\theta_j}(h_{\theta}(x_{n\times 1})-y)\\ 
&amp;=(h_{\theta}(x_{n\times 1})-y)\cdot\frac{\partial}{\partial\theta_j}\left(\sum_{i=0}^n\theta_ix_i-y\right)\\
&amp;=(h_{\theta}(x_{n\times 1})-y)x_j \end{split} \]</span></p>
<p>　　上面式子中的<span class="math inline">\(j\)</span>表示的是第<span class="math inline">\(j\)</span>个特征。从这个推导过程就可以知道，当初我们为什么要在公式前乘上<span class="math inline">\(\frac{1}{2}\)</span>了。</p>
<p>　　这样，对于每一组训练数据，每一个特征分量<span class="math inline">\(\theta_j\)</span>的变化是这样的(<strong>注意:此时括号中的符号改变了，因为是负梯度的方法向</strong>):</p>
<p><span class="math display">\[\begin{equation}
\theta_j=\theta_j+\alpha\left(y^{(i)}-h_{\theta}(x_{n\times 1}^{(i)})\right)x_j^{(i)} \label{1} \end{equation}\]</span></p>
<h2 id="批梯度下降法bath-gradient-descent">批梯度下降法(bath gradient descent)</h2>
<p>　　在得到上面的公式之后，我们的算法也就形成了:</p>
<img src="/2017/08/24/Gradient-Descent/batch-descent.png" class="" title="batch梯度下降">
<p>　　上述算法中的式子是针对所有的训练数据的，这是从公式<span class="math inline">\(\ref{1}\)</span>变化而来，只是加入了一个累加的过程，此处不再证明。从公式中可以看到，每次迭代的时候，该算法都会遍历整个训练数据集，这个就被称为<strong>批梯度下降法(batch gradient descent)</strong>。需要注意的是，此处的梯度下降法是只能找到局部最优解，而非全局最优解。它有以下两个特点:</p>
<ol type="1">
<li>得到的结果是局部最优解，这依赖于初始值</li>
<li>每次迭代它的梯度大小都在变化，且越来越趋近于0</li>
</ol>
<h2 id="随机梯度下降法stochastic-gradient-descent">随机梯度下降法(stochastic gradient descent)</h2>
<p>　　在利用<strong>批梯度下降法(bath gradient descent)</strong>进行计算的时候，你会发现，每计算一个参数分量，都需要遍历整个训练数据集，这样做的效率明显不高，因此我们有一个替代的算法：</p>
<img src="/2017/08/24/Gradient-Descent/sgd.png" class="" title="随机梯度下降">
<p>　　可以看到，这个算法每次都只利用了一组数据进行计算，这样就大大减少了计算量。这个算法称为<strong>随机梯度下降法(stochastic gradient descent)</strong>。但是，带来的相应后果就是，它最终得到的解可能是在真正的最小值的附近，而不是最小值本身。因此只有在数据量很大的情况下才会使用这个算法。</p>
<h1 id="参考文献及推荐阅读">参考文献及推荐阅读</h1>
<ul>
<li>斯坦福《机器学习》公开课第二集及其配套讲义</li>
<li><a href="http://www.cnblogs.com/LeftNotEasy/archive/2010/12/05/mathmatic_in_machine_learning_1_regression_and_gradient_descent.html">机器学习中的数学</a></li>
<li><a href="http://www.cnblogs.com/jerrylead/archive/2011/03/05/1971867.html" title="对线性回归，logistic回归和一般回归的认识">对线性回归，logistic回归和一般回归的认识</a></li>
<li>《统计学习方法》李航</li>
</ul>
<hr />
<p>本文来自：<a href="http://zhouyichu.com/machine-learning/Gradient-Descent/" title="线性回归与梯度下降法">线性回归与梯度下降法</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的配置和使用</title>
    <url>/2017/08/01/Hexo%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Hexo是一个开源的静态博客生成器，用node.js开发，作者是台湾大学生tommy351。Hexo的安装使用必须依赖node.js和Git，以下内容简要说明其步骤。</p>
<span id="more"></span>
<h2 id="安装node.js">1、安装node.js</h2>
<p>1） 下载与安装</p>
<p>下载地址<a href="https://nodejs.org/dist/v6.11.1/node-v6.11.1-win-x64.zip" title="Node.js下载">Node.js</a>, 解压之后，在环境变量Path中添加上述node.js的路径(假设为<code>D:\Dev\Node</code>）。设置成功后，打开命令行，可以看看node.js的版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm --version</span><br><span class="line">3.10.10</span><br></pre></td></tr></table></figure>
<p>2） npm的配置</p>
<p>配置npm的代理，缓存地址等。（以下配置为全局配置（<code>--global</code>）便于copy到U盘携带。）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置缓存位置</span></span><br><span class="line">$ npm config <span class="built_in">set</span> cache D:\Dev\node\npm-cache --global</span><br><span class="line"><span class="comment"># 设置代理服务器</span></span><br><span class="line">$ npm config <span class="built_in">set</span> proxy=<span class="string">&quot;http://127.0.0.1:8122&quot;</span> --global</span><br><span class="line"><span class="comment"># 设置npm默认使用HTTP方式而不是HTTPS</span></span><br><span class="line">$ npm config <span class="built_in">set</span> registry http://registry.npmjs.org --global</span><br></pre></td></tr></table></figure>
<p>或者直接打开<code>&lt;node&gt;/etc/npmrc</code>文件（没有就新建）进行编辑：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cache=D:\Dev\node\npm-cache</span><br><span class="line">proxy=http://127.0.0.1:8122/</span><br><span class="line">registry=http://registry.npmjs.org</span><br></pre></td></tr></table></figure>
<p>配置完成，运行<code>npm config list</code>命令看看配置的情况。如果正确，node.js已经安装配置完成，可以安装Hexo。</p>
<h2 id="git的安装与配置">2、Git的安装与配置</h2>
<p>Git的安装与配置，网上有很多教程，这里不再详细说明。无论是msi安装还是绿色解压安装，均需要在Path环境变量中设置路径。如果以下命令返回版本号，则git安装完成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 1.9.5.msysgit.1</span><br></pre></td></tr></table></figure>
<p>说明： 1)使用 git 的版本对发布有重要影响，版本2.13.3.windows.1/1.95.msysgit.1可以正常工作，版本 2.7.2.windows.1无法正常工作。 2)在使用代理服务器时，可能需要导入CA认证文件。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.sslCAInfo /ssl/certs/your.cert.CA.crt</span><br></pre></td></tr></table></figure></p>
<h2 id="hexo的安装和使用">3、Hexo的安装和使用</h2>
<p>1）安装 Hexo的安装分为3个过程，首先安装<code>hexo-cli</code> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli </span><br></pre></td></tr></table></figure> 等待进度条跑到头，出现一堆提示信息，<code>hexo-cli</code>安装完成。</p>
<p>第二步，安装hexo <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo --save</span><br></pre></td></tr></table></figure> 第三步，初始化网站 指定一个目录初始化网站 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init xxx</span><br></pre></td></tr></table></figure> 第四步，完成安装 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure> 2）显示版本信息 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo -v  (或 hexo version)</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Windows_NT 10.0.17134 win32 x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 8.11.3</span><br><span class="line">v8: 6.2.414.54</span><br><span class="line">uv: 1.19.1</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">modules: 57</span><br><span class="line">nghttp2: 1.32.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.0.2o</span><br><span class="line">icu: 60.1</span><br><span class="line">unicode: 10.0</span><br><span class="line">cldr: 32.0</span><br><span class="line">tz: 2017c                      </span><br></pre></td></tr></table></figure></p>
<p>3）Hexo的基本使用</p>
<ol type="1">
<li>创建一个网站：<code>hexo init blog</code>；注意：不能使用当前目录作为网站目录。如果使用<code>hexo init .</code>，会出现<code>ERROR Local hexo not found in D:\Dev\Project\blog</code>的错误。</li>
<li>创建页面：<code>hexo new newpage</code>，newpage就是新页面的标题，支持中文；</li>
<li>开始用markdown写</li>
<li>在blog目录内安装Hexo的git插件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
</ol>
<p>4）Hexo的配置</p>
<p>Hexo的配置内容还是比较简单，核心是修改配置文件<code>_config.yml</code>，关于配置部分还是查阅相关的<a href="https://hexo.io/zh-cn/docs/" title="Helo Docs">文档</a>比较靠谱。</p>
<ol start="5" type="1">
<li>页面生成与发布</li>
</ol>
<p>Hexo支持同时向多个gits提交，以下以Github为例。 1. 在Github上建一个新的库，例如：<code>yourname.github.io</code>，其URL地址为：<code>https://github.com/yourname/youname.github.io.git</code> 2. 修改<code>blog</code>中的<code>_config.yml</code>中的<code>deploy</code>字段： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: </span><br><span class="line">    - https://xxxx@git.oschina.net/xxxx/xxxx.git</span><br><span class="line">    - https://github.com/yourname/youname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure> 3. 执行命令<code>hexo d -g</code>，接着在提示框中输入github的用户名和密码就ok了。 4. 访问<code>https://github.com/yourname/youname.github.io.git</code>试试。</p>
<h2 id="hexonext使用latex">4、Hexo+Next使用Latex</h2>
<p>1）基本配置 打开配置文件<code>themes/next/_config.yml</code>，找到<code># MathJax Support</code>，将<code>enable</code>改为<code>true</code>即可 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span><br><span class="line"></span><br></pre></td></tr></table></figure> 然后在需要使用<code>Latex</code>的页面头部添加： <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>2）<code>mathjax</code>的CDN可以使用如下链接，不过cloudflare的访问速度... <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cdn: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure> 3）在录入公式时，Latex的源文件并不能正常渲染，其原因在于next自己有很多转义字符，因此必须对某些字符做转义后使用。先将目前遇到的转义字符记录如下，以后再继续补齐。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Latex字符</th>
<th style="text-align: center;">转义后字符</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">\</td>
<td style="text-align: center;">\\</td>
</tr>
<tr class="even">
<td style="text-align: center;">_</td>
<td style="text-align: center;">\_</td>
</tr>
</tbody>
</table>
<p>4）<del>添加公式自动编号支持</del>，<code>next 6.3.0</code>已经<font color=#FF0000>内置支持</font></p>
<p>使用时，在需要添加公式编号的位置<code>\label&#123;公式名称&#125;</code>，引用时<code>$ref&#123;公式名称&#125;</code>。注意，自动编号的公式需要使用<code>equation</code>关键字。 <figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125; <span class="keyword">\theta</span><span class="built_in">_</span>j := <span class="keyword">\theta</span><span class="built_in">_</span>j + </span><br><span class="line"><span class="keyword">\alpha</span> <span class="keyword">\sum</span> <span class="keyword">\limits</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>n(y<span class="built_in">^</span>&#123;(i)&#125;-h<span class="built_in">_</span>&#123;<span class="keyword">\theta</span>&#125;(x<span class="built_in">^</span>&#123;(i)&#125;))x<span class="built_in">_</span>j<span class="built_in">^</span>&#123;(i)&#125;</span><br><span class="line"><span class="keyword">\label</span>&#123;mini-BGD&#125; </span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">公式<span class="built_in">$</span>(<span class="keyword">\ref</span>&#123;mini-BGD&#125;)<span class="built_in">$</span></span><br></pre></td></tr></table></figure></p>
<p>效果： <span class="math display">\[ \begin{equation} \theta_j := \theta_j + 
\alpha \sum \limits_{i=1}^n(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}
\label{mini-BGD} 
\end{equation}\]</span></p>
<p>公式<span class="math inline">\((\ref{mini-BGD})\)</span></p>
<p>以下内容，来自<code>next</code>官方文档：</p>
<p>对于多行公式，在 <code>equation</code> 环境中，你可以使用 <code>aligned</code>、<code>cases</code>、<code>array</code> 环境把公式分成多行，</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">f(x)=</span><br><span class="line">    <span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">        0<span class="built_in">&amp;</span> x=0<span class="keyword">\\</span></span><br><span class="line">        1<span class="built_in">&amp;</span> x <span class="keyword">\neq</span> 0</span><br><span class="line">    <span class="keyword">\end</span>&#123;cases&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;  <span class="keyword">\label</span>&#123;eq1&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{equation}
f(x)=
\begin{cases}
0&amp; x=0\\
1&amp; x \neq 0
\end{cases}
\end{equation}\label{eq1}
\]</span></p>
<p>要对齐多个公式，我们需要使用 <code>align</code> 环境。align 环境中的每个公式都有自己的编号：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">a <span class="built_in">&amp;</span>= b + c <span class="keyword">\label</span>&#123;eq3&#125; <span class="keyword">\\</span></span><br><span class="line">x <span class="built_in">&amp;</span>= yz <span class="keyword">\label</span>&#123;eq4&#125;<span class="keyword">\\</span></span><br><span class="line">l <span class="built_in">&amp;</span>= m - n <span class="keyword">\label</span>&#123;eq5&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\left\{
\begin{align}
a &amp;= b + c \label{eq3} \\
x &amp;= yz \label{eq4}\\
l &amp;= m - n \label{eq5}
\end{align}
\right.
\]</span></p>
<p>在 <code>align</code> 环境中，如果你不想给某个或某几个公式编号，那么在这些公式后面使用 <a href="https://tex.stackexchange.com/questions/17528/show-equation-number-only-once-in-align-environment"><code>\nonumber</code></a> 命令即可。例如：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">-4 + 5x <span class="built_in">&amp;</span>= 2+y <span class="keyword">\nonumber</span>  <span class="keyword">\\</span></span><br><span class="line"> w+2 <span class="built_in">&amp;</span>= -1+w <span class="keyword">\\</span></span><br><span class="line"> ab <span class="built_in">&amp;</span>= cb</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p>有时，你可能会希望采用更加奇特的方式来标记和引用你的公式，你可以通过使用 <code>\tag&#123;&#125;</code> 命令来实现，例如：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span>  x+1 <span class="keyword">\over</span> <span class="keyword">\sqrt</span>&#123;1-x<span class="built_in">^</span>2&#125; <span class="keyword">\tag</span>&#123;i&#125;<span class="keyword">\label</span>&#123;eq<span class="built_in">_</span>tag&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[  x+1 \over \sqrt{1-x^2} \tag{i}\label{eq_tag}\]</span> 公式<span class="math inline">\((\ref{eq_tag})\)</span></p>
<h2 id="修改next主题分类菜单下日期格式">5、修改Next主题“分类”菜单下日期格式</h2>
<p>原时期格式为<code>MM-DD</code>格式，希望将年份一起显示成为<code>YYYY-MM-DD</code>。</p>
<p>1）打开<code>themes/next/layout/_macro/post-collapse.swig</code>，将第27行日期格式由<code>MM-DD</code>改为<code>YYYY-MM-DD</code>: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; date(post.date, &#x27;YYYY-MM-DD&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure> 2）上述修改完成后，日期可以显示为完整的年-月-日格式，但与post名称重叠。打开<code>themes/next/source/css/_common/components/post/post-collapse.styl</code>，第96行： <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-title</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">110px</span>;  # 此处原来是<span class="number">60px</span>，修改为<span class="number">110px</span></span><br></pre></td></tr></table></figure> 3）这种修改是一种全局修改，不仅在“分类”下，“存档”菜单下的日期格式也同样修改。</p>
<h2 id="插件">6、插件</h2>
<p>可以在<code>package.json</code>中查看所有插件，除基本功能插件外，目前安装的插件如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save    # 站内搜索</span><br><span class="line"># npm install hexo-pdf --save                 # 支持显示pdf，未安装</span><br></pre></td></tr></table></figure> ## 7、添加版权 打开<code>themes/next/_config.yml</code>，搜索<code>copyright</code>，将<code>post_copyright</code>的<code>enable</code>改为<code>true</code>。</p>
<h2 id="修改标签显示图标">8、修改标签显示图标</h2>
<p>打开<code>themes/next/layout/_macro/post.swig</code>，搜索<code>rel="tag"&gt;#</code>，将之改为<code>&lt;i class="fa fa-tag"&gt;&lt;/i&gt;</code>。</p>
<p>本文参考<a href="http://lier.space/2017/07/13/hexo-tutorial4/">这篇文档</a>，向作者表示感谢。</p>
]]></content>
      <categories>
        <category>折腾</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 编码风格</title>
    <url>/2017/08/31/Qt_Coding_Style/</url>
    <content><![CDATA[<p>这是我们编写Qt代码时所使用的编码惯例的一个概述。数据是通过挖掘Qt源码、论坛、邮件列表以及与开发者的协作而收集起来的。 <span id="more"></span></p>
<h1 id="缩进">1、缩进</h1>
<ul>
<li>采用4个空格</li>
<li>空格，不要用TAB！</li>
</ul>
<h1 id="变量声明">2、变量声明</h1>
<ul>
<li>每行一个变量</li>
<li>尽可能避免短的变量名(比如<code>a</code>, <code>rbarr</code>, <code>nughdeget</code>)</li>
<li>单字符的变量只在临时变量或循环的计数中使用</li>
<li>等到真正需要使用时再定义变量 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">char</span> *c, *d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="type">int</span> width;</span><br><span class="line"><span class="type">char</span> *nameOfThis;</span><br><span class="line"><span class="type">char</span> *nameOfThat;</span><br></pre></td></tr></table></figure> 以小写字符开头，后续单词以大写开头 ----------------------------------</li>
<li>避免使用缩写 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="type">short</span> Cntr;</span><br><span class="line"><span class="type">char</span> ITEM_DELIM = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Correct</span></span><br><span class="line"><span class="string">short counter;</span></span><br><span class="line"><span class="string">char itemDelimiter = &#x27;</span><span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure></li>
<li>类名总是以大写开头。公有类以<code>Q</code>开头(<code>QRgb</code>)，公有函数通常以<code>q</code>开头(<code>qRgb</code>)。</li>
</ul>
<h1 id="空白">3、空白</h1>
<ul>
<li><p>利用空行将语句恰当地分组</p></li>
<li><p>总是使用一个空行(不要空多行)</p></li>
<li><p>总是在每个关键字和大括号前使用一个空格 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">if</span>(foo)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>对指针和引用，在类型和<code>*</code>、<code>&amp;</code>之间加一个空格，但在<code>*</code>、<code>&amp;</code>与变量之间不加空格 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *x;</span><br><span class="line"><span class="type">const</span> QString &amp;myString;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> y = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>二元操作符前后加空白</p></li>
<li><p>类型转换后不加空白</p></li>
<li><p>尽量避免C风格的类型转换</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="type">char</span>* blockOfMemory = (<span class="type">char</span>* ) <span class="built_in">malloc</span>(data.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="type">char</span> *blockOfMemory = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(<span class="built_in">malloc</span>(data.<span class="built_in">size</span>()));</span><br></pre></td></tr></table></figure>
<h1 id="大括号">4、大括号</h1>
<ul>
<li><p>基本原则：左大括号和语句保持在同一行： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">if</span> (codec)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> (codec) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>例外：函数定义和类定义中，左大括号总是单独占一行： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;foo: %i&quot;</span>, g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Moo</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>控制语句的body中只有一行时不使用大括号 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">if</span> (address.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; +<span class="string">&#x27;&#x27;i) &#123;</span></span><br><span class="line"><span class="string">    qDebug(&quot;%i&quot;, i);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Correct</span></span><br><span class="line"><span class="string">if (address.isEmpty())</span></span><br><span class="line"><span class="string">    return false;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for (int i = 0; i &lt; 10;i)</span></span><br><span class="line"><span class="string">    qDebug(&quot;%i&quot;, i);</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>例外1：如果父语句跨多行，则使用大括号 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> (address.<span class="built_in">isEmpty</span>() || !<span class="built_in">isValid</span>()</span><br><span class="line">    || !codec) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>例外2：在if-else结构中，有一处跨多行，则使用大括号 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">if</span> (address.<span class="built_in">isEmpty</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;%s&quot;</span>, <span class="built_in">qPrintable</span>(address));</span><br><span class="line">    it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> (address.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;%s&quot;</span>, <span class="built_in">qPrintable</span>(address));</span><br><span class="line">    it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">if</span> (a)</span><br><span class="line">    <span class="keyword">if</span> (b)</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b)</span><br><span class="line">        …</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果控制语句的body为空，则使用大括号 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">while</span> (a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">while</span> (a) &#123;&#125;</span><br></pre></td></tr></table></figure> 5、圆括号 ==========</p></li>
<li><p>使用圆括号将表达式分组 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">if</span> (a &amp;&amp; b || c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> ((a &amp;&amp; b) || c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrong</span></span><br><span class="line">a<span class="number">&#x27;&#x27;</span> b &amp; c</span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line">(a + b) &amp; c</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h1 id="switch-语句">6、Switch 语句</h1>
<ul>
<li><code>case</code> 和 <code>switch</code> 位于同一列</li>
<li>每一个<code>case</code>必须有一个<code>break</code>(或<code>return</code>)语句，或者用注释说明无需<code>break</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (myEnum) &#123;</span><br><span class="line">    <span class="keyword">case</span> Value1:</span><br><span class="line">        <span class="built_in">doSomething</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Value2:</span><br><span class="line">        <span class="built_in">doSomethingElse</span>();</span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">defaultHandling</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="断行">7、断行</h1>
<ul>
<li>保持每行短于100个字符，需要时进行断行</li>
<li>逗号放一行的结束，操作符放到一行的开头。如果你的编辑器太窄，一个放在行尾的操作符不容易被看到。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> (longExpression</span><br><span class="line">    + otherLongExpression</span><br><span class="line">    + otherOtherLongExpression) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">if</span> (longExpression +</span><br><span class="line">    otherLongExpression +</span><br><span class="line">    otherOtherLongExpression) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="继承与关键字-virtual">8、继承与关键字 <code>virtual</code></h1>
<ul>
<li>重新实现一个虚函数时，头文件中不放置 <code>virtual</code> 关键字。</li>
</ul>
<h1 id="通用例外">9、通用例外</h1>
<ul>
<li>如果它使你的代码看起来不好，你可以打破任何一个规则 。</li>
</ul>
<p>本文来自：<a href="https://wiki.qt.io/Qt_Coding_Style/zh" title="Qt编码风格">Qt编码风格</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：三种梯度下降法</title>
    <url>/2017/08/24/Three-Gradient-Descent/</url>
    <content><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>最近需要手写一个Feedforward的网络结构，在选择优化算法的时候，猛然发现原来Batch Gradient Descent和mini-Batch Gradient Descent是两种不同的优化策略，感觉这里遗漏了一大块知识，赶忙补充了一下，此处做一下记录。 <span id="more"></span></p>
<h1 id="batch-gradient-descent">Batch Gradient Descent</h1>
<p>在优化目标函数的时候，Batch Gradient Descent(BGD)是先计算整个数据集上的梯度，然后再进行更新操作。对于参数<span class="math inline">\(\theta\)</span>来说，每更新一次其中的某一位权重<span class="math inline">\(\theta_j\)</span>，BGD都需要遍历整个数据集。</p>
<p>对于目标函数<span class="math inline">\(h_{\theta}(x)\)</span>用公式来表示就是:</p>
<p><span class="math display">\[
\begin{equation} 
\theta_j := \theta_j +
\alpha\sum\limits_{i=1}^m(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}
\label{BGD} 
\end{equation} 
\]</span></p>
<p>其中的<span class="math inline">\((y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}\)</span>其实就是对于训练样例<span class="math inline">\(x^{(i)}\)</span>的<span class="math inline">\(j\)</span>属性的梯度,<span class="math inline">\(m\)</span>是训练集的大小,具体的推导过程可以在<a href="http://zhouyichu.com/machine-learning/Gradient-Descent/" title="梯度下降法推导">这里</a>查看。</p>
<p>从公式<span class="math inline">\((\ref{BGD})\)</span>中可以看到，BGD是对整个数据集进行扫描然后计算整体梯度(<span class="math inline">\(\sum\)</span>求和过程)，进行更新。其实，这才是真正的梯度.</p>
<p>BGD的优点在于对于凸问题，它是能够保证收敛到全局最优点的。而缺点就是，计算量很大，计算每一位的权重都要遍历整个数据集，这代价未免太大了，计算量是无法接受的。随之而来的另外一个缺点就是BGD是无法进行online训练的，它必须要知道全部的训练集的情况下才能进行训练，这对于一些线上系统也是一个问题。</p>
<h1 id="stochastic-gradient-descent">Stochastic Gradient Descent</h1>
<p>SGD是对BGD的一个改进方案，改变之处在更新时不需要遍历整个数据集，而是每一个实例都进行更新。具体公式是:</p>
<p><span class="math display">\[\begin{equation} \theta_j := \theta_j +
\alpha(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)} \label{SGD}
\end{equation}\]</span></p>
<p>比较公式<span class="math inline">\((\ref{BGD})\)</span>和<span class="math inline">\((\ref{SGD})\)</span>，我们可以发现区别就在省略了求和过程<span class="math inline">\(\sum\)</span>，也就是说更新权重的时候，不需要计算整体的梯度，而是仅仅依靠当前实例的梯度进行更新。</p>
<p>如此改变之后，速度明显提高了很多，但是这也是有风险的。由于进行频繁的梯度更新，很有可能直接跳过了最优点。因此，SGD实际上是无法保证收敛到全局最优点的，而且不是那么的稳定。</p>
<h1 id="mini-batch-gradient-descent">Mini-Batch Gradient Descent</h1>
<p>而Mini-Batch是对上述两种策略的一种中和，它的基本思想就是从整个训练集上选取一个子集，对这个自己进行BGD的更新。具体公式可以表示为:</p>
<p><span class="math display">\[\begin{equation} \theta_j := \theta_j +
\alpha\sum\limits_{i=1}^n(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}
\label{mini-BGD} \end{equation}\]</span></p>
<p>比较公式<span class="math inline">\((\ref{BGD})\)</span>和<span class="math inline">\((\ref{mini-BGD})\)</span>会发现唯一的区别在于求和时的项数不一样，此处的<span class="math inline">\(n\)</span>不再是训练集的大小，而是一个小于或等于<span class="math inline">\(m\)</span>的数，通常范围在于50-256。</p>
<p>简单来说，先把大小为<span class="math inline">\(m\)</span>的训练集平均分为大小为<span class="math inline">\(n\)</span>的<span class="math inline">\(\frac{m}{n}\)</span>个子集，每次读入一个子集，进行梯度计算，更新权重。</p>
<p>相比SGD来说，它更加稳定；相比BGD来说，它计算量较小。</p>
<h1 id="总结">总结</h1>
<table>
<thead>
<tr class="header">
<th></th>
<th>BGD</th>
<th>SGD</th>
<th>mini-Batch</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>训练集</td>
<td>固定</td>
<td>固定</td>
<td>固定</td>
</tr>
<tr class="even">
<td>单次迭代样本数</td>
<td>整个训练集</td>
<td>固定</td>
<td>训练集的子集</td>
</tr>
<tr class="odd">
<td>算法复杂度</td>
<td>高</td>
<td>低</td>
<td>一般</td>
</tr>
<tr class="even">
<td>收敛性</td>
<td>稳定</td>
<td>不稳定</td>
<td>较稳定</td>
</tr>
</tbody>
</table>
<p>本文来自：<a href="http://zhouyichu.com/machine-learning/Three-Gradient-Descent/" title="三种梯度下降法">三种梯度下降法</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>SGD</tag>
        <tag>BGD</tag>
        <tag>mini-batch</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下转换参数序列规则</title>
    <url>/2017/11/20/argument_sequence_converting_rule_on_windows/</url>
    <content><![CDATA[<p>使用subprocess时，对参数转换的一些规则，原文来自<a href="https://docs.python.org/3/library/subprocess.html#converting-argument-sequence" title="Python文档">converting-argument-sequence</a></p>
<span id="more"></span>
<h1 id="在windows下将一个参数序列转换为一个字符串进行命令解析时需遵循以下规则对应-ms-c-runtime-规则">在Windows下，将一个参数序列转换为一个字符串进行命令解析时，需遵循以下规则（对应 MS C runtime 规则）：</h1>
<ol type="1">
<li>参数由白字符分隔，白字符可以是空格(Space)或制表符(Tab)。</li>
<li>由双引号包围的字符串被解释为单个参数，无论其中是否包含白字符。 带引号的字符串可以嵌入到参数中。</li>
<li>双引号前加上反斜杠被解释为一个双引号文本（反斜杠“\”视为转义字符，同C语言）。</li>
<li>反斜杠仅视为文本，除反斜杠之后紧跟一个双引号。</li>
<li>如果反斜杠后紧跟一个双引号，则每对反斜杠都解释为反斜杠文本。 如果反斜杠的数量是奇数，则最后一个反斜杠将转义下一个双引号，如规则3所述。</li>
</ol>
<h1 id="原文">原文：</h1>
<blockquote>
<ol type="1">
<li>Arguments are delimited by white space, which is either a space or a tab.</li>
<li>A string surrounded by double quotation marks is interpreted as a single argument, regardless of white space contained within. A quoted string can be embedded in an argument.</li>
<li>A double quotation mark preceded by a backslash is interpreted as a literal double quotation mark.</li>
<li>Backslashes are interpreted literally, unless they immediately precede a double quotation mark.</li>
<li>If backslashes immediately precede a double quotation mark, every pair of backslashes is interpreted as a literal backslash. If the number of backslashes is odd, the last backslash escapes the next double quotation mark as described in rule 3.</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>subprocess</tag>
      </tags>
  </entry>
  <entry>
    <title>MinGW编译Box2D</title>
    <url>/2018/10/30/box2d_mingw_compile/</url>
    <content><![CDATA[<p><a href="https://github.com/erincatto/Box2D">Box2D</a>是一个著名的2D物理引擎。网上很多文章是老版本，使用<code>cmake</code>编译，最新的<code>git</code>版本，已经移除了<code>cmake</code>支持，使用<code>premake5</code>编译。本文记录了使用<code>mingw</code>编译该版本的方法。</p>
<span id="more"></span>
<p>编译平台：MinGW 5.3.0 32位, Win10x64</p>
<p>编译器信息：</p>
<blockquote>
<p>g++ -v</p>
</blockquote>
<blockquote>
<p>gcc version 5.3.0 (i686-posix-dwarf-rev0, Built by MinGW-W64 project)</p>
</blockquote>
<h2 id="下载box2d源码">1、下载<code>Box2D</code>源码：</h2>
<p><code>Box2D</code>源码仓库：<a href="https://github.com/erincatto/Box2D">https://github.com/erincatto/Box2D</a></p>
<h2 id="下载premake5">2、下载<code>premake5</code>，</h2>
<p>下载地址：<a href="https://premake.github.io/download.html">premake5</a></p>
<h2 id="编辑box2d目录下的premake5.lua">3、编辑<code>Box2D</code>目录下的<code>premake5.lua</code></h2>
<p>主要有4个部分，</p>
<ol type="1">
<li><code>configurations</code>调换两个配置的位置，从而默认创建<code>release</code>版本;</li>
<li><code>defaultplatform</code>改为<code>x86</code>，因为这里用的是32位版本编译器;</li>
<li>在<code>kind 'StaticLib'</code>后面添加两行，创建<code>libBox2D.a</code>的库: <figure class="highlight patch"><table><tr><td class="code"><pre><span class="line"> 	kind &#x27;StaticLib&#x27;</span><br><span class="line"><span class="addition">+    targetextension &#x27;.a&#x27;</span></span><br><span class="line"><span class="addition">+    targetprefix &#x27;lib&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>在<code>filter &#123; 'system:windows' &#125;</code>过滤器下，添加两个缺少的库<code>gdi32</code>和<code>imm32</code>；</li>
</ol>
<figure class="highlight patch"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-    	links &#123; &#x27;Box2D&#x27;, &#x27;opengl32&#x27;, &#x27;winmm&#x27; &#125;</span></span><br><span class="line"><span class="addition">+    	links &#123; &#x27;Box2D&#x27;, &#x27;opengl32&#x27;, &#x27;winmm&#x27;, &#x27;gdi32&#x27;,&#x27;imm32&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>完整的<code>diff</code>文件如下： <figure class="highlight patch"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git &quot;a/premake5-a174dba-left.lua&quot; &quot;b/premake5.lua&quot;</span></span><br><span class="line"><span class="comment">index 092eab4..138cc76 100644</span></span><br><span class="line"><span class="comment">--- &quot;a/premake5-a174dba-left.lua&quot;</span></span><br><span class="line"><span class="comment">+++ &quot;b/premake5.lua&quot;</span></span><br><span class="line"><span class="meta">@@ -2,7 +2,7 @@</span></span><br><span class="line"> -- https://premake.github.io/</span><br><span class="line"> </span><br><span class="line"> workspace &#x27;Box2D&#x27;</span><br><span class="line"><span class="deletion">-	configurations &#123; &#x27;Debug&#x27;, &#x27;Release&#x27; &#125;</span></span><br><span class="line"><span class="addition">+	configurations &#123; &#x27;Release&#x27;,&#x27;Debug&#x27; &#125;</span></span><br><span class="line"> 	startproject &#x27;Testbed&#x27;</span><br><span class="line"> 	location &#x27;Build&#x27;</span><br><span class="line"> 	symbols &#x27;On&#x27;</span><br><span class="line"><span class="meta">@@ -15,7 +15,7 @@</span> workspace &#x27;Box2D&#x27;</span><br><span class="line">         platforms &#123; &#x27;x86_64&#x27; &#125;</span><br><span class="line">     filter &#x27;system:windows&#x27;</span><br><span class="line">         platforms &#123; &#x27;x86&#x27;, &#x27;x86_64&#x27; &#125;</span><br><span class="line"><span class="deletion">-        defaultplatform &#x27;x86_64&#x27;</span></span><br><span class="line"><span class="addition">+        defaultplatform &#x27;x86&#x27;</span></span><br><span class="line"> 		defines &#123; &#x27;_CRT_SECURE_NO_WARNINGS&#x27; &#125;</span><br><span class="line"> 	filter &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -29,6 +29,8 @@</span> workspace &#x27;Box2D&#x27;</span><br><span class="line"> </span><br><span class="line"> project &#x27;Box2D&#x27;</span><br><span class="line"> 	kind &#x27;StaticLib&#x27;</span><br><span class="line"><span class="addition">+    targetextension &#x27;.a&#x27;</span></span><br><span class="line"><span class="addition">+    targetprefix &#x27;lib&#x27;</span></span><br><span class="line"> 	files &#123; &#x27;Box2D/**&#x27; &#125;</span><br><span class="line"> 	includedirs &#123; &#x27;.&#x27; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -79,7 +81,7 @@</span> project &#x27;Testbed&#x27;</span><br><span class="line"> 			&#x27;Testbed/glfw/wgl_context.c&#x27;,</span><br><span class="line"> 			&#x27;Testbed/glfw/egl_context.c&#x27;</span><br><span class="line"> 		&#125;</span><br><span class="line"><span class="deletion">-    	links &#123; &#x27;Box2D&#x27;, &#x27;opengl32&#x27;, &#x27;winmm&#x27; &#125;</span></span><br><span class="line"><span class="addition">+    	links &#123; &#x27;Box2D&#x27;, &#x27;opengl32&#x27;, &#x27;winmm&#x27;, &#x27;gdi32&#x27;,&#x27;imm32&#x27; &#125;</span></span><br><span class="line"> </span><br><span class="line">     filter &#123; &#x27;system:macosx&#x27; &#125;</span><br><span class="line">     	files</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>将上述patch文件保存，使用git自带的patch命令，可以很方便的打补丁，命令如下：</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">$ patch premake5.lua build.patch</span><br></pre></td></tr></table></figure>
<h2 id="运行premake5创建makefile">3、运行<code>premake5</code>，创建<code>Makefile</code></h2>
<p>可以首先运行<code>premake5 --help</code>，看看支持哪些命令。生成<code>MinGW</code>可编译的<code>Makefile</code>需要使用<code>gmake2</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ premake5 gmake2</span><br><span class="line">Building configurations...</span><br><span class="line">Running action &#x27;gmake2&#x27;...</span><br><span class="line">Generated Build/Makefile...</span><br><span class="line">Generated Build/Box2D.make...</span><br><span class="line">Generated Build/HelloWorld.make...</span><br><span class="line">Generated Build/Testbed.make...</span><br><span class="line">Done (247ms).</span><br></pre></td></tr></table></figure>
<h2 id="修改testbed.make">4、修改<code>Testbed.make</code></h2>
<p>进入<code>Build</code>目录，打开<code>Testbed.make</code>，在文件开始处前添加<code>CC=gcc</code>，注意<code>CC</code>需要大写</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ------注意增加这一句------</span></span><br><span class="line">CC=gcc   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="保存开始编译">5、保存，开始编译</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mingw32-make</span><br></pre></td></tr></table></figure>
<h2 id="运行">6、运行</h2>
<p>在<code>Build\bin\x86\Release</code>目录下找到<code>Testbed.exe</code>，运行后，在Test中选择<code>Tumbler</code>，可以看到一个旋转的矩形，编译完成。</p>
<h2 id="安装">7、安装</h2>
<p>新建安装目录<code>Box2D</code>/<code>Box2D\include</code>/<code>Box2d\lib</code>，将<code>.h</code>文件复制到<code>include</code>目录下，<code>.a</code>文件复制到<code>lib</code>目录下，批处理文件如下</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> BUILD_CONFIG=Release</span><br><span class="line"><span class="built_in">set</span> PLATFORM=x86</span><br><span class="line"><span class="built_in">set</span> IGNORED=ignored.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> %~dp0.\Box2d %~dp0.\Box2D\include %~dp0.\Box2D\lib %~dp0.\Box2D\bin</span><br><span class="line"><span class="comment">rem echo %~dp0</span></span><br><span class="line"><span class="built_in">echo</span> .cpp&gt;<span class="variable">%IGNORED%</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">xcopy</span> %~dp0..\Box2D %~dp0.\Box2D\include /E /EXCLUDE:<span class="variable">%IGNORED%</span> /Y</span><br><span class="line"><span class="built_in">copy</span> <span class="variable">%~dp0.\bin\%</span>PLATFORM<span class="variable">%\%</span>BUILD_CONFIG%\libBox2D.a %~dp0.\Box2D\lib\ /Y</span><br><span class="line"><span class="built_in">copy</span> <span class="variable">%~dp0.\bin\%</span>PLATFORM<span class="variable">%\%</span>BUILD_CONFIG%\*.exe %~dp0.\Box2D\bin\ /Y</span><br><span class="line"><span class="built_in">del</span> <span class="variable">%IGNORED%</span></span><br><span class="line"></span><br><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>折腾</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>MinGW</tag>
        <tag>Box2D</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：C/C++语言宏定义技巧</title>
    <url>/2018/09/03/cpp_macro_usage/</url>
    <content><![CDATA[<p>记录一些C++中宏定义的使用技巧，转自<a href="https://blog.csdn.net/yujinqiong/article/details/4098700">CSND</a>。</p>
<span id="more"></span>
<h2 id="防止一个头文件被重复包含">1.防止一个头文件被重复包含</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COMDEF_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMDEF_H </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//头文件内容 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<h2 id="重新定义一些类型防止由于各种平台和编译器的不同而产生的类型字节数差异方便移植">2.重新定义一些类型,防止由于各种平台和编译器的不同,而产生的类型字节数差异,方便移植。</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="type">unsigned</span> <span class="type">char</span>      boolean;     <span class="comment">/* Boolean value type. */</span>   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>  uint32;      <span class="comment">/* Unsigned 32 bit value */</span> </span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">unsigned</span> <span class="type">short</span>     uint16;      <span class="comment">/* Unsigned 16 bit value */</span> </span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">unsigned</span> <span class="type">char</span>      uint8;       <span class="comment">/* Unsigned 8  bit value */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">signed</span> <span class="type">long</span> <span class="type">int</span>    int32;       <span class="comment">/* Signed 32 bit value */</span> </span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">signed</span> <span class="type">short</span>       int16;       <span class="comment">/* Signed 16 bit value */</span> </span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">signed</span> <span class="type">char</span>        int8;        <span class="comment">/* Signed 8  bit value */</span>   </span><br></pre></td></tr></table></figure>
<h2 id="得到指定地址上的一个字节或字">3. 得到指定地址上的一个字节或字</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  MEM_B(x)  ( *( (byte *) (x) ) ) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  MEM_W(x)  ( *( (word *) (x) ) ) </span></span><br></pre></td></tr></table></figure>
<h2 id="求最大值和最小值">4. 求最大值和最小值</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  MAX(x, y)  ( ((x) &gt; (y)) ? (x) : (y) ) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  MIN(x, y)  ( ((x) &lt; (y)) ? (x) : (y) ) </span></span><br></pre></td></tr></table></figure>
<h2 id="得到一个field在结构体struct中的偏移量">5. 得到一个field在结构体(struct)中的偏移量</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FPOS( type, field ) / </span></span><br><span class="line">    <span class="comment">/*lint -e545 */</span> ( (dword) &amp;(( type *) <span class="number">0</span>)-&gt; field ) <span class="comment">/*lint +e545 */</span> </span><br></pre></td></tr></table></figure>
<h2 id="得到一个结构体中field所占用的字节数">6. 得到一个结构体中field所占用的字节数</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSIZ( type, field ) sizeof( ((type *) 0)-&gt;field ) </span></span><br></pre></td></tr></table></figure>
<h2 id="按照lsb格式把两个字节转化为一个word">7. 按照LSB格式把两个字节转化为一个Word</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] ) </span></span><br></pre></td></tr></table></figure>
<h2 id="按照lsb格式把一个word转化为两个字节">8. 按照LSB格式把一个Word转化为两个字节</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  FLOPW( ray, val ) / </span></span><br><span class="line">  (ray)[<span class="number">0</span>] = ((val) / <span class="number">256</span>); / </span><br><span class="line">  (ray)[<span class="number">1</span>] = ((val) &amp; <span class="number">0xFF</span>) </span><br></pre></td></tr></table></figure>
<h2 id="得到一个变量的地址word宽度">9. 得到一个变量的地址（word宽度）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  B_PTR( var )  ( (byte *) (void *) &amp;(var) ) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  W_PTR( var )  ( (word *) (void *) &amp;(var) ) </span></span><br></pre></td></tr></table></figure>
<h2 id="得到一个字的高位和低位字节">10. 得到一个字的高位和低位字节</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  WORD_LO(xxx)  ((byte) ((word)(xxx) &amp; 255)) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  WORD_HI(xxx)  ((byte) ((word)(xxx) &gt;&gt; 8)) </span></span><br></pre></td></tr></table></figure>
<h2 id="返回一个比x大的最接近的8的倍数">11. 返回一个比X大的最接近的8的倍数</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RND8(x)        ((((x) + 7) / 8 ) * 8 ) </span></span><br></pre></td></tr></table></figure>
<h2 id="将一个字母转换为大写">12. 将一个字母转换为大写</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  UPCASE(c)   ( ((c) &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;z&#x27;</span>) ? ((c) - 0x20) : (c) ) </span></span><br></pre></td></tr></table></figure>
<h2 id="判断字符是不是10进值的数字">13. 判断字符是不是10进值的数字</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  DECCHK(c)   ((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>) </span></span><br></pre></td></tr></table></figure>
<h2 id="判断字符是不是16进值的数字">14. 判断字符是不是16进值的数字</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  HEXCHK(c)   ( ((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>)  / </span></span><br><span class="line">                       ((c) &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;F&#x27;</span>)  / </span><br><span class="line">                       ((c) &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;f&#x27;</span>) ) </span><br></pre></td></tr></table></figure>
<h2 id="防止溢出的一个方法">15. 防止溢出的一个方法</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  INC_SAT(val)  (val = ((val)+1 &gt; (val)) ? (val)+1 : (val)) </span></span><br></pre></td></tr></table></figure>
<h2 id="返回数组元素的个数">16. 返回数组元素的个数</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  ARR_SIZE(a)  (sizeof((a)) / sizeof((a[0]))) </span></span><br></pre></td></tr></table></figure>
<h2 id="对于io空间映射在存储空间的结构输入输出处理">17. 对于IO空间映射在存储空间的结构,输入输出处理</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inp(port)         (*((volatile byte *) (port))) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inpw(port)        (*((volatile word *) (port))) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inpdw(port)       (*((volatile dword *)(port))) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outp(port, val)   (*((volatile byte *) (port)) = ((byte) (val))) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outpw(port, val)  (*((volatile word *) (port)) = ((word) (val))) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val))) </span></span><br></pre></td></tr></table></figure>
<h2 id="使用一些宏跟踪调试">18. 使用一些宏跟踪调试</h2>
<p>ANSI标准说明了五个预定义的宏名。它们是： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_LINE_      <span class="comment">// 行号</span></span><br><span class="line">_FILE_      <span class="comment">// 文件名</span></span><br><span class="line">_DATE_      <span class="comment">// 日期</span></span><br><span class="line">_TIME_      <span class="comment">// 时间</span></span><br><span class="line">_STDC_      <span class="comment">// 是否符合标准</span></span><br></pre></td></tr></table></figure></p>
<p>如果编译器不符合标准,则可能仅支持以上宏名中的几个,或根本不支持。此外，编译器可能会提供其它预定义的宏名。</p>
<p><code>_LINE_</code>及<code>_FILE_</code>宏指令在有关<code>#line</code>的部分中已讨论,这里讨论其余的宏名。</p>
<p><code>_DATE_</code>宏指令含有形式为月/日/年的串,表示源文件被翻译到代码时的日期。</p>
<p>源代码翻译到目标代码的时间作为串包含在<code>_TIME_</code>中。串形式为<code>时:分:秒</code>。</p>
<p>如果实现是标准的,则宏<code>_STDC_</code>含有十进制常量1。如果它含有任何其它数,则实现是非标准的。</p>
<p>当定义了_DEBUG,输出数据信息和所在文件所在行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DEBUGMSG(msg,date) printf(msg);printf(<span class="string">&quot;%d%d%d&quot;</span>,date,_LINE_,_FILE_) </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DEBUGMSG(msg,date)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<h2 id="宏中和的用法">19. 宏中<code>#</code>和<code>##</code>的用法</h2>
<h3 id="一般用法">1) 一般用法</h3>
<p><code>#</code>把宏参数变为一个字符串,<code>##</code>把两个宏参数连接在一起，用法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR(s)     #s </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONS(a,b)  int(a##e##b) </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="built_in">STR</span>(vck));           <span class="comment">// 输出字符串&quot;vck&quot; </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d/n&quot;</span>, <span class="built_in">CONS</span>(<span class="number">2</span>,<span class="number">3</span>));  <span class="comment">// 2e3 输出:2000 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="当宏参数是另一个宏的时候">2) 当宏参数是另一个宏的时候</h3>
<p>需要注意的是凡宏定义里有用<code>#</code>或<code>##</code>的地方宏参数是不会再展开.</p>
<h4 id="非和的情况">(1) 非<code>#</code>和<code>##</code>的情况</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOW        (2) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUL(a,b)   (a*b) </span></span><br></pre></td></tr></table></figure>
<p>如下例子，<code>MUL</code>里的参数<code>TOW</code>会被展开为<code>(2)</code>. <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宏会被展开为： printf(&quot;%d*%d=%d/n&quot;, (2), (2), ((2)*(2))); </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d/n&quot;</span>, TOW, TOW, <span class="built_in">MUL</span>(TOW,TOW)); </span><br></pre></td></tr></table></figure></p>
<h4 id="当有或的时候">(2) 当有<code>#</code>或<code>##</code>的时候</h4>
<p>假设有如下定义： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR(s)     #s </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A          (2) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONS(a,b)  int(a##e##b) </span></span><br></pre></td></tr></table></figure></p>
<p>现在希望作如下转换：将<code>INT_MAX</code>的值转换为字符串；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下行被展开为： printf(&quot;int max: %s/n&quot;, &quot;INT_MAX&quot;); </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int max: %s/n&quot;</span>,  <span class="built_in">STR</span>(INT_MAX));   <span class="comment">// INT_MAX（定义在 #include&lt;climits&gt; 中）</span></span><br><span class="line"><span class="comment">// 注意，此处只进行了一次替换，INT_MAX成为了输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下行被展开为：printf(&quot;%s/n&quot;, int(AeA));                </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s/n&quot;</span>, <span class="built_in">CONS</span>(A, A));               <span class="comment">// compile error  </span></span><br><span class="line"><span class="comment">// 注意，此处只进行了一次替换，a##e##b变成了 AeA，并没有将A继续替换为2，</span></span><br><span class="line"><span class="comment">// 从而出现编译错误，而不是希望得到的2e2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>INT_MAX</code>和<code>A</code>都不会再被展开, 解决这个问题的方法很简单，加多一层中间转换宏。使得所有宏的参数全部展开, 从而在转换后的宏里(<code>_STR</code>)获得正确的宏参数.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _STR(s)     #s </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR(s)      _STR(s)          <span class="comment">// 转换宏 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A           (2) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CONS(a,b)  int(a##e##b) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONS(a,b)   _CONS(a,b)       <span class="comment">// 转换宏 </span></span></span><br></pre></td></tr></table></figure>
<p>转换后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下语句输出为: int max: 0x7fffffff</span></span><br><span class="line"><span class="comment">// STR(INT_MAX) --&gt;  _STR(0x7fffffff) 然后再转换成字符串; </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int max: %s/n&quot;</span>, <span class="built_in">STR</span>(INT_MAX));          <span class="comment">// INT_MAX,int型的最大值,为一个变量 #include&lt;climits&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下语句输出为：200 </span></span><br><span class="line"><span class="comment">// CONS(A, A)  --&gt;  _CONS((2), (2))  --&gt; int((2)e(2)) </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d/n&quot;</span>, <span class="built_in">CONS</span>(A, A));   </span><br></pre></td></tr></table></figure>
<h3 id="和的一些应用特例">3) <code>#</code>和<code>##</code>的一些应用特例</h3>
<h4 id="合并匿名变量名">(1) 合并匿名变量名</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  ___ANONYMOUS1(type, var, <span class="keyword">line</span>)  type  var##<span class="keyword">line</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  __ANONYMOUS0(type, <span class="keyword">line</span>)  ___ANONYMOUS1(type, _anonymous, <span class="keyword">line</span>) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  ANONYMOUS(type)  __ANONYMOUS0(type, __LINE__) </span></span><br></pre></td></tr></table></figure>
<p>例：<code>ANONYMOUS(static int);</code> 即: <code>static int _anonymous70;</code>，<code>70</code>表示该行行号;</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 40%" />
<col style="width: 7%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th>宏的层次</th>
<th>转换前</th>
<th style="text-align: center;">方向</th>
<th>转换后</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>第1层：</td>
<td><code>ANONYMOUS(static int);</code></td>
<td style="text-align: center;">--&gt;</td>
<td><code>__ANONYMOUS0(static int, __LINE__);</code></td>
</tr>
<tr class="even">
<td>第2层：</td>
<td><code>__ANONYMOUS0(static int, __LINE__);</code></td>
<td style="text-align: center;">--&gt;</td>
<td><code>___ANONYMOUS1(static int, _anonymous, 70);</code></td>
</tr>
<tr class="odd">
<td>第3层：</td>
<td><code>___ANONYMOUS1(static int, _anonymous, 70);</code></td>
<td style="text-align: center;">--&gt;</td>
<td><code>static int  _anonymous70;</code></td>
</tr>
</tbody>
</table>
<p>即每次只能解开当前层的宏，所以<code>__LINE__</code>在第二层才能被解开;</p>
<h4 id="填充结构">(2) 填充结构</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  FILL(a)   &#123;a, #a&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IDD</span>&#123;OPEN, CLOSE&#125;; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123; </span><br><span class="line">  IDD id; </span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> * msg; </span><br><span class="line">&#125;MSG; </span><br><span class="line"></span><br><span class="line">MSG _msg[] = &#123;<span class="built_in">FILL</span>(OPEN), <span class="built_in">FILL</span>(CLOSE)&#125;; </span><br></pre></td></tr></table></figure>
<p>相当于： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MSG _msg[] = &#123;&#123;OPEN, <span class="string">&quot;OPEN&quot;</span>&#125;, </span><br><span class="line">              &#123;CLOSE, <span class="string">&quot;CLOSE&quot;</span>&#125;&#125;; </span><br></pre></td></tr></table></figure></p>
<h4 id="记录文件名-.">(3) 记录文件名 .</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _GET_FILE_NAME(f)   #f </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GET_FILE_NAME(f)    _GET_FILE_NAME(f) </span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>  FILE_NAME[] = <span class="built_in">GET_FILE_NAME</span>(__FILE__); </span><br></pre></td></tr></table></figure>
<h4 id="得到一个数值类型所对应的字符串缓冲大小">(4) 得到一个数值类型所对应的字符串缓冲大小</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _TYPE_BUF_SIZE(type)  sizeof #type </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TYPE_BUF_SIZE(type)   _TYPE_BUF_SIZE(type) </span></span><br><span class="line"><span class="type">char</span>  buf[<span class="built_in">TYPE_BUF_SIZE</span>(INT_MAX)]; </span><br><span class="line">   <span class="comment">// --&gt;  char  buf[_TYPE_BUF_SIZE(0x7fffffff)]; </span></span><br><span class="line">   <span class="comment">// --&gt;  char  buf[sizeof &quot;0x7fffffff&quot;]; </span></span><br></pre></td></tr></table></figure>
<p>相当于： <code>char  buf[11];</code></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>宏定义</tag>
      </tags>
  </entry>
  <entry>
    <title>神器FFmpeg的使用</title>
    <url>/2018/01/27/ffmpeg_usage/</url>
    <content><![CDATA[<p>以前进行视频转换，用这个那个工具，最后发现神器<code>FFmpeg</code>太强大了。<code>FFmpeg</code>参数众多，以下记录<code>ffmpeg</code>的一些用法。</p>
<h2 id="ffmpeg简介">1.FFmpeg简介</h2>
<p>以下内容来自<a href="https://zh.wikipedia.org/wiki/FFmpeg">维基百科</a> &gt; FFmpeg是一个自由软件，可以运行音频和视频多种格式的录影、转换、流功能，包含了libavcodec——这是一个用于多个项目中音频和视频的解码器库，以及libavformat——一个音频与视频格式转换库。</p>
<span id="more"></span>
<h2 id="ffmpeg命令行工具组成">2. FFmpeg命令行工具组成</h2>
<p>FFmpeg命令行工具包含以下三个基本工具： 1) <code>ffmpeg</code>：视频文件转换命令行工具，支持经过实时电视卡抓取和编码成视频文件； 2) <code>ffserver</code>：基于HTTP、RTSP用于实时广播的多媒体服务器。也支持时间平移； 3) <code>ffplay</code>：用 SDL和FFmpeg库开发的一个简单的媒体播放器；</p>
<h2 id="ffmpeg的下载">3. FFmpeg的下载</h2>
<p>FFmpeg的下载地址：<a href="https://ffmpeg.zeranoe.com/builds/">FFmpeg下载</a> ，一般下载static版本，解压后设置环境变量即可使用。</p>
<h2 id="ffmpeg命令格式">4. FFmpeg命令格式</h2>
<p>FFmpeg工具的基本格式为： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg [global_options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</span><br></pre></td></tr></table></figure> 其中，<code>-i</code> 参数表示输入参数；之后的参数是输出参数。</p>
<p>ffmpeg 的一般工作流，是从源文件开始，依次经过分流器、解码器、编码器、混流器，最后完成输出文件。下图是官网给出的示意： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> _______              ______________</span><br><span class="line">|       |            |              |</span><br><span class="line">| input |  demuxer   | encoded data |   decoder</span><br><span class="line">| file  | ---------&gt; | packets      | -----+</span><br><span class="line">|_______|            |______________|      |</span><br><span class="line">                                           v</span><br><span class="line">                                       _________</span><br><span class="line">                                      |         |</span><br><span class="line">                                      | decoded |</span><br><span class="line">                                      | frames  |</span><br><span class="line">                                      |_________|</span><br><span class="line"> ________             ______________       |</span><br><span class="line">|        |           |              |      |</span><br><span class="line">| output | &lt;-------- | encoded data | &lt;----+</span><br><span class="line">| file   |   muxer   | packets      |   encoder</span><br><span class="line">|________|           |______________|</span><br></pre></td></tr></table></figure></p>
<p>一些基本的概念： - 流（stream）：视频文件中，一般具有视频流与音频流，有的具有字幕流。它们需要不同的解码/编码器。想要混合/分离视频与音频，就需要混流/分流器。 - 流复制（stream）：如果某种数据流的内容不需要任何改动，那么可以直接跳过该数据流的解码与编码步骤。分离出该数据流后，直接等待参与混流即可。</p>
<p>ffmpeg 在有多个流的情况下，不会全部保留；默认只会选择同类流中<strong>质量最佳的</strong>。如果质量同样，那么选择索引号靠前的流。你可以选择手动控制流的选择，这需要额外的参数，我们下文介绍。</p>
<h2 id="主要参数">5. 主要参数</h2>
<p>下表中： 1. 以 <code>&lt;&gt;</code> 包裹的表示由用户具体指定；以 <code>[]</code> 包裹的表示是可选参数，可以指定也可以省略。 2. 括号内的 <code>i</code> 表示该参数用于输入流，<code>o</code> 表示用于输出流，<code>i/o</code> 表示均可，<code>global</code> 表示全局参数。 3. 关键字 <code>duration</code>, <code>position</code> 或 <code>offset</code> 满足：<code>[-][HH:]MM:SS[.m...]</code> 这种时间戳格式。或者以秒为单位的 <code>SS[.m...]</code> 格式。</p>
<p>常用的如下： - <code>-b[:stream_specifier] (o)</code>：输出比特率。 - <code>-f &lt;fmt&gt; (i/o)</code>：指定 <code>fmt</code> 作为输入或输出的视频格式。一般会根据文件扩展名自动选择，但有时需要手动指定。<br />
- <code>-i &lt;filename&gt; (i)</code>：指定 <code>filename</code> 作为源文件。<br />
- <code>-y (global)</code>：文件存在时直接覆盖。<br />
- <code>-n (global)</code>：文件存在时不覆盖并立即退出。<br />
- <code>-bsf[:stream_specifier] &lt;bitstream_filters&gt; (o)</code>：设置比特流滤镜。<code>bitstream_filters</code> 是一个逗号分隔的滤镜列表。 - <code>-stream_loop &lt;num&gt; (i)</code>：指定输入流的循环次数。0 表示不循环，-1 表示无限循环。<br />
- <code>-c[:stream_specifier] &lt;codec&gt; (i/o)</code>：<code>-c</code>可写为<code>-codec</code>。选择一个 <code>codec</code> ，即编码器（输出时）或一个解码器（输入时），参与到 <code>stream_specifier</code> 指定的一个或多个流的编码/解码中。在输出时，<code>&lt;codec&gt;</code> 可以被指定为 <code>copy</code>，表示复制数据流。<br />
- <code>-t &lt;duration&gt; (i/o)</code>：（在参数 <code>-i</code> 之前指定）工作持续 <code>duration</code> 时长。一般用于指定剪辑数据流的范围。 它与 <code>-to</code> 参数相互冲突，但本参数优先。<br />
- <code>-to &lt;position&gt; (o)</code>：到 <code>position</code> 位置后，终止输出。与 <code>-t</code> 参数冲突，本参数优先级低。 - <code>-fs &lt;limit_size&gt; (o)</code>：输出文件大小达到 <code>limit_size</code> 后停止输出，单位是 byte.<br />
- <code>-ss &lt;position&gt; (i/o)</code>：（在参数 <code>-i</code> 之前指定）从 <code>position</code> 指定的位置开始工作。<em>注意：大多数情形下，工作起始位置是不精确的。ffmpeg会找到其前部的一个点作为真正的起始，并在结束工作后将该点与用户指定点之间的内容抛弃。然而，如果你使用了 copy 参数，这部分内容却会被保留。</em><br />
- <code>-sseof &lt;position&gt; (i/o)</code>：类似 <code>-ss</code> 参数，只不过是从数据流末端向前寻找 <code>position</code>。此时 0 表示数据流末。<br />
- <code>-itsoffset &lt;offset&gt; (i)</code>：指定输入流以原时间戳加上 <code>offset</code> 作为其输入时间戳。<br />
- <code>-metadata[:metadata_specifier] key=value (o)</code>：以键值对的形式设置元数据。<br />
- <code>-frames[:stream_specifier] &lt;num&gt; (o)</code>：在输出 <code>num</code> 帧后停止写入。 - <code>-qscale[:stream_specifier] q (o)</code>：使用固定质量(VBR)。<br />
- <code>stats (global)</code>：输出编码过程，是系统默认值。可以使用 <code>-nostats</code> 关闭。<br />
- <code>-attach &lt;filename&gt; (o)</code>：将 <code>filename</code> 文件附加到输出文件。附件流作为文件的最后一个流，只有很少的文件类型被支持（例如字体）。</p>
<h2 id="视频参数">6. 视频参数</h2>
<ul>
<li><code>-vframes &lt;num&gt;</code>：文件的总帧数。<code>-frames:v</code> 的别名。</li>
<li><code>-r[:steam_specifier] &lt;fps&gt; (i/o)</code>：文件的帧率。</li>
<li><code>-s[:steam_specifier] &lt;size&gt; (i/o)</code>：帧尺寸。参数 <code>size</code> 需要满足格式 <code>&lt;width&gt;x&lt;height&gt;</code>，例如<code>320x240</code>。 -<code>aspect[:steam_specifier] &lt;asp&gt; (o)</code>：宽高比，例如 <code>4:3</code>。如果使用了 <code>-vcodec copy</code>，那么指定容器的宽高比而不是视频的。</li>
<li><code>-vn (o)</code>：禁止输出视频。</li>
<li><code>-vcodec &lt;codec&gt; (o)</code>：设置视频编码器。<code>-codec:v</code> 的别名。</li>
<li><code>-pass[:stream_specifier] &lt;n&gt;</code>：选择当前编码数（1或者2），常用于二次编码的情况。在第一次编码中，音频输出往往被设置为 NULL，对于 Windows 与 Unix 系统分别是： <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i foo.mov -c:v libxvid -pass <span class="number">1</span> -an -f rawvideo -y <span class="built_in">NUL</span></span><br><span class="line">ffmpeg -i foo.mov -c:v libxvid -pass <span class="number">1</span> -an -f rawvideo -y /dev/null</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="音频参数">7. 音频参数</h2>
<ul>
<li><code>-aframes &lt;num&gt; (o)</code>：文件的总帧数。<code>-frames:a</code> 的别名。</li>
<li><code>-ar[:stream_specifier] &lt;freq&gt; (i/o)</code>：采样率。默认输出等于输入。仅当输入文件为真实设备或者 raw 数据时，该参数才能用于输入过程。</li>
<li><code>-aq &lt;q&gt; (o)</code>：音频品质（VBR）。 <code>-q:a</code> 的别名。</li>
<li><code>-ac[:stream_specifier] &lt;channel&gt; (i/o)</code>：设置音频通道数。默认输出等于输入。仅当输入文件为真实设备或者 raw 数据时，该参数才能用于输入过程。</li>
<li><code>-an (o)</code>：禁止输出音频。</li>
<li><code>-acode &lt;codec&gt; (i/o)</code>：设置音频的解码器或编码器。<code>-codec:a</code> 的别名。</li>
</ul>
<h2 id="字幕参数">8. 字幕参数</h2>
<ul>
<li><code>-scodec &lt;codec&gt; (i/o)</code>：字幕解码器或编码器。<code>codec:s</code> 的别名。</li>
<li><code>-sn (o)</code>：禁止输出字幕。</li>
<li><code>canvas_size &lt;size&gt;</code>：设置字幕渲染区域的尺寸。</li>
</ul>
<h2 id="其他参数">9. 其他参数</h2>
<p>以下直接在 <code>ffmpeg</code> 后使用，例如：<code>ffmpeg -version</code>。</p>
<ul>
<li><code>-bsfs</code>：可用的比特流滤镜。</li>
<li><code>-h [arg]</code>：帮助。arg 的内容可以是：
<ul>
<li><code>decoders</code>：可用的解码器。或特指：<code>decoder=&lt;name&gt;</code>。</li>
<li><code>encoders</code>：可用的编码器。或特指：<code>encoder=&lt;name&gt;</code>。</li>
<li><code>filters</code>：所有滤镜。或特指：<code>filter=&lt;name&gt;</code>。</li>
<li><code>formats</code>：可用的分流器与混流器。或特指分流器：<code>demuxer=&lt;name&gt;</code>，或特指混流器：<code>muxer=&lt;name&gt;</code>。</li>
</ul></li>
<li><code>-protocols</code>：支持的协议。</li>
<li><code>-version</code>：版本信息。</li>
</ul>
<h2 id="ffmpeg-实用例子">10.FFmpeg 实用例子</h2>
<h3 id="合并视频">10.1 合并视频</h3>
<p>参考：<a href="https://trac.ffmpeg.org/wiki/Concatenate">FFmpeg Wiki - Concatenate</a></p>
<p>第一种方案：将这几个视频放在一个新文件夹内，Shift 右键运行 cmd，输入（<em>注意：如果要保存为批处理文件，请循环变量的双写百分号。</em>）： <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">for</span> %i <span class="keyword">in</span> (*.flv) <span class="keyword">do</span> @<span class="built_in">echo</span> file &#x27;%i&#x27;) &gt; mylist.txt</span><br><span class="line">ffmpeg -f concat -i mylist.txt -c <span class="built_in">copy</span> output.flv</span><br></pre></td></tr></table></figure> 这样速度很快也没有中间文件，原则上要求文件规格相近。</p>
<p>另一种方案：先将这几个视频无损地转为 mpegts 文件，再通过 concat 协议合并。以常见的 H.264 视频与 aac 音频为例：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &quot;<span class="number">1</span>.flv&quot; -c <span class="built_in">copy</span> -bsf:v h264_mp4toannexb -f mpegts <span class="number">1</span>.ts</span><br><span class="line">ffmpeg -i &quot;<span class="number">2</span>.flv&quot; -c <span class="built_in">copy</span> -bsf:v h264_mp4toannexb -f mpegts <span class="number">2</span>.ts</span><br><span class="line">ffmpeg -i &quot;concat:<span class="number">1</span>.ts|<span class="number">2</span>.ts&quot; -c <span class="built_in">copy</span> -bsf:a aac_adtstoasc &quot;All.mp4&quot;</span><br></pre></td></tr></table></figure>
<p>这种方案是早期方案，支持更广，包括非 mpeg 容器的 mpeg 编码内容（H.264, MPEG4, MPEG2, AAC, MP3等）。不过这样会产生中间文件。</p>
<h3 id="分割视频">10.2 分割视频</h3>
<p>指定视频的起始与持续时长就可以分割视频了。下例截取了视频的前 5 秒（00:05:00），注意<code>-t</code>后接“截取视频段长度”而不是“截取终点时刻”：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &quot;input.mp4&quot; -ss <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> -t <span class="number">5</span> -c <span class="built_in">copy</span> &quot;output.mp4&quot;</span><br></pre></td></tr></table></figure>
<p>建议使用规范的 mp4 格式文件，否则可能出现视频无法正常混流的现象。</p>
<h3 id="批量格式转换">10.3 批量格式转换</h3>
<p>比如，对于数据流用 mpeg 编码的一个 flv 文件，可以这样转为 mp4 文件： <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &quot;input.flv&quot; -c <span class="built_in">copy</span> &quot;output.mp4&quot;</span><br></pre></td></tr></table></figure></p>
<p>因此一个批量转换也很容易通过 for 语句实现（<code>%~n</code> 表示保留不含扩展名的文件名）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for %i in (*.mp4) do ffmpeg -i &quot;%i&quot; -c copy &quot;%~ni.flv&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="静态图水印">10.4 静态图水印</h3>
<p>下例添加 png 或其他静态格式的水印，放置在距左侧 20 像素,距顶端 40 像素的地方。水印与视频的基准点都是左上角点。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -i wm.png -filter_complex &quot;overlay=<span class="number">20</span>:<span class="number">40</span>&quot; output.mp4</span><br></pre></td></tr></table></figure>
<p>如果要放在右下角使用<code>overlay= main_w-overlay_w:main_h-overlay_h</code>，参数的含义应该较好理解。</p>
<p>如果要指定水印的大小，比如 384x216： <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -i wm.png -filter_complex &quot;[<span class="number">1</span>:v]scale=<span class="number">384</span>:<span class="number">216</span>[wm];[<span class="number">0</span>:v][wm]overlay=<span class="number">0</span>:<span class="number">0</span>&quot; output.mp4</span><br></pre></td></tr></table></figure></p>
<p>参数 <code>0:v</code> 表示第1个输入的视频流（本例即input.mp4的视频流），<code>1:v</code> 表示第2个输入的视频流（本例即wm.gif）。分号前的[wm]用于引用。</p>
<h3 id="gif水印">10.5 GIF水印</h3>
<p>添加 gif 水印与静态图水印有一些不同之处： - 需要将 <code>ignore_loop</code> 参数指明为 0，表示 gif 无限循环。 - 需要用到复合过滤器 <code>filter_complex</code>。 - 需要过滤器的 <code>shortest=1</code> 选项，表示至少在一个视频流循环一次后，再终止输出。如果不加该选项，输出将无法自行停止。</p>
<p>一个指定 50x50 大小 GIF 水印在左上角的例子： <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -y -i input.mp4 -ignore_loop <span class="number">0</span> -i wm.gif -filter_complex &quot;[<span class="number">1</span>:v]scale=<span class="number">50</span>:<span class="number">50</span>[wm];[<span class="number">0</span>:v][wm]overlay=<span class="number">0</span>:<span class="number">0</span>:shortest=<span class="number">1</span>&quot; output.mp4</span><br></pre></td></tr></table></figure></p>
<h3 id="外挂字幕">10.6 外挂字幕</h3>
<p>将字幕作为单独的数据流（而不是混入视频流中），封装到容器内。一般对此特性有良好支持的容器是 mkv。在封装时，一般需要转为 ass 格式。 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -i input.srt -c:v <span class="built_in">copy</span> -c:a <span class="built_in">copy</span> -c:s ass output.mkv</span><br></pre></td></tr></table></figure></p>
<p>一些注意点： - 字幕文件请用 UTF-8 编码。 - Windows 系统缺少一个字体接口，因此需要自己配置 fonts.conf 文件，放在 <code>%FONTCONFIG_PATH%</code> 这个环境用户变量里（往往需要你自己新建）。该变量应该指向<code>C:\Users\用户名\</code>。</p>
<p>网上流传了一份 fonts.conf 文件内容（见附录），请复制后粘贴到你对应文件夹的 fonts.conf 文件中。</p>
<h3 id="内嵌字幕">10.7 内嵌字幕</h3>
<p>在播放器不支持独立字幕流的场合，需要将字幕混入视频流中（因此需要重编码）。 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vf subtitles=input.srt output.mp4</span><br></pre></td></tr></table></figure></p>
<p>如果字幕以字幕流的形式位于一个视频文件中，可以直接调用： <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mkv -vf subtitles=input.mkv output.mp4</span><br></pre></td></tr></table></figure></p>
<p>如果希望在嵌入字幕时保留以前多个音轨，可以使用： <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &quot;input.mp4&quot; -map <span class="number">0</span>:<span class="number">0</span> -map <span class="number">0</span>:<span class="number">1</span> -map <span class="number">0</span>:<span class="number">2</span> -vf subtitles=input.Chs.srt output.mp4</span><br><span class="line"></span><br><span class="line"># 一个实际的例子</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> I <span class="keyword">in</span> `ls ../*.mp4`;<span class="keyword">do</span> ffmpeg -y -i &quot;../$I&quot; -map <span class="number">0</span>:<span class="number">0</span> -map <span class="number">0</span>:<span class="number">1</span> -map <span class="number">0</span>:<span class="number">2</span> -vf subtitles=../$&#123;I%.*&#125;.Chs.srt &quot;$&#123;I##*/&#125;&quot;;done</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>同样，Windows 用户需要配置 fonts.conf 文件（参加附录11）。</p>
<h3 id="将多个图片制作为视频">10.8 将多个图片制作为视频</h3>
<p>使用Python绘制了一系列顺序命名的图像，现在将其转为视频: <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -r <span class="number">25</span> -f image2 -s <span class="number">1200</span>x800 -i result_png/epo_%<span class="number">05</span>d.png -vcodec libx264 -crf <span class="number">25</span>  -pix_fmt yuv420p test.mp4</span><br></pre></td></tr></table></figure> <code>result_png/epo_%05d.png</code>表示 <code>result_png</code>目录下的<code>epo_xxxxx.png</code>文件，<code>xxxxx</code>从<code>00000</code>到<code>99999</code>。 <code>-r</code> 帧率(fps)； <code>-crf</code> 画质，越低表示质量越好，通常 15-25 已经不错了； <code>-s</code> 解析度 <code>-pix_fmt yuv420p</code>指定pixel format, 根据需要修改 输出文件名为 test.mp4。</p>
<h3 id="截取视频片段">10.9 截取视频片段</h3>
<p>自开始时间（<code>-ss</code>参数，格式为<code>HH:MM:SS</code>）到结束时间（<code>-to</code>参数,格式为<code>HH:MM:SS</code>）截取视频， <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -ss <span class="number">00</span>:<span class="number">02</span>:<span class="number">40</span> -i &quot;old_file.mp4&quot; -to <span class="number">00</span>:<span class="number">43</span>:<span class="number">24</span>  -vcodec <span class="built_in">copy</span> -acodec <span class="built_in">copy</span> &quot;new_file.mp4&quot;</span><br></pre></td></tr></table></figure> 当需要获取视频时长时，可以使用<code>ffprobe 文件名</code>进行检测。Python脚本参见<a href="/2018/01/03/ffmpeg_video_strip/">博文链接</a></p>
<h3 id="下载m3u8视频流">10.10 下载m3u8视频流</h3>
<p>用法比较简单，如下所示，该命令有时无法下载视频： <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ffmpeg -i http://...../abc.m3u8 &quot;输出文件名.mp4&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="附录windows-的-fonts.conf">11. 附录：Windows 的 fonts.conf</h2>
<p>参考页面：<a href="https://github.com/FiveYellowMice/how-to-convert-videos-with-ffmpeg-zh/blob/master/etc/fontconfig-windows/fonts.conf">该用户的 Github</a>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dir</span>&gt;</span>C:\WINDOWS\Fonts<span class="tag">&lt;/<span class="name">dir</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">match</span> <span class="attr">target</span>=<span class="string">&quot;pattern&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">qual</span>=<span class="string">&quot;any&quot;</span> <span class="attr">name</span>=<span class="string">&quot;family&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>mono<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">edit</span> <span class="attr">name</span>=<span class="string">&quot;family&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;assign&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">match</span> <span class="attr">target</span>=<span class="string">&quot;pattern&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">qual</span>=<span class="string">&quot;all&quot;</span> <span class="attr">name</span>=<span class="string">&quot;family&quot;</span> <span class="attr">compare</span>=<span class="string">&quot;not_eq&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>sans-serif<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">qual</span>=<span class="string">&quot;all&quot;</span> <span class="attr">name</span>=<span class="string">&quot;family&quot;</span> <span class="attr">compare</span>=<span class="string">&quot;not_eq&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>serif<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">qual</span>=<span class="string">&quot;all&quot;</span> <span class="attr">name</span>=<span class="string">&quot;family&quot;</span> <span class="attr">compare</span>=<span class="string">&quot;not_eq&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">edit</span> <span class="attr">name</span>=<span class="string">&quot;family&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;append_last&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>sans-serif<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">family</span>&gt;</span>Times<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prefer</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>Times New Roman<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">default</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">family</span>&gt;</span>Helvetica<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prefer</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>Arial<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">default</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>sans<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">family</span>&gt;</span>Courier<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prefer</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>Courier New<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">default</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">family</span>&gt;</span>serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prefer</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>Times New Roman<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">family</span>&gt;</span>sans<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prefer</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>Arial<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">family</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prefer</span>&gt;</span><span class="tag">&lt;<span class="name">family</span>&gt;</span>Andale Mono<span class="tag">&lt;/<span class="name">family</span>&gt;</span><span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">match</span> <span class="attr">target</span>=<span class="string">&quot;pattern&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">&quot;family&quot;</span> <span class="attr">compare</span>=<span class="string">&quot;eq&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Courier New<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">edit</span> <span class="attr">name</span>=<span class="string">&quot;family&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;prepend&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">match</span> <span class="attr">target</span>=<span class="string">&quot;pattern&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">&quot;family&quot;</span> <span class="attr">compare</span>=<span class="string">&quot;eq&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Courier<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">edit</span> <span class="attr">name</span>=<span class="string">&quot;family&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;prepend&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ol type="1">
<li><a href="http://hamelot.io/visualization/using-ffmpeg-to-convert-a-set-of-images-into-a-video/">Using ffmpeg to convert a set of images into a video</a></li>
<li><a href="https://wklchris.github.io/FFmpeg.html">FFmpeg命令行</a></li>
</ol>
]]></content>
      <categories>
        <category>折腾</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>使用FFMpeg及Python进行视频裁剪</title>
    <url>/2018/01/03/ffmpeg_video_strip/</url>
    <content><![CDATA[<p>最近追剧《风筝》，从某管下载的视频，前后有不低于1分钟的片头和片尾，片头更是达到了2分40秒，又懒得每次遥控下一个文件，干脆写个脚本裁剪片头和片尾。</p>
<span id="more"></span>
<p>注意事项： 1、文件名不能含有空格，含有空格的文件需要预先处理。原文件名称为<code>风筝 _ Kite 29【DVD版】（柳雲龍、羅海瓊、李小冉等主演）.mp4</code>，可以使用下列脚本进行批量重命名： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">files = [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> f.startswith(<span class="string">&#x27;风筝&#x27;</span>) <span class="keyword">and</span> f.endswith(<span class="string">&#x27;.mp4&#x27;</span>)]</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">    os.rename(f,<span class="string">&quot;&#123;&#125;_&#123;&#125;.mp4&quot;</span>.<span class="built_in">format</span>(f[:<span class="number">2</span>],f[<span class="number">10</span>:<span class="number">12</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure> 注：下面的脚本中已经包含上述处理步骤。</p>
<p>2、系统中需要有ffmpeg，下载地址在这里<a href="https://ffmpeg.zeranoe.com/builds/" title="FFMPEG下载">下载FFMpeg</a>，对于绿色版，请预先设置好环境变量。</p>
<p>新文件在上一级目录保存，转换完成后，可以删除原文件，如果懒得可以，可以直接在脚本中删除。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runCommand</span>(<span class="params">cmd</span>):</span><br><span class="line">    output = subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE, stderr = subprocess.STDOUT)</span><br><span class="line">    <span class="comment">#rst = output.stdout.read().decode(&quot;UTF8&quot;).strip()</span></span><br><span class="line">    rst = output.stdout.readlines()<span class="comment">#.decode(&quot;UTF8&quot;).strip()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">processVideoStripCmd</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">secondsToString</span>(<span class="params">seconds</span>):</span><br><span class="line">        strSeconds = []</span><br><span class="line">        strSeconds.append(seconds//<span class="number">3600</span>)</span><br><span class="line">        strSeconds.append((seconds-strSeconds[<span class="number">0</span>]*<span class="number">3600</span>)//<span class="number">60</span>)</span><br><span class="line">        strSeconds.append(seconds%<span class="number">60</span>)</span><br><span class="line">        strSeconds = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x :<span class="built_in">str</span>.<span class="built_in">format</span>(<span class="string">&#x27;&#123;:02d&#125;&#x27;</span>,x),strSeconds)) </span><br><span class="line">        strSeconds = <span class="string">&quot;:&quot;</span>.join(strSeconds)</span><br><span class="line">        <span class="keyword">return</span> strSeconds</span><br><span class="line"></span><br><span class="line">    timeFromBegin = <span class="number">160</span>      <span class="comment"># 距离文件开始起始时间</span></span><br><span class="line">    timeToEOF =<span class="number">90</span>            <span class="comment"># 距离文件结束截止时间</span></span><br><span class="line"></span><br><span class="line">    files = [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> f.startswith(<span class="string">&#x27;old_风筝&#x27;</span>) <span class="keyword">and</span> f.endswith(<span class="string">&#x27;.mp4&#x27;</span>)]</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----\n&quot;</span>,f)</span><br><span class="line">        cmd = <span class="string">&#x27;ffprobe &quot;&#123;&#125;&quot;&#x27;</span>.<span class="built_in">format</span>(f)</span><br><span class="line">        rst = runCommand(cmd)</span><br><span class="line">        rst = [r.decode(<span class="string">&quot;UTF8&quot;</span>).strip() <span class="keyword">for</span> r <span class="keyword">in</span> rst <span class="keyword">if</span> <span class="string">&quot;Duration&quot;</span> <span class="keyword">in</span> r.decode(<span class="string">&quot;UTF8&quot;</span>).strip()]</span><br><span class="line">        <span class="comment">#print(len(rst))</span></span><br><span class="line">        duration = <span class="string">&quot;&quot;</span></span><br><span class="line">        validDura = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(rst)&gt;<span class="number">0</span>:</span><br><span class="line">            start = <span class="built_in">len</span>(<span class="string">&#x27;Duration: &#x27;</span>)</span><br><span class="line">            duration=rst[<span class="number">0</span>][start:start+<span class="number">8</span>]</span><br><span class="line">            t = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,duration.split(<span class="string">&#x27;:&#x27;</span>)))</span><br><span class="line">            v = t[<span class="number">0</span>]*<span class="number">3600</span>+t[<span class="number">1</span>]*<span class="number">60</span>+t[<span class="number">2</span>]</span><br><span class="line">            v = v-timeFromBegin     <span class="comment">#开头</span></span><br><span class="line">            v = v-timeToEOF         <span class="comment">#结尾</span></span><br><span class="line">            validDura = secondsToString(v) </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\t 总时长:&#123;&#125;, 有效时长:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(duration,validDura))</span><br><span class="line">            </span><br><span class="line">            cmd = <span class="string">&#x27;ffmpeg -ss &#123;&#125; -i &quot;&#123;&#125;&quot; -t &#123;&#125; -vcodec copy -acodec copy &quot;../&#123;&#125;&quot;&#x27;</span>.<span class="built_in">format</span>(secondsToString(timeFromBegin),f,validDura,f[<span class="number">4</span>:])</span><br><span class="line">            <span class="built_in">print</span>(cmd)</span><br><span class="line">            rst = runCommand(cmd)</span><br><span class="line">            rst = [ r.decode(<span class="string">&quot;UTF8&quot;</span>).strip() <span class="keyword">for</span> r <span class="keyword">in</span> rst]</span><br><span class="line">            os.remove(f)</span><br><span class="line">            <span class="comment">#print(&quot;\n&quot;.join(rst))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;共处理&#123;&#125;个文件&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(files)))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    files = [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">if</span> f.startswith(<span class="string">&#x27;风筝&#x27;</span>) <span class="keyword">and</span> f.endswith(<span class="string">&#x27;.mp4&#x27;</span>)] </span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        os.rename(f,<span class="string">&quot;old_&#123;&#125;_&#123;&#125;.mp4&quot;</span>.<span class="built_in">format</span>(f[:<span class="number">2</span>],f[<span class="number">10</span>:<span class="number">12</span>]))</span><br><span class="line">    </span><br><span class="line">    result = processVideoStripCmd()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>git配置及命令行乱码</title>
    <url>/2018/08/24/git-usage/</url>
    <content><![CDATA[<p>日常使用Git，越来越觉得GUI不方便，以下记录下Git命令行配置</p>
<span id="more"></span>
<h2 id="设置alias">1、设置alias</h2>
<p>通过以下命令配置git的alias</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br><span class="line">$ git config --global alias.last <span class="string">&quot;log -1 HEAD&quot;</span></span><br><span class="line"></span><br><span class="line">$ rem 以下两行解决乱码</span><br><span class="line">$ git config --global i18n.commitencoding utf-8</span><br><span class="line">$ git config --global i18n.logoutputencoding utf-8</span><br></pre></td></tr></table></figure>
<p>最后一句命令中，<code>logoutputencoding</code>设为<code>gbk</code>还是<code>utf-8</code>取决于命令行本身的编码。<code>Windows</code>自带的<code>cmd</code>默认编码为<code>gbk</code>，则改为如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global i18n.logoutputencoding gbk</span><br></pre></td></tr></table></figure>
<p>我这里使用的是<code>cmder</code>，输出编码为<code>utf-8</code>因此不需要专门设置。</p>
<p>通过以下命令查看配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global --list</span><br><span class="line"></span><br><span class="line">user.name= yourname</span><br><span class="line">user.email=your@email.com</span><br><span class="line">http.postbuffer=64M</span><br><span class="line">https.postbuffer=64M</span><br><span class="line">alias.co=checkout</span><br><span class="line">alias.br=branch</span><br><span class="line">alias.ci=commit</span><br><span class="line">alias.st=status</span><br><span class="line">alias.last=<span class="built_in">log</span> -1 HEAD</span><br><span class="line">i18n.commitencoding=utf-8</span><br><span class="line">i18n.logoutputencoding=utf-8</span><br></pre></td></tr></table></figure>
<p>配置完成后，需要设置环境变量<code>LESSCHARSET</code>，或在命令行下执行<code>set LESSCHARSET=utf-8</code>。<code>cmder</code>可以在<code>user-profile.cmd</code>里，添加如下一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b &lt;分支名&gt;</span><br><span class="line">$ git push origin &lt;本地分支名&gt;:&lt;远端分支名&gt;</span><br></pre></td></tr></table></figure>
<h2 id="常用命令">2、常用命令</h2>
<ol type="1">
<li><code>git init .</code>： 初始化仓库</li>
<li><code>git clone &lt;url&gt;</code>： 克隆一个仓库</li>
<li><code>git st</code>(<code>git status</code>)：查看仓库状态</li>
<li><code>git add ...</code>：添加文件</li>
<li><code>git last</code>(<code>git log -1 HEAD</code>)：查看上一次的提交</li>
<li><code>git diff</code>：查看更改</li>
<li><code>git checkout -b &lt;分支名&gt;</code>：切换的<分支>，没有就新建</li>
<li><code>git checkout &lt;文件名&gt;</code>： 检出文件</li>
<li><code>git push origin &lt;分支名&gt;:&lt;远端分支名&gt;</code>：推送分支<远端分支名>如果相同则可以忽略，<code>git push origin &lt;分支名&gt;</code></li>
</ol>
<h2 id="分支">3、分支</h2>
<ol type="1">
<li><code>git branch</code> 查看所有分支</li>
<li><code>git checkout -b branchname</code> 创建并直接切换到分支</li>
<li><code>git branch branchname</code> 创建分支</li>
<li><code>git checkout branchname</code> 切换分支</li>
<li><code>git branch -d branchname</code> 删除分支</li>
<li><code>git stash</code> 保存工作区修改，不是存储区</li>
<li><code>git stash list</code> 查看所有保存在工作区的修改列表</li>
<li><code>git stash pop</code> 恢复工作区修改并删除stash内容</li>
<li><code>git stash appy</code> 恢复工作区修改但不删除stash内容</li>
<li><code>git stash drop</code> 删除<code>stash</code> 内容</li>
<li><code>git merge --no-ff -m "comment" branchname</code> 合并当前及branchname分支（推荐的merge方法，--no-ff提交模式可以在Git log后看到merge的节点，否则看不到）</li>
<li><code>git log --graph --pretty=oneline --abbrev-commit</code> 查看简化的提交日志</li>
<li><code>git remote</code> 查看远程库信息</li>
<li><code>git remote -v</code> 显示更详细的远程库信息</li>
<li><code>git push origin master</code> 推送本地master分支到远程仓库origin的master分支</li>
<li><code>git push origin dev</code> 推送本地dev分支到远程仓库origin的dev分支</li>
<li><code>git tag v1.0</code> 给发布版本创建标签</li>
<li><code>git tag</code> 查看所有标签</li>
<li><code>git tag commitId</code> 给谋而历史提交id打上标签</li>
<li><code>git show v1.0</code> 查看标签详细信息</li>
<li><code>git tag -d v1.0</code> 删除标签</li>
<li><code>git push origin v1.0</code> 推送标签到远程</li>
<li><code>git push origin --tags</code> 推送全部标签到远程</li>
<li><code>git push origin :refs/tags/tagname</code> 删除远程标签</li>
</ol>
<h3 id="创建与合并分支">1) 创建与合并分支</h3>
<p><code>git merge</code>如果有冲突，打开冲突的文件，手动改动冲突部分， 再重新<code>git add</code>, <code>git commit</code></p>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理。</p>
<ul>
<li><code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能再上面干活。</li>
<li>那在哪里干活呢？干活在<code>dev</code>分支上。</li>
<li>每个人都有自己的分支，时不时地往分支<code>dev</code>上合并就可以了。</li>
</ul>
<h3 id="bug分支">2) bug分支</h3>
<p>修复bug时，通过创建新的Bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复<code>bug</code>, 修复后，再<code>git stash pop</code> 回到工作现场</p>
<h3 id="feature分支">3) feature分支</h3>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D</code>强行删除。</p>
<h3 id="多人协作">4) 多人协作</h3>
<p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p>
<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li>master分支是主分支，因此要时刻与远程同步；</li>
<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<p>在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<h2 id="标签">4、标签</h2>
<p>发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>本文转载了<a href="https://blog.csdn.net/chenxiaodan_danny/article/details/51426204">这篇文档</a>，向作者表示感谢。</p>
]]></content>
      <categories>
        <category>折腾</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>utf-8</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法评价指标</title>
    <url>/2017/08/29/machinelearning_roc_pr/</url>
    <content><![CDATA[<p>　　为了衡量机器学习算法特别是分类算法的优劣，常用精确率(Precision)与召回率(Recall)，RoC曲线与PR曲线等指标，本文具体说明上述各项指标的基本含义。</p>
<span id="more"></span>
<h1 id="混淆矩阵">1、混淆矩阵</h1>
<p>　　考虑一个二分类问题，即将实例分成正类（positive）或负类（negative）。对一个二分类问题来说，会出现四种情况。如果一个实例是正类并且也被预测成正类，即为真正类（True positive）,如果实例是负类被预测成正类，称之为假正类（False positive）。相应地，如果实例是负类被预测成负类，称之为真负类（True negative）,正类被预测成负类则为假负类（false negative）。</p>
<h2 id="tp-fp-tn-fn">TP, FP, TN, FN</h2>
<ol type="1">
<li>True Positives,TP：预测为正样本，实际也为正样本的特征数</li>
<li>False Positives,FP：预测为正样本，实际为负样本的特征数</li>
<li>True Negatives,TN：预测为负样本，实际也为负样本的特征数</li>
<li>False Negatives,FN：预测为负样本，实际为正样本的特征数</li>
</ol>
<p>　　混淆矩阵如下表所示，1代表正类，0代表负类：</p>

<table style="margin-left: auto; margin-right: auto;" border="0">
<tbody>
<tr>
<td style="text-align: left;">&nbsp;</td>
<td style="text-align: center;"><span style="font-size: 16px; color: #ff0000;">预测“1”</span></td>
<td style="text-align: center;"><span style="font-size: 16px; color: #ff0000;">预测“0”</span></td>
</tr>
<tr>
<td style="text-align: center;"><span style="font-size: 16px; color: #008000; background-color: #ffffff;">实际“1”</span></td>
<td style="text-align: center;"><span style="font-size: 16px;">True Positive(TP)</span></td>
<td style="text-align: center;"><span style="font-size: 16px;">False Negative(FN)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span style="font-size: 16px; color: #008000; background-color: #ffffff;">实际“0”</span></td>
<td style="text-align: center;"><span style="font-size: 16px;">False Positive(FP)</span></td>
<td style="text-align: center;"><span style="font-size: 16px;">True Negative(TN)</span></td>
</tr>
</tbody>
</table>

<h1 id="精确率precision与召回率recall">2、精确率(precision)与召回率(Recall)</h1>
<p>　　<strong><font color="#FF0000">精确率(Precision)</font></strong>的定义在上图可以看出，是绿色半圆除以红色绿色组成的圆。<strong><font color="#FF0000">召回率(Recall)</font></strong>的定义也在图上能看出，是绿色半圆除以左边的长方形。<strong><font color="#FF0000">特异性(specificity，或<span class="math inline">\(FP_{rate}\)</span>)</font></strong>的定义图上没有直接写明，这里给出，是红色半圆除以右边的长方形。<strong><font color="#FF0000">F1值</font></strong>来综合评估精确率和召回率，它是精确率和召回率的调和均值。当精确率和召回率都高时,<span class="math inline">\(F_1\)</span>值也会高。严格的数学定义如下：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">名称</th>
<th>数学定义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>精确率（Precision）</strong></td>
<td>$ \displaystyle P = \frac {TP}{TP+FP} $</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>召回率(Recall)</strong></td>
<td>$ \displaystyle R=\frac{TP}{TP+FN} $</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>特异性(Specificity, <span class="math inline">\(FP_{rate}\)</span>)</strong></td>
<td>$ \displaystyle S=\frac{FP}{FP+TN} $</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong><span class="math inline">\(F_1\)</span>值</strong></td>
<td>$\displaystyle \frac {2} {F_{1}} = \frac {1}{P}+\frac {1}{R} \quad \Leftrightarrow \quad F_{1} = 2 \times \left ( \frac{P\cdot R}{P+R} \right ) $</td>
</tr>
</tbody>
</table>
<p>　　有时候我们对精确率和召回率并不是一视同仁，比如有时候我们更加重视精确率。我们用一个参数<span class="math inline">\(\beta\)</span>来度量两者之间的关系，含有参数<span class="math inline">\(\beta\)</span>的<span class="math inline">\(F_1\)</span>我们记为<span class="math inline">\(F_{\beta}\)</span>。如果<span class="math inline">\(\beta&gt;1\)</span>，召回率有更大影响，如果<span class="math inline">\(\beta&lt;1\)</span>，精确率有更大影响。当<span class="math inline">\(\beta=1\)</span>时，精确率和召回率影响力相同，<span class="math inline">\(F_{\beta}\)</span>退化为<span class="math inline">\(F_1\)</span>的形式。严格的数学定义如下：</p>
<p><span class="math display">\[ F_{\beta} = \frac{(1+\beta_{2})\cdot P \cdot R} {\beta_{2}\cdot P+R}  \]</span></p>
<h1 id="roc曲线">3、RoC曲线</h1>
<p>　　以召回率为<span class="math inline">\(y\)</span>轴，以特异性为<span class="math inline">\(x\)</span>轴，我们就直接得到了RoC曲线。召回率越高，特异性越小，RoC曲线越靠近左上角，模型和算法就越高效，如图2。另一方面，如果ROC是光滑的，那么基本可以判断没有太大的过拟合（overfitting）。从几何的角度讲，RoC曲线下方的面积越大越大，则模型越优。所以有时候我们用RoC曲线下的面积，即AUC（Area Under Curve）值来作为算法和模型好坏的标准。</p>
<img src="/2017/08/29/machinelearning_roc_pr/roc.png" class="" title="图2 RoC曲线">
<h1 id="pr曲线">4、PR曲线</h1>
<p>　　以精确率为<span class="math inline">\(y\)</span>轴，以召回率为<span class="math inline">\(x\)</span>轴，我们就得到了PR曲线。精确率越高，召回率越高，PR曲线越靠近右上角，模型和算法就越高效。和ROC一样，先看PR曲线的平滑度，再看谁上谁下（同一测试集上）。一般来说，上面的比下面的好。当P和R接近F1值就也越大，一般会画出连接(0,0)和(1,1)的线，线和PR曲线重合处的F1是这条线最大的F1（光滑的情况下），此时的F1对于PR曲线就好象AUC对于ROC曲线一样。数字比一条线更方便调模型。</p>
<img src="/2017/08/29/machinelearning_roc_pr/pr.png" class="" title="图3 PR曲线">
<h1 id="roc和pr曲线之间的关系和不同">5、ROC和PR曲线之间的关系和不同</h1>
<p>　　RoC曲线和PR曲线是非常常用的衡量模型分类能力两个指标，在模型评估中具有重要的作用。当正负样本的分布较为平衡时，ROC和PR的趋势差不多。但当样本分布不均时，两者就截然不同了，ROC效果依然看似很好，但是PR上反映效果一般。因此，对非平衡（倾斜）数据集，PR曲线或F1值将是更好的选择。</p>
<blockquote>
<p>解释：</p>
<p>　　设数据集负类占大多数（例如占99%），正类为极少数（例如占1%）。此时负类样本预测为负类的数值TN较大，负类样本预测为正类的数值FP较少。此时当FP的数量变化时，由于<span class="math inline">\(\displaystyle FP_{rate}=\frac{FP}{FP+TN}\)</span>，所以<span class="math inline">\(FP_{rate}\)</span>不会有很大变化。</p>
<p>　　但是<span class="math inline">\(\displaystyle PR=\frac{TP}{TP +FP}\)</span>，正类样本预测为正类的数值TP以及负类样本预测正类的数值FP均较小，因此，当FP稍有变化，PR曲线即可以捕获到这个差异，所以效果会更好。</p>
</blockquote>
<hr />
<p>参考文档：</p>
<ol type="1">
<li><a href="https://www.zhihu.com/question/30643044">精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/5993450.html">精确率与召回率，RoC曲线与PR曲线</a></li>
<li><a href="https://www.bbsmax.com/A/D854V4Z3zE/">ROC曲线和PR曲线</a></li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Precision</tag>
        <tag>Recall</tag>
        <tag>ROC</tag>
        <tag>PR</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：矩阵求导法则</title>
    <url>/2017/08/27/matrix_differential_rules/</url>
    <content><![CDATA[<p>矩阵运算中的求导 <span id="more"></span></p>
<p>原文地址：<a href="http://files.cnblogs.com/files/leoleo/matrix_rules.pdf">这里</a>，备份地址：<a href="/2017/08/27/matrix_differential_rules/matrix_rules.pdf">这里</a></p>
<img src="/2017/08/27/matrix_differential_rules/matrix_rules-1.png" class="">
<img src="/2017/08/27/matrix_differential_rules/matrix_rules-2.png" class="">
<img src="/2017/08/27/matrix_differential_rules/matrix_rules-3.png" class="">
<img src="/2017/08/27/matrix_differential_rules/matrix_rules-4.png" class="">
]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10下安装Google Tensorflow Object Detecting API</title>
    <url>/2017/12/05/object-detecting-api-installation/</url>
    <content><![CDATA[<p>随着Google发布的Object Detecting API再次更新，打算尝试下该物体检测API库。 <span id="more"></span></p>
<h1 id="下载">1、下载</h1>
<p>　　使用git首先到<a href="https://github.com/tensorflow/models">github</a> 把所有的models拖下来。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tensorflow/models</span><br></pre></td></tr></table></figure></p>
<h1 id="下载protoc下载地址">2、下载protoc(<a href="https://github.com/google/protobuf/releases">下载地址</a>)</h1>
<p>　　Windows平台，下载最下面的win32版本。</p>
<h1 id="编译各种proto文件">3、编译各种proto文件。</h1>
<p>　　按照官方文档：<code>protoc object_detection/protos/*.proto --python_out=.</code>，总是出错，提示 <code>object_detection/protos/*.proto: No such file or directory</code>，干脆写个批处理搞定。 <figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="built_in">path</span>=<span class="variable">%path%</span>;D:\Dev\protoc\bin</span><br><span class="line"><span class="keyword">for</span> /f <span class="variable">%%v</span> <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> object_detection\protos\*.proto /b&#x27;) <span class="keyword">do</span> (</span><br><span class="line">    protoc object_detection/protos/<span class="variable">%%v</span> --python_out=.</span><br><span class="line">)</span><br></pre></td></tr></table></figure> 　　 # 4、这一步比较坑，在<a href="https://www.ctolib.com/topics-125488.html">这里</a> 找到了解决方法。 　　在<code>site-packages</code>添加一个路径文件，如<code>tensorflow_model.pth</code>，必须以<code>pth</code>结尾，在文件里填上模块文件所在的目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:\gits\models\research</span><br><span class="line">E:\gits\models\research\slim</span><br></pre></td></tr></table></figure>
<h1 id="测试">5、测试</h1>
<p>　　按照文档说明，到这里就已经安装完成，可以运行测试了。然而，又有新情况出现： 　　执行<code>python object_detection/builders/model_builder_test.py</code>进行测试时，出现如下错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;object_detection/builders/model_builder_test.py&quot;</span>, line <span class="number">21</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> object_detection.builders <span class="keyword">import</span> model_builder</span><br><span class="line">  File <span class="string">&quot;E:\gits\models\research\object_detection\builders\model_builder.py&quot;</span>, line <span class="number">19</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> object_detection.builders <span class="keyword">import</span> box_predictor_builder</span><br><span class="line">  File <span class="string">&quot;E:\gits\models\research\object_detection\builders\box_predictor_builder.py&quot;</span>, line <span class="number">18</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> object_detection.core <span class="keyword">import</span> box_predictor</span><br><span class="line">  File <span class="string">&quot;E:\gits\models\research\object_detection\core\box_predictor.py&quot;</span>, line <span class="number">35</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    slim = tf.contrib.slim</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\python\util\lazy_loader.py&quot;</span>, line <span class="number">53</span>, <span class="keyword">in</span> __getattr__</span><br><span class="line">    module = self._load()</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\python\util\lazy_loader.py&quot;</span>, line <span class="number">42</span>, <span class="keyword">in</span> _load</span><br><span class="line">    module = importlib.import_module(self.__name__)</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\importlib\__init__.py&quot;</span>, line <span class="number">126</span>, <span class="keyword">in</span> import_module</span><br><span class="line">    <span class="keyword">return</span> _bootstrap._gcd_import(name[level:], package, level)</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\__init__.py&quot;</span>, line <span class="number">31</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> tensorflow.contrib <span class="keyword">import</span> distributions</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\distributions\__init__.py&quot;</span>, line <span class="number">33</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> tensorflow.contrib.distributions.python.ops.estimator <span class="keyword">import</span> *</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\distributions\python\ops\estimator.py&quot;</span>, line <span class="number">21</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> tensorflow.contrib.learn.python.learn.estimators.head <span class="keyword">import</span> _compute_weighted_loss</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\learn\__init__.py&quot;</span>, line <span class="number">92</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> tensorflow.contrib.learn.python.learn <span class="keyword">import</span> *</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\learn\python\__init__.py&quot;</span>, line <span class="number">23</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> tensorflow.contrib.learn.python.learn <span class="keyword">import</span> *</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\learn\python\learn\__init__.py&quot;</span>, line <span class="number">25</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> tensorflow.contrib.learn.python.learn <span class="keyword">import</span> estimators</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\learn\python\learn\estimators\__init__.py&quot;</span>, line <span class="number">297</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> tensorflow.contrib.learn.python.learn.estimators.dnn <span class="keyword">import</span> DNNClassifier</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\learn\python\learn\estimators\dnn.py&quot;</span>, line <span class="number">30</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> tensorflow.contrib.learn.python.learn.estimators <span class="keyword">import</span> dnn_linear_combined</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\learn\python\learn\estimators\dnn_linear_combined.py&quot;</span>, line <span class="number">31</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> tensorflow.contrib.learn.python.learn.estimators <span class="keyword">import</span> estimator</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\learn\python\learn\estimators\estimator.py&quot;</span>, line <span class="number">49</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> tensorflow.contrib.learn.python.learn.learn_io <span class="keyword">import</span> data_feeder</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\learn\python\learn\learn_io\__init__.py&quot;</span>, line <span class="number">21</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> tensorflow.contrib.learn.python.learn.learn_io.dask_io <span class="keyword">import</span> extract_dask_data</span><br><span class="line">  File <span class="string">&quot;D:\Dev\Anaconda3\lib\site-packages\tensorflow\contrib\learn\python\learn\learn_io\dask_io.py&quot;</span>, line <span class="number">27</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    allowed_classes = (dd.Series, dd.DataFrame)</span><br><span class="line">AttributeError: module <span class="string">&#x27;dask.dataframe&#x27;</span> has no attribute <span class="string">&#x27;Series&#x27;</span></span><br></pre></td></tr></table></figure>
<p>　　查了一下，安装的<code>dask</code>是<code>0.15.2</code>版本，Google一下，也没发现什么有价值的，不过搜到一篇文章说<code>pandas</code>由于版本变换，可能会出现API接口，于是使用<code>conda</code>升级了一下<code>dask</code>，升级完成后，上述例子可以运行了。然后手痒的把所有的包都升级下<code>conda update --all --copy -y</code>，诡异的事情发生了，因为包的依赖关系，<code>dask</code>降级为<code>0.15.2</code>，然而，跑测试居然还是没问题。到这里，啥原因也不清楚了。最后附上测试正确的结果：</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">...........</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">11</span> tests <span class="keyword">in</span> <span class="number">0</span>.<span class="number">151</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>至此，安装完成，跑个例子试试看.</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>usages</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tensorflow</tag>
        <tag>object deteching</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习中的过拟合与欠拟合</title>
    <url>/2018/01/28/overfitting-underfitting/</url>
    <content><![CDATA[<p>　　在机器学习算法中，经常会遇到两个问题：<strong>欠拟合（underfitting）</strong>和<strong>过拟合（overfitting）</strong>。所谓欠拟合就是算法没有学习到足够的特征，预测结果较差，即拟合程度不够；过拟合则刚好相反，算法除了学习到一般特征外，也学习到了样本个体的局部特征，即拟合过度。</p>
<p>造成这两种结果的原因主要有两个：</p>
<p>　　（1）模型选择不好，简单问题选择了复杂的模型，容易过拟合；复杂的问题选择了简单的模型容易欠拟合。<br/> 　　（2）参数设置和调整有问题。特别存在学习率的方法，学习率调整不当，容易引起这两种结果。</p>
<span id="more"></span>
<h1 id="白天鹅与黑天鹅问题">1、白天鹅与黑天鹅问题</h1>
<p>　　过拟合的一个形象的例子是白天鹅与黑天鹅例子。给一群天鹅让机器来学习天鹅的特征，经过训练后，算法学习到了以下特征：</p>
<p>　　（1）天鹅有翅膀，天鹅的嘴巴是长长的弯曲的，天鹅的脖子是长长的有点曲度，天鹅的整个体型像一个“2”且略大于鸭子。</p>
<p>　　这时，算法已经基本能区别天鹅和其他动物了。很不巧，训练样本中天鹅的羽毛全是白色的，这时：</p>
<p>　　（2）算法经过学习后，会认为天鹅的羽毛都是白的。当预测对象是黑色羽毛的黑天鹅时，算法会认为预测对象不是天鹅。</p>
<p>　　上面这个例子中，<strong>(1)</strong>中的规律都是对的，是所有天鹅都具备特征，也就是所谓的<strong>全局特征</strong>；<strong>(2)</strong>中的规律：天鹅的羽毛是白色的。这实际上只是样本的个体特征，并非所有天鹅的特征，也就是<strong>局部特征</strong>。如果算法只学习到了部分全局特征（即<strong>欠拟合</strong>），或者在学习到全局特征的同时，又学习到了局部特征（即<strong>过拟合</strong>），会导致无法识别黑天鹅的情况。</p>
<h1 id="过拟合与欠拟合的产生原因">2、过拟合与欠拟合的产生原因</h1>
<p>　　利用机器学习对训练集样本进行训练、学习样本数据的特征时，算法除学习到样本数据一般的、共性的特征外，也会学到仅训练样本特有的个体特征（视为噪声）。通常，前者称为全局特征，后者称为局部特征。</p>
<p>　　机器学习算法在学习过程中，无法区别局部特征和全局特征。在训练完成后，算法除学到全局特征外，也可能会学到一些训练样本的局部特征。由于新样本未含有训练样本所特有的局部特征，因此，算法学到的局部特征占比越高，对新样本预测正确的概率越低，即所谓的“泛化性”（或“鲁棒性”）变差，这是过拟合造成的最大问题。</p>
<p>　　过拟合是算法学习的太彻底，把训练样本的所有特征几乎都学到了。过多的局部特征（由于噪声带来的假特征），造成模型的“泛化性”和识别正确率较低。</p>
<p>　　一般，解决过拟合问题，从两方面入手：首先是训练样本，要具有代表性，局部特征尽量少。另一方面，算法在训练时，不能学习的太过彻底，降低学到局部特征和错误特征的几率，使得识别正确率得到优化。</p>
<h1 id="解决过拟合的方法">3、解决过拟合的方法</h1>
<p>　　解决过拟合的常见方法有：early stopping、数据集扩增（Data augmentation）、正则化（Regularization）、Dropout等。</p>
<h2 id="early-stopping">3.1 Early Stopping</h2>
<p>　　算法训练的过程，本质上是对算法参数进行迭代更新的过程，如梯度下降（Gradient descent）算法。Early stopping通过在算法对数据集训练收敛前停止迭代，来防止过拟合。具体方法是，在每一个Epoch结束时（1个Epoch是对所有训练数据遍历一轮）计算validation data的accuracy，当accuracy不再提高时，就停止训练。</p>
<p>　　Early Stopping方法很符合直观感受，因为accurary都不再提高了，继续训练也是无益的，只会拉长训练时间。该方法的一个重点是，怎样才认为accurary不再提高了呢？并不是说accuracy一降下来便认为不再提高了，因为可能经过这个Epoch后，accuracy降低了，但是随后的Epoch又让accuracy又上去了，所以不能根据一两次的连续降低就判断不再提高。一般的做法是，在训练的过程中，记录到目前为止最好的accuracy，当连续10次Epoch（或者更多次）没达到最佳accuracy时，则可以认为accuracy不再提高了。此时便可以停止迭代了（Early Stopping）。这种策略也称为“No-improvement-in-N”，N即Epoch的次数，可以根据实际情况取，如10、20、30……</p>
<h2 id="数据集扩增">3.2 数据集扩增</h2>
<p>　　数据集扩增即需要得到更多的符合要求的数据，即和已有的数据是独立同分布的，或者近似独立同分布的。一般有以下方法：</p>
<ol type="1">
<li>从数据源头采集更多数据</li>
<li>复制原有数据并加上随机噪声</li>
<li>重采样</li>
<li>根据当前数据集估计数据分布参数，使用该分布产生更多数据等</li>
</ol>
<h2 id="正则化">3.3 正则化</h2>
<p>　　正则化方法是指在进行目标函数或代价函数优化时，在目标函数或代价函数后面加上一个正则化项，一般有L1正则化与L2正则化等。</p>
<ul>
<li>L0正则化的值是模型参数中非零参数的个数。</li>
<li>L1正则化表示各个参数绝对值之和。</li>
<li>L2正则化标识各个参数的平方的和的开方值。</li>
</ul>
<p>　　正则化会导致参数稀疏，一个好处是可以简化模型，避免过拟合。因为一个模型中真正重要的参数可能并不多，如果模型中所有参数都起作用，那么会过于偏重训练数据本身特征（局部特征），从而导致模型的范化能力较差。另一个好处是参数变少可以使整个模型获得更好的可解释性。且参数越小，模型就会越简单，这是因为越复杂的模型，越是会尝试对所有的样本进行拟合，甚至包括一些异常样本点（噪声），很容易造成在较小的区间里预测值产生较大的波动，这种较大的波动也反映了在这个区间里的导数很大，而只有较大的参数值才能产生较大的导数。因此复杂的模型，其参数值会比较大。</p>
<p>　　L1正则化趋向于使模型中起作用的参数减少（权值为0），而L2正则化则趋向于使得模型中各个参数的权值较小，甚至趋于0(但不会为0)。权值越小则对应特征对模型的影响就较小。这相当于对这部分无关特征做了一个惩罚，即使它们的值波动比较大，受限于参数值很小，也不会对模型的输出结果造成太大影响，也就使得模型不会习得这部分特征而发生过拟合。</p>
<p>　　简单的总结：L1正则化会趋向于产生少量的特征，而其他的特征都是0，可用于特征选择；L2正则化会选择更多的特征，但这些特征的权值都会接近于0。</p>
<h3 id="l0正则化">3.3.1 L0正则化</h3>
<p>　　由于稀疏的参数可以防止过拟合，因此用L0范数（非零参数的个数）来做正则化项是可以防止过拟合的。</p>
<p>　　直观上看，利用非零参数的个数，可以很好的来选择特征，实现特征稀疏的效果，具体操作时选择参数非零的特征即可。但因为L0正则化很难求解，是个NP难问题，因此一般采用L1正则化。L1正则化是L0正则化的最优凸近似，比L0容易求解，并且也可以实现稀疏的效果。</p>
<h3 id="l1正则化">3.3.2 L1正则化</h3>
<p>　　L1正则化在实际中往往替代L0正则化，来防止过拟合，也称为Lasso。</p>
<p>　　L1正则化之所以可以防止过拟合，是因为L1范数就是各个参数的绝对值相加得到的，而参数值大小和模型复杂度是成正比的。因此复杂的模型，其L1范数就大，最终导致损失函数就大，说明这个模型就不够好。</p>
<p>　　通常，L1正则化在目标函数后面加上参数的L1范数和项，即参数绝对值和与参数的积项，即：</p>
<p><span class="math display">\[ 
\begin{equation}
C=C_0+\frac{\lambda}{n} \sum_w |w|
\end{equation}
\]</span> 　　其中<span class="math inline">\(C_0\)</span>代表原始的代价函数，<span class="math inline">\(n\)</span>是样本数，<span class="math inline">\(\lambda\)</span>是正则化项系数，衡量正则化项与<span class="math inline">\(C_0\)</span>项的比重。最后一项即为L1正则项。使用L1正则化后，计算梯度时，<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>的梯度变为：</p>
<p><span class="math display">\[
\begin{equation}
\frac{\partial C}{\partial w}=\frac{\partial C_0}{\partial w}+\frac{\lambda}{n} sgn(w) \label {weight-gradient} 
\end{equation}
\]</span></p>
<p><span class="math display">\[\begin {equation} \frac{\partial C}{\partial b} = \frac{\partial C_0}{\partial b} \label {bias-gradient} 
\end {equation}
\]</span></p>
<p>　　其中，<span class="math inline">\(sgn\)</span>是符号函数，即<span class="math inline">\(w\)</span>是正数时<span class="math inline">\(sng(w)\)</span>为<span class="math inline">\(+1\)</span>，而<span class="math inline">\(w\)</span>为负数时<span class="math inline">\(sng(w)\)</span>为<span class="math inline">\(-1\)</span>。注意式(<span class="math inline">\(\ref {bias-gradient}\)</span>)中，正则化项对bias项无贡献。参数更新使用下式：</p>
<p><span class="math display">\[\begin{equation}
w := w + \alpha \frac{\partial C_0}{\partial w} + \beta \frac{\lambda}{n} sgn(w)
\label{L1_weight_update} 
\end{equation}\]</span> <span class="math display">\[ \begin {equation} b: = b + \alpha \frac{\partial C_0}{\partial b} \label {L1-bias-update} \end {equation}\]</span></p>
<p>　　其中，梯度下降算法中，<span class="math inline">\(\alpha &lt; 0\)</span>，<span class="math inline">\(\beta &lt; 0\)</span>，而在梯度上升算法中则相反。</p>
<p>　　与式(<span class="math inline">\(\ref {L1_weight_update}\)</span>)做个比较，未经正则化的线性回归中，权值项<span class="math inline">\(w\)</span>的更新方程为：</p>
<p><span class="math display">\[\begin{equation}
w := w + \alpha \frac{\partial C_0}{\partial w} \label{normal_weight_update} 
\end{equation}\]</span></p>
<p>　　注意，未正则化的线性回归中，权值参数<span class="math inline">\(w\)</span>的更新(式(<span class="math inline">\(\ref {normal_weight_update}\)</span>))，没有式(<span class="math inline">\(\ref {L1_weight_update}\)</span>)等号右侧第二项（即正则化项）；包含了L1正则化项的线性回归称为<span class="math inline">\(Lasso\)</span>回归。常数项<span class="math inline">\(b\)</span>的更新方程同式<span class="math inline">\((\ref {L1-bias-update})\)</span>。</p>
<p>　　可以看出，当<span class="math inline">\(w\)</span>为正时，更新后<span class="math inline">\(w\)</span>会变小；当<span class="math inline">\(w\)</span>为负时，更新后<span class="math inline">\(w\)</span>会变大；因此L1正则化项令那些原先处于<span class="math inline">\(0\)</span>（即<span class="math inline">\(|w|≈0\)</span>）附近的参数<span class="math inline">\(w\)</span>往<span class="math inline">\(0\)</span>移动，使得部分参数为<span class="math inline">\(0\)</span>，从而降低模型的复杂度（模型的复杂度由参数决定），从而防止过拟合，提高模型的泛化能力。</p>
<p>　　L1正则化有个问题：L1范数在<span class="math inline">\(0\)</span>处不可导，即<span class="math inline">\(|w|\)</span>在<span class="math inline">\(0\)</span>处不可导，因此在<span class="math inline">\(w\)</span>为0时，使用原来的未经正则化的更新方程来对<span class="math inline">\(w\)</span>进行更新，即令<span class="math inline">\(sgn(0)=0\)</span>，即：</p>
<p><span class="math display">\[
\begin{equation}
sgn(w) = 
\left \{ 
    \begin{matrix}
        1 &amp; (w&gt;0)\\ 
        0 &amp; (w=0)\\ 
        -1 &amp; (w&lt;0) 
    \end{matrix} 
\right.
\end{equation}
\]</span></p>
<h3 id="l2正则化">3.3.2 L2正则化</h3>
<p>　　L2正则化就是在代价函数后面再加上一个基于L2范数的正则化项，即： <span class="math display">\[\begin{equation}C=C_0+\frac{\lambda}{2n}\sum_w w^2 \label{L2-regulation-1}\end{equation}\]</span> 　　式(<span class="math inline">\(\ref {L2-regulation-1}\)</span>)中，等号右侧第一项<span class="math inline">\(C_0\)</span>为原始的代价函数，第一项是L2正则化项，它是这样来的：所有参数<span class="math inline">\(w\)</span>的平方的和，除以训练集的样本大小<span class="math inline">\(n\)</span>。<span class="math inline">\(\lambda\)</span>是正则化项系数，衡量正则化项与<span class="math inline">\(C_0\)</span>项的比重。正则化项中的系数<span class="math inline">\(\frac {1}{2}\)</span>，主要是为了计算方便，正则化项求导时会产生一个<span class="math inline">\(2\)</span>，与<span class="math inline">\(\frac {1}{2}\)</span>相乘刚好凑整。</p>
<p>　　使用L2正则化后，梯度的计算与L1正则化类似，<span class="math inline">\(w\)</span>的梯度变为：</p>
<p><span class="math display">\[
\begin{equation}
\frac{\partial C}{\partial w}=\frac{\partial C_0}{\partial w}+\frac{\lambda}{n} w \label {weight-gradient-2} 
\end{equation}
\]</span></p>
<p>　　参数<span class="math inline">\(b\)</span>的梯度表达式与式(<span class="math inline">\(\ref {bias-gradient}\)</span>)相同，且正则化项对bias项同样无贡献。</p>
<p>　　L2正则化使用下式对权值参数<span class="math inline">\(w\)</span>进行更新： <span class="math display">\[
\begin{equation} 
w := w + \alpha \frac {\partial \theta}{\partial w} + \beta \frac{\lambda}{n}w \label{L2-weight-update} 
\end{equation}\]</span> 　　其中，梯度下降算法中，<span class="math inline">\(\alpha &lt; 0\)</span>，<span class="math inline">\(\beta &lt; 0\)</span>，而在梯度上升算法中则相反。</p>
<p>　　仍然以线性回归为例，将式(<span class="math inline">\(\ref {L2-weight-update}\)</span>)与式(<span class="math inline">\(\ref {normal_weight_update}\)</span>)做个比较，类似L1正则化，未正则化的线性回归不包含式(<span class="math inline">\(\ref {L2-weight-update}\)</span>)等号右侧第二项(L2正则化项)。包含L2正则化项的线性回归称为岭回归(<span class="math inline">\(Ridge \ Regression\)</span>)或权值衰减(<span class="math inline">\(weight \ decay\)</span>)。</p>
<p>　　与L1正则化类似，L2正则化项倾向于减小权值参数<span class="math inline">\(w\)</span>（但不为0）。</p>
<p>　　顺便提一下参数的更新，在对模型参数进行学习更新时，常用mini-batch（小批量更新）和 full-batch（全批量更新）两种方式。mini-batch在每轮学习（称为1个epoch或1次迭代，即把训练样本全部轮一遍）过程中，分批处理，使用部分样本进行参数更新，直到全部样本训练完成。这种方法的好处是数据量少，资源消耗少，速度快。每轮次的损失函数为所有mini batch的平均损失值。如果每次mini batch中样本个数为m，那么参数的更新方程中的正则化项需修正为：</p>
<p>　　L1正则化项：<span class="math inline">\(\displaystyle \frac{\lambda}{m}\sum_w |w|\)</span>， L2正则化项：<span class="math inline">\(\displaystyle \frac{\lambda}{2m}\sum_w w^2\)</span>。full-batch不用修正。</p>
<h3 id="正则化小结">3.3.4 正则化小结</h3>
<p>　　正则化可以降低模型的复杂度，避免模型过分拟合训练数据，包括噪声与异常点（outliers）。另一方面，正则化即是假设模型参数服从一定的先验概率，即为模型参数添加先验（不同的正则化方式为不同的先验分布）。这就规定了参数的分布，使得模型的复杂度降低（简言之，限定条件越多，模型的复杂度越低），这样模型对于噪声与异常点的抗干扰性的能力增强，从而提高模型的泛化能力。　</p>
<p>　 　　L1正则化与L2正则化的区别在于：L1正则化是拉普拉斯先验，而L2正则化是高斯先验。它们都是服从均值为0，协方差为<span class="math inline">\(\frac{1}{\lambda}\)</span>。当<span class="math inline">\(\lambda = 0\)</span>时（即没有先验，没有正则化项），相当于先验分布具有无穷大的协方差，则先验约束非常弱，模型为了拟合所有的训练集数据， 参数<span class="math inline">\(w\)</span>可以变得任意大从而使得模型不稳定，即方差大而偏差小。<span class="math inline">\(\lambda\)</span>越大，表明先验分布的协方差越小、偏差越大，模型越稳定。也就是说，正则化项是在偏差bias与方差variance之间做平衡的tradeoff。图1为L1与L2正则化的区别：</p>
<img src="/2018/01/28/overfitting-underfitting/l1l2regulation.jpg" class="" title="图1. L1与L2正则化的区别">
<p>　　图1中的模型是线性回归，有两个特征，要优化的参数分别是<span class="math inline">\(w_1\)</span>和<span class="math inline">\(w_2\)</span>，左图是L2正则化，右图是L1正则化。蓝色线是优化过程中遇到的等高线，一圈代表一个目标函数值，圆心是某一个样本观测值，半径为误差值。正则化相当于增加了受限条件（红色边界），二者相交处是最优参数。可见L1正则化的最优参数只可能在坐标轴上，从而出现0权重参数，使得模型稀疏。  </p>
<h2 id="dropout">3.4 Dropout</h2>
<p>  正则化是通过在代价函数后面加上正则化项来防止模型过拟合，Dropout方法是通过修改人工神经网络（ANN）中隐藏层的神经元个数来防止过拟合。该方法是在对网络进行训练时用一种技巧（trick），对于如下所示的三层人工神经网络：</p>
<img src="/2018/01/28/overfitting-underfitting/nn_without_dropout.png" class="" title="图2. 经典三层人工神经网络">
<p>　　对于图2的神经网络，在训练开始时，随机删除一些（可以设定为一半，也可以为1/3，1/4等）隐藏层神经元，即认为这些神经元不存在，同时保持输入层与输出层神经元的个数不变，这样便得到如下的ANN：</p>
<img src="/2018/01/28/overfitting-underfitting/nn_with_dropout.png" class="" title="图3. dropout之后的人工神经网络">
<p>　　然后按照BP学习算法对ANN中的参数进行学习更新（虚线连接的单元不更新，因为认为这些神经元被临时删除了）。这样一次迭代更新便完成了。下一次迭代中，同样随机删除一些神经元。后续训练过程循环进行这一操作，直至训练结束。</p>
<p>　　Dropout能够有助于防止过拟合的简单解释，运用了dropout的训练过程，相当于训练了很多个只有部分隐层单元的神经网络（简称“部分网络”）。每一个这样的部分网络，都可以给出一个分类结果，这些结果有的是正确的，有的是错误的。随着训练的进行，大部分半数网络都可以给出正确的分类结果，那么少数的错误分类结果就不会对最终结果造成大的影响。</p>
<hr />
<h1 id="参考文档">4、参考文档</h1>
<ol type="1">
<li><a href="http://blog.csdn.net/btbujhj/article/details/73468993">机器学习中防止过拟合的处理方法</a></li>
<li><a href="http://blog.csdn.net/u012162613/article/details/44261657">正则化方法：L1和L2 regularization、数据集扩增、dropout</a></li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>overfitting</tag>
        <tag>正则化</tag>
        <tag>Dropout</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow中遇到的问题及解决方法</title>
    <url>/2017/08/25/problems-with-solution-in-tensorflow/</url>
    <content><![CDATA[<p>本文为转载，记录一下在使用TensorFlow的过程中，遇到的较为困扰的问题及最终的解决方法。 <span id="more"></span></p>
<h1 id="q1.-如何查看tensorflow中tensor-variable-constant的值">Q1. 如何查看TensorFlow中Tensor, Variable, Constant的值？</h1>
<p>TensorFlow中的许多方法返回的都是一个Tensor对象。在Debug的过程中，我们发现只能看到Tensor对象的一些属性信息，无法查看Tensor具体的输出值；而对于Variable和Constant，我们很容易对其进行创建操作，但是如何得到它们的值呢？</p>
<p>假设<code>ts</code>是我们想要查看的对象(Variable / Constant / 0输入的Tensor)，运行 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts_res = sess.run(ts)</span><br><span class="line"><span class="built_in">print</span>(ts_res)</span><br></pre></td></tr></table></figure> 其中，<code>sess</code>为之前创建或默认的<code>session</code>. 运行后将得到一个<code>narray</code>格式的<code>ts_res</code>对象，通过<code>print</code>函数我们可以很方便的查看其中的内容。</p>
<p>但是，如果<code>ts</code>是一个有输入要求的Tensor，需要在查看其输出值前，填充(feed)输入数据。如下（假设ts只有一种输入）： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">input</span> = ××××××  <span class="comment"># the input data need to feed</span></span><br><span class="line">ts_res = sess.run(ts, feed_dict=<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(ts_res)</span><br></pre></td></tr></table></figure> 其他要求多种输入的<code>Tensor</code>类似处理即可。</p>
<h1 id="q2.-模型训练完成后如何获取模型的参数">Q2. 模型训练完成后，如何获取模型的参数？</h1>
<p>模型训练完成后，通常会将模型参数存储于<code>/checkpoint/×××.model</code>文件(当然文件路径和文件名都可以更改，许多基于TensorFlow的开源包习惯将模型参数存储为model或者model.ckpt文件)。那么，在模型训练完成后，如何得到这些模型参数呢？</p>
<p>需要以下两个步骤：</p>
<p><strong>Step 1: 通过tf.train.Saver()恢复模型参数</strong></p>
<p>运行 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">saver = tf.train.Saver()</span><br></pre></td></tr></table></figure> 通过<code>saver</code>的<code>restore()</code>方法可以从本地的模型文件中恢复模型参数。大致做法如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># your model&#x27;s params</span></span><br><span class="line"><span class="comment"># you don&#x27;t have to initialize them</span></span><br><span class="line"></span><br><span class="line">x = tf.placeholder(tf.float32)</span><br><span class="line">y = tf.placeholder(tf.float32)</span><br><span class="line">W = tf.Variable(...)</span><br><span class="line">b = tf.Variable(...)</span><br><span class="line"></span><br><span class="line">y_ = tf.add(b, tf.matmul(x, w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># create the saver</span></span><br><span class="line"></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="comment"># creat the session you used in the training processing</span></span><br><span class="line"><span class="comment"># launch the model</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  <span class="comment"># Restore variables from disk.</span></span><br><span class="line">  saver.restore(sess, <span class="string">&quot;/your/path/model.ckpt&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Model restored.&quot;</span>)</span><br><span class="line">  <span class="comment"># Do some work with the model, such as do a prediction</span></span><br><span class="line">  pred = sess.run(y_, feed_dict=&#123;batch_x&#125;)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure> 有关TensorFlow中变量的创建、存储及恢复操作，详细见<a href="http://tensorflow.org/how_tos/variables/index.md">API文档</a>.</p>
<p><strong>Step 2: 通过<code>tf.trainable\_variables()</code>得到训练参数</strong></p>
<p><code>tf.trainable\_variables()</code>方法将返回模型中所有可训练的参数，详细见<a href="https://www.tensorflow.org/versions/r0.7/api_docs/python/state_ops.html#trainable_variables">API文档</a>。类似于以下的变量参数不会被返回： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf_var = tf.Variable(<span class="number">0</span>, name=<span class="string">&quot;××××××&quot;</span>, trainable=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure> 还可以通过<code>Variable</code>的<code>name</code>属性过滤出需要查看的参数，如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var = [v <span class="keyword">for</span> v <span class="keyword">in</span> t_vars <span class="keyword">if</span> v.name == <span class="string">&quot;W&quot;</span>]</span><br></pre></td></tr></table></figure></p>
<p>本文来自：<a href="http://www.jeyzhang.com/problems-with-solution-in-tensorflow.html" title="TensorFlow中遇到的问题及解决方法">TensorFlow中遇到的问题及解决方法</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>神经网络</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
        <tag>深度学习</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pyinstaller将Python脚本打包为exe</title>
    <url>/2017/09/05/pyinstaller-usage-under-py35/</url>
    <content><![CDATA[<p>最近使用PyQt 5写了一个带界面的Python脚本，记录下几个过程。 <span id="more"></span></p>
<h1 id="pyqt5使用ui编辑器界面">1、PyQt5使用ui编辑器界面</h1>
<p>　　先使用Qt的<code>designer</code>编辑界面，设界面为<code>appForm.ui</code>，以下命令将<code>Form</code>转换为Python脚本： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyuic5 appForm.ui -o appForm.py</span><br></pre></td></tr></table></figure></p>
<h1 id="将py脚本打包成exe">2、将py脚本打包成exe</h1>
<p>　　<del>标准的<code>pip</code>安装:<code>pip install -U installer</code>，当前安装的版本为<code>3.2.1</code>，安装完成后会出现两个错误，以下分别解决。</del></p>
<p>　　直接使用<code>pip</code>安装出错，这里使用whl包离线安装，下载地址：<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs"><code>lfd</code></a>，当前版本为<code>3.4</code>(2019.2.26)。命令：</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">pip install PyInstaller-<span class="number">3</span>.<span class="number">4</span>-py2.py3-none-any.whl</span><br></pre></td></tr></table></figure>
<del>
<h2 id="错误syntaxerror-yield-inside-async-function">2.1 错误：<code>SyntaxError: 'yield' inside async function</code></h2>
<p>　　根据<a href="https://github.com/pyinstaller/pyinstaller/commit/48d5554ae74c2759d1fc099d4b2546288cad59fb">这里</a>修正，主要包含以下两个文件的修改： 　　1） 修改<code>PyInstaller/building/api.py</code>文件： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">     logger.info(<span class="string">&quot;Building PYZ (ZlibArchive) %s&quot;</span>, self.name)</span><br><span class="line">     <span class="comment"># Do not bundle PyInstaller bootstrap modules into PYZ archive.</span></span><br><span class="line">     toc = self.toc - self.dependencies</span><br><span class="line">-    <span class="keyword">for</span> entry <span class="keyword">in</span> toc:</span><br><span class="line">+    <span class="keyword">for</span> entry <span class="keyword">in</span> toc[:]:</span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> entry[<span class="number">0</span>] <span class="keyword">in</span> self.code_dict <span class="keyword">and</span> entry[<span class="number">2</span>] == <span class="string">&#x27;PYMODULE&#x27;</span>:</span><br><span class="line">             <span class="comment"># For some reason the code-object, modulegraph created</span></span><br><span class="line">             <span class="comment"># is not available. Recreate it</span></span><br><span class="line">-            self.code_dict[entry[<span class="number">0</span>]] = get_code_object(entry[<span class="number">0</span>], entry[<span class="number">1</span>])</span><br><span class="line">+            <span class="keyword">try</span>:</span><br><span class="line">+                self.code_dict[entry[<span class="number">0</span>]] = get_code_object(entry[<span class="number">0</span>], entry[<span class="number">1</span>])</span><br><span class="line">+            <span class="keyword">except</span> SyntaxError:</span><br><span class="line">+                <span class="comment"># Exclude the module in case this is code meant for a newer Python version.</span></span><br><span class="line">+                toc.remove(entry)</span><br><span class="line">     <span class="comment"># sort content alphabetically to support reproducible builds</span></span><br><span class="line">     toc.sort()</span><br></pre></td></tr></table></figure></p>
<p>　　2） 修改<code>PyInstaller/lib/modulegraph/modulegraph.py</code>文件 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">     m = self.createNode(cls, fqname)</span><br><span class="line">     m.filename = pathname</span><br><span class="line">     <span class="keyword">if</span> co <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">-        <span class="keyword">if</span> <span class="built_in">isinstance</span>(co, ast.AST):</span><br><span class="line">-            co_ast = co</span><br><span class="line">-            co = <span class="built_in">compile</span>(co_ast, pathname, <span class="string">&#x27;exec&#x27;</span>, <span class="number">0</span>, <span class="literal">True</span>)</span><br><span class="line">-        <span class="keyword">else</span>:</span><br><span class="line">-            co_ast = <span class="literal">None</span></span><br><span class="line">-        self._scan_code(m, co, co_ast)</span><br><span class="line">+        <span class="keyword">try</span>:</span><br><span class="line">+            <span class="keyword">if</span> <span class="built_in">isinstance</span>(co, ast.AST):</span><br><span class="line">+                co_ast = co</span><br><span class="line">+                co = <span class="built_in">compile</span>(co_ast, pathname, <span class="string">&#x27;exec&#x27;</span>, <span class="number">0</span>, <span class="literal">True</span>)</span><br><span class="line">+            <span class="keyword">else</span>:</span><br><span class="line">+                co_ast = <span class="literal">None</span></span><br><span class="line">+            self._scan_code(m, co, co_ast)</span><br><span class="line">    ...</span><br><span class="line">-        <span class="keyword">if</span> self.replace_paths:</span><br><span class="line">-            co = self._replace_paths_in_code(co)</span><br><span class="line">-        m.code = co</span><br><span class="line">+            <span class="keyword">if</span> self.replace_paths:</span><br><span class="line">+                co = self._replace_paths_in_code(co)</span><br><span class="line">+            m.code = co</span><br><span class="line">+        <span class="keyword">except</span> SyntaxError:</span><br><span class="line">+            self.msg(<span class="number">2</span>, <span class="string">&quot;load_module: SynaxError in &quot;</span>, pathname)</span><br><span class="line">+            cls = InvalidSourceModule</span><br><span class="line">+            m = self.createNode(cls, fqname)</span><br><span class="line"> </span><br><span class="line">     self.msgout(<span class="number">2</span>, <span class="string">&quot;load_module -&gt;&quot;</span>, m)</span><br><span class="line">     <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure></p>
<h2 id="替换plugins">2.2 替换plugins</h2>
　　由于本脚本仅使用了PyQt5，而打包时会打包PyQt4，造成程序无法运行。可以作如下修正。进入<code>$&#123;Python&#125;$/Lib/site-packages/PyInstaller/loader/rthooks</code>目录，将<code>pyi_rth_qt4plugins.py</code>备份后删除，复制一份<code>pyi_rth_qt5plugins.py</code>并重命名为<code>pyi_rth_qt4plugins.py</code>。
</del>
<p>　　安装完成直接使用。</p>
<h2 id="pyinstaller的使用">2.3 pyinstaller的使用</h2>
<p>　　详细的命令，可以使用<code>pyinstaller --help</code>获得，通常使用如下命令打包： <del><code>pyinstaller app.py appForm.py  --hidden-import=PyQt4 --hidden-import=Matplotlib --noconsole</code></del></p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">pyinstaller app.py appForm.py --noconsole</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　直接运行上述命令，会出现：<code>Cannot find existing PyQt5 plugin directories</code>错误，这时按照提示的位置创建路径(测试时提示路径为：<code>C:/qt/_h_env/Library/plugins</code>)，并将<code>pyqt5.dll</code>和<code>pyqt5qmlplugin.dll</code>文件复制到该路径即可。</p>
<p>　　再次执行上述命令，即可正常生成exe文件。此时exe文件因缺少<code>platforms</code>的<code>qwindows.dll</code>文件而无法正常运行，在exe同目录下新建一个<code>platforms</code>，将同目录下的<code>qwindows.dll</code>移至这个目录即可。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>usages</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyinstaller</tag>
        <tag>py打包exe</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之logging日志</title>
    <url>/2018/07/31/python_logging/</url>
    <content><![CDATA[<p>　　<code>Python</code>中的<code>logging</code>模块，功能强大，非常方便调试输出。<code>Django</code>也使用了Python自带的<code>logging</code>模块作为日志打印工具。本文简单介绍下<code>logging</code>模块的使用方法，以及如何在Django中使用。</p>
<span id="more"></span>
<h1 id="简介">1、简介</h1>
<p>　　<code>logging</code>模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。<code>logging</code>模块是<code>Python</code>的一个标准库模块，由标准库模块提供日志记录API的关键好处是所有<code>Python</code>模块都可以使用这个日志记录功能。</p>
<p>　　<code>logging</code>是线程安全的，主要功能由4部分组成：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">组件</th>
<th>　　　　　　　　　　　　功能 　　　　</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Logger</td>
<td>用户使用的直接接口，将日志传递给<code>Handler</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">Handler</td>
<td>控制日志输出到哪里，console，file… ，一个<code>logger</code>可以有多个<code>Handler</code>；</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Filter</td>
<td>控制哪些日志可以从<code>logger</code>流向<code>Handler</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">Formatter</td>
<td>控制日志的格式</td>
</tr>
</tbody>
</table>
<h1 id="最简单的使用方法">2、最简单的使用方法</h1>
<p>　　最简单的使用方法为“两步走”方式，1）导入模块，2）记录日志内容，多用于输出一个简单的日志内容。此时日志将按照默认格式输出。默认格式为：<code>"%(levelname)s:%(name)s:%(message)s"</code>。如果希望改变日志格式，可以调用<code>basicConfig</code>函数完成。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最简使用方法</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment">#改变默认日志格式</span></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;[%(threadName)-9s(%(lineno)d)] %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">logging.info(<span class="string">&#x27;log内容&#x27;</span>)</span><br></pre></td></tr></table></figure> 　　<code>basicConfig</code>函数中<code>level</code>参数控制日志输出级别（即<code>Filter</code>)。<code>logging</code>模块中定义的日志级别有5个，</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">日志级别（level）</th>
<th>　　　　　　　　　描述　　　　　　　　　　　　</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">logging.DEBUG</td>
<td>最详细的日志信息，典型应用场景是 问题诊断</td>
</tr>
<tr class="even">
<td style="text-align: center;">logging.INFO</td>
<td>信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作</td>
</tr>
<tr class="odd">
<td style="text-align: center;">logging.WARNING</td>
<td>当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的</td>
</tr>
<tr class="even">
<td style="text-align: center;">logging.ERROR</td>
<td>由于一个更严重的问题导致某些功能不能正常运行时记录的信息</td>
</tr>
<tr class="odd">
<td style="text-align: center;">logging.CRITICAL</td>
<td>当发生严重错误，导致应用程序不能继续运行时记录的信息</td>
</tr>
</tbody>
</table>
<p>　　<code>basicConfig</code>函数所有参数如下表所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数名称</th>
<th>　　　　　　　　　　　　　　　　描述</th>
<th style="text-align: center;">常用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">filename</td>
<td>指定日志输出目标文件的文件名，指定该设置项后日志就不会被输出到控制台了</td>
<td style="text-align: center;">　</td>
</tr>
<tr class="even">
<td style="text-align: center;">filemode</td>
<td>指定日志文件的打开模式，默认为追加模式(<code>'a'</code>)。该选项在<code>filename</code>指定时才有效</td>
<td style="text-align: center;">　</td>
</tr>
<tr class="odd">
<td style="text-align: center;">format</td>
<td>指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。</td>
<td style="text-align: center;"><i class="fa fa-check"></i></td>
</tr>
<tr class="even">
<td style="text-align: center;">datefmt</td>
<td>指定日期/时间格式。仅在<code>format</code>中包含时间字段<code>%(asctime)s</code>时才有效</td>
<td style="text-align: center;">　</td>
</tr>
<tr class="odd">
<td style="text-align: center;">level</td>
<td>指定日志器的日志级别</td>
<td style="text-align: center;"><i class="fa fa-check"></i></td>
</tr>
<tr class="even">
<td style="text-align: center;">stream</td>
<td>指定日志输出目标流，多指向控制台。</td>
<td style="text-align: center;">　</td>
</tr>
<tr class="odd">
<td style="text-align: center;">style</td>
<td>指定<code>format</code>格式字符串的风格，可取值为'%'、'{'和'$'，默认为'%'</td>
<td style="text-align: center;">　</td>
</tr>
<tr class="even">
<td style="text-align: center;">handlers</td>
<td>该选项应是包含多个<code>Handler</code>的可迭代对象，这些<code>Handler</code>将会被添加到<code>root logger</code>。</td>
<td style="text-align: center;">　</td>
</tr>
</tbody>
</table>
<p>注意：<strong><code>filename</code>、<code>stream</code>和<code>handlers</code>这三个参数仅能取其一，不能同时出现</strong>，否则会引发<code>ValueError</code>异常。</p>
<h1 id="标准使用方法">3、标准使用方法</h1>
<p>　　在<code>basicConfig</code>函数进行完整参数配置，已经接近标准<code>logging</code>模块的使用方法。<code>logging</code>模块的标准使用方法，包括自定义上述4个组件，控制日志的格式、级别及输出对象等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,logLevel=logging.DEBUG</span>):</span><br><span class="line">        log = self.__logFileName()</span><br><span class="line">        self.__logger=self.__setupLogger(log,logLevel=logLevel)</span><br><span class="line">        self.__logger.info(<span class="string">&quot;脚本 &#123;&#125; 开始运行,时间：&#123;&#125; &quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                           os.path.basename(__file__), self.__currentTime()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__logFileName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        在脚本目录下，创建一个同名的log文件</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 脚本所在路径</span></span><br><span class="line">        scriptPath = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">        <span class="comment"># 脚本名（去除扩展名）</span></span><br><span class="line">        scriptName = os.path.splitext(os.path.abspath(__file__))[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 日志文件</span></span><br><span class="line">        logFile = <span class="string">&quot;&#123;&#125;.log&quot;</span>.<span class="built_in">format</span>(scriptPath,scriptName)  </span><br><span class="line">        logFile = os.path.join(scriptPath, logFile)</span><br><span class="line">        <span class="keyword">return</span> logFile</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__currentTime</span>(<span class="params">self, used_in_filename=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="comment"># 默认为标准显示时间(used_in_filename为False)，否则用于文件名</span></span><br><span class="line">        timeFmt = <span class="string">&quot;%Y%m%d-%H%M%S&quot;</span> <span class="keyword">if</span> used_in_filename <span class="keyword">else</span> <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span></span><br><span class="line">        <span class="keyword">return</span> datetime.now().strftime(timeFmt)    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建日志</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setupLogger</span>(<span class="params">self,logFileName, logLevel=logging.DEBUG</span>):</span><br><span class="line">        <span class="comment"># 获取logger</span></span><br><span class="line">        logger = logging.getLogger(<span class="string">&quot;runLog&quot;</span>)</span><br><span class="line">        <span class="comment"># 设置logger级别</span></span><br><span class="line">        logger.setLevel(logLevel)</span><br><span class="line">        <span class="comment"># 设置Handlers，这里有两个Handler，一个为文件，一个为控制台</span></span><br><span class="line">        fh = logging.FileHandler(logFileName, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        ch = logging.StreamHandler()</span><br><span class="line">        <span class="comment"># 设置logger的输出格式</span></span><br><span class="line">        fmtStr = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> logLevel == logging.ERROR:</span><br><span class="line">            fmtStr = <span class="string">&quot;%(asctime)s (%(filename)s:%(lineno)d)[%(levelname)s]:%(message)s&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> logLevel == logging.CRITICAL:</span><br><span class="line">            fmtStr = <span class="string">&quot;%(asctime)s (%(filename)s:%(lineno)d)[%(levelname)s]:%(message)s&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> logLevel == logging.DEBUG:</span><br><span class="line">            fmtStr = <span class="string">&quot;%(asctime)s (%(filename)s:%(lineno)d)[%(levelname)s]:%(message)s&quot;</span></span><br><span class="line">    </span><br><span class="line">        logFmt = logging.Formatter(fmtStr, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将格式告诉Handler</span></span><br><span class="line">        fh.setFormatter(logFmt)</span><br><span class="line">        ch.setFormatter(logFmt)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向logger中添加Handlers</span></span><br><span class="line">        logger.addHandler(fh)</span><br><span class="line">        logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭日志</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__closeLogger</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> hdl <span class="keyword">in</span> self.__logger.handlers[:]:</span><br><span class="line">            hdl.close()</span><br><span class="line">            self.__logger.removeHandler(hdl)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end</span>(<span class="params">self</span>):</span><br><span class="line">        logger = self.__logger</span><br><span class="line">        logger.info(<span class="string">&quot;脚本 %s 运行完成,时间：%s &quot;</span> %</span><br><span class="line">                    (os.path.basename(__file__), self.__currentTime()))</span><br><span class="line">        self.__closeLogger()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    </span><br><span class="line">    task = Task() </span><br><span class="line">    <span class="comment"># do dask...</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment">#关闭log</span></span><br><span class="line">    task.end()</span><br></pre></td></tr></table></figure>
<p>logging模块中，Formatter可使用的预定义格式化字符串如下表：</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 19%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">字段/属性名称</th>
<th>使用格式</th>
<th>　　　　　　　　　　　　描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">asctime</td>
<td>%(asctime)s</td>
<td>日志事件发生的时间，如：2018-07-08 16:49:45,896</td>
</tr>
<tr class="even">
<td style="text-align: center;">created</td>
<td>%(created)f</td>
<td>日志事件发生的时间--时间戳，即调用time.time()函数返回的值</td>
</tr>
<tr class="odd">
<td style="text-align: center;">relativeCreated</td>
<td>%(relativeCreated)d</td>
<td>日志事件发生的时间相对于logging模块加载时间的相对毫秒数（一般不用）</td>
</tr>
<tr class="even">
<td style="text-align: center;">msecs</td>
<td>%(msecs)d</td>
<td>日志事件发生事件的毫秒部分</td>
</tr>
<tr class="odd">
<td style="text-align: center;">levelname</td>
<td>%(levelname)s</td>
<td>日志日志级别名称（'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'）</td>
</tr>
<tr class="even">
<td style="text-align: center;">levelno</td>
<td>%(levelno)s</td>
<td>数字形式的日志级别（10, 20, 30, 40, 50）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">name</td>
<td>%(name)s</td>
<td>日志器名称，默认是'root'，因为默认使用的是 rootLogger</td>
</tr>
<tr class="even">
<td style="text-align: center;">message</td>
<td>%(message)s</td>
<td>日志记录的文本内容，通过 msg % args计算得到的</td>
</tr>
<tr class="odd">
<td style="text-align: center;">pathname</td>
<td>%(pathname)s</td>
<td>调用日志记录函数的源码文件的全路径</td>
</tr>
<tr class="even">
<td style="text-align: center;">filename</td>
<td>%(filename)s</td>
<td>pathname的文件名部分，包含文件后缀</td>
</tr>
<tr class="odd">
<td style="text-align: center;">module</td>
<td>%(module)s</td>
<td>filename的名称部分，不包含后缀</td>
</tr>
<tr class="even">
<td style="text-align: center;">lineno</td>
<td>%(lineno)d</td>
<td>调用日志记录函数的源代码所在的行号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">funcName</td>
<td>%(funcName)s</td>
<td>调用日志记录函数的函数名</td>
</tr>
<tr class="even">
<td style="text-align: center;">process</td>
<td>%(process)d</td>
<td>进程ID</td>
</tr>
<tr class="odd">
<td style="text-align: center;">processName</td>
<td>%(processName)s</td>
<td>进程名称</td>
</tr>
<tr class="even">
<td style="text-align: center;">thread</td>
<td>%(thread)d</td>
<td>线程ID</td>
</tr>
<tr class="odd">
<td style="text-align: center;">threadName</td>
<td>%(thread)s</td>
<td>线程名称</td>
</tr>
</tbody>
</table>
<p>logging模块中，预定义的Handler下表：</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Handler</th>
<th style="text-align: left;">　　　　　　　　描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">logging.StreamHandler</td>
<td style="text-align: left;">将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。</td>
</tr>
<tr class="even">
<td style="text-align: center;">logging.FileHandler</td>
<td style="text-align: left;">将日志消息发送到磁盘文件，默认情况下文件大小会无限增长</td>
</tr>
<tr class="odd">
<td style="text-align: center;">logging.handlers.RotatingFileHandler</td>
<td style="text-align: left;">将日志消息发送到磁盘文件，并支持日志文件按大小切割</td>
</tr>
<tr class="even">
<td style="text-align: center;">logging.hanlders.TimedRotatingFileHandler</td>
<td style="text-align: left;">将日志消息发送到磁盘文件，并支持日志文件按时间切割</td>
</tr>
<tr class="odd">
<td style="text-align: center;">logging.handlers.HTTPHandler</td>
<td style="text-align: left;">将日志消息以GET或POST的方式发送给一个HTTP服务器</td>
</tr>
<tr class="even">
<td style="text-align: center;">logging.handlers.SMTPHandler</td>
<td style="text-align: left;">将日志消息发送给一个指定的email地址</td>
</tr>
<tr class="odd">
<td style="text-align: center;">logging.NullHandler</td>
<td style="text-align: left;">该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免'No handlers could be found for logger XXX'信息的出现。</td>
</tr>
</tbody>
</table>
<h1 id="django中日志模块的使用">4、Django中日志模块的使用</h1>
<h2 id="项目里setting.py里配置">1）项目里setting.py里配置</h2>
<p>Django通过在settings文件中使用LOGGING来定制日志输出(包括定义logger, handler, formatter等)</p>
<p>例如，settings文件中定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BASE_LOG_DIR = os.path.join(BASE_DIR, <span class="string">&quot;log&quot;</span>)</span><br><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,  <span class="comment"># 保留字</span></span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,  <span class="comment"># 禁用已经存在的logger实例</span></span><br><span class="line">    <span class="comment"># 日志文件的格式</span></span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># 详细的日志格式</span></span><br><span class="line">        <span class="string">&#x27;standard&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]&#x27;</span></span><br><span class="line">                      <span class="string">&#x27;[%(levelname)s][%(message)s]&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 简单的日志格式</span></span><br><span class="line">        <span class="string">&#x27;simple&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 定义一个特殊的日志格式</span></span><br><span class="line">        <span class="string">&#x27;collect&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(message)s&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># 过滤器</span></span><br><span class="line">    <span class="string">&#x27;filters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;require_debug_true&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;()&#x27;</span>: <span class="string">&#x27;django.utils.log.RequireDebugTrue&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># 处理器</span></span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># 在终端打印</span></span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filters&#x27;</span>: [<span class="string">&#x27;require_debug_true&#x27;</span>],  <span class="comment"># 只有在Django debug为True时才在屏幕打印日志</span></span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>,  <span class="comment">#</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;simple&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 默认的</span></span><br><span class="line">        <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,  <span class="comment"># 保存到文件，自动切</span></span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: os.path.join(BASE_LOG_DIR, <span class="string">&quot;xxx_info.log&quot;</span>),  <span class="comment"># 日志文件</span></span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">50</span>,  <span class="comment"># 日志大小 50M</span></span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">3</span>,  <span class="comment"># 最多备份几个</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;standard&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;encoding&#x27;</span>: <span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 专门用来记错误日志</span></span><br><span class="line">        <span class="string">&#x27;error&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;ERROR&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,  <span class="comment"># 保存到文件，自动切</span></span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: os.path.join(BASE_LOG_DIR, <span class="string">&quot;xxx_err.log&quot;</span>),  <span class="comment"># 日志文件</span></span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">50</span>,  <span class="comment"># 日志大小 50M</span></span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;standard&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;encoding&#x27;</span>: <span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 专门定义一个收集特定信息的日志</span></span><br><span class="line">        <span class="string">&#x27;collect&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,  <span class="comment"># 保存到文件，自动切</span></span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: os.path.join(BASE_LOG_DIR, <span class="string">&quot;xxx_collect.log&quot;</span>),</span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">50</span>,  <span class="comment"># 日志大小 50M</span></span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;collect&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;encoding&#x27;</span>: <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">       <span class="comment"># 默认的logger应用如下配置</span></span><br><span class="line">        <span class="string">&#x27;&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;default&#x27;</span>, <span class="string">&#x27;console&#x27;</span>, <span class="string">&#x27;error&#x27;</span>],  <span class="comment"># 上线之后可以把&#x27;console&#x27;移除</span></span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,  <span class="comment"># 向不向更高级别的logger传递</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 名为 &#x27;collect&#x27;的logger还单独处理</span></span><br><span class="line">        <span class="string">&#x27;collect&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>, <span class="string">&#x27;collect&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="views.py里使用">2）views.py里使用</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment"># 生成一个以当前文件名为名字的logger实例</span></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    logger.debug(<span class="string">&quot;调试日志信息....&quot;</span>)</span><br><span class="line">    logger.info(<span class="string">&quot;通知日志信息.....&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>logging</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程之生产者消费者</title>
    <url>/2018/07/20/python_multithread_producer_consumer/</url>
    <content><![CDATA[<h1 id="写在前面">1、写在前面</h1>
<p>经典的生产者和消费者模型中，<span class="math inline">\(N\)</span>个线程根据要求生产出第一步处理结果，<span class="math inline">\(M\)</span>个消费者线程对上述结果进行第二步处理。生产者与消费者之间有明确的前后顺序关系。</p>
<img src="/2018/07/20/python_multithread_producer_consumer/producer_consumer.png" class="" title="生产者消费者模型">
<span id="more"></span>
<p>关于生产者消费者问题，wikipedia是这么描述的：</p>
<blockquote>
<p>生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
</blockquote>
<p>解决方案，wikipedia也给出了一个解释:</p>
<blockquote>
<p>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用进程间通信的方法解决该问题，常用的方法有信号灯法等。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。</p>
</blockquote>
<h1 id="python中的生产者消费者模型">2、Python中的生产者消费者模型：</h1>
<p>利用Python中<code>Queue</code>对象，可以很方便的解决生产者消费者问题。例如在程序中，创建两个<code>Queue</code>对象，前者是输入任务存放对象(<code>task_queue</code>)，后者是该任务完成后的结果存放对象(<code>out_queue</code>)。生产者首先从<code>task_queue</code>中取出任务（<code>Queue.get()</code>）,进行处理后，将处理结果存入<code>out_queue</code>，然后调用<code>Queue.task_done()</code>函数，表明处理完成。关于<code>Queue.task_done()</code>函数。官方文档给出说明如下：</p>
<blockquote>
<p>Queue.task_done()</p>
<p>Indicate that a formerly enqueued task is complete. Used by queue consumer threads. For each get() used to fetch a task, a subsequent call to task_done() tells the queue that the processing on the task is complete.</p>
<p>If a join() is currently blocking, it will resume when all items have been processed (meaning that a task_done() call was received for every item that had been put() into the queue).</p>
<p>Raises a ValueError if called more times than there were items placed in the queue.</p>
</blockquote>
<p>翻译如下：</p>
<blockquote>
<p>Queue.task_done()</p>
<p>表明之前队列中的任务已经完成。由Queue的消费线程使用。 使用<code>get()</code>函数获取任务后，当调用<code>task_done()</code>函数时，表示当前所处理的任务已经完成。</p>
<p>如果使用<code>join()</code>阻塞当前执行，那么当所有的任务处理完成后，阻塞会解除。（意味着对每个放进(<code>put()</code>)队列的项目处理后，会接收到1个<code>task_done()</code>通知).</p>
<p>调用次数大于Queue中放入项目数量时，会发出<code>ValueError</code>异常</p>
</blockquote>
<p>简要理解：</p>
<ol type="1">
<li>每个<code>put()</code>进去的项目，使用<code>get()</code>获取，处理完成后，调用<code>task_done()</code>发送完成通知。</li>
<li>如果<code>put()</code>时，缓冲的<code>Queue</code>队列已满，则该线程阻塞，等待缓冲<code>Queue</code>有空间，缓冲队列有空间之后，<code>put()</code>立即执行。</li>
<li>如果使用<code>join()</code>阻塞了线程，那么所有任务完成后，接收到1个<code>task_done()</code>通知，阻塞解除，线程继续执行。</li>
<li>每个<code>get()</code>的项目对应一个<code>task_done()</code>，调用<code>task_done()</code>的次数大于<code>get()</code>时，会发出<code>ValueError</code>异常。</li>
</ol>
<p>最后需要说明一点的是，<code>Queue</code>对象的两个成员函数，<code>put()</code>、<code>get()</code>，在目标队列已满(<code>put()</code>)或为空时(<code>get()</code>)均会阻塞线程，一旦条件满足能够放入或取出数据时，线程解除阻塞，继续向下执行。</p>
<p>实际使用时，可以采用两种方案：</p>
<ol type="1">
<li>一个对象一个线程方式，每个对象管理自己的线程；</li>
<li>一个对象管理多个线程的方式，</li>
</ol>
<p>上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个对象一个线程方式</span></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,<span class="built_in">format</span>=<span class="string">&#x27;[%(threadName)-9s] %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,task_queue, out_queue,name=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()        </span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.name = name</span><br><span class="line">        self.__task_q = task_queue</span><br><span class="line">        self.__rets_q = out_queue</span><br><span class="line">        <span class="comment"># 去掉下面依据注释，可以发现，该函数为主线程执行</span></span><br><span class="line">        <span class="comment"># logging.debug(&quot;(Producer.__init__)任务大小：&#123;&#125;&quot;.format(task_queue.qsize()))</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            logging.info(<span class="string">&#x27;P: 任务队列大小  &#123;&#125;，缓冲队列大小 &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.__task_q.qsize(),self.__rets_q.qsize()))</span><br><span class="line">            item = self.__task_q.get()</span><br><span class="line">            result = self.job(item)</span><br><span class="line">            logging.info(<span class="string">&quot;P: 值= &#123;&#125; , 结果= &#123;&#125; &quot;</span>.<span class="built_in">format</span>(item,result))</span><br><span class="line">            self.__rets_q.put(result)            </span><br><span class="line">            logging.info(<span class="string">&quot;P: -------------压入缓冲队列 &#123;&#125;--------------&quot;</span>.<span class="built_in">format</span>(item))</span><br><span class="line">            self.__task_q.task_done()</span><br><span class="line">            time.sleep(random.randint(<span class="number">1</span>,<span class="number">5</span>)/<span class="number">40</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">job</span>(<span class="params">self,data</span>):        </span><br><span class="line">        logging.debug(<span class="string">&quot;P开始处理数据(in job)： &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">        <span class="comment">#time.sleep(random.randint(1,5)/40)</span></span><br><span class="line">        d = data*<span class="number">3</span>        </span><br><span class="line">        logging.debug(<span class="string">&quot;P数据处理完成(in job)：&#123;&#125;*3=&#123;&#125; &quot;</span>.<span class="built_in">format</span>(data,d))</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,task_queue,name=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()        </span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.name = name</span><br><span class="line">        self.__tasks_q = task_queue</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            logging.info(<span class="string">&#x27;C: 任务队列大小  &#123;&#125; &#x27;</span>.<span class="built_in">format</span>(self.__tasks_q.qsize()))</span><br><span class="line">            item = self.__tasks_q.get()</span><br><span class="line">            logging.info(<span class="string">&#x27;C:-------------取出任务数据 &#123;&#125;(&#123;&#125;)--------------&#x27;</span>.<span class="built_in">format</span>(item,item//<span class="number">3</span>))</span><br><span class="line">            result = self.job(item)</span><br><span class="line">            logging.info(<span class="string">&quot;C: 值= &#123;&#125; , 结果= &#123;&#125; &quot;</span>.<span class="built_in">format</span>(item,result))</span><br><span class="line">            self.__tasks_q.task_done()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">job</span>(<span class="params">self,data</span>):</span><br><span class="line">        logging.debug(<span class="string">&quot;C开始处理数据(in job)： &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">5</span>)/<span class="number">40</span>)</span><br><span class="line">        d = fib(data)</span><br><span class="line">        logging.debug(<span class="string">&quot;C数据处理完成(in job)： --------------(&#123;&#125;)fib(&#123;&#125;)=&#123;&#125;----------&quot;</span>.<span class="built_in">format</span>(data//<span class="number">3</span>,data,d))</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># N 生产者数量</span></span><br><span class="line">    <span class="comment"># M 消费者数量</span></span><br><span class="line">    N = <span class="number">3</span></span><br><span class="line">    M = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 任务队列</span></span><br><span class="line">    task_queue = Queue()</span><br><span class="line">    <span class="comment"># 处理后任务队列</span></span><br><span class="line">    ret_queue = Queue()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化任务队列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        task_queue.put(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建N个生产者（每个生产者1个线程）</span></span><br><span class="line">    producers = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        p = Producer(task_queue=task_queue, out_queue=ret_queue, name=<span class="string">&#x27; 生产者&#123;:02d&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line">        producers.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建M个消费者（每个消费者1个线程）</span></span><br><span class="line">    consumers = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        c = Consumer(task_queue=ret_queue, name=<span class="string">&#x27; 消费者&#123;:02d&#125;&#x27;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line">        consumers.append(c)</span><br><span class="line">        c.start()</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 阻塞线程，等待任务完成</span></span><br><span class="line">    task_queue.join()</span><br><span class="line">    ret_queue.join()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当任务完成后，主线程退出，子线程也随之退出</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    logging.debug(<span class="string">&quot;开始运行.......&quot;</span>)</span><br><span class="line">    main()</span><br><span class="line">    logging.debug(<span class="string">&#x27;运行完成.....&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例程2： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个对象多个线程方式</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,<span class="built_in">format</span>=<span class="string">&#x27;(%(threadName)-9s) %(message)s&#x27;</span>,)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, task_queue, out_queue, threadCount=<span class="number">3</span></span>):</span><br><span class="line">        self.__task_queue = task_queue</span><br><span class="line">        self.__out_queue = out_queue        </span><br><span class="line">        self.__thrdCount = threadCount</span><br><span class="line">        self.__threads = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(threadCount):</span><br><span class="line">            p = Thread(name=<span class="string">&quot;生产者&#123;:02d&#125;&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>),target=self.thread_worker)</span><br><span class="line">            p.setDaemon(<span class="literal">True</span>)            </span><br><span class="line">            self.__threads.append(p)</span><br><span class="line">            p.start()        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">thread_worker</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            logging.info(<span class="string">&#x27;P: 任务队列大小  &#123;&#125;，缓冲队列大小 &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.__task_queue.qsize(),self.__out_queue.qsize()))</span><br><span class="line">            <span class="comment">#if not self.__out_queue.full():</span></span><br><span class="line">            item = self.__task_queue.get()</span><br><span class="line">            result = self.job(item)</span><br><span class="line">            logging.info(<span class="string">&quot;P: 值= &#123;&#125; , 结果= &#123;&#125; &quot;</span>.<span class="built_in">format</span>(item,result))</span><br><span class="line">            self.__out_queue.put(result)            </span><br><span class="line">            logging.info(<span class="string">&quot;P: -------------压入缓冲队列 &#123;&#125;--------------&quot;</span>.<span class="built_in">format</span>(item))</span><br><span class="line">            self.__task_queue.task_done()</span><br><span class="line">            <span class="comment">#else:</span></span><br><span class="line">            <span class="comment">#    logging.info(&#x27;P: ---缓冲队列已满，等待中zzzZZZ...&#x27;)</span></span><br><span class="line">            time.sleep(random.randint(<span class="number">1</span>,<span class="number">5</span>)/<span class="number">40</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">job</span>(<span class="params">self,data</span>):</span><br><span class="line">        logging.debug(<span class="string">&quot;P开始处理数据(in job)： &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">        <span class="comment">#time.sleep(random.randint(1,5)/40)</span></span><br><span class="line">        d = data*<span class="number">3</span>        </span><br><span class="line">        logging.debug(<span class="string">&quot;P数据处理完成(in job)：&#123;&#125;*3=&#123;&#125; &quot;</span>.<span class="built_in">format</span>(data,d))</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">                </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, task_queue, threadCount=<span class="number">4</span></span>):</span><br><span class="line">        self.__task_queue= task_queue</span><br><span class="line">        self.__thrdCount = threadCount</span><br><span class="line">        self.__threads = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(threadCount):</span><br><span class="line">            c = Thread(name=<span class="string">&quot;消费者&#123;:02d&#125;&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>),target=self.thread_worker)</span><br><span class="line">            c.setDaemon(<span class="literal">True</span>)            </span><br><span class="line">            self.__threads.append(c)</span><br><span class="line">            c.start()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">thread_worker</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            logging.info(<span class="string">&#x27;C: 任务队列大小  &#123;&#125; &#x27;</span>.<span class="built_in">format</span>(self.__task_queue.qsize()))</span><br><span class="line">            item = self.__task_queue.get()</span><br><span class="line">            logging.info(<span class="string">&#x27;C:-------------取出任务数据 &#123;&#125;(&#123;&#125;)--------------&#x27;</span>.<span class="built_in">format</span>(item,item//<span class="number">3</span>))</span><br><span class="line">            result = self.job(item)</span><br><span class="line">            logging.info(<span class="string">&quot;C: 值= &#123;&#125; , 结果= &#123;&#125; &quot;</span>.<span class="built_in">format</span>(item,result))</span><br><span class="line">            self.__task_queue.task_done()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">job</span>(<span class="params">self,data</span>):</span><br><span class="line">        logging.debug(<span class="string">&quot;C开始处理数据(in job)： &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">5</span>)/<span class="number">40</span>)</span><br><span class="line">        d = fib(data)</span><br><span class="line">        logging.debug(<span class="string">&quot;C数据处理完成(in job)： --------------(&#123;&#125;)fib(&#123;&#125;)=&#123;&#125;----------&quot;</span>.<span class="built_in">format</span>(data//<span class="number">3</span>,data,d))</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.info(<span class="string">&quot;任务开始.........&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    BUFFER_SIZE=<span class="number">2</span></span><br><span class="line">    tasks_queue = Queue()</span><br><span class="line">    ret_queue = Queue(maxsize=BUFFER_SIZE)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        tasks_queue.put(i)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    p = Producer(task_queue=tasks_queue,out_queue=ret_queue,threadCount=<span class="number">3</span>)</span><br><span class="line">    c = Consumer(task_queue=ret_queue,threadCount=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    tasks_queue.join()</span><br><span class="line">    ret_queue.join()</span><br><span class="line">    </span><br><span class="line">    logging.info(<span class="string">&quot;任务完成！&quot;</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt文档翻译:Scribble例程</title>
    <url>/2015/04/22/qt-example-scribble/</url>
    <content><![CDATA[<img src="/2015/04/22/qt-example-scribble/scribble-example.png" class="" title="scribble例程">
<p>以前翻译的一篇Qt文档，从163博客上迁移过来。 <span id="more"></span></p>
<p>本例程中，我们重写鼠标事件处理程序来实现绘图，重写<code>Paint</code>事件处理程序来更新应用程序，并重写<code>resize</code>事件，以优化应用程序的外观。此外，重写了<code>close</code>事件处理程序，在程序关闭之前处理截获的<code>close</code>事件。</p>
<p>本例程还演示了如何使用<a href="http://doc.qt.io/qt-5/qpainter.html"><code>QPainter</code></a>的进行实时图像绘制和窗口组件(widget)的重绘制。</p>
<p>Scribble例程是一个绘图例程。文件菜单使用户可以打开并编辑现有的图像文件，保存图像和退出应用程序。在绘图时， 选项菜单可以使用户选择画笔颜色和画笔宽度，或清除屏幕。此外帮助菜单提供关于Scribble例程和Qt的信息。</p>
<p>本例程包括两个类： - <code>ScribbleArea</code>是一个显示<a href="http://doc.qt.io/qt-5/qimage.html"><code>QImage</code></a>并能让用户在该组件上绘图的自定义组件。 - <code>MainWindow</code>在<code>ScribbleArea</code>上方提供了一个菜单。</p>
<p>首先学习<code>ScribbleArea</code>类。然后是使用<code>ScribbleArea</code>的<code>MainWindow</code>类。</p>
<h1 id="scribblearea类的定义">ScribbleArea类的定义</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScribbleArea</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScribbleArea</span>(QWidget *parent = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">openImage</span><span class="params">(<span class="type">const</span> QString &amp;fileName)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">saveImage</span><span class="params">(<span class="type">const</span> QString &amp;fileName, <span class="type">const</span> <span class="type">char</span> *fileFormat)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPenColor</span><span class="params">(<span class="type">const</span> QColor &amp;newColor)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPenWidth</span><span class="params">(<span class="type">int</span> newWidth)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isModified</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> modified; &#125;</span><br><span class="line">    <span class="function">QColor <span class="title">penColor</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> myPenColor; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">penWidth</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> myPenWidth; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearImage</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resizeEvent</span><span class="params">(QResizeEvent *event)</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawLineTo</span><span class="params">(<span class="type">const</span> QPoint &amp;endPoint)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resizeImage</span><span class="params">(QImage *image, <span class="type">const</span> QSize &amp;newSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> modified;</span><br><span class="line">    <span class="type">bool</span> scribbling;</span><br><span class="line">    <span class="type">int</span> myPenWidth;</span><br><span class="line">    QColor myPenColor;</span><br><span class="line">    QImage image;</span><br><span class="line">    QPoint lastPoint;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ScribbleArea</code>类继承自<code>QWidget</code>。重写<code>mousePressEvent()</code>、<code>mouseMoveEvent()</code>和<code>mouseReleaseEvent()</code>函数来实现绘图。重写<code>paintEvent()</code>函数和<code>resizeEvent()</code>函数以更新绘图区，并保证绘图的<code>QImage</code>与<code>widget</code>组件在所有情况下同样大小。</p>
<p>公有函数： - <code>openImage()</code>从文件中导入图像到绘图区，使用户能够编辑图像; - <code>save()</code>函数保存当前显示的图像文件; - <code>clearImage()</code>槽函数将清除程序显示在绘图区中的图像。</p>
<p>私有函数<code>drawLineTo()</code>函数负责实际的图像绘制工作,<code>resizeImage()</code>函数处理<code>QImage</code>的大小的变化。 槽函数<code>print()</code>处理打印。</p>
<p>我们还需要以下私有变量： - <code>modified</code>：为<code>true</code>，绘图区的图像有未保存的更改。 - <code>scribbling</code>：为<code>true</code>，用户在绘图区内按下鼠标左键。 - <code>penWidth</code>和<code>penColor</code>：保存当前设置宽度和颜色的应用程序中使用的笔。 - <code>image</code>：存储由用户所绘制的图像。 - <code>lastPoint</code>：保存上一次鼠标按下或移动事件的光标位置。</p>
<h1 id="scribblearea-类的实现">ScribbleArea 类的实现</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ScribbleArea::<span class="built_in">ScribbleArea</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setAttribute</span>(Qt::WA_StaticContents);</span><br><span class="line">    modified = <span class="literal">false</span>;</span><br><span class="line">    scribbling = <span class="literal">false</span>;</span><br><span class="line">    myPenWidth = <span class="number">1</span>;</span><br><span class="line">    myPenColor = Qt::blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中，设置widget的Qt::WA_StaticContents属性，以表明widget的内容以左上角为起点，且在widget尺寸变化时保持不变。Qt使用该属性优化尺寸变化时的paint事件。这仅仅是一种优化，且只用于内容为静态并起始于左上角的widget。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ScribbleArea::openImage</span><span class="params">(<span class="type">const</span> QString &amp;fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QImage loadedImage;</span><br><span class="line">    <span class="keyword">if</span> (!loadedImage.<span class="built_in">load</span>(fileName))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    QSize newSize = loadedImage.<span class="built_in">size</span>().<span class="built_in">expandedTo</span>(<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">resizeImage</span>(&amp;loadedImage, newSize);</span><br><span class="line">    image = loadedImage;</span><br><span class="line">    modified = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>openImage()</code>函数，载入指定图像。然后使用私有<code>resizeImage()</code>函数，调整已加载图像的QImage在两个方向上和图片一样大，同时设置image成员变量为已加载图像。最后，调用<code>QWidget::update()</code>函数进行重绘。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ScribbleArea::saveImage</span><span class="params">(<span class="type">const</span> QString &amp;fileName, <span class="type">const</span> <span class="type">char</span> *fileFormat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QImage visibleImage = image;</span><br><span class="line">    <span class="built_in">resizeImage</span>(&amp;visibleImage, <span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (visibleImage.<span class="built_in">save</span>(fileName, fileFormat)) &#123;</span><br><span class="line">        modified = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>saveImage()</code>函数创建一个QImage对象，该对象仅覆盖实际image的可见部分 ，并使用<code>QImage::save()</code>函数保存。如果图像保存成功，因为没有未保存的数据，绘图区<code>modified</code>变量被设置为<code>false</code> 。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScribbleArea::setPenColor</span><span class="params">(<span class="type">const</span> QColor &amp;newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myPenColor = newColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScribbleArea::setPenWidth</span><span class="params">(<span class="type">int</span> newWidth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myPenWidth = newWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>setPenColor()</code>和<code>setPenWidth()</code>函数设置当前画笔的颜色和宽度。这些值会在后面的绘图操作中使用。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScribbleArea::clearImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    image.<span class="built_in">fill</span>(<span class="built_in">qRgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    modified = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 公有<code>clearImage()</code>槽函数清除在绘图区中显示的图像。该函数简单地用RGB值为<code>(255,255,255)</code>的白色填充整个图像。和以前一样，当图像修改时，设置<code>modified</code>为<code>true</code> 并重绘。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScribbleArea::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::LeftButton) &#123;</span><br><span class="line">        lastPoint = event-&gt;<span class="built_in">pos</span>();</span><br><span class="line">        scribbling = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScribbleArea::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton) &amp;&amp; scribbling)</span><br><span class="line">        <span class="built_in">drawLineTo</span>(event-&gt;<span class="built_in">pos</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScribbleArea::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::LeftButton &amp;&amp; scribbling) &#123;</span><br><span class="line">        <span class="built_in">drawLineTo</span>(event-&gt;<span class="built_in">pos</span>());</span><br><span class="line">        scribbling = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 对于鼠标按下和鼠标释放事件，<code>QMouseEvent::button()</code>函数可以判断是哪个按键触发的该事件。对于鼠标移动事件，我们使用<code>QMouseEvent::buttons()</code>函数来查找当前按住的按键（即“或”组合）。</p>
<p>如果用户按下鼠标左键，鼠标位置存储于<code>lastPoint</code>中。同时做一个标记：用户正在绘画。（这里必须有<code>scribbling</code>变量，因为我们不能确定鼠标移动和鼠标释放事件是否是在同一个widget上完成。）</p>
<p>如果用户用左键移动鼠标按下或释放按钮时，调用私有<code>drawLineTo()</code>函数进行绘制。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScribbleArea::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    QRect dirtyRect = event-&gt;<span class="built_in">rect</span>();</span><br><span class="line">    painter.<span class="built_in">drawImage</span>(dirtyRect, image, dirtyRect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在重写的<code>paintEvent()</code>函数中，我们简单地为绘图区域创建一个QPainter对象，并绘制图像。</p>
<p>在这一点，可能会有疑问，在<code>paintEvent()</code>函数中为什么不直接在widget上进行绘制，而是绘制在一个QImage对象上并复制该QImage对象到屏幕上。理由有三点：</p>
<ul>
<li>窗口系统要求widget组件能够随时进行重绘。例如，窗口最小化后恢复原状态时，窗口系统会清空widget上的内容，并发送一个paint事件。换句话说，不能依赖于窗口系统记住程序内绘制的图片内容。</li>
<li>一般情况下，Qt禁止在<code>paintEvent()</code>函数外进行绘制工作。特别需要注意，不能在鼠标事件处理函数中进行paint(绘制)工作。（虽然可以使用widget的<code>Qt::WA_PaintOnScreen</code>的属性改变上述行为。）</li>
<li>如果初始化正确，QImage对象可以保证每个颜色通道(红，绿，蓝，和α)使用8位的色深，而QWidget对象则可能只有较低的色深，这取决于显示器的配置。这意味着，如果载入一个24位或32位图像，并将其绘制到QWidget对象上 ，然后复制该QWidget到QImage时，图像会失去一些信息。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScribbleArea::resizeEvent</span><span class="params">(QResizeEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">width</span>() &gt; image.<span class="built_in">width</span>() || <span class="built_in">height</span>() &gt; image.<span class="built_in">height</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> newWidth = <span class="built_in">qMax</span>(<span class="built_in">width</span>() + <span class="number">128</span>, image.<span class="built_in">width</span>());</span><br><span class="line">        <span class="type">int</span> newHeight = <span class="built_in">qMax</span>(<span class="built_in">height</span>() + <span class="number">128</span>, image.<span class="built_in">height</span>());</span><br><span class="line">        <span class="built_in">resizeImage</span>(&amp;image, <span class="built_in">QSize</span>(newWidth, newHeight));</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    QWidget::<span class="built_in">resizeEvent</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当用户启动Scribble程序时，会产生一个<code>resize</code>事件，同时一个image对象会被创建并显示在绘图区。我们使这个初始图像大小比应用程序的主窗口和绘图区稍大些，这可以避免用户在调整主窗口大小时，图像大小的频繁调整（这会非常低效）。但当主窗口比该初始尺寸大时，图像必须重新调整大小。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScribbleArea::drawLineTo</span><span class="params">(<span class="type">const</span> QPoint &amp;endPoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;image)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(myPenColor, myPenWidth, Qt::SolidLine, Qt::RoundCap,</span><br><span class="line">                        Qt::RoundJoin));</span><br><span class="line">    painter.<span class="built_in">drawLine</span>(lastPoint, endPoint);</span><br><span class="line">    modified = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rad = (myPenWidth / <span class="number">2</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">update</span>(<span class="built_in">QRect</span>(lastPoint, endPoint).<span class="built_in">normalized</span>()</span><br><span class="line">                                     .<span class="built_in">adjusted</span>(-rad, -rad, +rad, +rad));</span><br><span class="line">    lastPoint = endPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在<code>drawLineTo()</code>函数中，绘制一条从上一次鼠标按下到鼠标移动事件发生时鼠标位置的直线，同时设置<code>modified</code>为<code>true</code>，并创建一个重绘事件，然后更新<code>lastPoint</code>，这样下一次调用<code>drawLineTo()</code>函数时，绘图将继续下去。</li>
</ul>
<p><code>update()</code>函数可以不带参数调用（注：不带参数执行会进行整个窗口的重绘，这会带来闪烁的问题），一个简单的优化方法是，传递一个绘图区内需要更新的QRect对象进行更新，这可以避免widget的完整重绘（防止闪烁）。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScribbleArea::resizeImage</span><span class="params">(QImage *image, <span class="type">const</span> QSize &amp;newSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (image-&gt;<span class="built_in">size</span>() == newSize)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QImage <span class="title">newImage</span><span class="params">(newSize, QImage::Format_RGB32)</span></span>;</span><br><span class="line">    newImage.<span class="built_in">fill</span>(<span class="built_in">qRgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;newImage)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawImage</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>, <span class="number">0</span>), *image);</span><br><span class="line">    *image = newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> QImage没有很好的调整图像大小API函数。利用<code>QImage::copy()</code>函数，可以完成这个功能，但在扩大图像大小时，空白区域会使用黑色背景进行填充，而这里希望使用的是白色背景。</p>
<p>所以，在这里创建一个尺寸合适的新QImage对象并使用白色背景进行填充，并使用QPainter将原来的图像绘制到这个新的QImage对象上。新图像使用<code>QImage::Format_RGB32</code>格式，即每个象素会被存储为<code>0xffRRGGBB</code>（其中RR，GG和BB是红色，绿色和蓝色通道，<code>ff</code>为十六进制值255）。</p>
<p>打印由<code>print()</code>槽函数处理： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScribbleArea::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(QT_NO_PRINTER) &amp;&amp; !defined(QT_NO_PRINTDIALOG)</span></span><br><span class="line">    <span class="function">QPrinter <span class="title">printer</span><span class="params">(QPrinter::HighResolution)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPrintDialog <span class="title">printDialog</span><span class="params">(&amp;printer, <span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure> 首先为要求输出的格式创建一个高解析度的QPrinter对象，使用QPrintDialog提示用户指定一个页面尺寸和输出格式。</p>
<p>如果对话框返回<code>accepted</code>，打印任务会在绘制设备上执行： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (printDialog.<span class="built_in">exec</span>() == QDialog::Accepted) &#123;</span><br><span class="line">        <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;printer)</span></span>;</span><br><span class="line">        QRect rect = painter.<span class="built_in">viewport</span>();</span><br><span class="line">        QSize size = image.<span class="built_in">size</span>();</span><br><span class="line">        size.<span class="built_in">scale</span>(rect.<span class="built_in">size</span>(), Qt::KeepAspectRatio);</span><br><span class="line">        painter.<span class="built_in">setViewport</span>(rect.<span class="built_in">x</span>(), rect.<span class="built_in">y</span>(), size.<span class="built_in">width</span>(), size.<span class="built_in">height</span>());</span><br><span class="line">        painter.<span class="built_in">setWindow</span>(image.<span class="built_in">rect</span>());</span><br><span class="line">        painter.<span class="built_in">drawImage</span>(<span class="number">0</span>, <span class="number">0</span>, image);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// QT_NO_PRINTER</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 用这种方式进行图像打印，简单来说，就是在QPrinter上进行绘图。在绘制到绘图设备前，需要将图像缩放到页面可提供的空间大小。</p>
<h1 id="mainwindow类的定义">MainWindow类的定义</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeEvent</span><span class="params">(QCloseEvent *event)</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">penColor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">penWidth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">about</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createActions</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createMenus</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">maybeSave</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">saveFile</span><span class="params">(<span class="type">const</span> QByteArray &amp;fileFormat)</span></span>;</span><br><span class="line"></span><br><span class="line">    ScribbleArea *scribbleArea;</span><br><span class="line"></span><br><span class="line">    QMenu *saveAsMenu;</span><br><span class="line">    QMenu *fileMenu;</span><br><span class="line">    QMenu *optionMenu;</span><br><span class="line">    QMenu *helpMenu;</span><br><span class="line"></span><br><span class="line">    QAction *openAct;</span><br><span class="line">    QList&lt;QAction *&gt; saveAsActs;</span><br><span class="line">    QAction *exitAct;</span><br><span class="line">    QAction *penColorAct;</span><br><span class="line">    QAction *penWidthAct;</span><br><span class="line">    QAction *printAct;</span><br><span class="line">    QAction *clearScreenAct;</span><br><span class="line">    QAction *aboutAct;</span><br><span class="line">    QAction *aboutQtAct;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>MainWindow</code>类继承自QMainWindow 。需要重写QWidget中的<code>closeEvent()</code>处理函数。<code>open() 、</code>save()<code>、</code>penColor()<code>和</code>penWidth()`槽函数对应于相应的菜单项。另外，创建了四个私有函数。</p>
<p>返回值为布尔型<code>maybeSave()</code>函数用于检测是否有未保存的更改。如果有，则提示用户保存更改。如果用户点击取消 ，则该函数数返回<code>false</code>。<code>saveFile()</code>函数让用户保存当前显示在绘图区中的图像。</p>
<h1 id="mainwindow类的实现">MainWindow类的实现</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    scribbleArea = <span class="keyword">new</span> ScribbleArea;</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(scribbleArea);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">createActions</span>();</span><br><span class="line">    <span class="built_in">createMenus</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Scribble&quot;</span>));</span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中，首先创建一个绘图区作为MainWindow的中央widget(central widget)。然后创建相关的动作(actions)和菜单。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::closeEvent</span><span class="params">(QCloseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">maybeSave</span>()) &#123;</span><br><span class="line">        event-&gt;<span class="built_in">accept</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event-&gt;<span class="built_in">ignore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当用户希望关闭程序时，一般通常单击文件|退出或单击X标题栏按钮进行，此时程序会向widget发送<code>close</code>事件。通过重写事件处理函数，可以拦截应用程序的关闭事件。</p>
<p>在这个例子中，<code>close</code>事件用于提示用户保存所有未保存的更改。主要逻辑在<code>maybeSave()</code>函数中实现。如果<code>maybeSave()</code>返回<code>true</code>，表明没有修改或用户已成功保存，则接受该事件。应用程序可以正常终止。如果<code>maybeSave()</code>返回<code>false</code>，用户点击了取消 ，则“忽略”该事件，程序仍然正常运行不受影响。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">maybeSave</span>()) &#123;</span><br><span class="line">        QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>,</span><br><span class="line">                                   <span class="built_in">tr</span>(<span class="string">&quot;Open File&quot;</span>), QDir::<span class="built_in">currentPath</span>());</span><br><span class="line">        <span class="keyword">if</span> (!fileName.<span class="built_in">isEmpty</span>())</span><br><span class="line">            scribbleArea-&gt;<span class="built_in">openImage</span>(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>open()</code>槽函数中，在新的图像载入到绘图区前，首先提示用户保存当前显示图片中所有未保存的修改。然后提示用户选择一个文件，进而架在该文件至ScribbleArea 。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::save</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QAction *action = <span class="built_in">qobject_cast</span>&lt;QAction *&gt;(<span class="built_in">sender</span>());</span><br><span class="line">    QByteArray fileFormat = action-&gt;<span class="built_in">data</span>().<span class="built_in">toByteArray</span>();</span><br><span class="line">    <span class="built_in">saveFile</span>(fileFormat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>save()</code>槽函数在用户选择另存为菜单项时被调用，然后在格式菜单中选择适当的格式。首先需要做的第一件事就是找出哪一个action使用<code>QObject::sender</code>发出的信号。该函数以QObject指针的形式返回发送者。既然发送者是一个动作的对象，因此可以安全的将该指针转换为QObject （因为QAction派生于QObject类）。可以使用C语言风格或C++风格的<code>static_cast&lt;&gt;()</code>进行强制类型转换，但作为一个安全编程技术，这里使用<code>qobject_cast()</code>进行该类型转换。用这个方法的优点是，如果该对象是错误的类型，会返回一个空指针。空指针造成的程序崩溃比不安全的类型转换造成的程序崩溃更加易于诊断。</p>
<p>一旦获得了发送的action，可通过的<code>QAction::data()</code>提取选定的格式。（当创建actions时，使用<code>QAction::setData()</code>以QVariant类型设置附加到该action上的自定义数据。更多内容，在<code>createActions()</code>函数中讨论</p>
<p>现在，已经获得了存储格式，那么可以调用私有的<code>saveFile()</code>函数保存当前显示的图像。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::penColor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QColor newColor = QColorDialog::<span class="built_in">getColor</span>(scribbleArea-&gt;<span class="built_in">penColor</span>());</span><br><span class="line">    <span class="keyword">if</span> (newColor.<span class="built_in">isValid</span>())</span><br><span class="line">        scribbleArea-&gt;<span class="built_in">setPenColor</span>(newColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>penColor()</code>槽函数返回用户通过QColorDialog选取的新颜色 。如果用户选择了新颜色，则将其作为绘图区的颜色。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::penWidth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    <span class="type">int</span> newWidth = QInputDialog::<span class="built_in">getInt</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Scribble&quot;</span>),</span><br><span class="line">                                        <span class="built_in">tr</span>(<span class="string">&quot;Select pen width:&quot;</span>),</span><br><span class="line">                                        scribbleArea-&gt;<span class="built_in">penWidth</span>(),</span><br><span class="line">                                        <span class="number">1</span>, <span class="number">50</span>, <span class="number">1</span>, &amp;ok);</span><br><span class="line">    <span class="keyword">if</span> (ok)</span><br><span class="line">        scribbleArea-&gt;<span class="built_in">setPenWidth</span>(newWidth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在<code>penWidth()</code>槽函数中使用QInputDialog返回画笔宽度。QInputDialog类提供了一种简单的对话框获得用户输入的单个值。这里使用包含QLabel和QSpinBox 的静态<code>QInputDialog::getInt()</code>函数。QSpinBox使用绘图区笔宽进行初始化，允许的范围内从1至50，步进值为1(即以1为向上和向下箭头递增或递减的值）。</p>
<p>如果用户点击OK，布尔型的ok变量被设为<code>true</code>，如果用户点击Cancel，则该变量被设为<code>false</code>， <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::about</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">about</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;About Scribble&quot;</span>),</span><br><span class="line">            <span class="built_in">tr</span>(<span class="string">&quot;&lt;p&gt;The &lt;b&gt;Scribble&lt;/b&gt; example shows how to use QMainWindow as the &quot;</span></span><br><span class="line">               <span class="string">&quot;base widget for an application, and how to reimplement some of &quot;</span></span><br><span class="line">               <span class="string">&quot;QWidget&#x27;s event handlers to receive the events generated for &quot;</span></span><br><span class="line">               <span class="string">&quot;the application&#x27;s widgets:&lt;/p&gt;&lt;p&gt; We reimplement the mouse event &quot;</span></span><br><span class="line">               <span class="string">&quot;handlers to facilitate drawing, the paint event handler to &quot;</span></span><br><span class="line">               <span class="string">&quot;update the application and the resize event handler to optimize &quot;</span></span><br><span class="line">               <span class="string">&quot;the application&#x27;s appearance. In addition we reimplement the &quot;</span></span><br><span class="line">               <span class="string">&quot;close event handler to intercept the close events before &quot;</span></span><br><span class="line">               <span class="string">&quot;terminating the application.&lt;/p&gt;&lt;p&gt; The example also demonstrates &quot;</span></span><br><span class="line">               <span class="string">&quot;how to use QPainter to draw an image in real time, as well as &quot;</span></span><br><span class="line">               <span class="string">&quot;to repaint widgets.&lt;/p&gt;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>about()</code>槽函数用于创建一个描述本例程设计的消息框。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createActions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    openAct = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Open...&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    openAct-&gt;<span class="built_in">setShortcuts</span>(QKeySequence::Open);</span><br><span class="line">    <span class="built_in">connect</span>(openAct, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">open</span>()));</span><br><span class="line"></span><br><span class="line">    foreach (QByteArray format, QImageWriter::<span class="built_in">supportedImageFormats</span>()) &#123;</span><br><span class="line">        QString text = <span class="built_in">tr</span>(<span class="string">&quot;%1...&quot;</span>).<span class="built_in">arg</span>(<span class="built_in">QString</span>(format).<span class="built_in">toUpper</span>());</span><br><span class="line"></span><br><span class="line">        QAction *action = <span class="keyword">new</span> <span class="built_in">QAction</span>(text, <span class="keyword">this</span>);</span><br><span class="line">        action-&gt;<span class="built_in">setData</span>(format);</span><br><span class="line">        <span class="built_in">connect</span>(action, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">save</span>()));</span><br><span class="line">        saveAsActs.<span class="built_in">append</span>(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printAct = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Print...&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(printAct, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), scribbleArea, <span class="built_in">SLOT</span>(<span class="built_in">print</span>()));</span><br><span class="line"></span><br><span class="line">    exitAct = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;E&amp;xit&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    exitAct-&gt;<span class="built_in">setShortcuts</span>(QKeySequence::Quit);</span><br><span class="line">    <span class="built_in">connect</span>(exitAct, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br><span class="line"></span><br><span class="line">    penColorAct = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Pen Color...&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(penColorAct, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">penColor</span>()));</span><br><span class="line"></span><br><span class="line">    penWidthAct = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;Pen &amp;Width...&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(penWidthAct, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">penWidth</span>()));</span><br><span class="line"></span><br><span class="line">    clearScreenAct = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Clear Screen&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    clearScreenAct-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">tr</span>(<span class="string">&quot;Ctrl+L&quot;</span>));</span><br><span class="line">    <span class="built_in">connect</span>(clearScreenAct, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()),</span><br><span class="line">            scribbleArea, <span class="built_in">SLOT</span>(<span class="built_in">clearImage</span>()));</span><br><span class="line"></span><br><span class="line">    aboutAct = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;About&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(aboutAct, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">about</span>()));</span><br><span class="line"></span><br><span class="line">    aboutQtAct = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;About &amp;Qt&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(aboutQtAct, <span class="built_in">SIGNAL</span>(<span class="built_in">triggered</span>()), qApp, <span class="built_in">SLOT</span>(<span class="built_in">aboutQt</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>createAction()</code>函数中，创建各个菜单项并把它们连接到相应的槽函数中。特别是创建另存为菜单子菜单中的action。<code>QImageWriter::supportedImageFormats()</code>函数来获取支持格式的列表（返回类型为<code>QList&lt;QByteArray&gt;</code>对象）。</p>
<p>然后遍历该列表，为每种格式创建一个action。进而调用<code>QAction::setData()</code>函数设置文件格式，以便在调用<code>QAction::data()</code>函数时返回文件格式。当然，也可以通过截去action文本中的“...”获得文件格式，只是有点笨。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::createMenus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    saveAsMenu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Save As&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    foreach (QAction *action, saveAsActs)</span><br><span class="line">        saveAsMenu-&gt;<span class="built_in">addAction</span>(action);</span><br><span class="line"></span><br><span class="line">    fileMenu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(openAct);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addMenu</span>(saveAsMenu);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(printAct);</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    fileMenu-&gt;<span class="built_in">addAction</span>(exitAct);</span><br><span class="line"></span><br><span class="line">    optionMenu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Options&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    optionMenu-&gt;<span class="built_in">addAction</span>(penColorAct);</span><br><span class="line">    optionMenu-&gt;<span class="built_in">addAction</span>(penWidthAct);</span><br><span class="line">    optionMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    optionMenu-&gt;<span class="built_in">addAction</span>(clearScreenAct);</span><br><span class="line"></span><br><span class="line">    helpMenu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Help&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line">    helpMenu-&gt;<span class="built_in">addAction</span>(aboutAct);</span><br><span class="line">    helpMenu-&gt;<span class="built_in">addAction</span>(aboutQtAct);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(fileMenu);</span><br><span class="line">    <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(optionMenu);</span><br><span class="line">    <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(helpMenu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在<code>createMenu()</code>函数中，<code>saveAs</code>添加了上面已创建的格式actions 。然后，向文件，选项和帮助菜单添加剩下的actions，以及<code>saveAs</code>菜单的子菜单</p>
<p>QMenu类在菜单栏、下文菜单和弹出菜单中提供一个菜单widget。QMenuBar类提供一个具有下拉列表的QMenu菜单的水平菜单栏。最后，将文件和选项菜单置于MainWindow的菜单栏，该菜单栏可通过<code>QMainWindow::menuBar()</code>函数获得。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::maybeSave</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scribbleArea-&gt;<span class="built_in">isModified</span>()) &#123;</span><br><span class="line">       QMessageBox::StandardButton ret;</span><br><span class="line">       ret = QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Scribble&quot;</span>),</span><br><span class="line">                          <span class="built_in">tr</span>(<span class="string">&quot;The image has been modified.\n&quot;</span></span><br><span class="line">                             <span class="string">&quot;Do you want to save your changes?&quot;</span>),</span><br><span class="line">                          QMessageBox::Save | QMessageBox::Discard</span><br><span class="line">                          | QMessageBox::Cancel);</span><br><span class="line">        <span class="keyword">if</span> (ret == QMessageBox::Save) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">saveFile</span>(<span class="string">&quot;png&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == QMessageBox::Cancel) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>mayBeSave()</code>函数检测是否有未保存的更改。如果有，使用QMessageBox警告用户，该图像已经修改，并提示用户进行保存。</p>
<p>类似QColorDialog和QFileDialog中 ，最简单的创建QMessageBox方法是使用它的静态函数。QMessageBox提供了沿着两个方向分派的一系列不同消息：严重性（问题，信息，警告和严重）和复杂性（必要响应按钮的数目）。这里使用<code>warning()</code>函数因为消息相对较为重要。</p>
<p>如果用户选择保存，调用私有<code>saveFile()</code>函数。简单起见，我们使用PNG作为文件格式;用户可以随时按取消 ，并使用其他格式保存文件。</p>
<p><code>maybeSave()</code>函数返回<code>false</code>，如果用户点击取消;否则返回<code>true</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::saveFile</span><span class="params">(<span class="type">const</span> QByteArray &amp;fileFormat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString initialPath = QDir::<span class="built_in">currentPath</span>() + <span class="string">&quot;/untitled.&quot;</span> + fileFormat;</span><br><span class="line"></span><br><span class="line">    QString fileName = QFileDialog::<span class="built_in">getSaveFileName</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Save As&quot;</span>),</span><br><span class="line">                               initialPath,</span><br><span class="line">                               <span class="built_in">tr</span>(<span class="string">&quot;%1 Files (*.%2);;All Files (*)&quot;</span>)</span><br><span class="line">                               .<span class="built_in">arg</span>(QString::<span class="built_in">fromLatin1</span>(fileFormat.<span class="built_in">toUpper</span>()))</span><br><span class="line">                               .<span class="built_in">arg</span>(QString::<span class="built_in">fromLatin1</span>(fileFormat)));</span><br><span class="line">    <span class="keyword">if</span> (fileName.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> scribbleArea-&gt;<span class="built_in">saveImage</span>(fileName, fileFormat.<span class="built_in">constData</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>saveFile()</code>函数弹出一个带有建议文件名的文件对话框。静态<code>QFileDialog::GetSaveFileName ()</code>函数返回由用户选择的文件名。该文件并非一定要存在。</p>
<p>文件列表：</p>
<p><a href="http://doc.qt.io/qt-5/qtwidgets-widgets-scribble-mainwindow-cpp.html">widgets/scribble/mainwindow.cpp</a> <a href="http://doc.qt.io/qt-5/qtwidgets-widgets-scribble-mainwindow-h.html">widgets/scribble/mainwindow.h</a> <a href="http://doc.qt.io/qt-5/qtwidgets-widgets-scribble-scribblearea-cpp.html">widgets/scribble/scribblearea.cpp</a> <a href="http://doc.qt.io/qt-5/qtwidgets-widgets-scribble-scribblearea-h.html">widgets/scribble/scribblearea.h</a> <a href="http://doc.qt.io/qt-5/qtwidgets-widgets-scribble-main-cpp.html">widgets/scribble/main.cpp</a> <a href="http://doc.qt.io/qt-5/qtwidgets-widgets-scribble-scribble-pro.html">widgets/scribble/scribble.pro</a></p>
<p>本文来自：<a href="http://ferret.blog.163.com/blog/static/6442378020153225204031" title="[Qt文档翻译]Scribble例程">[Qt文档翻译]Scribble例程</a></p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04下1.5版TensorFlow-gpu升级记录</title>
    <url>/2018/02/04/tensorflow_upgrade_with_cuda9_cudnn7/</url>
    <content><![CDATA[<p>使用pip升级TensorFlow时，发现TF已经升级至1.5版本。以下记录更新步骤 系统信息： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ubuntu 16.04 LTS x86_64</span><br><span class="line">Python 3.5.4 :: Anaconda custom (64-bit)</span><br></pre></td></tr></table></figure> <span id="more"></span> # 1、更新TensorFlow 如果直接使用<code>pip install -U</code>升级，会出现futures的错误： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Collecting futures&gt;=3.1.1 (from tensorflow-tensorboard&lt;1.6.0,&gt;=1.5.0-&gt;tensorflow)</span><br><span class="line">  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/1f/9e/7b2ff7e965fc654592269f2906ade1c7d705f1bf25b7d469fa153f7d19eb/futures-3.2.0.tar.gz</span><br><span class="line">Unknown requires Python <span class="string">&#x27;&gt;=2.6, &lt;3&#x27;</span> but the running Python is 3.5.4</span><br></pre></td></tr></table></figure> 解决办法先安装futures的3.1.1版本，然后安装TensorFlow 1.5。注意不能使用'-U'参数更新： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install futures==3.1.1</span><br><span class="line">pip install tensorflow-gpu==1.5.0</span><br></pre></td></tr></table></figure> 安装完成执行以下测试语句，报错说找不到<code>libcublas.so.9.0</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="built_in">print</span>(tf.__version__)</span><br></pre></td></tr></table></figure> 错误： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ImportError: libcublas.so.9.0: cannot open shared object file: </span><br><span class="line">             No such file or directory</span><br></pre></td></tr></table></figure></p>
<h1 id="更新cuda-9和cudnn-7">2、更新<code>cuda 9</code>和<code>cudnn 7</code></h1>
<h2 id="下载以下两个文件至本地">(1) 下载以下两个文件至本地：</h2>
<p><a href="http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-repo-ubuntu1604_9.0.176-1_amd64.deb">cuda-repo-ubuntu1604_9.0.176-1_amd64.deb</a> <a href="http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pub">7fa2af80.pub</a></p>
<h2 id="执行以下两个命令">(2) 执行以下两个命令：</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i cuda-repo-ubuntu1604_9.0.176-1_amd64.deb</span><br><span class="line">sudo apt-key add ./7fa2af80.pub</span><br></pre></td></tr></table></figure>
<p>nvidia文档说明如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i cuda-repo-&lt;distro&gt;_&lt;version&gt;_&lt;architecture&gt;.deb</span><br><span class="line">sudo apt-key add /var/cuda-repo-&lt;version&gt;/7fa2af80.pub</span><br></pre></td></tr></table></figure></p>
<h2 id="给apt-get设置代理">(3) 给apt-get设置代理：</h2>
<p>网址<code>http://developer.download.nvidia.com/</code>无法通过ipv6访问，设置代理： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/apt/apt.conf</span><br></pre></td></tr></table></figure> 添加代理服务器配置后保存： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquire::http::Proxy &quot;http://127.0.0.1:8122&quot;;</span><br><span class="line">Acquire::https::Proxy &quot;http://127.0.0.1:8122&quot;;</span><br></pre></td></tr></table></figure></p>
<h2 id="执行更新动作">(4) 执行更新动作</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<h2 id="列出需要更新的软件版本">(5) 列出需要更新的软件版本</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-cache policy cuda</span><br></pre></td></tr></table></figure>
<p>命令格式： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-cache policy &lt;package name&gt;</span><br></pre></td></tr></table></figure> 输出： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cuda:</span><br><span class="line">  已安装：8.0.61-1</span><br><span class="line">  候选： 9.1.85-1</span><br><span class="line">  版本列表：</span><br><span class="line">     9.1.85-1 500</span><br><span class="line">        500 http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64  Packages</span><br><span class="line">     9.0.176-1 500</span><br><span class="line">        500 http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64  Packages</span><br><span class="line">        100 /var/lib/dpkg/status</span><br><span class="line"> *** 8.0.61-1 500</span><br><span class="line">        500 http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64  Packages</span><br><span class="line">     8.0.44-1 500</span><br><span class="line">        500 http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64  Packages</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="选取指定的版本">(6) 选取指定的版本</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update cuda=9.0.176-1</span><br></pre></td></tr></table></figure>
<h2 id="创建软链接并验证安装">(7) 创建软链接并验证安装</h2>
<p>创建软链接： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/</span><br><span class="line">sudo <span class="built_in">ln</span> -s cuda-9.0 cuda</span><br></pre></td></tr></table></figure> 安装完成之后，使用以下命令验证安装情况，注意，需要设定环境变量(可在<code>~/.bashrc</code>中添加)： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/local/cuda/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="string">&quot;<span class="variable">$LD_LIBRARY_PATH</span>:/usr/local/cuda/lib64:/usr/local/cuda/extras/CUPTI/lib64&quot;</span></span><br><span class="line"><span class="built_in">export</span> CUDA_HOME=/usr/local/cuda</span><br><span class="line"></span><br></pre></td></tr></table></figure> 显示驱动基本情况，执行<code>nvidia-smi</code>，输出： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Sun Feb  4 11:36:36 2018</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 390.12                 Driver Version: 390.12                    |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  GeForce GTX 108...  Off  | 00000000:03:00.0 Off |                  N/A |</span><br><span class="line">|  0%   19C    P5    26W / 250W |      0MiB / 11176MiB |      2%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID   Type   Process name                             Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure> 执行<code>nvcc -V</code>，输出： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2017 NVIDIA Corporation</span><br><span class="line">Built on Fri_Sep__1_21:08:03_CDT_2017</span><br><span class="line">Cuda compilation tools, release 9.0, V9.0.176</span><br></pre></td></tr></table></figure> ## (8) 安装cudnn 然后进入选定目录，执行以下命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c http://developer.download.nvidia.com/compute/machine-learning/cudnn/secure/v7.0.5/prod/9.0_20171129/cudnn-9.0-linux-x64-v7.tgz</span><br><span class="line">tar -zxvf cudnn-9.0-linux-x64-v7.tgz</span><br><span class="line">sudo <span class="built_in">cp</span> cuda/include/cudnn.h /usr/local/cuda/include/</span><br><span class="line">sudo <span class="built_in">cp</span> cuda/lib64/libcudnn* /usr/local/cuda/lib64/ -d</span><br><span class="line">sudo <span class="built_in">chmod</span> a+r /usr/local/cuda/include/cudnn.h</span><br><span class="line">sudo <span class="built_in">chmod</span> a+r /usr/local/cuda/lib64/libcudnn*</span><br></pre></td></tr></table></figure></p>
<h2 id="更新完成后恢复原有的配置">(9) 更新完成后，恢复原有的配置</h2>
<p>去除<code>apt-get</code>代理: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> /etc/apt/apt.conf /etc/apt/apt.conf.with_proxy</span><br></pre></td></tr></table></figure> 去除<code>nvidia</code>更新源，将<code>cuda.list</code>的内容注释掉： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/apt/sources.list.d/cuda.list</span><br></pre></td></tr></table></figure></p>
<h2 id="如果以后需要更新则将第9步的内容恢复即可">(10) 如果以后需要更新，则将第(9)步的内容恢复即可。</h2>
<p>参考文档</p>
<p>[1] <a href="https://github.com/tensorflow/tensorflow/issues/16478">Failed install on Windows</a><br/> [2] <a href="http://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#ubuntu-installation">nvidia文档</a><br/> [3] <a href="https://askubuntu.com/questions/257290/configure-proxy-for-apt">Configure proxy for APT?</a><br/> [4] <a href="https://askubuntu.com/questions/428772/how-to-install-specific-version-of-some-package/428778">How to install specific version of some package</a><br/> [5] <a href="http://www.52nlp.cn/tag/cudnn-7-0">深度学习服务器环境配置</a></p>
]]></content>
      <categories>
        <category>折腾</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>tensorflow</tag>
        <tag>cuda</tag>
        <tag>cudnn</tag>
      </tags>
  </entry>
  <entry>
    <title>TexLive的配置和使用</title>
    <url>/2018/07/08/texlive_config/</url>
    <content><![CDATA[<p>以前使用miktex编译Letex，很久没更新，没法自动安装缺失的包。Google之后，考虑使用TexLive，并使用清华大学镜像。以下内容简要说明其步骤。</p>
<span id="more"></span>
<h2 id="安装texlive">1、安装TexLive</h2>
<h3 id="下载与安装">1） 下载与安装</h3>
<p>网上很多都是直接下载安装包进行安装，一般要超过4G大小的一个镜像。个人对这种方法无爱，以下安装使用的是在线安装模式。 首先下载<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/install-tl.zip" title="TexLive 在线安装包">install-tl.zip</a>。 解压之后，进入<code>install-tl-日期</code>目录，编辑<code>install-tl-advanced.bat</code>文件，添加清华的镜像源： <figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">-repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet</span><br></pre></td></tr></table></figure> 完整的命令行如下： <figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> &quot;%~dp0install-tl-windows.bat&quot; -repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet -gui perltk %*</span><br></pre></td></tr></table></figure></p>
<p>双击修改后的<code>install-tl-advanced.bat</code>文件，进入<code>GUI</code>安装模式，根据自己的情况配置。这里安装路径设置为<code>D:\Dev\TexLive</code>，安装模式为<code>portable</code>。</p>
<img src="/2018/07/08/texlive_config/img01.png" class="" title="图1.GUI安装界面">
<p>为了省事，可以选择全部安装，也可以选择自定义安装包。下图给出自定义的安装包：</p>
<img src="/2018/07/08/texlive_config/img02.png" class="" title="图2.自定义安装包">
<p>配置完成之后，点击<code>安装TexLive</code>，可以开始喝茶慢慢等。安装完成之后，在环境变量<code>PATH</code>中添加<code>TexLive</code>的路径：<code>D:\Dev\TexLive\win32\bin</code>。至此<code>TexLive</code>已经基本可以使用了。</p>
<h3 id="安装texliveonfly">2） 安装<code>TexLiveonfly</code></h3>
<p>进入命令行模式，使用<code>tlmgr</code>进行包的管理。</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">$ tlmgr search texliveonfly</span><br><span class="line">texliveonfly - On-the-fly download of missing TeX live packages</span><br><span class="line"></span><br><span class="line">$ tlmgr install texliveonfly</span><br><span class="line"><span class="function">tlmgr.pl: <span class="title">package</span> <span class="title">repository</span> <span class="title">https</span>://<span class="title">mirrors.tuna.tsinghua.edu.cn</span>/<span class="title">CTAN</span>/<span class="title">systems</span>/<span class="title">texlive</span>/<span class="title">tlnet</span> (<span class="title">not</span> <span class="title">verified</span>: <span class="title">gpg</span> <span class="title">unavailable</span>)</span></span><br><span class="line"><span class="function"><span class="title">tlmgr.pl</span> <span class="title">install</span>: <span class="title">package</span> <span class="title">already</span> <span class="title">present</span>: <span class="title">texliveonfly</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p><code>texliveonfly</code>安装完成后，修改其默认的配置参数：进入目录<code>D:\Dev\TexLive\texmf-dist\scripts\texliveonfly</code>，编辑<code>texliveonfly.py</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 第一处修改 ###</span></span><br><span class="line"><span class="comment">#defaultCompiler = &quot;pdflatex&quot;</span></span><br><span class="line">defaultCompiler = <span class="string">&quot;xelatex&quot;</span>         <span class="comment"># pdflatex 改为 xelatex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 第二处修改 ###</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    texlive_bin_path = <span class="string">&quot;D:\\Dev\\TexLive\\bin\\win32&quot;</span>   <span class="comment"># 增加这一行</span></span><br><span class="line">    tlmgr_cmd = <span class="string">&#x27;tlmgr.bat&#x27;</span>                             <span class="comment"># 增加这一行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Parse command line</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 第三处修改 ###</span></span><br><span class="line">    parser.add_option(<span class="string">&#x27;--texlive_bin&#x27;</span>, dest=<span class="string">&#x27;texlive_bin&#x27;</span>, metavar=<span class="string">&#x27;LOCATION&#x27;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;Custom location for the TeX Live bin folder&#x27;</span>, default=texlive_bin_path)  <span class="comment"># default=&#x27;&#x27; 改为 texlive_bin_path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 第四处修改 ###</span></span><br><span class="line">    <span class="comment">#initializes tlmgr, responds if the program not found</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        tlmgr_path = os.path.join(options.texlive_bin, tlmgr_cmd)   <span class="comment"># tlmgr 改为 tlmgr_cmd</span></span><br></pre></td></tr></table></figure>
<p>以上修改的目的是将告诉<code>texliveonfly.py</code>具体的编译路径和命令。经过上述修改，可以在命令行里直接使用<code>texliveonfly xx.tex</code>命令编译<code>tex</code>文件。</p>
]]></content>
      <categories>
        <category>折腾</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>TexLive</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 18.04的使用</title>
    <url>/2019/05/19/ubuntu_1804/</url>
    <content><![CDATA[<p>从最初的<code>Ubuntu 12.04</code>到现在的<code>18.04</code>，随着<code>Ubuntu</code>的更新很多以前的配置无法继续使用，重新开一个帖子，记录新版本的命令和配置。 以下命令，在<code>Ubuntu Server 18.04</code>上测试通过。</p>
<span id="more"></span>
<h2 id="查看系统信息">0、查看系统信息</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----------当前计算机信息---------------&quot;</span></span><br><span class="line"><span class="comment"># 显示当前系统及版本号</span></span><br><span class="line"><span class="built_in">echo</span> 系统版本：$<span class="string">&#x27;\t&#x27;</span> `lsb_release -a 2&gt;&amp;1 | grep -i <span class="string">&#x27;description&#x27;</span> | <span class="built_in">cut</span> -d$<span class="string">&#x27;\t&#x27;</span> -f2`</span><br><span class="line"><span class="comment"># 显示内核及版本号</span></span><br><span class="line"><span class="comment"># Kernel=`uname -s -r`</span></span><br><span class="line"><span class="built_in">echo</span> 内核版本：$<span class="string">&#x27;\t&#x27;</span>  `<span class="built_in">uname</span> -s -r`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示CPU信息</span></span><br><span class="line"><span class="built_in">echo</span> CPU型号：</span><br><span class="line">grep -i <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示显卡信息</span></span><br><span class="line"><span class="built_in">echo</span> 显卡信息：</span><br><span class="line">lspci | grep -i <span class="string">&#x27;vga&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示网口信息</span></span><br><span class="line"><span class="built_in">echo</span> 以太网信息：</span><br><span class="line">lspci | grep -i <span class="string">&#x27;Ethernet&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示内存信息</span></span><br><span class="line"><span class="built_in">echo</span> 内存容量：`grep -i <span class="string">&#x27;MemTotal&#x27;</span> /proc/meminfo | <span class="built_in">cut</span> -d: -f2`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示硬盘信息</span></span><br><span class="line"><span class="built_in">echo</span> 硬盘信息：</span><br><span class="line">lsblk -d -o NAME,SIZE,TYPE,MOUNTPOINT</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-------------DONE---------------------&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="安装php7.2nginx和mariadb三件套">1、安装<code>php(7.2)</code>、<code>nginx</code>和<code>mariadb</code>三件套</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、nginx 和 mariadb</span></span><br><span class="line"></span><br><span class="line">PKGS=<span class="string">&quot;nginx&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> mariadb-server mariadb-client&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、php 7.2</span></span><br><span class="line"></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-cli&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-ldap&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-fpm&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-mysql&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-mbstring&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-xml&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-xmlrpc&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-curl&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-gd&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-imap&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-intl&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php-imagick&quot;</span></span><br><span class="line">PKGS=<span class="string">&quot;<span class="variable">$PKGS</span> php7.2-zip&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#PKGS=&quot;$PKGS php7.2-sqlite3&quot;</span></span><br><span class="line"><span class="comment">#PKGS=&quot;$PKGS php-memcached&quot;</span></span><br><span class="line"><span class="comment">#PKGS=&quot;$PKGS php-imagick&quot;</span></span><br><span class="line"><span class="comment">#PKGS=&quot;$PKGS php7.2-readline&quot;</span></span><br><span class="line"><span class="comment">#PKGS=&quot;$PKGS php7.2-common&quot;</span></span><br><span class="line"><span class="comment">#PKGS=&quot;$PKGS php7.2-bcmath&quot;</span></span><br><span class="line"><span class="comment">#PKGS=&quot;$PKGS php7.2-soap&quot;</span></span><br><span class="line"><span class="comment">#PKGS=&quot;$PKGS php7.2-tidy&quot;</span></span><br><span class="line"><span class="comment">#PKGS=&quot;$PKGS php7.2-xsl&quot;</span></span><br><span class="line"><span class="comment">#PKGS=&quot;$PKGS php7.2-opcache&quot;</span></span><br><span class="line"><span class="comment">#PKGS=&quot;$PKGS php-apcu&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、执行安装命令</span></span><br><span class="line">sudo apt install -y <span class="variable">$PKGS</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置固定ip地址">2、配置固定IP地址</h2>
<p>编辑<code>/etc/netplan/01-netcfg.yaml</code>： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This file describes the network interfaces available on your system</span><br><span class="line"># For more information, see netplan(5).</span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd</span><br><span class="line">  ethernets:</span><br><span class="line">    enp8s0:</span><br><span class="line">      optional: true</span><br><span class="line">      dhcp4: yes</span><br><span class="line">      dhcp6: yes</span><br><span class="line">    eno1:</span><br><span class="line">      optional: true</span><br><span class="line">      dhcp4: no</span><br><span class="line">      addresses: [10.3.89.198/24]</span><br><span class="line">      gateway4: 10.3.89.1</span><br><span class="line">      nameservers:</span><br><span class="line">        addresses: [202.119.248.66,218.2.135.1]</span><br><span class="line">      dhcp6: yes</span><br><span class="line"></span><br></pre></td></tr></table></figure> 注意，每个网口的<code>optinal</code>要填上，否则如果网线未连接，启动时会一直等待该网口，导致启动时间超长。配置完成之后，使用命令<code>sudo netplan apply</code>进行应用</p>
<h2 id="随时监控系统状况的watch命令">3、随时监控系统状况的<code>watch</code>命令</h2>
<p>如果需要对系统运行时的状态进行监控，如CPU、显卡或硬盘的温度等进行监控，可以使用<code>watch</code>命令。</p>
<p>首先创建脚本<code>thermal.sh</code>，一次性运行所有监控程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># CPU温度</span></span><br><span class="line">sensors</span><br><span class="line"><span class="comment"># 硬盘温度</span></span><br><span class="line">sudo hddtemp /dev/sda</span><br><span class="line"><span class="comment"># 显卡（这里是N卡）</span></span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<p>然后执行<code>watch</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch -n 1 ./thermal.sh</span><br></pre></td></tr></table></figure>
<p>可以编辑一个<code>alias</code>加入<code>bash_aliases</code>: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> wt=<span class="string">&#x27;watch -n 1 /&#123;full_path&#125;/thermal.sh&#x27;</span></span><br></pre></td></tr></table></figure> 按<code>ctrl+c</code>终止运行</p>
<h2 id="解决更新时无网络授权问题">4、解决更新时无网络授权问题：</h2>
<p>在使用<code>sudo apt update</code>时，通常使用国内镜像进行加速，比如清华大学镜像站。常规方案是编辑<code>/etc/apt/sources.list</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除原有备份</span></span><br><span class="line">sudo <span class="built_in">mv</span> /etc/apt/sources.list.bak /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 复制一个备份</span></span><br><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">sudo sed -i <span class="string">&#x27;sed -i &#x27;</span>s/http:\/\/us.archive.ubuntu.com/https:\/\/mirrors.tuna.tsinghua.edu.cn/g<span class="string">&#x27; /etc/apt/sources.list</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>此时执行更新命令，如果仅有<code>IPv6</code>网络，<code>IPv4</code>没有授权，那么<code>http://security.ubuntu.com</code> 会报错，提示无网络访问权限。</p>
<p>编辑<code>/etc/hosts</code>，增加<code>2001:67c:1360:8001::17 security.ubuntu.com</code>即可。具体IP地址可以通过<code>pin6</code>或<code>host</code>命令来获取 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping6 security.ubuntu.com</span><br><span class="line"><span class="comment"># host -t AAAA security.ubuntu.com</span></span><br></pre></td></tr></table></figure> 以后访问<code>security.ubuntu.com</code>均通过IPv6进行，不走IPv4。</p>
<h2 id="使用代理安装第三方ppa">5、使用代理安装第三方PPA</h2>
<p>　　<code>Ubuntu 18.04</code>自带的<code>ffmpeg</code>太老，想更新以下，找到了第三方的一个PPA，<a href="https://launchpad.net/~jonathonf/+archive/ubuntu/ffmpeg-4?field.series_filter=bionic">Jonathon F : ffmpeg-4</a>，无奈服务器没有<code>ipv4</code>网络访问授权，考虑使用代理进行安装。</p>
<p>　　1) 打开<code>apt</code>代理，添加<code>PPA</code>库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:jonathonf/ffmpeg-4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现错误：</span></span><br><span class="line"><span class="comment"># Error: retrieving gpg key timed out</span></span><br></pre></td></tr></table></figure>
<p>　　2) 手动添加<code>gpg key</code>:</p>
<p>　　(1) 访问<a href="https://launchpad.net/~jonathonf/+archive/ubuntu/ffmpeg-4?field.series_filter=bionic">Jonathon F : ffmpeg-4</a>，进入页面；</p>
<p>　　(2) 在PPA页面内，点击：<code>Technical details about this PPA</code>，找到<code>Signing key:</code>，点击<code>(What is this?)</code>前的一串Key。页面跳转到<code>https://keyserver.ubuntu.com/pks/lookup?...</code>，点击<code>sig  sig</code>后面的签名key，出现一个公钥： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="line"></span><br><span class="line">xsFNBFSs/wABEAC2gPjfZeJLl9+KsSG2GvMMnPHJ/rpuFPq7ODPtRxuWscEs1VtN</span><br><span class="line">BcHuy6spxm2Iss2611Jp29KU/2J2d1KwmCaBFuwOwmZGioQ+U6isa2XQnOdYAAV3</span><br><span class="line">3b7FJKtbb8TugupdmuHkSnTYPTQRl1CEOz3sdkS7dizPitZYCK4w1xosJq/eaYrh</span><br><span class="line">0F2POb+2bjlqwHPyTxf6za1vPk5Gpo2OGhJ6ITeS2YG15MRore+0j00RZa5kNPOX</span><br><span class="line">7QBFtoFl8hcHCNw09rmnJj1ODZ9rLgPI0yiikf0J5ivLKjCoiJJlzw9AE8HslkX0</span><br><span class="line">a4cYAC0cCFnKQMoX1ja3avtuw4rd8yDwkZofez8iPNYUYJOIQrh1jrjLWaY8VgXy</span><br><span class="line">FRYJiJAeKz7herI/aP+mMW6Tw5TVoDp7sGqxCYwTSLsZTTEvfq+kCtKELfuTFrLE</span><br><span class="line">Ayzx9X2CWqvM086bAt07B3SWQJgs8VdgWom0zKhk1AQiMDkgjnoQoX9vMy8agV4g</span><br><span class="line">kOxsJAp7Y7hPrAn5swd4lRbbdvHofWlZiQ/0Jnw0kP28+MX0Q8uhOHH9ynZiFLu+</span><br><span class="line">AzJVlya46nxNT8P+rrlEcCJxF2XlgRrHqJdyFbSGMGe7ZmoermvDdwVMaVdvETYA</span><br><span class="line">5a9gyT42aFbkfTam9V7mLKYCtj02fsWQA/LqBqkZXccv6v+boCgKhzR+VwARAQAB</span><br><span class="line">zR5MYXVuY2hwYWQgUFBBIGZvciBKIEZlcm55aG91Z2jCwXgEEwECACIFAlSs/wAC</span><br><span class="line">GwMGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEIz2OtPwb8ZZJBoP/3e6Phxo</span><br><span class="line">x3BXOv+Jv4EQ2Ns25F+jIFYyRtobGE+Tx/lmeOEwfQptp2xqJ4upWn9qVR8SG0qf</span><br><span class="line">pG2TmcxiufxHq7n0T+ul3683RPL2CvfeCHqSzw8iO9iAQ3d6m0jsTrsS4mGcpb0x</span><br><span class="line">9a21wIL31R6TMp8vpwsUvTeCY9/LD2uruLn3dDt8fZM0nBu3s93GhiQwsHjFVupz</span><br><span class="line">ebJymw5+yJRmyIz4hoJrBNtxgvrl8sY2l5ze96/U4dUuRmd3NhPW5x8K3Eb2ohMe</span><br><span class="line">zrluf2c76/aLGWd/curkBgGS2a9gYIXKsNpp6NvOZDzOt2e6V4zHHACtSCvL6Voa</span><br><span class="line">0LPkC2LJENl6bUfARTofmmkcGo8s3mwKakTFTADSUI2dCcCJ6flbpMwt31ZEmb+b</span><br><span class="line">4GI+oVgqfsIVCwAMgCeu+97e7JnMEAUaRp4CX350ww6DtG/CoZLinX+GTbxjUhIK</span><br><span class="line">izC0gBlxac8h+Iw//0AT/MjUGbEUQQogn1BKPh56NhL60VFAz1ngew3kCUyn3F1b</span><br><span class="line">GLSysLK9d813dxtiQEjnSeAa6onR0pGHSD4nFjQAKbQcqyuVSyV9xWOyLShx3ExT</span><br><span class="line">Do1eNe8P1PPekh99iaBU9IAtUJmJAHexhPXvoNcYtQwLPlJlkXYtqd5/lll+SeAN</span><br><span class="line">tNM8R2lljdCtbCCm7A0wAKAeiZ1RJHIdeExb</span><br><span class="line">=jENS</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK-----</span><br></pre></td></tr></table></figure> 　　(3) 将上述公钥保存为一个文件，如<code>ffmpeg_gpg.key</code>，使用如下命令添加该公钥： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-key add ffmpeg_gpg.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示</span></span><br><span class="line"><span class="comment"># OK</span></span><br></pre></td></tr></table></figure> 　　到这里，第三方库已经安装好了，开始更新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果已经安装过，先卸载</span></span><br><span class="line"><span class="comment"># sudo apt remove ffmpeg</span></span><br><span class="line"><span class="comment"># sudo apt autoremove</span></span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install ffmpeg</span><br></pre></td></tr></table></figure>
<p>　　安装时会出现一堆错误，主要原因是使用<code>XX.Net</code>做代理，<code>SSL</code>验证会错误。不过没关系，<code>launchpad.net</code>可以访问，安装失败后，去掉代理重新执行安装命令即可完成安装。</p>
<p>　　(4) <code>ffmpeg</code>命令冲突的解决</p>
<p>　　系统里安装<code>anaconda</code>，在<code>anaconda3/bin</code>目录下，同样有<code>ffmpeg</code>和<code>ffprobe</code>两个可执行文件，如果不作处理，默认会运行这两个程序，而这两个程序不支持<code>h264</code>编码。一个简单的解决办法，使用<code>alias</code>，编辑<code>~/.bash_aliases</code>，增加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias ffmpeg=&quot;/usr/bin/ffmpeg &quot;</span><br><span class="line">alias ffprobe=&quot;/usr/bin/ffprobe &quot;</span><br></pre></td></tr></table></figure>
<p>　　运行<code>source ~/.bashrc</code>重新激活一下<code>alias</code>即可。</p>
<p>　　(5) 测试： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ ffmpeg -version</span><br><span class="line">ffmpeg version 4.1.4-0york3~18.04 Copyright (c) 2000-2019 the FFmpeg developers</span><br><span class="line">built with gcc 7 (Ubuntu 7.4.0-1ubuntu1~18.04.1)</span><br><span class="line">configuration: --prefix=/usr --extra-version=<span class="string">&#x27;0york3~18.04&#x27;</span> --toolchain=hardened </span><br><span class="line">	--libdir=/usr/lib/x86_64-linux-gnu --incdir=/usr/include/x86_64-linux-gnu --<span class="built_in">arch</span>=amd64 </span><br><span class="line">	--enable-gpl --disable-stripping --enable-avresample --disable-filter=resample --enable-avisynth </span><br><span class="line">	--enable-gnutls --enable-ladspa --enable-libaom --enable-libass --enable-libbluray </span><br><span class="line">	--enable-libbs2b --enable-libcaca --enable-libcdio --enable-libcodec2 --enable-libflite </span><br><span class="line">	--enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgme </span><br><span class="line">	--enable-libgsm --enable-libjack --enable-libmp3lame --enable-libmysofa --enable-libopenjpeg </span><br><span class="line">	--enable-libopenmpt --enable-libopus --enable-libpulse --enable-librsvg --enable-librubberband </span><br><span class="line">	--enable-libshine --enable-libsnappy --enable-libsoxr --enable-libspeex --enable-libssh </span><br><span class="line">	--enable-libtheora --enable-libtwolame --enable-libvidstab --enable-libvorbis --enable-libvpx </span><br><span class="line">	--enable-libwavpack --enable-libwebp --enable-libx265 --enable-libxml2 --enable-libxvid </span><br><span class="line">	--enable-libzmq --enable-libzvbi --enable-lv2 --enable-omx --enable-openal --enable-opengl </span><br><span class="line">	--enable-sdl2 --enable-nonfree --enable-libfdk-aac --enable-libdc1394 --enable-libdrm </span><br><span class="line">	--enable-libiec61883 --enable-chromaprint --enable-frei0r --enable-libx264 --enable-shared</span><br><span class="line">libavutil      56. 22.100 / 56. 22.100</span><br><span class="line">libavcodec     58. 35.100 / 58. 35.100</span><br><span class="line">libavformat    58. 20.100 / 58. 20.100</span><br><span class="line">libavdevice    58.  5.100 / 58.  5.100</span><br><span class="line">libavfilter     7. 40.101 /  7. 40.101</span><br><span class="line">libavresample   4.  0.  0 /  4.  0.  0</span><br><span class="line">libswscale      5.  3.100 /  5.  3.100</span><br><span class="line">libswresample   3.  3.100 /  3.  3.100</span><br><span class="line">libpostproc    55.  3.100 / 55.  3.100</span><br><span class="line"></span><br><span class="line">~$ ffmpeg -encoders | grep 264</span><br><span class="line"> V..... libx264              libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264)</span><br><span class="line"> V..... libx264rgb           libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264)</span><br><span class="line"> V..... h264_omx             OpenMAX IL H.264 video encoder (codec h264)</span><br><span class="line"> V..... h264_v4l2m2m         V4L2 mem2mem H.264 encoder wrapper (codec h264)</span><br><span class="line"> V..... h264_vaapi           H.264/AVC (VAAPI) (codec h264)</span><br></pre></td></tr></table></figure></p>
<h2 id="修改默认安装语言修复显示日期乱码">6、修改默认安装语言(修复显示日期乱码）</h2>
<p>　　以下命令测试版本为<code>ubuntu 14.04 LTS</code>和<code>ubuntu 16.04 LTS</code>；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo locale-gen zh_CN</span><br><span class="line">sudo locale-gen zh_CN.UTF-8</span><br><span class="line">sudo dpkg-reconfigure locales</span><br><span class="line">sudo update-locale LANG=<span class="string">&quot;zh_CN.UTF-8&quot;</span> LANGUAGE=<span class="string">&quot;zh_CN&quot;</span></span><br></pre></td></tr></table></figure>
<p>　　退出shell，重新登录后起作用。测试，使用命令<code>locale</code>，成功后输出如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user@2019:~$ locale</span><br><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">LANGUAGE=zh_CN</span><br><span class="line">LC_CTYPE=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_NUMERIC=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_TIME=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_COLLATE=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_MONETARY=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_MESSAGES=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_PAPER=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_NAME=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_ADDRESS=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_TELEPHONE=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_MEASUREMENT=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_IDENTIFICATION=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_ALL=zh_CN.UTF-8</span><br></pre></td></tr></table></figure></p>
<h2 id="批量重命名带数字的文件">7、批量重命名带数字的文件</h2>
<p>在b站上下载的很多合集里，文件名包含数字序列，如 <code>xxxP9. 1.xxx</code> <code>xxx.P9. 2.xxx</code> <code>xxx.P10 .1.xxx</code>，现需要将其重新命名为：<code>xxxP09.01.xxx</code> <code>xxx.P09.02.xxx</code> <code>xxx.P10.01.xxx</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数: </span></span><br><span class="line"><span class="comment">#    -n dry-run模式，并未实际运行，可用于测试命令，</span></span><br><span class="line"><span class="comment">#    -v 运行命令并显示受影响的文件</span></span><br><span class="line"><span class="comment"># 1个数字，使用前补0方式命名</span></span><br><span class="line">rename -n <span class="string">&#x27;s/P(\d).\ (\d)/P0$1.0$2/&#x27;</span> *.mp4</span><br><span class="line"><span class="comment"># 2个数字，移除空格</span></span><br><span class="line">rename -v <span class="string">&#x27;s/P(\d&#123;2&#125;).\ (\d&#123;2&#125;)/P$1.$2/&#x27;</span> *.mp4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="安装g-11">8、安装<code>g++ 11</code></h2>
<p><code>Ubuntu 18.04</code>自带的<code>g++</code>版本是<code>7.5</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ g++7 --version</span><br><span class="line"><span class="comment"># 一堆输出....</span></span><br><span class="line"><span class="comment"># 最后一句</span></span><br><span class="line">gcc version 7.5.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果希望安装新版的<code>g++</code>，需要使用<code>PPA</code>源 <code>ubuntu-toolchain-r/test</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 添加PPA，已有可以略过</span></span><br><span class="line">$ sudo apt install software-properties-common</span><br><span class="line">$ sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装</span></span><br><span class="line">$ sudo apt install gcc-11 g++-11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.修改默认编译器为g++11</span></span><br><span class="line">$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 110 --slave /usr/bin/g++ g++ /usr/bin/g++-11 --slave /usr/bin/gcov gcov /usr/bin/gcov-11</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 70 --slave /usr/bin/g++ g++ /usr/bin/g++-7 --slave /usr/bin/gcov gcov /usr/bin/gcov-7</span><br><span class="line"><span class="comment"># 4. 修改默认版本</span></span><br><span class="line">$ sudo update-alternatives --config gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有 2 个候选项可用于替换 gcc (提供 /usr/bin/gcc)。</span></span><br><span class="line"><span class="comment">#   选择       路径           优先级  状态</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># * 0            /usr/bin/gcc-11   110       自动模式</span></span><br><span class="line"><span class="comment">#   1            /usr/bin/gcc-11   110       手动模式</span></span><br><span class="line"><span class="comment">#   2            /usr/bin/gcc-7    70        手动模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 测试</span></span><br><span class="line">$ gcc -v</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># Using built-in specs.</span></span><br><span class="line"><span class="comment"># COLLECT_GCC=g++</span></span><br><span class="line"><span class="comment"># COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper</span></span><br><span class="line"><span class="comment"># OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa</span></span><br><span class="line"><span class="comment"># OFFLOAD_TARGET_DEFAULT=1</span></span><br><span class="line"><span class="comment"># Target: x86_64-linux-gnu</span></span><br><span class="line"><span class="comment"># Configured with: ../src/configure -v --with-pkgversion=&#x27;Ubuntu 11.1.0-1ubuntu1~18.04.1&#x27; --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --disable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-YRKbe7/gcc-11-11.1.0/debian/tmp-nvptx/usr,amdgcn-amdhsa=/build/gcc-11-YRKbe7/gcc-11-11.1.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span></span><br><span class="line"><span class="comment"># Thread model: posix</span></span><br><span class="line"><span class="comment"># Supported LTO compression algorithms: zlib zstd</span></span><br><span class="line"><span class="comment"># gcc version 11.1.0 (Ubuntu 11.1.0-1ubuntu1~18.04.1)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="x黑群晖">X、黑群晖</h2>
<p>设置周期任务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/crontab</span><br><span class="line">sudo synoservice --restart crond</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>折腾</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>18.04</tag>
      </tags>
  </entry>
  <entry>
    <title>使用rsync进行同步备份</title>
    <url>/2019/06/17/ubuntu_rsync/</url>
    <content><![CDATA[<p>　　<code>rsync</code>是常用的数据镜像备份工具，它可以：</p>
<ol type="1">
<li>可以镜像保存整个目录树和文件系统。</li>
<li>可以很容易做到保持原来文件的权限、时间、软硬链接等等。</li>
<li>无须特殊权限即可安装。</li>
</ol>
<p>　　本文记录使用<code>rsync</code>进行系统备份的基本方法。</p>
<span id="more"></span>
<h1 id="修改目标机server端的rsync为daemon模式">1、修改目标机（Server端）的<code>rsync</code>为<code>daemon</code>模式</h1>
<p>　　编辑<code>/etc/default/rsync</code>文件，将<code>RSYNC_ENABLE=false</code>改为<code>true</code>，然后重新启动<code>rsync</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/default/rsync</span><br></pre></td></tr></table></figure>
<p>　　修改为<code>daemon</code>模式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># start rsync in daemon mode from init.d script?</span><br><span class="line">#  only allowed values are &quot;true&quot;, &quot;false&quot;, and &quot;inetd&quot;</span><br><span class="line">#  Use &quot;inetd&quot; if you want to start the rsyncd from inetd,</span><br><span class="line">#  all this does is prevent the init.d script from printing a message</span><br><span class="line">#  about not starting rsyncd (you still need to modify inetd&#x27;s config yourself).</span><br><span class="line"># RSYNC_ENABLE=false</span><br><span class="line">RSYNC_ENABLE=true</span><br></pre></td></tr></table></figure></p>
<h1 id="复制一份rsyncd.conf文件并修改">2、复制一份<code>rsyncd.conf</code>文件并修改</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /etc/rsync</span><br><span class="line">sudo <span class="built_in">cp</span> /usr/share/doc/rsync/examples/rsyncd.conf /etc/rsync</span><br><span class="line"><span class="built_in">cd</span> /etc</span><br><span class="line"><span class="comment"># 这里注意，做了一个软连接</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s rsync/rsyncd.conf rsyncd.conf</span><br></pre></td></tr></table></figure>
<p>　　修改后的文件如下，特别注意<code>auth users</code>字段，指允许的用户 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sample rsyncd.conf configuration file</span><br><span class="line"></span><br><span class="line"># GLOBAL OPTIONS</span><br><span class="line"></span><br><span class="line">#motd file=/etc/motd</span><br><span class="line">log file=/var/log/rsyncd</span><br><span class="line"># for pid file, do not use /var/run/rsync.pid if</span><br><span class="line"># you are going to run rsync out of the init.d script.</span><br><span class="line"># The init.d script does its own pid file handling,</span><br><span class="line"># so omit the &quot;pid file&quot; line completely in that case.</span><br><span class="line">pid file=/var/run/rsyncd.pid</span><br><span class="line">syslog facility=daemon</span><br><span class="line">#socket options=</span><br><span class="line"></span><br><span class="line"># MODULE OPTIONS</span><br><span class="line"></span><br><span class="line">[ftp_pub]</span><br><span class="line"></span><br><span class="line">    comment = public archive</span><br><span class="line">    path = /wd_4t_sda/ftpService/pub/</span><br><span class="line">    use chroot = yes</span><br><span class="line">#   max connections=10</span><br><span class="line">    lock file = /var/lock/rsyncd</span><br><span class="line"># the default for read only is yes...</span><br><span class="line">    read only = yes</span><br><span class="line">    list = yes</span><br><span class="line">    uid = nobody</span><br><span class="line">    gid = nogroup</span><br><span class="line">#   exclude =</span><br><span class="line">    exclude from = /etc/rsync/exclude_rules_pub.conf</span><br><span class="line">#   include =</span><br><span class="line">#   include from =</span><br><span class="line">    auth users = user</span><br><span class="line">    secrets file = /etc/rsync/rsyncd.secrets</span><br><span class="line">    strict modes = yes</span><br><span class="line">    hosts allow = 10.3.89.98</span><br><span class="line">    hosts deny = *</span><br><span class="line">#   ignore errors = no</span><br><span class="line">    ignore errors = yes</span><br><span class="line">    ignore nonreadable = yes</span><br><span class="line">#   transfer logging = no</span><br><span class="line">    transfer logging = yes</span><br><span class="line">    log format = %t: host %h (%a) %o %f (%l bytes). Total %b bytes.</span><br><span class="line">    timeout = 600</span><br><span class="line">    refuse options = checksum dry-run</span><br><span class="line">    dont compress = *.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2 *.tbz *.7z</span><br><span class="line"></span><br><span class="line">[ftp_other]</span><br><span class="line">    comment = public archive</span><br><span class="line">    path = /wd_4t_sda/ftpService/</span><br><span class="line">    use chroot = yes</span><br><span class="line">#   max connections=10</span><br><span class="line">    lock file = /var/lock/rsyncd</span><br><span class="line"># the default for read only is yes...</span><br><span class="line">    read only = yes</span><br><span class="line">    list = yes</span><br><span class="line">    uid = nobody</span><br><span class="line">    gid = nogroup</span><br><span class="line">#   exclude =</span><br><span class="line">    exclude from = /etc/rsync/exclude_rules_other.conf</span><br><span class="line">#   include =</span><br><span class="line">#   include from =</span><br><span class="line">    auth users = user</span><br><span class="line">    secrets file = /etc/rsync/rsyncd.secrets</span><br><span class="line">    strict modes = yes</span><br><span class="line">    hosts allow = 10.3.89.98</span><br><span class="line">    hosts deny = *</span><br><span class="line">#   ignore errors = no</span><br><span class="line">    ignore errors = yes</span><br><span class="line">    ignore nonreadable = yes</span><br><span class="line">#   transfer logging = no</span><br><span class="line">    transfer logging = yes</span><br><span class="line">    log format = %t: host %h (%a) %o %f (%l bytes). Total %b bytes.</span><br><span class="line">    timeout = 600</span><br><span class="line">    refuse options = checksum dry-run</span><br><span class="line">    dont compress = *.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2 *.tbz *.7z</span><br></pre></td></tr></table></figure></p>
<p>　　上述配置文件中，配置了2个模块，<code>ftp_pub</code>和<code>ftp_other</code>，这两个模块同步位置各有不同。</p>
<h1 id="创建密码文件">3、创建密码文件：</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/rsync/rsyncd.secrets</span><br></pre></td></tr></table></figure>
<p>内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用户名:密码</span><br><span class="line">user:123456</span><br></pre></td></tr></table></figure></p>
<h1 id="创建exclude-list">4、创建<code>exclude list</code>:</h1>
<p>　　分别创建以下两个`list</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/rsync/exclude_rules_other.conf</span><br><span class="line">sudo vi /etc/rsync/exclude_rules_pub.conf</span><br></pre></td></tr></table></figure>
<p>　　文件内容根据需要，一行一个路径，注意，路径均是针对配置文件中<code>path</code>的相对路径，绝对路径为<code>$(path)/exclude_path...</code>。</p>
<h1 id="重启rsync服务">5、重启<code>rsync</code>服务：</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service rsync restart</span><br></pre></td></tr></table></figure>
<p>　　以上服务端配置完成，客户端几乎无配置，只需要配置一个本地的密码文件，设该文件为<code>/etc/rsync/rsync.pwd</code>，内容为访问用户的密码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123456</span><br></pre></td></tr></table></figure></p>
<p>　　!注意：下面这两步操作是必须的,没有足够权限同步就会不成功 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 0600 /etc/rsync/rsync.pwd</span><br><span class="line">sudo <span class="built_in">chown</span> user:usergroup /etc/rsync/rsync.pwd</span><br></pre></td></tr></table></figure></p>
<h1 id="运行">6、运行</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -avlrtopg --progress --delete user@10.3.89.196::ftp_pub/ --password-file=/etc/rsync/rsync.pwd /wd_1t/ftpService/pub/ </span><br><span class="line">rsync -avlrtopg --progress --delete user@10.3.89.196::ftp_other/ --password-file=/etc/rsync/rsync.pwd /wd_10t_sdc/ftpService/others/ </span><br></pre></td></tr></table></figure>
<h1 id="使用crontab自动执行">7、使用<code>crontab</code>自动执行</h1>
<p>　　将第6点中的两个命令保存为一个<code>shell</code>脚本文件，设文件名为<code>~/rsync_job.sh</code>，编辑任务列表，并添加合适的周期：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p>　　配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Edit this file to introduce tasks to be run by cron.</span><br><span class="line">#</span><br><span class="line"># Each task to run has to be defined through a single line</span><br><span class="line"># indicating with different fields when the task will be run</span><br><span class="line"># and what command to run for the task</span><br><span class="line">#</span><br><span class="line"># To define the time you can provide concrete values for</span><br><span class="line"># minute (m), hour (h), day of month (dom), month (mon),</span><br><span class="line"># and day of week (dow) or use &#x27;*&#x27; in these fields (for &#x27;any&#x27;).#</span><br><span class="line"># Notice that tasks will be started based on the cron&#x27;s system</span><br><span class="line"># daemon&#x27;s notion of time and timezones.</span><br><span class="line">#</span><br><span class="line"># Output of the crontab jobs (including errors) is sent through</span><br><span class="line"># email to the user the crontab file belongs to (unless redirected).</span><br><span class="line">#</span><br><span class="line"># For example, you can run a backup of all your user accounts</span><br><span class="line"># at 5 a.m every week with:</span><br><span class="line"># 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/</span><br><span class="line">#</span><br><span class="line"># For more information see the manual pages of crontab(5) and cron(8)</span><br><span class="line">#</span><br><span class="line"># m h  dom mon dow   command</span><br><span class="line"># 每周一、周四和周六，凌晨2点执行脚本</span><br><span class="line">0 2 * * 1,4,6 bash /home/user/rsync_job.sh</span><br></pre></td></tr></table></figure>
<p>　　配置完成编辑后，重新载入<code>cron</code> 服务，使配置生效，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service cron restart</span><br></pre></td></tr></table></figure>
<p>　　关于时间格式的补充说明：</p>
<img src="/2019/06/17/ubuntu_rsync/crontab_cmd.png" class="" title="crontab格式说明">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;*&#x27; ：表示所有可能的值，例如month字段使用*，在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class="line">&#x27;,&#x27; ：用于指定多个单独值，例如，“1,2,5,7,8,9”，</span><br><span class="line">&#x27;-&#x27; ：用于连接两个整数，表示整数范围，例如“2-6”表示“2,3,4,5,6”</span><br><span class="line">&#x27;/&#x27; ：指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。如果&#x27;*&#x27;与之一起使用，表示每个xx，例如 &#x27; */10&#x27;，表示每隔10(分钟/小时/等)执行一次。</span><br></pre></td></tr></table></figure>
<hr />
<p><strong>参考：</strong></p>
<ol type="1">
<li><a href="https://blog.csdn.net/yimingsilence/article/details/52153732">https://blog.csdn.net/yimingsilence/article/details/52153732</a></li>
</ol>
]]></content>
      <categories>
        <category>折腾</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>洛阳西安暑期之旅</title>
    <url>/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p>用文字和图片记录下生活的点点滴滴。</p>
<p>陕西、河南历来以众多历史古迹著称，是华夏文化重要的承载地。暑假期间做了一次蜻蜓点水般的悠然之旅。</p>
<span id="more"></span>
<p>8月7日出发，第一站洛阳，途中路过少林寺，时间有限，拍一张少林寺服务器的图片留存，以后再来。 <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/sls.jpg" class="" title="少林寺服务区"></p>
<h2 id="第一站龙门石窟">第一站，龙门石窟。</h2>
<p>龙门石窟在2000年即列为世界文化遗产，抄一段维基上的说明：</p>
<blockquote>
<p>龙门石窟位于中国河南省洛阳市南郊12公里处的伊水两岸的龙门山和香山崖壁上，主要开凿于北魏至北宋的四百余年间，至今仍存有窟龛2100多个，造像10万余尊，碑刻题记3600余品，多在伊水西岸。数量之多位于中国各大石窟之首。其中“龙门二十品”是书法魏碑精华，唐代著名书法家褚遂良所书的“伊阙佛龛之碑”则是初唐楷书艺术的典范。 龙门石窟是中国著名的三大石刻艺术宝库之一，同时被誉为世界最伟大的古典艺术宝库之一，与甘肃敦煌莫高窟、山西大同云岗石窟、甘肃天水麦积山石窟并称为中国四大石窟，均已列为世界文化遗产。除此之外，重庆大足石刻也是中国境内被列入联合国教科文组织世界文化遗产名录的著名石窟。</p>
</blockquote>
<p>门票，100大洋， <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk01.jpg" class="" title="龙门石窟"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk02.jpg" class="" title="龙门石窟"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk03.jpg" class="" title="龙门石窟"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk04.jpg" class="" title="龙门石窟"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk05.png" class="" title="洛阳牡丹石"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk06.jpg" class="" title="万佛洞"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk07.jpg" class="" title="龙门石窟"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk08.jpg" class="" title="龙门石窟"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk09.jpg" class="" title="崖壁石窟"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk10.jpg" class="" title="伊河两岸"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk11.jpg" class="" title="西岸远景"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk12.jpg" class="" title="香山寺前"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk13.jpg" class="" title="白居易.草"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk14.jpg" class="" title="白居易墓"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/lmsk15.jpg" class="" title="告别石窟"></p>
<h2 id="第二站兵马俑">第二站，兵马俑。</h2>
<p>比龙门石窟名头更响的秦始皇兵马俑早在1987年就被联合国教科文组织批准列入《世界遗产名录》。</p>
<p>首先盗图一张： <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy01.jpg" class="" title="兵马俑博物馆(From wiki)"></p>
<p>人太多，简单拍几张照片 <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy02.jpg" class="" title="兵马俑1"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy03.jpg" class="" title="兵马俑2"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy04.jpg" class="" title="兵马俑3"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy05.jpg" class="" title="兵马俑4"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy06.jpg" class="" title="兵马俑5"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy07.jpg" class="" title="兵马俑6"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy08.jpg" class="" title="兵马俑7"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy09.jpg" class="" title="兵马俑8"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy10.jpg" class="" title="兵马俑9"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy11.jpg" class="" title="兵马俑10"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy12.jpg" class="" title="兵马俑11"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/bmy13.jpg" class="" title="兵马俑12"></p>
<h2 id="第三站西安">第三站，西安。</h2>
<p>回民街 <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/hmj01.jpg" class="" title="回民街1"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/hmj02.jpg" class="" title="回民街2"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/hmj03.jpg" class="" title="回民街3"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/hmj04.jpg" class="" title="回民街4"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/hmj05.jpg" class="" title="回民街5"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/hmj06.jpg" class="" title="回民街6"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/hmj07.jpg" class="" title="回民街7"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/hmj08.jpg" class="" title="回民街8"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/hmj09.jpg" class="" title="回民街9"></p>
<h2 id="第四站陕博">第四站，陕博。</h2>
<p>陕西历史博物馆，藏品很珍贵，然而，然而，人不是多，是非常非常非常多。 几乎每个藏品前都围着一堆人，游客声、小朋友哭闹声、讲解员讲解声，整个环境非常嘈杂。</p>
<p>放几张图片。 <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/sb01.jpg" class="" title="陕博1"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/sb02.jpg" class="" title="陕博2"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/sb03.jpg" class="" title="陕博3"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/sb04.jpg" class="" title="陕博4"></p>
<h2 id="第五站潼关">第五站，潼关。</h2>
<p>维基说明： &gt; 潼关位于陕西省渭南市潼关县北，北临黄河，南踞山腰。《水经注》载：“河在关内南流潼激关山，因谓之潼关。”始建于东汉建安元年（196年）。潼关是关中东大门，历来为兵家必争之地。唐安史之乱初期，唐军于灵宝战败失守潼关，最终致使长安失陷。</p>
<p>踏上潼关关头，渭水与黄河交汇于此，隔河与山西相望，确实为三秦大地战略门户。注：现在已经道路已经修好，车直接可以到达关头。</p>
<img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/tg01.jpg" class="" title="潼关1">
<img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/tg02.jpg" class="" title="潼关2">
<img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/tg03.jpg" class="" title="潼关3：关头">
<img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/tg04.jpg" class="" title="潼关4：关上风光">
<img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/tg05.jpg" class="" title="潼关5">
<img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/tg06.jpg" class="" title="潼关6">
<p>滚滚黄河东逝水 <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/tg07.jpg" class="" title="潼关7"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/tg08.jpg" class="" title="潼关8"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/tg09.jpg" class="" title="潼关9：全景二水相汇"> <img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/tg10.jpg" class="" title="潼关10：景区正在建设"></p>
<h2 id="路遇">路遇</h2>
<img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/other01.jpg" class="" title="不明真相1">
<img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/other02.jpg" class="" title="不明真相2">
<img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/other03.jpg" class="" title="华山脚下">
<img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/other04.jpg" class="" title="平顶山1">
<img src="/2017/08/13/%E6%B4%9B%E9%98%B3%E8%A5%BF%E5%AE%89%E6%9A%91%E6%9C%9F%E4%B9%8B%E6%97%85/other05.jpg" class="" title="平顶山2">
]]></content>
      <categories>
        <category>生活点滴</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第0章_序言</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap00/</url>
    <content><![CDATA[<h1 id="序言">序言</h1>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap00/7178691-0d965cf51eb5af9e.png" class="" title="利用Python进行数据分析.第2版">
<h1 id="目录">目录</h1>
<ul>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap00/" title="利用Python进行数据分析_第0章_序言">第0章 序言</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap01/" title="利用Python进行数据分析_第01章_准备工作">第1章 准备工作</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap02/" title="利用Python进行数据分析__第02章_Python语法基础">第2章 Python语法基础，IPython和Jupyter Notebooks</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap03/" title="利用Python进行数据分析__第03章_Python的数据结构、函数和文件">第3章 Python的数据结构、函数和文件</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap04/" title="利用Python进行数据分析_第04章_NumPy基础：数组和矢量计算">第4章 NumPy基础：数组和矢量计算</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap05/" title="利用Python进行数据分析_第05章_pandas入门">第5章 pandas入门</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap06/" title="利用Python进行数据分析_第06章_数据加载、存储与文件格式">第6章 数据加载、存储与文件格式</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap07/" title="利用Python进行数据分析_第07章_数据清洗和准备">第7章 数据清洗和准备</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap08/" title="利用Python进行数据分析_第08章_数据规整：聚合、合并和重塑">第8章 数据规整：聚合、合并和重塑</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap09/" title="利用Python进行数据分析_第09章_绘图和可视化">第9章 绘图和可视化</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap10/" title="利用Python进行数据分析_第10章_数据聚合与分组运算">第10章 数据聚合与分组运算</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap11/" title="利用Python进行数据分析_第11章_时间序列">第11章 时间序列</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap12/" title="利用Python进行数据分析_第12章_pandas高级应用">第12章 pandas高级应用</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap13/" title="利用Python进行数据分析_第13章_Python建模库介绍">第13章 Python建模库介绍</a></li>
<li><a href="/2018/08/02/python_for_data_analysis/pfda_chap14/" title="利用Python进行数据分析_第14章_数据分析案例">第14章 数据分析案例</a></li>
</ul>
<span id="more"></span>
<h1 id="原文说明">原文说明</h1>
<p>在简书上阅读： <a href="https://www.jianshu.com/p/04d180d90a3f">https://www.jianshu.com/p/04d180d90a3f</a></p>
<p>下载本书：<a href="http://www.jianshu.com/p/fad9e41c1a42">http://www.jianshu.com/p/fad9e41c1a42</a> （更新为GitHub链接）</p>
<p>下载本书代码（本书GitHub地址）：<a href="https://github.com/wesm/pydata-book">https://github.com/wesm/pydata-book</a> （建议把代码下载下来之后，安装好Anaconda 3.6，在目录文件夹中用Jupyter notebook打开）</p>
<p>本书是2017年10月20号正式出版的，和第1版的不同之处有：</p>
<ul>
<li>包括Python教程内的所有代码升级为Python 3.6（第1版使用的是Python 2.7）</li>
<li>更新了Anaconda和其它包的Python安装方法</li>
<li>更新了Pandas为2017最新版</li>
<li>新增了一章，关于更高级的Pandas工具，外加一些tips</li>
<li>简要介绍了使用StatsModels和scikit-learn</li>
</ul>
<p>对有些内容进行了重新排版。</p>
<p><strong>译者注1</strong></p>
<blockquote>
<p>最大的改变是把第1版附录中的Python教程，单列成了现在的第2章和第3章，并且进行了扩充。可以说，本书第2版对新手更为友好了！</p>
</blockquote>
<p><strong>译者注2</strong>：</p>
<blockquote>
<p>毫无疑问，本书是学习Python数据分析最好的参考书。本来想把书名直接译为《Python数据分析》，这样更简短。但是为了尊重第1版的翻译，考虑到继承性，还是用老书名。这样读过第一版的老读者可以方便的用之前的书名检索到第二版。作者在写第二版的时候，有些文字是照搬第一版的。所以第二版的翻译也借鉴copy了第一版翻译：即，如果第二版中有和第一版相同的文字，则copy第一版的中文译本，觉得不妥的地方会稍加修改，剩下的不同的内容就自己翻译。这样做也是为读过第一版的老读者考虑——相同的内容可以直接跳过。</p>
</blockquote>
<h1 id="转载说明">转载说明</h1>
<p>本书为简书 <a href="https://www.jianshu.com/u/130f76596b02">SeanCheney</a> 翻译，其Github仓库地址为：<a href="https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version">github</a>。在github上，该书总共13章。</p>
<p>转载时，做了一些文字上的修订，同时补充第14章，并在首页添加目录以方便阅读。在以后阅读时，会继续文本上的修订。</p>
<p><strong>最后向译者致敬</strong>。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第01章_准备工作</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap01/</url>
    <content><![CDATA[<h1 id="第1章-准备工作">第1章 准备工作</h1>
<h2 id="本书的内容">1.1 本书的内容</h2>
<p>本书讲的是利用Python进行数据控制、处理、整理、分析等方面的具体细节和基本要点。我的目标是介绍Python编程和用于数据处理的库和工具环境，掌握这些，可以让你成为一个数据分析专家。虽然本书的标题是“数据分析”，重点却是Python编程、库，以及用于数据分析的工具。这就是数据分析要用到的Python编程。</p>
<span id="more"></span>
<h3 id="什么样的数据">1.1.1 什么样的数据？</h3>
<p>当书中出现“数据”时，究竟指的是什么呢？主要指的是结构化数据（structured data），这个故意含糊其辞的术语代指了所有通用格式的数据，例如：</p>
<ul>
<li>表格型数据，其中各列可能是不同的类型（字符串、数值、日期等）。比如保存在关系型数据库中或以制表符/逗号为分隔符的文本文件中的那些数据。</li>
<li>多维数组（矩阵）。</li>
<li>通过关键列（对于SQL用户而言，就是主键和外键）相互联系的多个表。</li>
<li>间隔平均或不平均的时间序列。</li>
</ul>
<p>这绝不是一个完整的列表。大部分数据集都能被转化为更加适合分析和建模的结构化形式，虽然有时这并不是很明显。如果不行的话，也可以将数据集的特征提取为某种结构化形式。例如，一组新闻文章可以被处理为一张词频表，而这张词频表就可以用于情感分析。</p>
<p>大部分电子表格软件（比如Microsoft Excel，它可能是世界上使用最广泛的数据分析工具了）的用户不会对此类数据感到陌生。</p>
<h2 id="为什么要使用python进行数据分析">1.2 为什么要使用Python进行数据分析</h2>
<p>许许多多的人（包括我自己）都很容易爱上Python这门语言。自从1991年诞生以来，Python现在已经成为最受欢迎的动态编程语言之一，其他还有Perl、Ruby等。由于拥有大量的Web框架（比如Rails（Ruby）和Django（Python）），自从2005年，使用Python和Ruby进行网站建设工作非常流行。这些语言常被称作脚本（scripting）语言，因为它们可以用于编写简短而粗糙的小程序（也就是脚本）。我个人并不喜欢“脚本语言”这个术语，因为它好像在说这些语言无法用于构建严谨的软件。在众多解释型语言中，由于各种历史和文化的原因，Python发展出了一个巨大而活跃的科学计算（scientific computing）社区。在过去的10年，Python从一个边缘或“自担风险”的科学计算语言，成为了数据科学、机器学习、学界和工业界软件开发最重要的语言之一。</p>
<p>在数据分析、交互式计算以及数据可视化方面，Python将不可避免地与其他开源和商业的领域特定编程语言/工具进行对比，如R、MATLAB、SAS、Stata等。近年来，由于Python的库（例如pandas和scikit-learn）不断改良，使其成为数据分析任务的一个优选方案。结合其在通用编程方面的强大实力，我们完全可以只使用Python这一种语言构建以数据为中心的应用。</p>
<h3 id="python作为胶水语言">1.2.1 Python作为胶水语言</h3>
<p>Python成为成功的科学计算工具的部分原因是，它能够轻松地集成C、C++以及Fortran代码。大部分现代计算环境都利用了一些Fortran和C库来实现线性代数、优选、积分、快速傅里叶变换以及其他诸如此类的算法。许多企业和国家实验室也利用Python来“粘合”那些已经用了多年的遗留软件系统。</p>
<p>大多数软件都是由两部分代码组成的：少量需要占用大部分执行时间的代码，以及大量不经常执行的“胶水代码”。大部分情况下，胶水代码的执行时间是微不足道的。开发人员的精力几乎都是花在优化计算瓶颈上面，有时更是直接转用更低级的语言（比如C）。</p>
<h3 id="解决两种语言问题">1.2.2 解决“两种语言”问题</h3>
<p>很多组织通常都会用一种类似于领域特定的计算语言（如SAS和R）对新想法做研究、原型构建和测试，然后再将这些想法移植到某个更大的生产系统中去（可能是用Java、C#或C++编写的）。人们逐渐意识到，Python不仅适用于研究和原型构建，同时也适用于构建生产系统。为什么一种语言就够了，却要使用两个语言的开发环境呢？我相信越来越多的企业也会这样看，因为研究人员和工程技术人员使用同一种编程工具将会给企业带来非常显著的组织效益。</p>
<h3 id="为什么不选python">1.2.3 为什么不选Python</h3>
<p>虽然Python非常适合构建分析应用以及通用系统，但它对不少应用场景适用性较差。</p>
<p>由于Python是一种解释型编程语言，因此大部分Python代码都要比用编译型语言（比如Java和C++）编写的代码运行慢得多。由于程序员的时间通常都比CPU时间值钱，因此许多人也愿意对此做一些取舍。但是，在那些延迟要求非常小或高资源利用率的应用中（例如高频交易系统），耗费时间使用诸如C++这样更低级、更低生产率的语言进行编程也是值得的。</p>
<p>对于高并发、多线程的应用程序而言（尤其是拥有许多计算密集型线程的应用程序），Python并不是一种理想的编程语言。这是因为Python有一个叫做全局解释器锁（Global Interpreter Lock，GIL）的组件，这是一种防止解释器同时执行多条Python字节码指令的机制。有关“为什么会存在GIL”的技术性原因超出了本书的范围。虽然很多大数据处理应用程序为了能在较短的时间内完成数据集的处理工作都需要运行在计算机集群上，但是仍然有一些情况需要用单进程多线程系统来解决。</p>
<p>这并不是说Python不能执行真正的多线程并行代码。例如，Python的C插件使用原生的C或C++的多线程，可以并行运行而不被GIL影响，只要它们不频繁地与Python对象交互。</p>
<h2 id="重要的python库">1.3 重要的Python库</h2>
<p>考虑到那些还不太了解Python科学计算生态系统和库的读者，下面我先对各个库做一个简单的介绍。</p>
<p>NumPy NumPy（Numerical Python的简称）是Python科学计算的基础包。本书大部分内容都基于NumPy以及构建于其上的库。它提供了以下功能（不限于此）：</p>
<ul>
<li><p>快速高效的多维数组对象ndarray。</p></li>
<li><p>用于对数组执行元素级计算以及直接对数组执行数学运算的函数。</p></li>
<li><p>用于读写硬盘上基于数组的数据集的工具。</p></li>
<li><p>线性代数运算、傅里叶变换，以及随机数生成。</p>
<p>-成熟的C API， 用于Python插件和原生C、C++、Fortran代码访问NumPy的数据结构和计算工具。</p></li>
</ul>
<p>除了为Python提供快速的数组处理能力，NumPy在数据分析方面还有另外一个主要作用，即作为在算法和库之间传递数据的容器。对于数值型数据，NumPy数组在存储和处理数据时要比内置的Python数据结构高效得多。此外，由低级语言（比如C和Fortran）编写的库可以直接操作NumPy数组中的数据，无需进行任何数据复制工作。因此，许多Python的数值计算工具要么使用NumPy数组作为主要的数据结构，要么可以与NumPy进行无缝交互操作。</p>
<h3 id="pandas">1.3.1 pandas</h3>
<p>pandas提供了快速便捷处理结构化数据的大量数据结构和函数。自从2010年出现以来，它助使Python成为强大而高效的数据分析环境。本书用得最多的pandas对象是DataFrame，它是一个面向列（column-oriented）的二维表结构，另一个是Series，一个一维的标签化数组对象。</p>
<p>pandas兼具NumPy高性能的数组计算功能以及电子表格和关系型数据库（如SQL）灵活的数据处理功能。它提供了复杂精细的索引功能，能更加便捷地完成重塑、切片和切块、聚合以及选取数据子集等操作。因为数据操作、准备、清洗是数据分析最重要的技能，pandas是本书的重点。</p>
<p>作为背景，我是在2008年初开始开发pandas的，那时我任职于AQR Capital Management，一家量化投资管理公司，我有许多工作需求都不能用任何单一的工具解决：</p>
<ul>
<li>有标签轴的数据结构，支持自动或清晰的数据对齐。这可以防止由于数据不对齐，或处理来源不同的索引不同的数据，所造成的错误。</li>
<li>集成时间序列功能。</li>
<li>相同的数据结构用于处理时间序列数据和非时间序列数据。</li>
<li>保存元数据的算术运算和压缩。</li>
<li>灵活处理缺失数据。</li>
<li>合并和其它流行数据库（例如基于SQL的数据库）的关系操作。</li>
</ul>
<p>我想只用一种工具就实现所有功能，并使用通用软件开发语言。Python是一个不错的候选语言，但是此时没有集成的数据结构和工具来实现。我一开始就是想把pandas设计为一款适用于金融和商业分析的工具，pandas专注于深度时间序列功能和工具，适用于时间索引化的数据。</p>
<p>对于使用R语言进行统计计算的用户，肯定不会对DataFrame这个名字感到陌生，因为它源自于R的data.frame对象。但与Python不同，data frames是构建于R和它的标准库。因此，pandas的许多功能不属于R或它的扩展包。</p>
<p>pandas这个名字源于panel data（面板数据，这是多维结构化数据集在计量经济学中的术语）以及Python data analysis（Python数据分析）。</p>
<h3 id="matplotlib">1.3.2 matplotlib</h3>
<p>matplotlib是最流行的用于绘制图表和其它二维数据可视化的Python库。它最初由John D.Hunter（JDH）创建，目前由一个庞大的开发团队维护。它非常适合创建出版物上用的图表。虽然还有其它的Python可视化库，matplotlib却是使用最广泛的，并且它和其它生态工具配合也非常完美。我认为，可以使用它作为默认的可视化工具。</p>
<h3 id="ipython和jupyter">1.3.3 IPython和Jupyter</h3>
<p>IPython项目起初是Fernando Pérez在2001年的一个用以加强和Python交互的子项目。在随后的16年中，它成为了Python数据栈最重要的工具之一。虽然IPython本身没有提供计算和数据分析的工具，它却可以大大提高交互式计算和软件开发的生产率。IPython鼓励“执行-探索”的工作流，区别于其它编程软件的“编辑-编译-运行”的工作流。它还可以方便地访问系统的shell和文件系统。因为大部分的数据分析代码包括探索、试错和重复，IPython可以使工作更快。</p>
<p>2014年，Fernando和IPython团队宣布了Jupyter项目，一个更宽泛的多语言交互计算工具的计划。IPython web notebook变成了Jupyter notebook，现在支持40种编程语言。IPython现在可以作为Jupyter使用Python的内核（一种编程语言模式）。</p>
<p>IPython变成了Jupyter庞大开源项目（一个交互和探索式计算的高效环境）中的一个组件。它最老也是最简单的模式，现在是一个用于编写、测试、调试Python代码的强化shell。你还可以使用通过Jupyter Notebook，一个支持多种语言的交互式网络代码“笔记本”，来使用IPython。IPython shell 和Jupyter notebooks特别适合进行数据探索和可视化。</p>
<p>Jupyter notebooks还可以编写Markdown和HTML内容，它提供了一种创建代码和文本的富文本方法。其它编程语言也在Jupyter中植入了内核，好让在Jupyter中可以使用Python以外的语言。</p>
<p>对我个人而言，我的大部分Python工作都要用到IPython，包括运行、调试和测试代码。</p>
<p>在本书的GitHub页面，你可以找到包含各章节所有代码实例的Jupyter notebooks。</p>
<h3 id="scipy">1.3.4 SciPy</h3>
<p>SciPy是一组专门解决科学计算中各种标准问题域的包的集合，主要包括下面这些包：</p>
<ul>
<li>scipy.integrate：数值积分例程和微分方程求解器。</li>
<li>scipy.linalg：扩展了由numpy.linalg提供的线性代数例程和矩阵分解功能。</li>
<li>scipy.optimize：函数优化器（最小化器）以及根查找算法。</li>
<li>scipy.signal：信号处理工具。</li>
<li>scipy.sparse：稀疏矩阵和稀疏线性系统求解器。</li>
<li>scipy.special：SPECFUN（这是一个实现了许多常用数学函数（如伽玛函数）的Fortran库）的包装器。</li>
<li>scipy.stats：标准连续和离散概率分布（如密度函数、采样器、连续分布函数等）、各种统计检验方法，以及更好的描述统计法。</li>
</ul>
<p>NumPy和SciPy结合使用，便形成了一个相当完备和成熟的计算平台，可以处理多种传统的科学计算问题。</p>
<h3 id="scikit-learn">1.3.5 scikit-learn</h3>
<p>2010年诞生以来，scikit-learn成为了Python的通用机器学习工具包。仅仅七年，就汇聚了全世界超过1500名贡献者。它的子模块包括：</p>
<ul>
<li>分类：SVM、近邻、随机森林、逻辑回归等等。</li>
<li>回归：Lasso、岭回归等等。</li>
<li>聚类：k-均值、谱聚类等等。</li>
<li>降维：PCA、特征选择、矩阵分解等等。</li>
<li>选型：网格搜索、交叉验证、度量。</li>
<li>预处理：特征提取、标准化。</li>
</ul>
<p>与pandas、statsmodels和IPython一起，scikit-learn对于Python成为高效数据科学编程语言起到了关键作用。虽然本书不会详细讲解scikit-learn，我会简要介绍它的一些模型，以及用其它工具如何使用这些模型。</p>
<h3 id="statsmodels">1.3.6 statsmodels</h3>
<p>statsmodels是一个统计分析包，起源于斯坦福大学统计学教授Jonathan Taylor，他设计了多种流行于R语言的回归分析模型。Skipper Seabold和Josef Perktold在2010年正式创建了statsmodels项目，随后汇聚了大量的使用者和贡献者。受到R的公式系统的启发，Nathaniel Smith发展出了Patsy项目，它提供了statsmodels的公式或模型的规范框架。</p>
<p>与scikit-learn比较，statsmodels包含经典统计学和经济计量学的算法。包括如下子模块：</p>
<ul>
<li>回归模型：线性回归，广义线性模型，健壮线性模型，线性混合效应模型等等。</li>
<li>方差分析（ANOVA）。</li>
<li>时间序列分析：AR，ARMA，ARIMA，VAR和其它模型。</li>
<li>非参数方法： 核密度估计，核回归。</li>
<li>统计模型结果可视化。</li>
</ul>
<p>statsmodels更关注与统计推断，提供不确定估计和参数p-值。相反的，scikit-learn注重预测。</p>
<p>同scikit-learn一样，我也只是简要介绍statsmodels，以及如何用NumPy和pandas使用它。</p>
<h2 id="安装和设置">1.4 安装和设置</h2>
<p>由于人们用Python所做的事情不同，所以没有一个普适的Python及其插件包的安装方案。由于许多读者的Python科学计算环境都不能完全满足本书的需要，所以接下来我将详细介绍各个操作系统上的安装方法。我推荐免费的Anaconda安装包。写作本书时，Anaconda提供Python 2.7和3.6两个版本，以后可能发生变化。本书使用的是Python 3.6，因此推荐选择Python 3.6或更高版本。</p>
<h3 id="windows">1.4.1 Windows</h3>
<p>要在Windows上运行，先下载<a href="https://www.anaconda.com/download/">Anaconda安装包</a>。推荐跟随Anaconda下载页面的Windows安装指导，安装指导在写作本书和读者看到此文的的这段时间内可能发生变化。</p>
<p>现在，来确认设置是否正确。打开命令行窗口（<code>cmd.exe</code>），输入<code>python</code>以打开Python解释器。可以看到类似下面的Anaconda版本的输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">C:\Users\wesm&gt;python</span><br><span class="line">Python 3.5.2 |Anaconda 4.1.1 (64-bit)| (default, Jul  5 2016, 11:41:13)</span><br><span class="line">[MSC v.1900 64 bit (AMD64)] on win32</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>要退出shell，按Ctrl-D（Linux或macOS上），Ctrl-Z（Windows上），或输入命令<code>exit()</code>，再按Enter。</p>
<h3 id="apple-os-x-macos">1.4.2 Apple (OS X, macOS)</h3>
<p>下载OS X Anaconda安装包，它的名字类似Anaconda3-4.1.0-MacOSX-x86_64.pkg。双击.pkg文件，运行安装包。安装包运行时，会自动将Anaconda执行路径添加到<code>.bash_profile</code>文件，它位于<code>/Users/$USER/.bash_profile</code>。</p>
<p>为了确认成功，在系统shell打开IPython：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ ipython</span><br></pre></td></tr></table></figure>
<p>要退出shell，按Ctrl-D，或输入命令<code>exit()</code>，再按Enter。</p>
<h3 id="gnulinux">1.4.3 GNU/Linux</h3>
<p>Linux版本很多，这里给出Debian、Ubantu、CentOS和Fedora的安装方法。安装包是一个脚本文件，必须在shell中运行。取决于系统是32位还是64位，要么选择x86 (32位)或x86_64 (64位)安装包。随后你会得到一个文件，名字类似于<code>Anaconda3-4.1.0-Linux-x86_64.sh</code>。用bash进行安装：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ bash Anaconda3-4.1.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：某些Linux版本在包管理器中有满足需求的Python包，只需用类似apt的工具安装就行。这里讲的用Anaconda安装，适用于不同的Linux安装包，也很容易将包升级到最新版本。</p>
</blockquote>
<p>接受许可之后，会向你询问在哪里放置Anaconda的文件。我推荐将文件安装到默认的home目录，例如<code>/home/$USER/anaconda</code>。</p>
<p>Anaconda安装包可能会询问你是否将<code>bin/</code>目录添加到<code>$PATH</code>变量。如果在安装之后有任何问题，你可以修改文件<code>.bashrc</code>（或<code>.zshrc</code>，如果使用的是zsh shell）为类似以下的内容：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">export PATH=/home/$USER/anaconda/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>做完之后，你可以开启一个新窗口，或再次用<code>~/.bashrc</code>执行<code>.bashrc</code>。</p>
<h3 id="安装或升级python包">1.4.4 安装或升级Python包</h3>
<p>在你阅读本书的时候，你可能想安装另外的不在Anaconda中的Python包。通常，可以用以下命令安装：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">conda install package_name</span><br></pre></td></tr></table></figure>
<p>如果这个命令不行，也可以用pip包管理工具：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pip install package_name</span><br></pre></td></tr></table></figure>
<p>你可以用<code>conda update</code>命令升级包：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">conda update package_name</span><br></pre></td></tr></table></figure>
<p>pip可以用<code>--upgrade</code>升级：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pip install --upgrade package_name</span><br></pre></td></tr></table></figure>
<p>本书中，你有许多机会尝试这些命令。</p>
<blockquote>
<p>注意：当你使用conda和pip二者安装包时，千万不要用pip升级conda的包，这样会导致环境发生问题。当使用Anaconda或Miniconda时，最好首先使用conda进行升级。</p>
</blockquote>
<p>Python 2 和 Python 3</p>
<p>第一版的Python 3.x出现于2008年。它有一系列的变化，与之前的Python 2.x代码有不兼容的地方。因为从1991年Python出现算起，已经过了17年，Python 3 的出现被视为吸取一些列教训的更优结果。</p>
<p>2012年，因为许多包还没有完全支持Python 3，许多科学和数据分析社区还是在使用Python 2.x。因此，本书第一版使用的是Python 2.7。现在，用户可以在Python 2.x和Python 3.x间自由选择，二者都有良好的支持。</p>
<p>但是，Python 2.x在2020年就会到期（包括重要的安全补丁），因此再用Python 2.7就不是好的选择了。因此，本书使用了Python 3.6，这一广泛使用、支持良好的稳定版本。我们已经称Python 2.x为“遗留版本”，简称Python 3.x为“Python”。我建议你也是如此。</p>
<p>本书基于Python 3.6。你的Python版本也许高于3.6，但是示例代码应该是向前兼容的。一些示例代码可能在Python 2.7上有所不同，或完全不兼容。</p>
<h3 id="集成开发环境ides和文本编辑器">1.4.5 集成开发环境（IDEs）和文本编辑器</h3>
<p>当被问到我的标准开发环境，我几乎总是回答“IPython加文本编辑器”。我通常在编程时，反复在IPython或Jupyter notebooks中测试和调试每条代码。也可以交互式操作数据，和可视化验证数据操作中某一特殊集合。在shell中使用pandas和NumPy也很容易。</p>
<p>但是，当创建软件时，一些用户可能更想使用特点更为丰富的IDE，而不仅仅是原始的Emacs或Vim的文本编辑器。以下是一些IDE：</p>
<ul>
<li>PyDev（免费），基于Eclipse平台的IDE；</li>
<li>JetBrains的PyCharm（商业用户需要订阅，开源开发者免费）；</li>
<li>Visual Studio（Windows用户）的Python Tools；</li>
<li>Spyder（免费），Anaconda附带的IDE；</li>
<li>Komodo IDE（商业）。</li>
</ul>
<p>因为Python的流行，大多数文本编辑器，比如Atom和Sublime Text 3，对Python的支持也非常好。</p>
<h2 id="社区和会议">1.5 社区和会议</h2>
<p>除了在网上搜索，各式各样的科学和数据相关的Python邮件列表是非常有帮助的，很容易获得回答。包括：</p>
<ul>
<li>pydata：一个Google群组列表，用以回答Python数据分析和pandas的问题；</li>
<li>pystatsmodels： statsmodels或pandas相关的问题；</li>
<li>scikit-learn和Python机器学习邮件列表，scikit-learn@python.org；</li>
<li>numpy-discussion：和NumPy相关的问题；</li>
<li>scipy-user：SciPy和科学计算的问题；</li>
</ul>
<p>因为这些邮件列表的URLs可以很容易搜索到，但因为可能发生变化，所以没有给出。</p>
<p>每年，世界各地会举办许多Python开发者大会。如果你想结识其他有相同兴趣的人，如果可能的话，我建议你去参加一个。许多会议会对无力支付入场费和差旅费的人提供财力帮助。下面是一些会议：</p>
<ul>
<li>PyCon和EuroPython：北美和欧洲的两大Python会议；</li>
<li>SciPy和EuroSciPy：北美和欧洲两大面向科学计算的会议；</li>
<li>PyData：世界范围内，一些列的地区性会议，专注数据科学和数据分析；</li>
<li>国际和地区的PyCon会议（<a href="http://pycon.org有完整列表）">http://pycon.org有完整列表）</a> 。</li>
</ul>
<h2 id="本书导航">1.6 本书导航</h2>
<p>如果之前从未使用过Python，那你可能需要先看看本书的第2章和第3章，我简要介绍了Python的特点，IPython和Jupyter notebooks。这些知识是为本书后面的内容做铺垫。如果你已经掌握Python，可以选择跳过。</p>
<p>接下来，简单地介绍了NumPy的关键特性，附录A中是更高级的NumPy功能。然后，我介绍了pandas，本书剩余的内容全部是使用pandas、NumPy和matplotlib处理数据分析的问题。我已经尽量让全书的结构循序渐进，但偶尔会有章节之间的交叉，有时用到的概念还没有介绍过。</p>
<p>尽管读者各自的工作任务不同，大体可以分为几类：</p>
<ul>
<li><p>与外部世界交互</p>
<p>阅读编写多种文件格式和数据存储；</p></li>
<li><p>数据准备</p>
<p>清洗、修改、结合、标准化、重塑、切片、切割、转换数据，以进行分析；</p></li>
<li><p>转换数据</p>
<p>对旧的数据集进行数学和统计操作，生成新的数据集（例如，通过各组变量聚类成大的表）；</p></li>
<li><p>建模和计算</p>
<p>将数据绑定统计模型、机器学习算法、或其他计算工具；</p></li>
<li><p>展示</p>
<p>创建交互式和静态的图表可视化和文本总结。</p></li>
</ul>
<h3 id="代码示例">1.6.1 代码示例</h3>
<p>本书大部分代码示例的输入形式和输出结果都会按照其在IPython shell或Jupyter notebooks中执行时的样子进行排版：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [5]: CODE EXAMPLE</span><br><span class="line">Out[5]: OUTPUT</span><br></pre></td></tr></table></figure>
<p>但你看到类似的示例代码，就是让你在<code>in</code>的部分输入代码，按Enter键执行（Jupyter中是按Shift-Enter）。然后就可以在<code>out</code>看到输出。</p>
<h3 id="示例数据">1.6.2 示例数据</h3>
<p>各章的示例数据都存放在GitHub上：<a href="http://github.com/pydata/pydata-book。">http://github.com/pydata/pydata-book。</a> 下载这些数据的方法有二：使用git版本控制命令行程序；直接从网站上下载该GitHub库的zip文件。如果遇到了问题，可以到我的个人主页，<a href="http://wesmckinney.com/，">http://wesmckinney.com/，</a> 获取最新的指导。</p>
<p>为了让所有示例都能重现，我已经尽我所能使其包含所有必需的东西，但仍然可能会有一些错误或遗漏。如果出现这种情况的话，请给我发邮件：wesmckinn@gmail.com。报告本书错误的最好方法是O’Reilly的errata页面，<a href="http://www.bit.ly/pyDataAnalysis_errata。">http://www.bit.ly/pyDataAnalysis_errata。</a></p>
<h3 id="引入惯例">1.6.3 引入惯例</h3>
<p>Python社区已经广泛采取了一些常用模块的命名惯例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> statsmodels <span class="keyword">as</span> sm</span><br></pre></td></tr></table></figure>
<p>也就是说，当你看到np.arange时，就应该想到它引用的是NumPy中的arange函数。这样做的原因是：在Python软件开发过程中，不建议直接引入类似NumPy这种大型库的全部内容（from numpy import *）。</p>
<h3 id="行话">1.6.4 行话</h3>
<p>由于你可能不太熟悉书中使用的一些有关编程和数据科学方面的常用术语，所以我在这里先给出其简单定义：</p>
<p>数据规整（Munge/Munging/Wrangling） 指的是将非结构化和（或）散乱数据处理为结构化或整洁形式的整个过程。这几个词已经悄悄成为当今数据黑客们的行话了。Munge这个词跟Lunge押韵。</p>
<p>伪码（Pseudocode） 算法或过程的“代码式”描述，而这些代码本身并不是实际有效的源代码。</p>
<p>语法糖（Syntactic sugar） 这是一种编程语法，它并不会带来新的特性，但却能使代码更易读、更易写。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析__第02章_Python语法基础</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap02/</url>
    <content><![CDATA[<h1 id="第2章-python语法基础ipython和jupyter-notebooks">第2章 Python语法基础，IPython和Jupyter Notebooks</h1>
<p>当我在2011年和2012年写作本书的第一版时，可用的学习Python数据分析的资源很少。这部分上是一个鸡和蛋的问题：我们现在使用的库，比如pandas、scikit-learn和statsmodels，那时相对来说并不成熟。2017年，数据科学、数据分析和机器学习的资源已经很多，原来通用的科学计算拓展到了计算机科学家、物理学家和其它研究领域的工作人员。学习Python和成为软件工程师的优秀书籍也有了。</p>
<span id="more"></span>
<p>因为这本书是专注于Python数据处理的，对于一些Python的数据结构和库的特性难免不足。因此，本章和第3章的内容只够你能学习本书后面的内容。</p>
<p>在我来看，没有必要为了数据分析而去精通Python。我鼓励你使用IPython shell和Jupyter试验示例代码，并学习不同类型、函数和方法的文档。虽然我已尽力让本书内容循序渐进，但读者偶尔仍会碰到没有之前介绍过的内容。</p>
<p>本书大部分内容关注的是基于表格的分析和处理大规模数据集的数据准备工具。为了使用这些工具，必须首先将混乱的数据规整为整洁的表格（或结构化）形式。幸好，Python是一个理想的语言，可以快速整理数据。Python使用得越熟练，越容易准备新数据集以进行分析。</p>
<p>最好在IPython和Jupyter中亲自尝试本书中使用的工具。当你学会了如何启动Ipython和Jupyter，我建议你跟随示例代码进行练习。与任何键盘驱动的操作环境一样，记住常见的命令也是学习曲线的一部分。</p>
<blockquote>
<p>笔记：本章没有介绍Python的某些概念，如类和面向对象编程，你可能会发现它们在Python数据分析中很有用。 为了加强Python知识，我建议你学习官方Python教程，<a href="https://docs.python.org/3/，或是通用的Python教程书籍，比如：">https://docs.python.org/3/，或是通用的Python教程书籍，比如：</a></p>
<ul>
<li>Python Cookbook，第3版，David Beazley和Brian K. Jones著（O’Reilly）</li>
<li>流畅的Python，Luciano Ramalho著 (O’Reilly)</li>
<li>高效的Python，Brett Slatkin著 (Pearson)</li>
</ul>
</blockquote>
<h2 id="python解释器">2.1 Python解释器</h2>
<p>Python是解释性语言。Python解释器同一时间只能运行一个程序的一条语句。标准的交互Python解释器可以在命令行中通过键入<code>python</code>命令打开：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ python</span><br><span class="line">Python 3.6.0 | packaged by conda-forge | (default, Jan 13 2017, 23:17:12)</span><br><span class="line">[GCC 4.8.2 20140120 (Red Hat 4.8.2-15)] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; a = 5</span><br><span class="line">&gt;&gt;&gt; print(a)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p><code>&gt;&gt;&gt;</code>提示输入代码。要退出Python解释器返回终端，可以输入<code>exit()</code>或按Ctrl-D。</p>
<p>运行Python程序只需调用Python的同时，使用一个<code>.py</code>文件作为它的第一个参数。假设创建了一个<code>hello_world.py</code>文件，它的内容是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>你可以用下面的命令运行它（<code>hello_world.py</code>文件必须位于终端的工作目录）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python hello_world.py</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>一些Python程序员总是这样执行Python代码的，从事数据分析和科学计算的人却会使用IPython，一个强化的Python解释器，或Jupyter notebooks，一个网页代码笔记本，它原先是IPython的一个子项目。在本章中，我介绍了如何使用IPython和Jupyter，在附录A中有更深入的介绍。当你使用<code>%run</code>命令，IPython会同样执行指定文件中的代码，结束之后，还可以与结果交互：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ ipython</span><br><span class="line">Python 3.6.0 | packaged by conda-forge | (default, Jan 13 2017, 23:17:12)</span><br><span class="line">Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"></span><br><span class="line">IPython 5.1.0 -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython&#x27;s features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python&#x27;s own help system.</span><br><span class="line">object?   -&gt; Details about &#x27;object&#x27;, use &#x27;object??&#x27; for extra details.</span><br><span class="line"></span><br><span class="line">In [1]: %run hello_world.py</span><br><span class="line">Hello world</span><br><span class="line"></span><br><span class="line">In [2]:</span><br></pre></td></tr></table></figure>
<p>IPython默认采用序号的格式<code>In [2]:</code>，与标准的<code>&gt;&gt;&gt;</code>提示符不同。</p>
<h2 id="ipython基础">2.2 IPython基础</h2>
<p>在本节中，我们会教你打开运行IPython shell和jupyter notebook，并介绍一些基本概念。</p>
<h3 id="运行ipython-shell">2.2.1 运行IPython Shell</h3>
<p>你可以用<code>ipython</code>在命令行打开IPython Shell，就像打开普通的Python解释器：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ ipython</span><br><span class="line">Python 3.6.0 | packaged by conda-forge | (default, Jan 13 2017, 23:17:12)</span><br><span class="line">Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"></span><br><span class="line">IPython 5.1.0 -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython&#x27;s features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python&#x27;s own help system.</span><br><span class="line">object?   -&gt; Details about &#x27;object&#x27;, use &#x27;object??&#x27; for extra details.</span><br><span class="line"></span><br><span class="line">In [1]: a = 5</span><br><span class="line">In [2]: a</span><br><span class="line">Out[2]: 5</span><br></pre></td></tr></table></figure>
<p>你可以通过输入代码并按Return（或Enter），运行任意Python语句。当你只输入一个变量，它会显示代表的对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: data = &#123;i : np.random.randn() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: data</span><br><span class="line">Out[<span class="number">7</span>]: </span><br><span class="line">&#123;<span class="number">0</span>: -<span class="number">0.20470765948471295</span>,</span><br><span class="line"> <span class="number">1</span>: <span class="number">0.47894333805754824</span>,</span><br><span class="line"> <span class="number">2</span>: -<span class="number">0.5194387150567381</span>,</span><br><span class="line"> <span class="number">3</span>: -<span class="number">0.55573030434749</span>,</span><br><span class="line"> <span class="number">4</span>: <span class="number">1.9657805725027142</span>,</span><br><span class="line"> <span class="number">5</span>: <span class="number">1.3934058329729904</span>,</span><br><span class="line"><span class="number">6</span>: <span class="number">0.09290787674371767</span>&#125;</span><br></pre></td></tr></table></figure>
<p>前两行是Python代码语句；第二条语句创建一个名为<code>data</code>的变量，它引用一个新创建的Python字典。最后一行打印<code>data</code>的值。</p>
<p>许多Python对象被格式化为更易读的形式，或称作<code>pretty-printed</code>，它与普通的<code>print</code>不同。如果在标准Python解释器中打印上述<code>data</code>变量，则可读性要降低：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from numpy.random import randn</span><br><span class="line">&gt;&gt;&gt; data = &#123;i : randn() for i in range(7)&#125;</span><br><span class="line">&gt;&gt;&gt; print(data)</span><br><span class="line">&#123;0: -1.5948255432744511, 1: 0.10569006472787983, 2: 1.972367135977295,</span><br><span class="line">3: 0.15455217573074576, 4: -0.24058577449429575, 5: -1.2904897053651216,</span><br><span class="line">6: 0.3308507317325902&#125;</span><br></pre></td></tr></table></figure>
<p>IPython还支持执行任意代码块（通过一个华丽的复制-粘贴方法）和整段Python脚本的功能。你也可以使用Jupyter notebook运行大代码块，接下来就会看到。</p>
<h3 id="运行jupyter-notebook">2.2.2 运行Jupyter Notebook</h3>
<p>notebook是Jupyter项目的重要组件之一，它是一个代码、文本（有标记或无标记）、数据可视化或其它输出的交互式文档。Jupyter Notebook需要与内核互动，内核是Jupyter与其它编程语言的交互编程协议。Python的Jupyter内核是使用IPython。要启动Jupyter，在命令行中输入<code>jupyter notebook</code>:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ jupyter notebook</span><br><span class="line">[I 15:20:52.739 NotebookApp] Serving notebooks from local directory:</span><br><span class="line">/home/wesm/code/pydata-book</span><br><span class="line">[I 15:20:52.739 NotebookApp] 0 active kernels</span><br><span class="line">[I 15:20:52.739 NotebookApp] The Jupyter Notebook is running at:</span><br><span class="line">http://localhost:8888/</span><br><span class="line">[I 15:20:52.740 NotebookApp] Use Control-C to stop this server and shut down</span><br><span class="line">all kernels (twice to skip confirmation).</span><br><span class="line">Created new window in existing browser session.</span><br></pre></td></tr></table></figure>
<p>在多数平台上，Jupyter会自动打开默认的浏览器（除非指定了<code>--no-browser</code>）。或者，可以在启动notebook之后，手动打开网页<code>http://localhost:8888/</code>。图2-1展示了Google Chrome中的notebook。</p>
<blockquote>
<p>笔记：许多人使用Jupyter作为本地的计算环境，但它也可以部署到服务器上远程访问。这里不做介绍，如果需要的话，鼓励读者自行到网上学习。</p>
</blockquote>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-c76c4f40777d3ef1.png" class="" title="&amp;#x56FE;2-1 Jupyter notebook&amp;#x542F;&amp;#x52A8;&amp;#x9875;&amp;#x9762;">
<p>要新建一个notebook，点击按钮New，选择“Python3”或“conda[默认项]”。如果是第一次，点击空格，输入一行Python代码。然后按Shift-Enter执行。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-86a6813291ead445.png" class="" title="&amp;#x56FE;2-2 Jupyter&amp;#x65B0;notebook&amp;#x9875;&amp;#x9762;">
<p>当保存notebook时（File目录下的Save and Checkpoint），会创建一个后缀名为<code>.ipynb</code>的文件。这是一个自包含文件格式，包含当前笔记本中的所有内容（包括所有已评估的代码输出）。可以被其它Jupyter用户加载和编辑。要加载存在的notebook，把它放到启动notebook进程的相同目录内。你可以用本书的示例代码练习，见图2-3。</p>
<p>虽然Jupyter notebook和IPython shell使用起来不同，本章中几乎所有的命令和工具都可以通用。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-bc9a0b4c30363747.png" class="" title="&amp;#x56FE;2-3 Jupyter&amp;#x67E5;&amp;#x770B;&amp;#x4E00;&amp;#x4E2A;&amp;#x5B58;&amp;#x5728;&amp;#x7684;notebook&amp;#x7684;&amp;#x9875;&amp;#x9762;">
<h3 id="tab补全">2.2.3 Tab补全</h3>
<p>从外观上，IPython shell和标准的Python解释器只是看起来不同。IPython shell的进步之一是具备其它IDE和交互计算分析环境都有的tab补全功能。在shell中输入表达式，按下Tab，会搜索已输入变量（对象、函数等等）的命名空间：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [1]: an_apple = 27</span><br><span class="line"></span><br><span class="line">In [2]: an_example = 42</span><br><span class="line"></span><br><span class="line">In [3]: an&lt;Tab&gt;</span><br><span class="line">an_apple    and         an_example  any</span><br></pre></td></tr></table></figure>
<p>在这个例子中，IPython呈现出了之前两个定义的变量和Python的关键字和内建的函数<code>any</code>。当然，你也可以补全任何对象的方法和属性：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [3]: b = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">In [4]: b.&lt;Tab&gt;</span><br><span class="line">b.append  b.count   b.insert  b.reverse</span><br><span class="line">b.clear   b.extend  b.pop     b.sort</span><br><span class="line">b.copy    b.index   b.remove</span><br></pre></td></tr></table></figure>
<p>同样也适用于模块：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [1]: import datetime</span><br><span class="line"></span><br><span class="line">In [2]: datetime.&lt;Tab&gt;</span><br><span class="line">datetime.date          datetime.MAXYEAR       datetime.timedelta</span><br><span class="line">datetime.datetime      datetime.MINYEAR       datetime.timezone</span><br><span class="line">datetime.datetime_CAPI datetime.time          datetime.tzinfo</span><br></pre></td></tr></table></figure>
<p>在Jupyter notebook和新版的IPython（5.0及以上），自动补全功能是下拉框的形式。</p>
<blockquote>
<p>笔记：注意，默认情况下，IPython会隐藏下划线开头的方法和属性，比如魔术方法和内部的“私有”方法和属性，以避免混乱的显示（和让新手迷惑！）这些也可以tab补全，但是你必须首先键入一个下划线才能看到它们。如果你喜欢总是在tab补全中看到这样的方法，你可以IPython配置中进行设置。可以在IPython文档中查找方法。</p>
</blockquote>
<p>除了补全命名、对象和模块属性，Tab还可以补全其它的。当输入看似文件路径时（即使是Python字符串），按下Tab也可以补全电脑上对应的文件信息：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [7]: datasets/movielens/&lt;Tab&gt;</span><br><span class="line">datasets/movielens/movies.dat    datasets/movielens/README</span><br><span class="line">datasets/movielens/ratings.dat   datasets/movielens/users.dat</span><br><span class="line"></span><br><span class="line">In [7]: path = &#x27;datasets/movielens/&lt;Tab&gt;</span><br><span class="line">datasets/movielens/movies.dat    datasets/movielens/README</span><br><span class="line">datasets/movielens/ratings.dat   datasets/movielens/users.dat</span><br></pre></td></tr></table></figure>
<p>结合<code>%run</code>，tab补全可以节省许多键盘操作。</p>
<p>另外，tab补全可以补全函数的关键词参数（包括等于号=）。见图2-4。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-8188b0386238c16a.png" class="" title="&amp;#x56FE;2-4 Jupyter notebook&amp;#x4E2D;&amp;#x81EA;&amp;#x52A8;&amp;#x8865;&amp;#x5168;&amp;#x51FD;&amp;#x6570;&amp;#x5173;&amp;#x952E;&amp;#x8BCD;">
<p>后面会仔细地学习函数。</p>
<h3 id="自省">2.2.4 自省</h3>
<p>在变量前后使用问号？，可以显示对象的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: b?</span><br><span class="line"><span class="type">Type</span>:       <span class="built_in">list</span></span><br><span class="line">String Form:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">Length:     <span class="number">3</span></span><br><span class="line">Docstring:</span><br><span class="line"><span class="built_in">list</span>() -&gt; new empty <span class="built_in">list</span></span><br><span class="line"><span class="built_in">list</span>(iterable) -&gt; new <span class="built_in">list</span> initialized <span class="keyword">from</span> iterable<span class="string">&#x27;s items</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [10]: print?</span></span><br><span class="line"><span class="string">Docstring:</span></span><br><span class="line"><span class="string">print(value, ..., sep=&#x27;</span> <span class="string">&#x27;, end=&#x27;</span>\n<span class="string">&#x27;, file=sys.stdout, flush=False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Prints the values to a stream, or to sys.stdout by default.</span></span><br><span class="line"><span class="string">Optional keyword arguments:</span></span><br><span class="line"><span class="string">file:  a file-like object (stream); defaults to the current sys.stdout.</span></span><br><span class="line"><span class="string">sep:   string inserted between values, default a space.</span></span><br><span class="line"><span class="string">end:   string appended after the last value, default a newline.</span></span><br><span class="line"><span class="string">flush: whether to forcibly flush the stream.</span></span><br><span class="line"><span class="string">Type:      builtin_function_or_method</span></span><br></pre></td></tr></table></figure>
<p>这可以作为对象的自省。如果对象是一个函数或实例方法，定义过的文档字符串，也会显示出信息。假设我们写了一个如下的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Add two numbers together</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    the_sum : type of arguments</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<p>然后使用?符号，就可以显示如下的文档字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: add_numbers?</span><br><span class="line">Signature: add_numbers(a, b)</span><br><span class="line">Docstring:</span><br><span class="line">Add two numbers together</span><br><span class="line"></span><br><span class="line">Returns</span><br><span class="line">-------</span><br><span class="line">the_sum : <span class="built_in">type</span> of arguments</span><br><span class="line">File:      &lt;ipython-<span class="built_in">input</span>-<span class="number">9</span>-6a548a216e27&gt;</span><br><span class="line"><span class="type">Type</span>:      function</span><br></pre></td></tr></table></figure>
<p>使用??会显示函数的源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: add_numbers??</span><br><span class="line">Signature: add_numbers(a, b)</span><br><span class="line">Source:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Add two numbers together</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    the_sum : type of arguments</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">File:      &lt;ipython-<span class="built_in">input</span>-<span class="number">9</span>-6a548a216e27&gt;</span><br><span class="line"><span class="type">Type</span>:      function</span><br></pre></td></tr></table></figure>
<p>?还有一个用途，就是像Unix或Windows命令行一样搜索IPython的命名空间。字符与通配符结合可以匹配所有的名字。例如，我们可以获得所有包含load的顶级NumPy命名空间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: np.*load*?</span><br><span class="line">np.__loader__</span><br><span class="line">np.load</span><br><span class="line">np.loads</span><br><span class="line">np.loadtxt</span><br><span class="line">np.pkgload</span><br></pre></td></tr></table></figure>
<h3 id="run命令">2.2.5 %run命令</h3>
<p>你可以用<code>%run</code>命令运行所有的Python程序。假设有一个文件<code>ipython_script_test.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>):</span><br><span class="line">    <span class="keyword">return</span> (x + y) / z</span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">6</span></span><br><span class="line">c = <span class="number">7.5</span></span><br><span class="line"></span><br><span class="line">result = f(a, b, c)</span><br></pre></td></tr></table></figure>
<p>可以如下运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: %run ipython_script_test.py</span><br></pre></td></tr></table></figure>
<p>这段脚本运行在空的命名空间（没有import和其它定义的变量），因此结果和普通的运行方式<code>python script.py</code>相同。文件中所有定义的变量（import、函数和全局变量，除非抛出异常），都可以在IPython shell中随后访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: c</span><br><span class="line">Out [<span class="number">15</span>]: <span class="number">7.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: result</span><br><span class="line">Out[<span class="number">16</span>]: <span class="number">1.4666666666666666</span></span><br></pre></td></tr></table></figure>
<p>如果一个Python脚本需要命令行参数（在<code>sys.argv</code>中查找），可以在文件路径之后传递，就像在命令行上运行一样。</p>
<blockquote>
<p>笔记：如果想让一个脚本访问IPython已经定义过的变量，可以使用<code>%run -i</code>。</p>
</blockquote>
<p>在Jupyter notebook中，你也可以使用<code>%load</code>，它将脚本导入到一个代码格中：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; %load ipython_script_test.py</span><br><span class="line"></span><br><span class="line">    def f(x, y, z):</span><br><span class="line">        return (x + y) / z</span><br><span class="line">    a = 5</span><br><span class="line">    b = 6</span><br><span class="line">    c = 7.5</span><br><span class="line"></span><br><span class="line">    result = f(a, b, c)</span><br></pre></td></tr></table></figure>
<h3 id="中断运行的代码">2.2.6 中断运行的代码</h3>
<p>代码运行时按Ctrl-C，无论是%run或长时间运行命令，都会导致<code>KeyboardInterrupt</code>。这会导致几乎所有Python程序立即停止，除非一些特殊情况。</p>
<blockquote>
<p>警告：当Python代码调用了一些编译的扩展模块，按Ctrl-C不一定将执行的程序立即停止。在这种情况下，你必须等待，直到控制返回Python解释器，或者在更糟糕的情况下强制终止Python进程。</p>
</blockquote>
<h3 id="从剪贴板执行程序">2.2.7 从剪贴板执行程序</h3>
<p>如果使用Jupyter notebook，你可以将代码复制粘贴到任意代码格执行。在IPython shell中也可以从剪贴板执行。假设在其它应用中复制了如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    y = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>最简单的方法是使用<code>%paste</code>和<code>%cpaste</code>函数。<code>%paste</code>可以直接运行剪贴板中的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: %paste</span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    y = <span class="number">8</span></span><br><span class="line"><span class="comment">## -- End pasted text --</span></span><br></pre></td></tr></table></figure>
<p><code>%cpaste</code>功能类似，但会给出一条提示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: %cpaste</span><br><span class="line">Pasting code; enter <span class="string">&#x27;--&#x27;</span> alone on the line to stop <span class="keyword">or</span> use Ctrl-D.</span><br><span class="line">:x = <span class="number">5</span></span><br><span class="line">:y = <span class="number">7</span></span><br><span class="line">:<span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">:    x += <span class="number">1</span></span><br><span class="line">:</span><br><span class="line">:    y = <span class="number">8</span></span><br><span class="line">:--</span><br></pre></td></tr></table></figure>
<p>使用<code>%cpaste</code>，你可以粘贴任意多的代码再运行。你可能想在运行前，先看看代码。如果粘贴了错误的代码，可以用Ctrl-C中断。</p>
<h3 id="键盘快捷键">2.2.8 键盘快捷键</h3>
<p>IPython有许多键盘快捷键进行导航提示（类似Emacs文本编辑器或UNIX bash Shell）和交互shell的历史命令。表2-1总结了常见的快捷键。图2-5展示了一部分，如移动光标。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-9ed3866ea25c11f8.png" class="" title="&amp;#x56FE;2-5 IPython shell&amp;#x4E2D;&amp;#x4E00;&amp;#x4E9B;&amp;#x5FEB;&amp;#x6377;&amp;#x952E;&amp;#x7684;&amp;#x8BF4;&amp;#x660E;">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-e179f5ea00e50691.png" class="" title="&amp;#x8868;2-1 IPython&amp;#x7684;&amp;#x6807;&amp;#x51C6;&amp;#x5FEB;&amp;#x6377;&amp;#x952E;">
<p>Jupyter notebooks有另外一套庞大的快捷键。因为它的快捷键比IPython的变化快，建议你参阅Jupyter notebook的帮助文档。</p>
<h3 id="魔术命令">2.2.9 魔术命令</h3>
<p>IPython中特殊的命令（Python中没有）被称作“魔术”命令。这些命令可以使普通任务更便捷，更容易控制IPython系统。魔术命令是在指令前添加百分号%前缀。例如，可以用<code>%timeit</code>（这个命令后面会详谈）测量任何Python语句，例如矩阵乘法，的执行时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: a = np.random.randn(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: %timeit np.dot(a, a)</span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">20.9</span> µs per loop</span><br></pre></td></tr></table></figure>
<p>魔术命令可以被看做IPython中运行的命令行。许多魔术命令有“命令行”选项，可以通过？查看：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [21]: %debug?</span><br><span class="line">Docstring:</span><br><span class="line">::</span><br><span class="line"></span><br><span class="line">  %debug [--breakpoint FILE:LINE] [statement [statement ...]]</span><br><span class="line"></span><br><span class="line">Activate the interactive debugger.</span><br><span class="line"></span><br><span class="line">This magic command support two ways of activating debugger.</span><br><span class="line">One is to activate debugger before executing code.  This way, you</span><br><span class="line">can set a break point, to step through the code from the point.</span><br><span class="line">You can use this mode by giving statements to execute and optionally</span><br><span class="line">a breakpoint.</span><br><span class="line"></span><br><span class="line">The other one is to activate debugger in post-mortem mode.  You can</span><br><span class="line">activate this mode simply running %debug without any argument.</span><br><span class="line">If an exception has just occurred, this lets you inspect its stack</span><br><span class="line">frames interactively.  Note that this will always work only on the last</span><br><span class="line">traceback that occurred, so you must call this quickly after an</span><br><span class="line">exception that you wish to inspect has fired, because if another one</span><br><span class="line">occurs, it clobbers the previous one.</span><br><span class="line"></span><br><span class="line">If you want IPython to automatically do this on every exception, see</span><br><span class="line">the %pdb magic for more details.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  statement             Code to run in debugger. You can omit this in cell</span><br><span class="line">                        magic mode.</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  --breakpoint &lt;FILE:LINE&gt;, -b &lt;FILE:LINE&gt;</span><br><span class="line">                        Set break point at LINE in FILE.</span><br></pre></td></tr></table></figure>
<p>魔术函数默认可以不用百分号，只要没有变量和函数名相同。这个特点被称为“自动魔术”，可以用<code>%automagic</code>打开或关闭。</p>
<p>一些魔术函数与Python函数很像，它的结果可以赋值给一个变量：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [22]: %pwd</span><br><span class="line">Out[22]: &#x27;/home/wesm/code/pydata-book</span><br><span class="line"></span><br><span class="line">In [23]: foo = %pwd</span><br><span class="line"></span><br><span class="line">In [24]: foo</span><br><span class="line">Out[24]: &#x27;/home/wesm/code/pydata-book&#x27;</span><br></pre></td></tr></table></figure>
<p>IPython的文档可以在shell中打开，我建议你用<code>%quickref</code>或<code>%magic</code>学习下所有特殊命令。表2-2列出了一些可以提高生产率的交互计算和Python开发的IPython指令。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-c72b11add9b8ccf8.png" class="" title="&amp;#x8868;2-2 &amp;#x4E00;&amp;#x4E9B;&amp;#x5E38;&amp;#x7528;&amp;#x7684;IPython&amp;#x9B54;&amp;#x672F;&amp;#x547D;&amp;#x4EE4;">
<h3 id="集成matplotlib">2.2.10 集成Matplotlib</h3>
<p>IPython在分析计算领域能够流行的原因之一是它非常好的集成了数据可视化和其它用户界面库，比如matplotlib。不用担心以前没用过matplotlib，本书后面会详细介绍。<code>%matplotlib</code>魔术函数配置了IPython shell和Jupyter notebook中的matplotlib。这点很重要，其它创建的图不会出现（notebook）或获取session的控制，直到结束（shell）。</p>
<p>在IPython shell中，运行<code>%matplotlib</code>可以进行设置，可以创建多个绘图窗口，而不会干扰控制台session：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [26]: %matplotlib</span><br><span class="line">Using matplotlib backend: Qt4Agg</span><br></pre></td></tr></table></figure>
<p>在JUpyter中，命令有所不同（图2-6）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [26]: %matplotlib inline</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-3ab3738a92a15486.png" class="" title="&amp;#x56FE;2-6 Jupyter&amp;#x884C;&amp;#x5185;matplotlib&amp;#x4F5C;&amp;#x56FE;">
<h2 id="python语法基础">2.3 Python语法基础</h2>
<p>在本节中，我将概述基本的Python概念和语言机制。在下一章，我将详细介绍Python的数据结构、函数和其它内建工具。</p>
<h3 id="语言的语义">2.3.1 语言的语义</h3>
<p>Python的语言设计强调的是可读性、简洁和清晰。有些人称Python为“可执行的伪代码”。</p>
<h3 id="使用缩进而不是括号">2.3.2 使用缩进，而不是括号</h3>
<p>Python使用空白字符（tab和空格）来组织代码，而不是像其它语言，比如R、C++、JAVA和Perl那样使用括号。看一个排序算法的<code>for</code>循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array:</span><br><span class="line">    <span class="keyword">if</span> x &lt; pivot:</span><br><span class="line">        less.append(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        greater.append(x)</span><br></pre></td></tr></table></figure>
<p>冒号标志着缩进代码块的开始，冒号之后的所有代码的缩进量必须相同，直到代码块结束。不管是否喜欢这种形式，使用空白符是Python程序员开发的一部分，在我看来，这可以让python的代码可读性大大优于其它语言。虽然期初看起来很奇怪，经过一段时间，你就能适应了。</p>
<blockquote>
<p>笔记：我强烈建议你使用四个空格作为默认的缩进，可以使用tab代替四个空格。许多文本编辑器的设置是使用制表位替代空格。某些人使用tabs或不同数目的空格数，常见的是使用两个空格。大多数情况下，四个空格是大多数人采用的方法，因此建议你也这样做。</p>
</blockquote>
<p>你应该已经看到，Python的语句不需要用分号结尾。但是，分号却可以用来给同在一行的语句切分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span>; b = <span class="number">6</span>; c = <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>Python不建议将多条语句放到一行，这会降低代码的可读性。</p>
<h3 id="万物皆对象">2.3.3 万物皆对象</h3>
<p>Python语言的一个重要特性就是它的对象模型的一致性。每个数字、字符串、数据结构、函数、类、模块等等，都是在Python解释器的自有“盒子”内，它被认为是Python对象。每个对象都有类型（例如，字符串或函数）和内部数据。在实际中，这可以让语言非常灵活，因为函数也可以被当做对象使用。</p>
<h3 id="注释">2.3.4 注释</h3>
<p>任何前面带有井号#的文本都会被Python解释器忽略。这通常被用来添加注释。有时，你会想排除一段代码，但并不删除。简便的方法就是将其注释掉：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file_handle:</span><br><span class="line">    <span class="comment"># keep the empty lines for now</span></span><br><span class="line">    <span class="comment"># if len(line) == 0:</span></span><br><span class="line">    <span class="comment">#   continue</span></span><br><span class="line">    results.append(line.replace(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>也可以在执行过的代码后面添加注释。一些人习惯在代码之前添加注释，前者这种方法有时也是有用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Reached this line&quot;</span>)  <span class="comment"># Simple status report</span></span><br></pre></td></tr></table></figure>
<h3 id="函数和对象方法调用">2.3.5 函数和对象方法调用</h3>
<p>你可以用圆括号调用函数，传递零个或几个参数，或者将返回值给一个变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = f(x, y, z)</span><br><span class="line">g()</span><br></pre></td></tr></table></figure>
<p>几乎Python中的每个对象都有附加的函数，称作方法，可以用来访问对象的内容。可以用下面的语句调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj.some_method(x, y, z)</span><br></pre></td></tr></table></figure>
<p>函数可以使用位置和关键词参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = f(a, b, c, d=<span class="number">5</span>, e=<span class="string">&#x27;foo&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>后面会有更多介绍。</p>
<h3 id="变量和参数传递">2.3.6 变量和参数传递</h3>
<p>当在Python中创建变量（或名字），你就在等号右边创建了一个对这个变量的引用。考虑一个整数列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>假设将a赋值给一个新变量b：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: b = a</span><br></pre></td></tr></table></figure>
<p>在有些方法中，这个赋值会将数据[1, 2, 3]也复制。在Python中，a和b实际上是同一个对象，即原有列表[1, 2, 3]（见图2-7）。你可以在a中添加一个元素，然后检查b：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: a.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: b</span><br><span class="line">Out[<span class="number">11</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-3e3a8c6b9c5040fc.png" class="" title="&amp;#x56FE;2-7 &amp;#x5BF9;&amp;#x540C;&amp;#x4E00;&amp;#x5BF9;&amp;#x8C61;&amp;#x7684;&amp;#x53CC;&amp;#x91CD;&amp;#x5F15;&amp;#x7528;">
<p>理解Python的引用的含义，数据是何时、如何、为何复制的，是非常重要的。尤其是当你用Python处理大的数据集时。</p>
<blockquote>
<p>笔记：赋值也被称作绑定，我们是把一个名字绑定给一个对象。变量名有时可能被称为绑定变量。</p>
</blockquote>
<p>当你将对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。因此可以改变可变参数的内容。假设有以下函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">append_element</span>(<span class="params">some_list, element</span>):</span><br><span class="line">    some_list.append(element)</span><br></pre></td></tr></table></figure>
<p>然后有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: append_element(data, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: data</span><br><span class="line">Out[<span class="number">29</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h3 id="动态引用强类型">2.3.7 动态引用，强类型</h3>
<p>与许多编译语言（如JAVA和C++）对比，Python中的对象引用不包含附属的类型。下面的代码是没有问题的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: a = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out[<span class="number">13</span>]: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: a = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out[<span class="number">15</span>]: <span class="built_in">str</span></span><br></pre></td></tr></table></figure>
<p>变量是在特殊命名空间中的对象的名字，类型信息保存在对象自身中。一些人可能会说Python不是“类型化语言”。这是不正确的，看下面的例子：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [16]: &#x27;5&#x27; + 5</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-16-f9dbf5f0b234&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 &#x27;5&#x27; + 5</span><br><span class="line">TypeError: must be str, not int</span><br></pre></td></tr></table></figure>
<p>在某些语言中，例如Visual Basic，字符串‘5’可能被默许转换（或投射）为整数，因此会产生10。但在其它语言中，例如JavaScript，整数5会被投射成字符串，结果是联结字符串‘55’。在这个方面，Python被认为是强类型化语言，意味着每个对象都有明确的类型（或类），默许转换只会发生在特定的情况下，例如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [17]: a = 4.5</span><br><span class="line"></span><br><span class="line">In [18]: b = 2</span><br><span class="line"></span><br><span class="line"># String formatting, to be visited later</span><br><span class="line">In [19]: print(&#x27;a is &#123;0&#125;, b is &#123;1&#125;&#x27;.format(type(a), type(b)))</span><br><span class="line">a is &lt;class &#x27;float&#x27;&gt;, b is &lt;class &#x27;int&#x27;&gt;</span><br><span class="line"></span><br><span class="line">In [20]: a / b</span><br><span class="line">Out[20]: 2.25</span><br></pre></td></tr></table></figure>
<p>知道对象的类型很重要，最好能让函数可以处理多种类型的输入。你可以用<code>isinstance</code>函数检查对象是某个类型的实例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [21]: a = 5</span><br><span class="line"></span><br><span class="line">In [22]: isinstance(a, int)</span><br><span class="line">Out[22]: True</span><br></pre></td></tr></table></figure>
<p><code>isinstance</code>可以用类型元组，检查对象的类型是否在元组中：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [23]: a = 5; b = 4.5</span><br><span class="line"></span><br><span class="line">In [24]: isinstance(a, (int, float))</span><br><span class="line">Out[24]: True</span><br><span class="line"></span><br><span class="line">In [25]: isinstance(b, (int, float))</span><br><span class="line">Out[25]: True</span><br></pre></td></tr></table></figure>
<h3 id="属性和方法">2.3.8 属性和方法</h3>
<p>Python的对象通常都有属性（其它存储在对象内部的Python对象）和方法（对象的附属函数可以访问对象的内部数据）。可以用<code>obj.attribute_name</code>访问属性和方法：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [1]: a = &#x27;foo&#x27;</span><br><span class="line"></span><br><span class="line">In [2]: a.&lt;Press Tab&gt;</span><br><span class="line">a.capitalize  a.format      a.isupper     a.rindex      a.strip</span><br><span class="line">a.center      a.index       a.join        a.rjust       a.swapcase</span><br><span class="line">a.count       a.isalnum     a.ljust       a.rpartition  a.title</span><br><span class="line">a.decode      a.isalpha     a.lower       a.rsplit      a.translate</span><br><span class="line">a.encode      a.isdigit     a.lstrip      a.rstrip      a.upper</span><br><span class="line">a.endswith    a.islower     a.partition   a.split       a.zfill</span><br><span class="line">a.expandtabs  a.isspace     a.replace     a.splitlines</span><br><span class="line">a.find        a.istitle     a.rfind       a.startswith</span><br></pre></td></tr></table></figure>
<p>也可以用<code>getattr</code>函数，通过名字访问属性和方法：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [27]: getattr(a, &#x27;split&#x27;)</span><br><span class="line">Out[27]: &lt;function str.split&gt;</span><br></pre></td></tr></table></figure>
<p>在其它语言中，访问对象的名字通常称作“反射”。本书不会大量使用<code>getattr</code>函数和相关的<code>hasattr</code>和<code>setattr</code>函数，使用这些函数可以高效编写原生的、可重复使用的代码。</p>
<h3 id="鸭子类型">2.3.9 鸭子类型</h3>
<p>经常地，你可能不关心对象的类型，只关心对象是否有某些方法或用途。这通常被称为“鸭子类型”，来自“走起来像鸭子、叫起来像鸭子，那么它就是鸭子”的说法。例如，你可以通过验证一个对象是否遵循迭代协议，判断它是可迭代的。对于许多对象，这意味着它有一个<code>__iter__</code>魔术方法，其它更好的判断方法是使用<code>iter</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isiterable</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">iter</span>(obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> TypeError: <span class="comment"># not iterable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>这个函数会返回字符串以及大多数Python集合类型为<code>True</code>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">In [29]: isiterable(&#x27;a string&#x27;)</span><br><span class="line">Out[29]: True</span><br><span class="line"></span><br><span class="line">In [30]: isiterable([1, 2, 3])</span><br><span class="line">Out[30]: True</span><br><span class="line"></span><br><span class="line">In [31]: isiterable(5)</span><br><span class="line">Out[31]: False</span><br></pre></td></tr></table></figure>
<p>我总是用这个功能编写可以接受多种输入类型的函数。常见的例子是编写一个函数可以接受任意类型的序列（list、tuple、ndarray）或是迭代器。你可先检验对象是否是列表（或是NUmPy数组），如果不是的话，将其转变成列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, <span class="built_in">list</span>) <span class="keyword">and</span> isiterable(x):</span><br><span class="line">    x = <span class="built_in">list</span>(x)</span><br></pre></td></tr></table></figure>
<h3 id="引入">2.3.10 引入</h3>
<p>在Python中，模块就是一个有<code>.py</code>扩展名、包含Python代码的文件。假设有以下模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># some_module.py</span></span><br><span class="line">PI = <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<p>如果想从同目录下的另一个文件访问<code>some_module.py</code>中定义的变量和函数，可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> some_module</span><br><span class="line">result = some_module.f(<span class="number">5</span>)</span><br><span class="line">pi = some_module.PI</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> some_module <span class="keyword">import</span> f, g, PI</span><br><span class="line">result = g(<span class="number">5</span>, PI)</span><br></pre></td></tr></table></figure>
<p>使用<code>as</code>关键词，你可以给引入起不同的变量名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> some_module <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">from</span> some_module <span class="keyword">import</span> PI <span class="keyword">as</span> pi, g <span class="keyword">as</span> gf</span><br><span class="line"></span><br><span class="line">r1 = sm.f(pi)</span><br><span class="line">r2 = gf(<span class="number">6</span>, pi)</span><br></pre></td></tr></table></figure>
<h3 id="二元运算符和比较运算符">2.3.11 二元运算符和比较运算符</h3>
<p>大多数二元数学运算和比较都不难想到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: <span class="number">5</span> - <span class="number">7</span></span><br><span class="line">Out[<span class="number">32</span>]: -<span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: <span class="number">12</span> + <span class="number">21.5</span></span><br><span class="line">Out[<span class="number">33</span>]: <span class="number">33.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: <span class="number">5</span> &lt;= <span class="number">2</span></span><br><span class="line">Out[<span class="number">34</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>表2-3列出了所有的二元运算符。</p>
<p>要判断两个引用是否指向同一个对象，可以使用<code>is</code>方法。<code>is not</code>可以判断两个对象是不同的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: b = a</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: c = <span class="built_in">list</span>(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: a <span class="keyword">is</span> b</span><br><span class="line">Out[<span class="number">38</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: a <span class="keyword">is</span> <span class="keyword">not</span> c</span><br><span class="line">Out[<span class="number">39</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>因为<code>list</code>总是创建一个新的Python列表（即复制），我们可以断定c是不同于a的。使用<code>is</code>比较与<code>==</code>运算符不同，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: a == c</span><br><span class="line">Out[<span class="number">40</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><code>is</code>和<code>is not</code>常用来判断一个变量是否为<code>None</code>，因为只有一个<code>None</code>的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: a = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: a <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">Out[<span class="number">42</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-9fb5f25b33166acf.png" class="" title="&amp;#x8868;2-3 &amp;#x4E8C;&amp;#x5143;&amp;#x8FD0;&amp;#x7B97;&amp;#x7B26;">
<h3 id="可变与不可变对象">2.3.12 可变与不可变对象</h3>
<p>Python中的大多数对象，比如列表、字典、NumPy数组，和用户定义的类型（类），都是可变的。意味着这些对象或包含的值可以被修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: a_list = [<span class="string">&#x27;foo&#x27;</span>, <span class="number">2</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: a_list[<span class="number">2</span>] = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: a_list</span><br><span class="line">Out[<span class="number">45</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="number">2</span>, (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<p>其它的，例如字符串和元组，是不可变的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: a_tuple = (<span class="number">3</span>, <span class="number">5</span>, (<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: a_tuple[<span class="number">1</span>] = <span class="string">&#x27;four&#x27;</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">47</span>-b7966a9ae0f1&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> a_tuple[<span class="number">1</span>] = <span class="string">&#x27;four&#x27;</span></span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>
<p>记住，可以修改一个对象并不意味就要修改它。这被称为副作用。例如，当写一个函数，任何副作用都要在文档或注释中写明。如果可能的话，我推荐避免副作用，采用不可变的方式，即使要用到可变对象。</p>
<h3 id="标量类型">2.3.13 标量类型</h3>
<p>Python的标准库中有一些内建的类型，用于处理数值数据、字符串、布尔值，和日期时间。这些单值类型被称为标量类型，本书中称其为标量。表2-4列出了主要的标量。日期和时间处理会另外讨论，因为它们是标准库的<code>datetime</code>模块提供的。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-27a30ac3e7d262a1.png" class="" title="&amp;#x8868;2-4 Python&amp;#x7684;&amp;#x6807;&amp;#x91CF;">
<h3 id="数值类型">2.3.14 数值类型</h3>
<p>Python的主要数值类型是<code>int</code>和<code>float</code>。<code>int</code>可以存储任意大的数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">48</span>]: ival = <span class="number">17239871</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: ival ** <span class="number">6</span></span><br><span class="line">Out[<span class="number">49</span>]: <span class="number">26254519291092456596965462913230729701102721</span></span><br></pre></td></tr></table></figure>
<p>浮点数使用Python的<code>float</code>类型。每个数都是双精度（64位）的值。也可以用科学计数法表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: fval = <span class="number">7.243</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: fval2 = <span class="number">6.78e-5</span></span><br></pre></td></tr></table></figure>
<p>不能得到整数的除法会得到浮点数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">52</span>]: <span class="number">3</span> / <span class="number">2</span></span><br><span class="line">Out[<span class="number">52</span>]: <span class="number">1.5</span></span><br></pre></td></tr></table></figure>
<p>要获得C-风格的整除（去掉小数部分），可以使用底除运算符//：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">53</span>]: <span class="number">3</span> // <span class="number">2</span></span><br><span class="line">Out[<span class="number">53</span>]: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串">2.3.15 字符串</h3>
<p>许多人是因为Python强大而灵活的字符串处理而使用Python的。你可以用单引号或双引号来写字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;one way of writing a string&#x27;</span></span><br><span class="line">b = <span class="string">&quot;another way&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于有换行符的字符串，可以使用三引号，'''或"""都行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">This is a longer string that</span></span><br><span class="line"><span class="string">spans multiple lines</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>字符串<code>c</code>实际包含四行文本，"""后面和lines后面的换行符。可以用<code>count</code>方法计算<code>c</code>中的新的行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: c.count(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">Out[<span class="number">55</span>]: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Python的字符串是不可变的，不能修改字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: a = <span class="string">&#x27;this is a string&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: a[<span class="number">10</span>] = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">57</span>-5ca625d1e504&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> a[<span class="number">10</span>] = <span class="string">&#x27;f&#x27;</span></span><br><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: b = a.replace(<span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;longer string&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: b</span><br><span class="line">Out[<span class="number">59</span>]: <span class="string">&#x27;this is a longer string&#x27;</span></span><br></pre></td></tr></table></figure>
<p>经过以上的操作，变量<code>a</code>并没有被修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: a</span><br><span class="line">Out[<span class="number">60</span>]: <span class="string">&#x27;this is a string&#x27;</span></span><br></pre></td></tr></table></figure>
<p>许多Python对象使用<code>str</code>函数可以被转化为字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: a = <span class="number">5.6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: s = <span class="built_in">str</span>(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: <span class="built_in">print</span>(s)</span><br><span class="line"><span class="number">5.6</span></span><br></pre></td></tr></table></figure>
<p>字符串是一个序列的Unicode字符，因此可以像其它序列，比如列表和元组（下一章会详细介绍两者）一样处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: s = <span class="string">&#x27;python&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: <span class="built_in">list</span>(s)</span><br><span class="line">Out[<span class="number">65</span>]: [<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: s[:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">66</span>]: <span class="string">&#x27;pyt&#x27;</span></span><br></pre></td></tr></table></figure>
<p>语法<code>s[:3]</code>被称作切片，适用于许多Python序列。后面会更详细的介绍，本书中用到很多切片。</p>
<p>反斜杠是转义字符，意思是它备用来表示特殊字符，比如换行符。要写一个包含反斜杠的字符串，需要进行转义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: s = <span class="string">&#x27;12\\34&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: <span class="built_in">print</span>(s)</span><br><span class="line"><span class="number">12</span>\<span class="number">34</span></span><br></pre></td></tr></table></figure>
<p>如果字符串中包含许多反斜杠，但没有特殊字符，这样做就很麻烦。幸好，可以在字符串前面加一个r，表明字符就是它自身：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: s = <span class="string">r&#x27;this\has\no\special\characters&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: s</span><br><span class="line">Out[<span class="number">70</span>]: <span class="string">&#x27;this\\has\\no\\special\\characters&#x27;</span></span><br></pre></td></tr></table></figure>
<p>r表示raw。</p>
<p>将两个字符串合并，会产生一个新的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: a = <span class="string">&#x27;this is the first half &#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: b = <span class="string">&#x27;and this is the second half&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: a + b</span><br><span class="line">Out[<span class="number">73</span>]: <span class="string">&#x27;this is the first half and this is the second half&#x27;</span></span><br></pre></td></tr></table></figure>
<p>字符串的模板化或格式化，是另一个重要的主题。Python 3拓展了此类的方法，这里只介绍一些。字符串对象有<code>format</code>方法，可以替换格式化的参数为字符串，产生一个新的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: template = <span class="string">&#x27;&#123;0:.2f&#125; &#123;1:s&#125; are worth US$&#123;2:d&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在这个字符串中，</p>
<ul>
<li><code>&#123;0:.2f&#125;</code>表示格式化第一个参数为带有两位小数的浮点数。</li>
<li><code>&#123;1:s&#125;</code>表示格式化第二个参数为字符串。</li>
<li><code>&#123;2:d&#125;</code>表示格式化第三个参数为一个整数。</li>
</ul>
<p>要替换参数为这些格式化的参数，我们传递<code>format</code>方法一个序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: template.<span class="built_in">format</span>(<span class="number">4.5560</span>, <span class="string">&#x27;Argentine Pesos&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">Out[<span class="number">75</span>]: <span class="string">&#x27;4.56 Argentine Pesos are worth US$1&#x27;</span></span><br></pre></td></tr></table></figure>
<p>字符串格式化是一个很深的主题，有多种方法和大量的选项，可以控制字符串中的值是如何格式化的。推荐参阅Python官方文档。</p>
<p>这里概括介绍字符串处理，第8章的数据分析会详细介绍。</p>
<h3 id="字节和unicode">2.3.16 字节和Unicode</h3>
<p>在Python 3及以上版本中，Unicode是一级的字符串类型，这样可以更一致的处理ASCII和Non-ASCII文本。在老的Python版本中，字符串都是字节，不使用Unicode编码。假如知道字符编码，可以将其转化为Unicode。看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: val = <span class="string">&quot;español&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: val</span><br><span class="line">Out[<span class="number">77</span>]: <span class="string">&#x27;español&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>encode</code>将这个Unicode字符串编码为UTF-8：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: val_utf8 = val.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: val_utf8</span><br><span class="line">Out[<span class="number">79</span>]: <span class="string">b&#x27;espa\xc3\xb1ol&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: <span class="built_in">type</span>(val_utf8)</span><br><span class="line">Out[<span class="number">80</span>]: <span class="built_in">bytes</span></span><br></pre></td></tr></table></figure>
<p>如果你知道一个字节对象的Unicode编码，用<code>decode</code>方法可以解码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: val_utf8.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">Out[<span class="number">81</span>]: <span class="string">&#x27;español&#x27;</span></span><br></pre></td></tr></table></figure>
<p>虽然UTF-8编码已经变成主流，但因为历史的原因，你仍然可能碰到其它编码的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: val.encode(<span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line">Out[<span class="number">82</span>]: <span class="string">b&#x27;espa\xf1ol&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: val.encode(<span class="string">&#x27;utf-16&#x27;</span>)</span><br><span class="line">Out[<span class="number">83</span>]: <span class="string">b&#x27;\xff\xfee\x00s\x00p\x00a\x00\xf1\x00o\x00l\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: val.encode(<span class="string">&#x27;utf-16le&#x27;</span>)</span><br><span class="line">Out[<span class="number">84</span>]: <span class="string">b&#x27;e\x00s\x00p\x00a\x00\xf1\x00o\x00l\x00&#x27;</span></span><br></pre></td></tr></table></figure>
<p>工作中碰到的文件很多都是字节对象，盲目地将所有数据编码为Unicode是不可取的。</p>
<p>虽然用的不多，你可以在字节文本的前面加上一个b：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: bytes_val = <span class="string">b&#x27;this is bytes&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: bytes_val</span><br><span class="line">Out[<span class="number">86</span>]: <span class="string">b&#x27;this is bytes&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: decoded = bytes_val.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: decoded  <span class="comment"># this is str (Unicode) now</span></span><br><span class="line">Out[<span class="number">88</span>]: <span class="string">&#x27;this is bytes&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="布尔值">2.3.17 布尔值</h3>
<p>Python中的布尔值有两个，True和False。比较和其它条件表达式可以用True和False判断。布尔值可以与and和or结合使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: <span class="literal">True</span> <span class="keyword">and</span> <span class="literal">True</span></span><br><span class="line">Out[<span class="number">89</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: <span class="literal">False</span> <span class="keyword">or</span> <span class="literal">True</span></span><br><span class="line">Out[<span class="number">90</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="类型转换">2.3.18 类型转换</h3>
<p>str、bool、int和float也是函数，可以用来转换类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: s = <span class="string">&#x27;3.14159&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: fval = <span class="built_in">float</span>(s)</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: <span class="built_in">type</span>(fval)</span><br><span class="line">Out[<span class="number">93</span>]: <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: <span class="built_in">int</span>(fval)</span><br><span class="line">Out[<span class="number">94</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: <span class="built_in">bool</span>(fval)</span><br><span class="line">Out[<span class="number">95</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: <span class="built_in">bool</span>(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">96</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="none">2.3.19 None</h3>
<p>None是Python的空值类型。如果一个函数没有明确的返回值，就会默认返回None：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">97</span>]: a = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: a <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">Out[<span class="number">98</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: b = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: b <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">Out[<span class="number">100</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>None也常常作为函数的默认参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_and_maybe_multiply</span>(<span class="params">a, b, c=<span class="literal">None</span></span>):</span><br><span class="line">    result = a + b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        result = result * c</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>另外，None不仅是一个保留字，还是唯一的NoneType的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: <span class="built_in">type</span>(<span class="literal">None</span>)</span><br><span class="line">Out[<span class="number">101</span>]: NoneType</span><br></pre></td></tr></table></figure>
<h3 id="日期和时间">2.3.20 日期和时间</h3>
<p>Python内建的<code>datetime</code>模块提供了<code>datetime</code>、<code>date</code>和<code>time</code>类型。<code>datetime</code>类型结合了<code>date</code>和<code>time</code>，是最常使用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, time</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: dt = datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: dt.day</span><br><span class="line">Out[<span class="number">104</span>]: <span class="number">29</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: dt.minute</span><br><span class="line">Out[<span class="number">105</span>]: <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>根据<code>datetime</code>实例，你可以用<code>date</code>和<code>time</code>提取出各自的对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: dt.date()</span><br><span class="line">Out[<span class="number">106</span>]: datetime.date(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: dt.time()</span><br><span class="line">Out[<span class="number">107</span>]: datetime.time(<span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure>
<p><code>strftime</code>方法可以将datetime格式化为字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: dt.strftime(<span class="string">&#x27;%m/%d/%Y %H:%M&#x27;</span>)</span><br><span class="line">Out[<span class="number">108</span>]: <span class="string">&#x27;10/29/2011 20:30&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>strptime</code>可以将字符串转换成<code>datetime</code>对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: datetime.strptime(<span class="string">&#x27;20091031&#x27;</span>, <span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">Out[<span class="number">109</span>]: datetime.datetime(<span class="number">2009</span>, <span class="number">10</span>, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>表2-5列出了所有的格式化命令。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap02/7178691-100f9a20c1536553.png" class="" title="&amp;#x8868;2-5 Datetime&amp;#x683C;&amp;#x5F0F;&amp;#x5316;&amp;#x6307;&amp;#x4EE4;&amp;#xFF08;&amp;#x4E0E;ISO C89&amp;#x517C;&amp;#x5BB9;&amp;#xFF09;">
<p>当你聚类或对时间序列进行分组，替换datetimes的time字段有时会很有用。例如，用0替换分和秒：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: dt.replace(minute=<span class="number">0</span>, second=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">110</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>因为<code>datetime.datetime</code>是不可变类型，上面的方法会产生新的对象。</p>
<p>两个datetime对象的差会产生一个<code>datetime.timedelta</code>类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">111</span>]: dt2 = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: delta = dt2 - dt</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: delta</span><br><span class="line">Out[<span class="number">113</span>]: datetime.timedelta(<span class="number">17</span>, <span class="number">7179</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: <span class="built_in">type</span>(delta)</span><br><span class="line">Out[<span class="number">114</span>]: datetime.timedelta</span><br></pre></td></tr></table></figure>
<p>结果<code>timedelta(17, 7179)</code>指明了<code>timedelta</code>将17天、7179秒的编码方式。</p>
<p>将<code>timedelta</code>添加到<code>datetime</code>，会产生一个新的偏移<code>datetime</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: dt</span><br><span class="line">Out[<span class="number">115</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: dt + delta</span><br><span class="line">Out[<span class="number">116</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<h3 id="控制流">2.3.21 控制流</h3>
<p>Python有若干内建的关键字进行条件逻辑、循环和其它控制流操作。</p>
<h3 id="ifelif和else">2.3.22 if、elif和else</h3>
<p>if是最广为人知的控制流语句。它检查一个条件，如果为True，就执行后面的语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;It&#x27;</span>s negative<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>
<p><code>if</code>后面可以跟一个或多个<code>elif</code>，所有条件都是False时，还可以添加一个<code>else</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;It&#x27;</span>s negative<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">elif x == 0:</span></span><br><span class="line"><span class="string">    print(&#x27;</span>Equal to zero<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">elif 0 &lt; x &lt; 5:</span></span><br><span class="line"><span class="string">    print(&#x27;</span>Positive but smaller than <span class="number">5</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    print(&#x27;</span>Positive <span class="keyword">and</span> larger than <span class="keyword">or</span> equal to <span class="number">5</span><span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>如果某个条件为True，后面的<code>elif</code>就不会被执行。当使用and和or时，复合条件语句是从左到右执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: a = <span class="number">5</span>; b = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: c = <span class="number">8</span>; d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: <span class="keyword">if</span> a &lt; b <span class="keyword">or</span> c &gt; d:</span><br><span class="line">   .....:     <span class="built_in">print</span>(<span class="string">&#x27;Made it&#x27;</span>)</span><br><span class="line">Made it</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>c &gt; d</code>不会被执行，因为第一个比较是True：</p>
<p>也可以把比较式串在一起：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">120</span>]: <span class="number">4</span> &gt; <span class="number">3</span> &gt; <span class="number">2</span> &gt; <span class="number">1</span></span><br><span class="line">Out[<span class="number">120</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="for循环">2.3.23 for循环</h3>
<p>for循环是在一个集合（列表或元组）中进行迭代，或者就是一个迭代器。for循环的标准语法是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="comment"># do something with value</span></span><br></pre></td></tr></table></figure>
<p>你可以用continue使for循环提前，跳过剩下的部分。看下面这个例子，将一个列表中的整数相加，跳过None：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sequence = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">None</span>, <span class="number">4</span>, <span class="literal">None</span>, <span class="number">5</span>]</span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> sequence:</span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    total += value</span><br></pre></td></tr></table></figure>
<p>可以用<code>break</code>跳出for循环。下面的代码将各元素相加，直到遇到5：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sequence = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">total_until_5 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> sequence:</span><br><span class="line">    <span class="keyword">if</span> value == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    total_until_5 += value</span><br></pre></td></tr></table></figure>
<p>break只中断for循环的最内层，其余的for循环仍会运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">121</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">   .....:     <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">   .....:         <span class="keyword">if</span> j &gt; i:</span><br><span class="line">   .....:             <span class="keyword">break</span></span><br><span class="line">   .....:         <span class="built_in">print</span>((i, j))</span><br><span class="line">   .....:</span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>如果集合或迭代器中的元素序列（元组或列表），可以用for循环将其方便地拆分成变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> iterator:</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure>
<h3 id="while循环">2.3.24 While循环</h3>
<p>while循环指定了条件和代码，当条件为False或用break退出循环，代码才会退出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">256</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> total &gt; <span class="number">500</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    total += x</span><br><span class="line">    x = x // <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="pass">2.3.25 pass</h3>
<p>pass是Python中的非操作语句。代码块不需要任何动作时可以使用（作为未执行代码的占位符）；因为Python需要使用空白字符划定代码块，所以需要pass：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;negative!&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> put something smart here</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;positive!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="range">2.3.26 range</h3>
<p>range函数返回一个迭代器，它产生一个均匀分布的整数序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">122</span>]: <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">122</span>]: <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">Out[<span class="number">123</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>range的三个参数是（起点，终点，步进）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">124</span>]: <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">20</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">124</span>]: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>, <span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">Out[<span class="number">125</span>]: [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>可以看到，range产生的整数不包括终点。range的常见用法是用序号迭代序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(seq)):</span><br><span class="line">    val = seq[i]</span><br></pre></td></tr></table></figure>
<p>可以使用list来存储range在其他数据结构中生成的所有整数，默认的迭代器形式通常是你想要的。下面的代码对0到99999中3或5的倍数求和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">    <span class="comment"># % is the modulo operator</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">or</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">sum</span> += i</span><br></pre></td></tr></table></figure>
<p>虽然range可以产生任意大的数，但任意时刻耗用的内存却很小。</p>
<h3 id="三元表达式">2.3.27 三元表达式</h3>
<p>Python中的三元表达式可以将if-else语句放到一行里。语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = true-expr <span class="keyword">if</span> condition <span class="keyword">else</span> false-expr</span><br></pre></td></tr></table></figure>
<p><code>true-expr</code>或<code>false-expr</code>可以是任何Python代码。它和下面的代码效果相同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">    value = true-expr</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    value = false-expr</span><br></pre></td></tr></table></figure>
<p>下面是一个更具体的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">126</span>]: x = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: <span class="string">&#x27;Non-negative&#x27;</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;Negative&#x27;</span></span><br><span class="line">Out[<span class="number">127</span>]: <span class="string">&#x27;Non-negative&#x27;</span></span><br></pre></td></tr></table></figure>
<p>和if-else一样，只有一个表达式会被执行。因此，三元表达式中的if和else可以包含大量的计算，但只有True的分支会被执行。因此，三元表达式中的if和else可以包含大量的计算，但只有True的分支会被执行。</p>
<p>虽然使用三元表达式可以压缩代码，但会降低代码可读性。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析__第03章_Python的数据结构、函数和文件</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap03/</url>
    <content><![CDATA[<h1 id="第03章-python的数据结构函数和文件">第03章 Python的数据结构、函数和文件</h1>
<p>本章讨论Python的内置功能，这些功能本书会用到很多。虽然扩展库，比如pandas和Numpy，使处理大数据集很方便，但它们是和Python的内置数据处理工具一同使用的。</p>
<span id="more"></span>
<p>我们会从Python最基础的数据结构开始：元组、列表、字典和集合。然后会讨论创建你自己的、可重复使用的Python函数。最后，会学习Python的文件对象，以及如何与本地硬盘交互。</p>
<h2 id="数据结构和序列">3.1 数据结构和序列</h2>
<p>Python的数据结构简单而强大。通晓它们才能成为熟练的Python程序员。</p>
<h3 id="元组">3.1.1 元组</h3>
<p>元组是一个固定长度，不可改变的Python序列对象。创建元组的最简单方式，是用逗号分隔一列值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: tup = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: tup</span><br><span class="line">Out[<span class="number">2</span>]: (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>当用复杂的表达式定义元组，最好将值放到圆括号内，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: nested_tup = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: nested_tup</span><br><span class="line">Out[<span class="number">4</span>]: ((<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p>用<code>tuple</code>可以将任意序列或迭代器转换成元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: <span class="built_in">tuple</span>([<span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line">Out[<span class="number">5</span>]: (<span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: tup = <span class="built_in">tuple</span>(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: tup</span><br><span class="line">Out[<span class="number">7</span>]: (<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可以用方括号访问元组中的元素。和C、C++、JAVA等语言一样，序列是从0开始的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: tup[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">&#x27;s&#x27;</span></span><br></pre></td></tr></table></figure>
<p>元组中存储的对象可能是可变对象。一旦创建了元组，元组中的对象就不能修改了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: tup = <span class="built_in">tuple</span>([<span class="string">&#x27;foo&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="literal">True</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: tup[<span class="number">2</span>] = <span class="literal">False</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">10</span>-c7308343b841&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> tup[<span class="number">2</span>] = <span class="literal">False</span></span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>
<p>如果元组中的某个对象是可变的，比如列表，可以在原位进行修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: tup[<span class="number">1</span>].append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: tup</span><br><span class="line">Out[<span class="number">12</span>]: (<span class="string">&#x27;foo&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>可以用加号运算符将元组串联起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: (<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>) + (<span class="number">6</span>, <span class="number">0</span>) + (<span class="string">&#x27;bar&#x27;</span>,)</span><br><span class="line">Out[<span class="number">13</span>]: (<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>元组乘以一个整数，像列表一样，会将几个元组的复制串联起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: (<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>) * <span class="number">4</span></span><br><span class="line">Out[<span class="number">14</span>]: (<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>对象本身并没有被复制，只是引用了它。</p>
<h3 id="拆分元组">3.1.2 拆分元组</h3>
<p>如果你想将元组赋值给类似元组的变量，Python会试图拆分等号右边的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: tup = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: a, b, c = tup</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: b</span><br><span class="line">Out[<span class="number">17</span>]: <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>即使含有元组的元组也会被拆分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: tup = <span class="number">4</span>, <span class="number">5</span>, (<span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: a, b, (c, d) = tup</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: d</span><br><span class="line">Out[<span class="number">20</span>]: <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>使用这个功能，你可以很容易地替换变量的名字，其它语言可能是这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tmp = a</span><br><span class="line">a = b</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure>
<p>但是在Python中，替换可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: a</span><br><span class="line">Out[<span class="number">22</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: b</span><br><span class="line">Out[<span class="number">23</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: b, a = a, b</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: a</span><br><span class="line">Out[<span class="number">25</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: b</span><br><span class="line">Out[<span class="number">26</span>]: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>变量拆分常用来迭代元组或列表序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: seq = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: <span class="keyword">for</span> a, b, c <span class="keyword">in</span> seq:</span><br><span class="line">   ....:     <span class="built_in">print</span>(<span class="string">&#x27;a=&#123;0&#125;, b=&#123;1&#125;, c=&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(a, b, c))</span><br><span class="line">a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span></span><br><span class="line">a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span></span><br><span class="line">a=<span class="number">7</span>, b=<span class="number">8</span>, c=<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>另一个常见用法是从函数返回多个值。后面会详解。</p>
<p>Python最近新增了更多高级的元组拆分功能，允许从元组的开头“摘取”几个元素。它使用了特殊的语法<code>*rest</code>，这也用在函数签名中以抓取任意长度列表的位置参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: values = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: a, b, *rest = values</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: a, b</span><br><span class="line">Out[<span class="number">31</span>]: (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: rest</span><br><span class="line">Out[<span class="number">32</span>]: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p><code>rest</code>的部分是想要舍弃的部分，rest的名字不重要。作为惯用写法，许多Python程序员会将不需要的变量使用下划线：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: a, b, *_ = values</span><br></pre></td></tr></table></figure>
<h3 id="tuple方法">3.1.3 tuple方法</h3>
<p>因为元组的大小和内容不能修改，它的实例方法都很轻量。其中一个很有用的就是<code>count</code>（也适用于列表），它可以统计某个值得出现频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: a.count(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">35</span>]: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="列表">3.1.4 列表</h3>
<p>与元组对比，列表的长度可变、内容可以被修改。你可以用方括号定义，或用<code>list</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">36</span>]: a_list = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: tup = (<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: b_list = <span class="built_in">list</span>(tup)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: b_list</span><br><span class="line">Out[<span class="number">39</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: b_list[<span class="number">1</span>] = <span class="string">&#x27;peekaboo&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: b_list</span><br><span class="line">Out[<span class="number">41</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;peekaboo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>列表和元组的语义接近，在许多函数中可以交叉使用。</p>
<p><code>list</code>函数常用来在数据处理中实体化迭代器或生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">42</span>]: gen = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: gen</span><br><span class="line">Out[<span class="number">43</span>]: <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: <span class="built_in">list</span>(gen)</span><br><span class="line">Out[<span class="number">44</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<h3 id="添加和删除元素">3.1.5 添加和删除元素</h3>
<p>可以用<code>append</code>在列表末尾添加元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: b_list.append(<span class="string">&#x27;dwarf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: b_list</span><br><span class="line">Out[<span class="number">46</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;peekaboo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;dwarf&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p><code>insert</code>可以在特定的位置插入元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: b_list.insert(<span class="number">1</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: b_list</span><br><span class="line">Out[<span class="number">48</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;peekaboo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;dwarf&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>插入的序号必须在0和列表长度之间。</p>
<blockquote>
<p>警告：与<code>append</code>相比，<code>insert</code>耗费的计算量大，因为对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，你可能需要使用<code>collections.deque</code>，一个双尾部队列。</p>
</blockquote>
<p>insert的逆运算是pop，它移除并返回指定位置的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: b_list.pop(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">49</span>]: <span class="string">&#x27;peekaboo&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: b_list</span><br><span class="line">Out[<span class="number">50</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;dwarf&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>可以用<code>remove</code>去除某个值，<code>remove</code>会先寻找第一个值并除去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: b_list.append(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: b_list</span><br><span class="line">Out[<span class="number">52</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;dwarf&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: b_list.remove(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: b_list</span><br><span class="line">Out[<span class="number">54</span>]: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;dwarf&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>如果不考虑性能，使用<code>append</code>和<code>remove</code>，可以把Python的列表当做完美的“多重集”数据结构。</p>
<p>用<code>in</code>可以检查列表是否包含某个值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: <span class="string">&#x27;dwarf&#x27;</span> <span class="keyword">in</span> b_list</span><br><span class="line">Out[<span class="number">55</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>否定<code>in</code>可以再加一个not：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: <span class="string">&#x27;dwarf&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> b_list</span><br><span class="line">Out[<span class="number">56</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>在列表中检查是否存在某个值远比字典和集合速度慢，因为Python是线性搜索列表中的值，但在字典和集合中，在同样的时间内还可以检查其它项（基于哈希表）。</p>
<h3 id="串联和组合列表">3.1.6 串联和组合列表</h3>
<p>与元组类似，可以用加号将两个列表串联起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>] + [<span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line">Out[<span class="number">57</span>]: [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<p>如果已经定义了一个列表，用<code>extend</code>方法可以追加多个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: x = [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: x.extend([<span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: x</span><br><span class="line">Out[<span class="number">60</span>]: [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<p>通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用<code>extend</code>追加元素，尤其是到一个大列表中，更为可取。因此：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">everything = []</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> list_of_lists:</span><br><span class="line">    everything.extend(chunk)</span><br></pre></td></tr></table></figure>
<p>要比串联方法快：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">everything = []</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> list_of_lists:</span><br><span class="line">    everything = everything + chunk</span><br></pre></td></tr></table></figure>
<h3 id="排序">3.1.7 排序</h3>
<p>你可以用<code>sort</code>函数将一个列表原地排序（不创建新的对象）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: a = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: a.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: a</span><br><span class="line">Out[<span class="number">63</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p><code>sort</code>有一些选项，有时会很好用。其中之一是二级排序key，可以用这个key进行排序。例如，我们可以按长度对字符串进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: b = [<span class="string">&#x27;saw&#x27;</span>, <span class="string">&#x27;small&#x27;</span>, <span class="string">&#x27;He&#x27;</span>, <span class="string">&#x27;foxes&#x27;</span>, <span class="string">&#x27;six&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: b.sort(key=<span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: b</span><br><span class="line">Out[<span class="number">66</span>]: [<span class="string">&#x27;He&#x27;</span>, <span class="string">&#x27;saw&#x27;</span>, <span class="string">&#x27;six&#x27;</span>, <span class="string">&#x27;small&#x27;</span>, <span class="string">&#x27;foxes&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>稍后，我们会学习<code>sorted</code>函数，它可以产生一个排好序的序列副本。</p>
<h3 id="二分搜索和维护已排序的列表">3.1.8 二分搜索和维护已排序的列表</h3>
<p><code>bisect</code>模块支持二分查找，和向已排序的列表插入值。<code>bisect.bisect</code>可以找到插入值后仍保证排序的位置，<code>bisect.insort</code>是向这个位置插入值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: <span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: bisect.bisect(c, <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">69</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: bisect.bisect(c, <span class="number">5</span>)</span><br><span class="line">Out[<span class="number">70</span>]: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: bisect.insort(c, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: c</span><br><span class="line">Out[<span class="number">72</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>bisect</code>模块不会检查列表是否已排好序，进行检查的话会耗费大量计算。因此，对未排序的列表使用<code>bisect</code>不会产生错误，但结果不一定正确。</p>
</blockquote>
<h3 id="切片">3.1.9 切片</h3>
<p>用切边可以选取大多数序列类型的一部分，切片的基本形式是在方括号中使用<code>start:stop</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: seq = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: seq[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">74</span>]: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>切片也可以被序列赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: seq[<span class="number">3</span>:<span class="number">4</span>] = [<span class="number">6</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: seq</span><br><span class="line">Out[<span class="number">76</span>]: [<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>切片的起始元素是包括的，不包含结束元素。因此，结果中包含的元素个数是<code>stop - start</code>。</p>
<p><code>start</code>或<code>stop</code>都可以被省略，省略之后，分别默认序列的开头和结尾：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: seq[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">77</span>]: [<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: seq[<span class="number">3</span>:]</span><br><span class="line">Out[<span class="number">78</span>]: [<span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>负数表明从后向前切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: seq[-<span class="number">4</span>:]</span><br><span class="line">Out[<span class="number">79</span>]: [<span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: seq[-<span class="number">6</span>:-<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">80</span>]: [<span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>需要一段时间来熟悉使用切片，尤其是当你之前学的是R或MATLAB。图3-1展示了正整数和负整数的切片。在图中，指数标示在边缘以表明切片是在哪里开始哪里结束的。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap03/7178691-522e2b688b755ff3.png" class="" title="图3-1 Python切片演示">
<p>在第二个冒号后面使用<code>step</code>，可以隔一个取一个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: seq[::<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">81</span>]: [<span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>一个聪明的方法是使用<code>-1</code>，它可以将列表或元组颠倒过来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: seq[::-<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">82</span>]: [<span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<h3 id="序列函数">3.1.10 序列函数</h3>
<p>Python有一些有用的序列函数。</p>
<h3 id="enumerate函数">3.1.11 enumerate函数</h3>
<p>迭代一个序列时，你可能想跟踪当前项的序号。手动的方法可能是下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> collection:</span><br><span class="line">   <span class="comment"># do something with value</span></span><br><span class="line">   i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>因为这么做很常见，Python内建了一个<code>enumerate</code>函数，可以返回<code>(i, value)</code>元组序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(collection):</span><br><span class="line">   <span class="comment"># do something with value</span></span><br></pre></td></tr></table></figure>
<p>当你索引数据时，使用<code>enumerate</code>的一个好方法是计算序列（唯一的）<code>dict</code>映射到位置的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: some_list = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: mapping = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(some_list):</span><br><span class="line">   ....:     mapping[v] = i</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: mapping</span><br><span class="line">Out[<span class="number">86</span>]: &#123;<span class="string">&#x27;bar&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;baz&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;foo&#x27;</span>: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sorted函数">3.1.12 sorted函数</h3>
<p><code>sorted</code>函数可以从任意序列的元素返回一个新的排好序的列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: <span class="built_in">sorted</span>([<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">Out[<span class="number">87</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: <span class="built_in">sorted</span>(<span class="string">&#x27;horse race&#x27;</span>)</span><br><span class="line">Out[<span class="number">88</span>]: [<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p><code>sorted</code>函数可以接受和<code>sort</code>相同的参数。</p>
<h3 id="zip函数">3.1.13 zip函数</h3>
<p><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: seq1 = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: seq2 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: zipped = <span class="built_in">zip</span>(seq1, seq2)</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: <span class="built_in">list</span>(zipped)</span><br><span class="line">Out[<span class="number">92</span>]: [(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;one&#x27;</span>), (<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;two&#x27;</span>), (<span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;three&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p><code>zip</code>可以处理任意多的序列，元素的个数取决于最短的序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: seq3 = [<span class="literal">False</span>, <span class="literal">True</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: <span class="built_in">list</span>(<span class="built_in">zip</span>(seq1, seq2, seq3))</span><br><span class="line">Out[<span class="number">94</span>]: [(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="literal">False</span>), (<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="literal">True</span>)]</span><br></pre></td></tr></table></figure>
<p><code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: <span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(seq1, seq2)):</span><br><span class="line">   ....:     <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;: &#123;1&#125;, &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(i, a, b))</span><br><span class="line">   ....:</span><br><span class="line"><span class="number">0</span>: foo, one</span><br><span class="line"><span class="number">1</span>: bar, two</span><br><span class="line"><span class="number">2</span>: baz, three</span><br></pre></td></tr></table></figure>
<p>给出一个“被压缩的”序列，<code>zip</code>可以被用来解压序列。也可以当作把行的列表转换为列的列表。这个方法看起来有点神奇：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: pitchers = [(<span class="string">&#x27;Nolan&#x27;</span>, <span class="string">&#x27;Ryan&#x27;</span>), (<span class="string">&#x27;Roger&#x27;</span>, <span class="string">&#x27;Clemens&#x27;</span>),</span><br><span class="line">   ....:             (<span class="string">&#x27;Schilling&#x27;</span>, <span class="string">&#x27;Curt&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: first_names, last_names = <span class="built_in">zip</span>(*pitchers)</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: first_names</span><br><span class="line">Out[<span class="number">98</span>]: (<span class="string">&#x27;Nolan&#x27;</span>, <span class="string">&#x27;Roger&#x27;</span>, <span class="string">&#x27;Schilling&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: last_names</span><br><span class="line">Out[<span class="number">99</span>]: (<span class="string">&#x27;Ryan&#x27;</span>, <span class="string">&#x27;Clemens&#x27;</span>, <span class="string">&#x27;Curt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="reversed函数">3.1.14 reversed函数</h3>
<p><code>reversed</code>可以从后向前迭代一个序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">100</span>]: <span class="built_in">list</span>(<span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">Out[<span class="number">100</span>]: [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>要记住<code>reversed</code>是一个生成器（后面详细介绍），只有实体化（即列表或for循环）之后才能创建翻转的序列。</p>
<h3 id="字典">3.1.15 字典</h3>
<p>字典可能是Python最为重要的数据结构。它更为常见的名字是哈希映射或关联数组。它是键值对的大小可变集合，键和值都是Python对象。创建字典的方法之一是使用尖括号，用冒号分隔键和值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: empty_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: d1 = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: d1</span><br><span class="line">Out[<span class="number">103</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像访问列表或元组中的元素一样，访问、插入或设定字典中的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">104</span>]: d1[<span class="number">7</span>] = <span class="string">&#x27;an integer&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: d1</span><br><span class="line">Out[<span class="number">105</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: d1[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">106</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>你可以用检查列表和元组是否包含某个值的方法，检查字典中是否包含某个键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: <span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> d1</span><br><span class="line">Out[<span class="number">107</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>del</code>关键字或<code>pop</code>方法（返回值的同时删除键）删除值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: d1[<span class="number">5</span>] = <span class="string">&#x27;some value&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: d1</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"> <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>,</span><br><span class="line"> <span class="number">5</span>: <span class="string">&#x27;some value&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: d1[<span class="string">&#x27;dummy&#x27;</span>] = <span class="string">&#x27;another value&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: d1</span><br><span class="line">Out[<span class="number">111</span>]: </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"> <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>,</span><br><span class="line"> <span class="number">5</span>: <span class="string">&#x27;some value&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;dummy&#x27;</span>: <span class="string">&#x27;another value&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: <span class="keyword">del</span> d1[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: d1</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line"> <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;dummy&#x27;</span>: <span class="string">&#x27;another value&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: ret = d1.pop(<span class="string">&#x27;dummy&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: ret</span><br><span class="line">Out[<span class="number">115</span>]: <span class="string">&#x27;another value&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: d1</span><br><span class="line">Out[<span class="number">116</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>keys</code>和<code>values</code>是字典的键和值的迭代器方法。虽然键值对没有顺序，这两个方法可以用相同的顺序输出键和值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: <span class="built_in">list</span>(d1.keys())</span><br><span class="line">Out[<span class="number">117</span>]: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: <span class="built_in">list</span>(d1.values())</span><br><span class="line">Out[<span class="number">118</span>]: [<span class="string">&#x27;some value&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">&#x27;an integer&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>用<code>update</code>方法可以将一个字典与另一个融合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">119</span>]: d1.update(&#123;<span class="string">&#x27;b&#x27;</span> : <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;c&#x27;</span> : <span class="number">12</span>&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: d1</span><br><span class="line">Out[<span class="number">120</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;an integer&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>update</code>方法是原地改变字典，因此任何传递给<code>update</code>的键的旧的值都会被舍弃。</p>
<h3 id="用序列创建字典">3.1.16 用序列创建字典</h3>
<p>常常，你可能想将两个序列配对组合成字典。下面是一种写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">zip</span>(key_list, value_list):</span><br><span class="line">    mapping[key] = value</span><br></pre></td></tr></table></figure>
<p>因为字典本质上是2元元组的集合，dict可以接受2元元组的列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">121</span>]: mapping = <span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">5</span>))))</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: mapping</span><br><span class="line">Out[<span class="number">122</span>]: &#123;<span class="number">0</span>: <span class="number">4</span>, <span class="number">1</span>: <span class="number">3</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<p>后面会谈到<code>dict comprehensions</code>，另一种构建字典的优雅方式。</p>
<h3 id="默认值">3.1.17 默认值</h3>
<p>下面的逻辑很常见：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> some_dict:</span><br><span class="line">    value = some_dict[key]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    value = default_value</span><br></pre></td></tr></table></figure>
<p>因此，dict的方法get和pop可以取默认值进行返回，上面的if-else语句可以简写成下面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = some_dict.get(key, default_value)</span><br></pre></td></tr></table></figure>
<p>get默认会返回None，如果不存在键，pop会抛出一个例外。关于设定值，常见的情况是在字典的值是属于其它集合，如列表。例如，你可以通过首字母，将一个列表中的单词分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">123</span>]: words = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;bat&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;atom&#x27;</span>, <span class="string">&#x27;book&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: by_letter = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">   .....:     letter = word[<span class="number">0</span>]</span><br><span class="line">   .....:     <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> by_letter:</span><br><span class="line">   .....:         by_letter[letter] = [word]</span><br><span class="line">   .....:     <span class="keyword">else</span>:</span><br><span class="line">   .....:         by_letter[letter].append(word)</span><br><span class="line">   .....:</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: by_letter</span><br><span class="line">Out[<span class="number">126</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;atom&#x27;</span>], <span class="string">&#x27;b&#x27;</span>: [<span class="string">&#x27;bat&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;book&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>
<p><code>setdefault</code>方法就正是干这个的。前面的for循环可以改写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    letter = word[<span class="number">0</span>]</span><br><span class="line">    by_letter.setdefault(letter, []).append(word)</span><br></pre></td></tr></table></figure>
<p><code>collections</code>模块有一个很有用的类，<code>defaultdict</code>，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">by_letter = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    by_letter[word[<span class="number">0</span>]].append(word)</span><br></pre></td></tr></table></figure>
<h3 id="有效的键类型">3.1.18 有效的键类型</h3>
<p>字典的值可以是任意Python对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为“可哈希性”。可以用<code>hash</code>函数检测一个对象是否是可哈希的（可被用作字典的键）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">127</span>]: <span class="built_in">hash</span>(<span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">Out[<span class="number">127</span>]: <span class="number">5023931463650008331</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: <span class="built_in">hash</span>((<span class="number">1</span>, <span class="number">2</span>, (<span class="number">2</span>, <span class="number">3</span>)))</span><br><span class="line">Out[<span class="number">128</span>]: <span class="number">1097636502276347782</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: <span class="built_in">hash</span>((<span class="number">1</span>, <span class="number">2</span>, [<span class="number">2</span>, <span class="number">3</span>])) <span class="comment"># fails because lists are mutable</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">129</span>-800cd14ba8be&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> <span class="built_in">hash</span>((<span class="number">1</span>, <span class="number">2</span>, [<span class="number">2</span>, <span class="number">3</span>])) <span class="comment"># fails because lists are mutable</span></span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br></pre></td></tr></table></figure>
<p>要用列表当做键，一种方法是将列表转化为元组，只要内部元素可以被哈希，它也就可以被哈希：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">130</span>]: d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: d[<span class="built_in">tuple</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: d</span><br><span class="line">Out[<span class="number">132</span>]: &#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合">3.1.19 集合</h3>
<p>集合是无序的不可重复的元素的集合。你可以把它当做字典，但是只有键没有值。可以用两种方式创建集合：通过set函数或使用尖括号set语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">133</span>]: <span class="built_in">set</span>([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">Out[<span class="number">133</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>&#125;</span><br><span class="line">Out[<span class="number">134</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>集合支持合并、交集、差分和对称差等数学集合运算。考虑两个示例集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">135</span>]: a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure>
<p>合并是取两个集合中不重复的元素。可以用<code>union</code>方法，或者<code>|</code>运算符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">137</span>]: a.union(b)</span><br><span class="line">Out[<span class="number">137</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">138</span>]: a | b</span><br><span class="line">Out[<span class="number">138</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure>
<p>交集的元素包含在两个集合中。可以用<code>intersection</code>或<code>&amp;</code>运算符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">139</span>]: a.intersection(b)</span><br><span class="line">Out[<span class="number">139</span>]: &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: a &amp; b</span><br><span class="line">Out[<span class="number">140</span>]: &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>表3-1列出了常用的集合方法。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap03/7178691-980efe5d98ecc4d6.png" class="" title="表3-1 Python的集合操作">
<p>所有逻辑集合操作都有另外的原地实现方法，可以直接用结果替代集合的内容。对于大的集合，这么做效率更高：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: c = a.copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: c |= b</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: c</span><br><span class="line">Out[<span class="number">143</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: d = a.copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: d &amp;= b</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: d</span><br><span class="line">Out[<span class="number">146</span>]: &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>与字典类似，集合元素通常都是不可变的。要获得类似列表的元素，必须转换成元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">147</span>]: my_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: my_set = &#123;<span class="built_in">tuple</span>(my_data)&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">149</span>]: my_set</span><br><span class="line">Out[<span class="number">149</span>]: &#123;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以检测一个集合是否是另一个集合的子集或父集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">150</span>]: a_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;.issubset(a_set)</span><br><span class="line">Out[<span class="number">151</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: a_set.issuperset(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">Out[<span class="number">152</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>集合的内容相同时，集合才对等：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">153</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; == &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">Out[<span class="number">153</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="列表集合和字典推导式">3.1.20 列表、集合和字典推导式</h3>
<p>列表推导式是Python最受喜爱的特性之一。它允许用户方便的从一个集合过滤元素，形成列表，在传递参数的过程中还可以修改元素。形式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> val <span class="keyword">in</span> collection <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure>
<p>它等同于下面的for循环;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        result.append(expr)</span><br></pre></td></tr></table></figure>
<p>filter条件可以被忽略，只留下表达式就行。例如，给定一个字符串列表，我们可以过滤出长度在2及以下的字符串，并将其转换成大写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: strings = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;bat&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;dove&#x27;</span>, <span class="string">&#x27;python&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: [x.upper() <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> <span class="built_in">len</span>(x) &gt; <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">155</span>]: [<span class="string">&#x27;BAT&#x27;</span>, <span class="string">&#x27;CAR&#x27;</span>, <span class="string">&#x27;DOVE&#x27;</span>, <span class="string">&#x27;PYTHON&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>用相似的方法，还可以推导集合和字典。字典的推导式如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_comp = &#123;key-expr : value-expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br></pre></td></tr></table></figure>
<p>集合的推导式与列表很像，只不过用的是尖括号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set_comp = &#123;expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br></pre></td></tr></table></figure>
<p>与列表推导式类似，集合与字典的推导也很方便，而且使代码的读写都很容易。来看前面的字符串列表。假如我们只想要字符串的长度，用集合推导式的方法非常方便：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">156</span>]: unique_lengths = &#123;<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> strings&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: unique_lengths</span><br><span class="line">Out[<span class="number">157</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>map</code>函数可以进一步简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">158</span>]: <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">len</span>, strings))</span><br><span class="line">Out[<span class="number">158</span>]: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>
<p>作为一个字典推导式的例子，我们可以创建一个字符串的查找映射表以确定它在列表中的位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">159</span>]: loc_mapping = &#123;val : index <span class="keyword">for</span> index, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(strings)&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">160</span>]: loc_mapping</span><br><span class="line">Out[<span class="number">160</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;as&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;bat&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;car&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;dove&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;python&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套列表推导式">3.1.21 嵌套列表推导式</h3>
<p>假设我们有一个包含列表的列表，包含了一些英文名和西班牙名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">161</span>]: all_data = [[<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Emily&#x27;</span>, <span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;Steven&#x27;</span>],</span><br><span class="line">   .....:             [<span class="string">&#x27;Maria&#x27;</span>, <span class="string">&#x27;Juan&#x27;</span>, <span class="string">&#x27;Javier&#x27;</span>, <span class="string">&#x27;Natalia&#x27;</span>, <span class="string">&#x27;Pilar&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>你可能是从一些文件得到的这些名字，然后想按照语言进行分类。现在假设我们想用一个列表包含所有的名字，这些名字中包含两个或更多的e。可以用for循环来做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names_of_interest = []</span><br><span class="line"><span class="keyword">for</span> names <span class="keyword">in</span> all_data:</span><br><span class="line">    enough_es = [name <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> name.count(<span class="string">&#x27;e&#x27;</span>) &gt;= <span class="number">2</span>]</span><br><span class="line">    names_of_interest.extend(enough_es)</span><br></pre></td></tr></table></figure>
<p>可以用嵌套列表推导式的方法，将这些写在一起，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">162</span>]: result = [name <span class="keyword">for</span> names <span class="keyword">in</span> all_data <span class="keyword">for</span> name <span class="keyword">in</span> names</span><br><span class="line">   .....:           <span class="keyword">if</span> name.count(<span class="string">&#x27;e&#x27;</span>) &gt;= <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: result</span><br><span class="line">Out[<span class="number">163</span>]: [<span class="string">&#x27;Steven&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>嵌套列表推导式看起来有些复杂。列表推导式的for部分是根据嵌套的顺序，过滤条件还是放在最后。下面是另一个例子，我们将一个整数元组的列表扁平化成了一个整数列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">164</span>]: some_tuples = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">165</span>]: flattened = [x <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples <span class="keyword">for</span> x <span class="keyword">in</span> tup]</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: flattened</span><br><span class="line">Out[<span class="number">166</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>记住，for表达式的顺序是与嵌套for循环的顺序一样（而不是列表推导式的顺序）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flattened = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tup:</span><br><span class="line">        flattened.append(x)</span><br></pre></td></tr></table></figure>
<p>你可以有任意多级别的嵌套，但是如果你有两三个以上的嵌套，你就应该考虑下代码可读性的问题了。分辨列表推导式的列表推导式中的语法也是很重要的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">167</span>]: [[x <span class="keyword">for</span> x <span class="keyword">in</span> tup] <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples]</span><br><span class="line">Out[<span class="number">167</span>]: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br></pre></td></tr></table></figure>
<p>这段代码产生了一个列表的列表，而不是扁平化的只包含元素的列表。</p>
<h2 id="函数">3.2 函数</h2>
<p>函数是Python中最主要也是最重要的代码组织和复用手段。作为最重要的原则，如果你要重复使用相同或非常类似的代码，就需要写一个函数。通过给函数起一个名字，还可以提高代码的可读性。</p>
<p>函数使用<code>def</code>关键字声明，用<code>return</code>关键字返回值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">x, y, z=<span class="number">1.5</span></span>):</span><br><span class="line">    <span class="keyword">if</span> z &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> z * (x + y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> z / (x + y)</span><br></pre></td></tr></table></figure>
<p>同时拥有多条return语句也是可以的。如果到达函数末尾时没有遇到任何一条return语句，则返回None。</p>
<p>函数可以有一些位置参数（positional）和一些关键字参数（keyword）。关键字参数通常用于指定默认值或可选参数。在上面的函数中，x和y是位置参数，而z则是关键字参数。也就是说，该函数可以下面这两种方式进行调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_function(<span class="number">5</span>, <span class="number">6</span>, z=<span class="number">0.7</span>)</span><br><span class="line">my_function(<span class="number">3.14</span>, <span class="number">7</span>, <span class="number">3.5</span>)</span><br><span class="line">my_function(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>函数参数的主要限制在于：关键字参数必须位于位置参数（如果有的话）之后。你可以任何顺序指定关键字参数。也就是说，你不用死记硬背函数参数的顺序，只要记得它们的名字就可以了。</p>
<blockquote>
<p>笔记：也可以用关键字传递位置参数。前面的例子，也可以写为： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;my_function(x=<span class="number">5</span>, y=<span class="number">6</span>, z=<span class="number">7</span>)</span><br><span class="line">&gt;my_function(y=<span class="number">6</span>, x=<span class="number">5</span>, z=<span class="number">7</span>)</span><br></pre></td></tr></table></figure> 这种写法可以提高可读性。</p>
</blockquote>
<h3 id="命名空间作用域和局部函数">3.2.1 命名空间、作用域，和局部函数</h3>
<p>函数可以访问两种不同作用域中的变量：全局（global）和局部（local）。Python有一种更科学的用于描述变量作用域的名称，即命名空间（namespace）。任何在函数中赋值的变量默认都是被分配到局部命名空间（local namespace）中的。局部命名空间是在函数被调用时创建的，函数参数会立即填入该命名空间。在函数执行完毕之后，局部命名空间就会被销毁（会有一些例外的情况，具体请参见后面介绍闭包的那一节）。看看下面这个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        a.append(i)</span><br></pre></td></tr></table></figure>
<p>调用func()之后，首先会创建出空列表a，然后添加5个元素，最后a会在该函数退出的时候被销毁。假如我们像下面这样定义a：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        a.append(i)</span><br></pre></td></tr></table></figure>
<p>虽然可以在函数中对全局变量进行赋值操作，但是那些变量必须用global关键字声明成全局的才行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">168</span>]: a = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: <span class="keyword">def</span> <span class="title function_">bind_a_variable</span>():</span><br><span class="line">   .....:     <span class="keyword">global</span> a</span><br><span class="line">   .....:     a = []</span><br><span class="line">   .....: bind_a_variable()</span><br><span class="line">   .....:</span><br><span class="line"></span><br><span class="line">In [<span class="number">170</span>]: <span class="built_in">print</span>(a)</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：我常常建议人们不要频繁使用global关键字。因为全局变量一般是用于存放系统的某些状态的。如果你发现自己用了很多，那可能就说明得要来点儿面向对象编程了（即使用类）。</p>
</blockquote>
<h3 id="返回多个值">3.2.2 返回多个值</h3>
<p>在我第一次用Python编程时（之前已经习惯了Java和C++），最喜欢的一个功能是：函数可以返回多个值。下面是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line">    c = <span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> a, b, c</span><br><span class="line"></span><br><span class="line">a, b, c = f()</span><br></pre></td></tr></table></figure>
<p>在数据分析和其他科学计算应用中，你会发现自己常常这么干。该函数其实只返回了一个对象，也就是一个元组，最后该元组会被拆包到各个结果变量中。在上面的例子中，我们还可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">return_value = f()</span><br></pre></td></tr></table></figure>
<p>这里的return_value将会是一个含有3个返回值的三元元组。此外，还有一种非常具有吸引力的多值返回方式——返回字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line">    c = <span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;a&#x27;</span> : a, <span class="string">&#x27;b&#x27;</span> : b, <span class="string">&#x27;c&#x27;</span> : c&#125;</span><br></pre></td></tr></table></figure>
<p>取决于工作内容，第二种方法可能很有用。</p>
<h3 id="函数也是对象">3.2.3 函数也是对象</h3>
<p>由于Python函数都是对象，因此，在其他语言中较难表达的一些设计思想在Python中就要简单很多了。假设我们有下面这样一个字符串数组，希望对其进行一些数据清理工作并执行一堆转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">171</span>]: states = [<span class="string">&#x27;   Alabama &#x27;</span>, <span class="string">&#x27;Georgia!&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="string">&#x27;georgia&#x27;</span>, <span class="string">&#x27;FlOrIda&#x27;</span>,</span><br><span class="line">   .....:           <span class="string">&#x27;south   carolina##&#x27;</span>, <span class="string">&#x27;West virginia?&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>不管是谁，只要处理过由用户提交的调查数据，就能明白这种乱七八糟的数据是怎么一回事。为了得到一组能用于分析工作的格式统一的字符串，需要做很多事情：去除空白符、删除各种标点符号、正确的大写格式等。做法之一是使用内建的字符串方法和正则表达式<code>re</code>模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_strings</span>(<span class="params">strings</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        value = value.strip()</span><br><span class="line">        value = re.sub(<span class="string">&#x27;[!#?]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, value)</span><br><span class="line">        value = value.title()</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">173</span>]: clean_strings(states)</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">[<span class="string">&#x27;Alabama&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Florida&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;South   Carolina&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;West Virginia&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>其实还有另外一种不错的办法：将需要在一组给定字符串上执行的所有运算做成一个列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove_punctuation</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">&#x27;[!#?]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, value)</span><br><span class="line"></span><br><span class="line">clean_ops = [<span class="built_in">str</span>.strip, remove_punctuation, <span class="built_in">str</span>.title]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_strings</span>(<span class="params">strings, ops</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        <span class="keyword">for</span> function <span class="keyword">in</span> ops:</span><br><span class="line">            value = function(value)</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>然后我们就有了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">175</span>]: clean_strings(states, clean_ops)</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">[<span class="string">&#x27;Alabama&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Georgia&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Florida&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;South   Carolina&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;West Virginia&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>这种多函数模式使你能在很高的层次上轻松修改字符串的转换方式。此时的clean_strings也更具可复用性！</p>
<p>还可以将函数用作其他函数的参数，比如内置的map函数，它用于在一组数据上应用一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">176</span>]: <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">map</span>(remove_punctuation, states):</span><br><span class="line">   .....:     <span class="built_in">print</span>(x)</span><br><span class="line">Alabama </span><br><span class="line">Georgia</span><br><span class="line">Georgia</span><br><span class="line">georgia</span><br><span class="line">FlOrIda</span><br><span class="line">south   carolina</span><br><span class="line">West virginia</span><br></pre></td></tr></table></figure>
<h3 id="匿名lambda函数">3.2.4 匿名（lambda）函数</h3>
<p>Python支持一种被称为匿名的、或lambda函数。它仅由单条语句组成，该语句的结果就是返回值。它是通过lambda关键字定义的，这个关键字没有别的含义，仅仅是说“我们正在声明的是一个匿名函数”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">short_function</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">equiv_anon = <span class="keyword">lambda</span> x: x * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>本书其余部分一般将其称为lambda函数。它们在数据分析工作中非常方便，因为你会发现很多数据转换函数都以函数作为参数的。直接传入lambda函数比编写完整函数声明要少输入很多字（也更清晰），甚至比将lambda函数赋值给一个变量还要少输入很多字。看看下面这个简单得有些傻的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_to_list</span>(<span class="params">some_list, f</span>):</span><br><span class="line">    <span class="keyword">return</span> [f(x) <span class="keyword">for</span> x <span class="keyword">in</span> some_list]</span><br><span class="line"></span><br><span class="line">ints = [<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">apply_to_list(ints, <span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>虽然你可以直接编写[x *2for x in ints]，但是这里我们可以非常轻松地传入一个自定义运算给apply_to_list函数。</p>
<p>再来看另外一个例子。假设有一组字符串，你想要根据各字符串不同字母的数量对其进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">177</span>]: strings = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;card&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;abab&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>这里，我们可以传入一个lambda函数到列表的sort方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">178</span>]: strings.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(<span class="built_in">set</span>(<span class="built_in">list</span>(x))))</span><br><span class="line"></span><br><span class="line">In [<span class="number">179</span>]: strings</span><br><span class="line">Out[<span class="number">179</span>]: [<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;abab&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;card&#x27;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：lambda函数之所以会被称为匿名函数，与def声明的函数不同，原因之一就是这种函数对象本身是没有提供名称__name__属性。</p>
</blockquote>
<h3 id="柯里化部分参数应用">3.2.5 柯里化：部分参数应用</h3>
<p>柯里化（currying）是一个有趣的计算机科学术语，它指的是通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。例如，假设我们有一个执行两数相加的简单函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>
<p>通过这个函数，我们可以派生出一个新的只有一个参数的函数——add_five，它用于对其参数加5：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_five = <span class="keyword">lambda</span> y: add_numbers(<span class="number">5</span>, y)</span><br></pre></td></tr></table></figure>
<p>add_numbers的第二个参数称为“柯里化的”（curried）。这里没什么特别花哨的东西，因为我们其实就只是定义了一个可以调用现有函数的新函数而已。内置的functools模块可以用partial函数将此过程简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">add_five = partial(add_numbers, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="生成器">3.2.6 生成器</h3>
<p>能以一种一致的方式对序列进行迭代（比如列表中的对象或文件中的行）是Python的一个重要特点。这是通过一种叫做迭代器协议（iterator protocol，它是一种使对象可迭代的通用方式）的方式实现的，一个原生的使对象可迭代的方法。比如说，对字典进行迭代可以得到其所有的键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">180</span>]: some_dict = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: <span class="keyword">for</span> key <span class="keyword">in</span> some_dict:</span><br><span class="line">   .....:     <span class="built_in">print</span>(key)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>当你编写for key in some_dict时，Python解释器首先会尝试从some_dict创建一个迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">182</span>]: dict_iterator = <span class="built_in">iter</span>(some_dict)</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: dict_iterator</span><br><span class="line">Out[<span class="number">183</span>]: &lt;dict_keyiterator at <span class="number">0x7fbbd5a9f908</span>&gt;</span><br></pre></td></tr></table></figure>
<p>迭代器是一种特殊对象，它可以在诸如for循环之类的上下文中向Python解释器输送对象。大部分能接受列表之类的对象的方法也都可以接受任何可迭代对象。比如min、max、sum等内置方法以及list、tuple等类型构造器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">184</span>]: <span class="built_in">list</span>(dict_iterator)</span><br><span class="line">Out[<span class="number">184</span>]: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>生成器（generator）是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的return替换为yeild即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">squares</span>(<span class="params">n=<span class="number">10</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Generating squares from 1 to &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(n ** <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> i ** <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>调用该生成器时，没有任何代码会被立即执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">186</span>]: gen = squares()</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: gen</span><br><span class="line">Out[<span class="number">187</span>]: &lt;generator <span class="built_in">object</span> squares at <span class="number">0x7fbbd5ab4570</span>&gt;</span><br></pre></td></tr></table></figure>
<p>直到你从该生成器中请求元素时，它才会开始执行其代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">188</span>]: <span class="keyword">for</span> x <span class="keyword">in</span> gen:</span><br><span class="line">   .....:     <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">Generating squares <span class="keyword">from</span> <span class="number">1</span> to <span class="number">100</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span> <span class="number">36</span> <span class="number">49</span> <span class="number">64</span> <span class="number">81</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="生成器表达式">3.2.7 生成器表达式</h3>
<p>另一种更简洁的构造生成器的方法是使用生成器表达式（generator expression）。这是一种类似于列表、字典、集合推导式的生成器。其创建方式为，把列表推导式两端的方括号改成圆括号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">189</span>]: gen = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">190</span>]: gen</span><br><span class="line">Out[<span class="number">190</span>]: &lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7fbbd5ab29e8</span>&gt;</span><br></pre></td></tr></table></figure>
<p>它跟下面这个冗长得多的生成器是完全等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_make_gen</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">gen = _make_gen()</span><br></pre></td></tr></table></figure>
<p>生成器表达式也可以取代列表推导式，作为函数参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">191</span>]: <span class="built_in">sum</span>(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line">Out[<span class="number">191</span>]: <span class="number">328350</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: <span class="built_in">dict</span>((i, i **<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">Out[<span class="number">192</span>]: &#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">16</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="itertools模块">3.2.8 itertools模块</h3>
<p>标准库itertools模块中有一组用于许多常见数据算法的生成器。例如，groupby可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">193</span>]: <span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: first_letter = <span class="keyword">lambda</span> x: x[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">195</span>]: names = [<span class="string">&#x27;Alan&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;Wes&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Albert&#x27;</span>, <span class="string">&#x27;Steven&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">196</span>]: <span class="keyword">for</span> letter, names <span class="keyword">in</span> itertools.groupby(names, first_letter):</span><br><span class="line">   .....:     <span class="built_in">print</span>(letter, <span class="built_in">list</span>(names)) <span class="comment"># names is a generator</span></span><br><span class="line">A [<span class="string">&#x27;Alan&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br><span class="line">W [<span class="string">&#x27;Wes&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>]</span><br><span class="line">A [<span class="string">&#x27;Albert&#x27;</span>]</span><br><span class="line">S [<span class="string">&#x27;Steven&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>表3-2中列出了一些我经常用到的itertools函数。建议参阅Python官方文档，进一步学习。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap03/7178691-111823d8767a104d.png" class="" title="表3-2 一些有用的itertools函数">
<h3 id="错误和异常处理">3.2.9 错误和异常处理</h3>
<p>优雅地处理Python的错误和异常是构建健壮程序的重要部分。在数据分析中，许多函数函数只用于部分输入。例如，Python的float函数可以将字符串转换成浮点数，但输入有误时，有<code>ValueError</code>错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">197</span>]: <span class="built_in">float</span>(<span class="string">&#x27;1.2345&#x27;</span>)</span><br><span class="line">Out[<span class="number">197</span>]: <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">198</span>]: <span class="built_in">float</span>(<span class="string">&#x27;something&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">198</span>-<span class="number">439904410854</span>&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> <span class="built_in">float</span>(<span class="string">&#x27;something&#x27;</span>)</span><br><span class="line">ValueError: could <span class="keyword">not</span> convert string to <span class="built_in">float</span>: <span class="string">&#x27;something&#x27;</span></span><br></pre></td></tr></table></figure>
<p>假如想优雅地处理float的错误，让它返回输入值。我们可以写一个函数，在try/except中调用float：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">attempt_float</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">float</span>(x)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>当float(x)抛出异常时，才会执行except的部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">200</span>]: attempt_float(<span class="string">&#x27;1.2345&#x27;</span>)</span><br><span class="line">Out[<span class="number">200</span>]: <span class="number">1.2345</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">201</span>]: attempt_float(<span class="string">&#x27;something&#x27;</span>)</span><br><span class="line">Out[<span class="number">201</span>]: <span class="string">&#x27;something&#x27;</span></span><br></pre></td></tr></table></figure>
<p>你可能注意到float抛出的异常不仅是ValueError：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">202</span>]: <span class="built_in">float</span>((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">202</span>-842079ebb635&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> <span class="built_in">float</span>((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">TypeError: <span class="built_in">float</span>() argument must be a string <span class="keyword">or</span> a number, <span class="keyword">not</span> <span class="string">&#x27;tuple&#x27;</span></span><br></pre></td></tr></table></figure>
<p>你可能只想处理ValueError，TypeError错误（输入不是字符串或数值）可能是合理的bug。可以写一个异常类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">attempt_float</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">float</span>(x)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>然后有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">204</span>]: attempt_float((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">204</span>-9bdfd730cead&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> attempt_float((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">203</span>-3e06b8379b6b&gt; <span class="keyword">in</span> attempt_float(x)</span><br><span class="line">      <span class="number">1</span> <span class="keyword">def</span> <span class="title function_">attempt_float</span>(<span class="params">x</span>):</span><br><span class="line">      <span class="number">2</span>     <span class="keyword">try</span>:</span><br><span class="line">----&gt; <span class="number">3</span>         <span class="keyword">return</span> <span class="built_in">float</span>(x)</span><br><span class="line">      <span class="number">4</span>     <span class="keyword">except</span> ValueError:</span><br><span class="line">      <span class="number">5</span>         <span class="keyword">return</span> x</span><br><span class="line">TypeError: <span class="built_in">float</span>() argument must be a string <span class="keyword">or</span> a number, <span class="keyword">not</span> <span class="string">&#x27;tuple&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以用元组包含多个异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">attempt_float</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">float</span>(x)</span><br><span class="line">    <span class="keyword">except</span> (TypeError, ValueError):</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>某些情况下，你可能不想抑制异常，你想无论try部分的代码是否成功，都执行一段代码。可以使用finally：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>
<p>这里，文件处理f总会被关闭。相似的，你可以用else让只在try部分成功的情况下，才执行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Succeeded&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>
<h3 id="ipython的异常">3.2.10 IPython的异常</h3>
<p>如果是在%run一个脚本或一条语句时抛出异常，IPython默认会打印完整的调用栈（traceback），在栈的每个点都会有几行上下文：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: %run examples/ipython_bug.py</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AssertionError                            Traceback (most recent call last)</span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">     <span class="number">13</span>     throws_an_exception()</span><br><span class="line">     <span class="number">14</span></span><br><span class="line">---&gt; <span class="number">15</span> calling_things()</span><br><span class="line"></span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="keyword">in</span> calling_things()</span><br><span class="line">     <span class="number">11</span> <span class="keyword">def</span> <span class="title function_">calling_things</span>():</span><br><span class="line">     <span class="number">12</span>     works_fine()</span><br><span class="line">---&gt; <span class="number">13</span>     throws_an_exception()</span><br><span class="line">     <span class="number">14</span></span><br><span class="line">     <span class="number">15</span> calling_things()</span><br><span class="line"></span><br><span class="line">/home/wesm/code/pydata-book/examples/ipython_bug.py <span class="keyword">in</span> throws_an_exception()</span><br><span class="line">      <span class="number">7</span>     a = <span class="number">5</span></span><br><span class="line">      <span class="number">8</span>     b = <span class="number">6</span></span><br><span class="line">----&gt; <span class="number">9</span>     <span class="keyword">assert</span>(a + b == <span class="number">10</span>)</span><br><span class="line">     <span class="number">10</span></span><br><span class="line">     <span class="number">11</span> <span class="keyword">def</span> <span class="title function_">calling_things</span>():</span><br><span class="line"></span><br><span class="line">AssertionError:</span><br></pre></td></tr></table></figure>
<p>自身就带有文本是相对于Python标准解释器的极大优点。你可以用魔术命令<code>%xmode</code>，从Plain（与Python标准解释器相同）到Verbose（带有函数的参数值）控制文本显示的数量。后面可以看到，发生错误之后，（用%debug或%pdb magics）可以进入stack进行事后调试。</p>
<h2 id="文件和操作系统">3.3 文件和操作系统</h2>
<p>本书的代码示例大多使用诸如pandas.read_csv之类的高级工具将磁盘上的数据文件读入Python数据结构。但我们还是需要了解一些有关Python文件处理方面的基础知识。好在它本来就很简单，这也是Python在文本和文件处理方面的如此流行的原因之一。</p>
<p>为了打开一个文件以便读写，可以使用内置的open函数以及一个相对或绝对的文件路径：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">207</span>]: path = <span class="string">&#x27;examples/segismundo.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: f = <span class="built_in">open</span>(path)</span><br></pre></td></tr></table></figure>
<p>默认情况下，文件是以只读模式（'r'）打开的。然后，我们就可以像处理列表那样来处理这个文件句柄f了，比如对行进行迭代：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>从文件中取出的行都带有完整的行结束符（EOL），因此你常常会看到下面这样的代码（得到一组没有EOL的行）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">209</span>]: lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(path)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">210</span>]: lines</span><br><span class="line">Out[<span class="number">210</span>]: </span><br><span class="line">[<span class="string">&#x27;Sueña el rico en su riqueza,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;que más cuidados le ofrece;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el pobre que padece&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;su miseria y su pobreza;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que a medrar empieza,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que afana y pretende,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que agravia y ofende,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;y en el mundo, en conclusión,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;todos sueñan lo que son,&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;aunque ninguno lo entiende.&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>如果使用open创建文件对象，一定要用close关闭它。关闭文件可以返回操作系统资源：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">211</span>]: f.close()</span><br></pre></td></tr></table></figure>
<p>用with语句可以可以更容易地清理打开的文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">212</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> f:</span><br><span class="line">   .....:     lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br></pre></td></tr></table></figure>
<p>这样可以在退出代码块时，自动关闭文件。</p>
<p>如果输入f =open(path,'w')，就会有一个新文件被创建在examples/segismundo.txt，并覆盖掉该位置原来的任何数据。另外有一个x文件模式，它可以创建可写的文件，但是如果文件路径存在，就无法创建。表3-3列出了所有的读/写模式。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap03/7178691-28274484129f0ea7.png" class="" title="表3-3 Python的文件模式">
<p>对于可读文件，一些常用的方法是read、seek和tell。read会从文件返回字符。字符的内容是由文件的编码决定的（如UTF-8），如果是二进制模式打开的就是原始字节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">213</span>]: f = <span class="built_in">open</span>(path)</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: f.read(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">214</span>]: <span class="string">&#x27;Sueña el r&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">215</span>]: f2 = <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>)  <span class="comment"># Binary mode</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">216</span>]: f2.read(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">216</span>]: <span class="string">b&#x27;Sue\xc3\xb1a el &#x27;</span></span><br></pre></td></tr></table></figure>
<p>read模式会将文件句柄的位置提前，提前的数量是读取的字节数。tell可以给出当前的位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">217</span>]: f.tell()</span><br><span class="line">Out[<span class="number">217</span>]: <span class="number">11</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">218</span>]: f2.tell()</span><br><span class="line">Out[<span class="number">218</span>]: <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>尽管我们从文件读取了10个字符，位置却是11，这是因为用默认的编码用了这么多字节才解码了这10个字符。你可以用sys模块检查默认的编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">219</span>]: <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">In [<span class="number">220</span>]: sys.getdefaultencoding()</span><br><span class="line">Out[<span class="number">220</span>]: <span class="string">&#x27;utf-8&#x27;</span></span><br></pre></td></tr></table></figure>
<p>seek将文件位置更改为文件中的指定字节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">221</span>]: f.seek(<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">221</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">222</span>]: f.read(<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">222</span>]: <span class="string">&#x27;ñ&#x27;</span></span><br></pre></td></tr></table></figure>
<p>最后，关闭文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">223</span>]: f.close()</span><br><span class="line"></span><br><span class="line">In [<span class="number">224</span>]: f2.close()</span><br></pre></td></tr></table></figure>
<p>向文件写入，可以使用文件的write或writelines方法。例如，我们可以创建一个无空行版的prof_mod.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">225</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tmp.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> handle:</span><br><span class="line">   .....:     handle.writelines(x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(path) <span class="keyword">if</span> <span class="built_in">len</span>(x) &gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">226</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tmp.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">   .....:     lines = f.readlines()</span><br><span class="line"></span><br><span class="line">In [<span class="number">227</span>]: lines</span><br><span class="line">Out[<span class="number">227</span>]: </span><br><span class="line">[<span class="string">&#x27;Sueña el rico en su riqueza,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;que más cuidados le ofrece;\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el pobre que padece\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;su miseria y su pobreza;\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que a medrar empieza,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que afana y pretende,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;sueña el que agravia y ofende,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;y en el mundo, en conclusión,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;todos sueñan lo que son,\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;aunque ninguno lo entiende.\n&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>表3-4列出了一些最常用的文件方法。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap03/7178691-d25bd6e730afeb39.png" class="" title="表3-4 Python重要的文件方法或属性">
<h3 id="文件的字节和unicode">3.3.1 文件的字节和Unicode</h3>
<p>Python文件的默认操作是“文本模式”，也就是说，你需要处理Python的字符串（即Unicode）。它与“二进制模式”相对，文件模式加一个b。我们来看上一节的文件（UTF-8编码、包含非ASCII字符）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">230</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> f:</span><br><span class="line">   .....:     chars = f.read(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">231</span>]: chars</span><br><span class="line">Out[<span class="number">231</span>]: <span class="string">&#x27;Sueña el r&#x27;</span></span><br></pre></td></tr></table></figure>
<p>UTF-8是长度可变的Unicode编码，所以当我从文件请求一定数量的字符时，Python会从文件读取足够多（可能少至10或多至40字节）的字节进行解码。如果以“rb”模式打开文件，则读取确切的请求字节数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">232</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">   .....:     data = f.read(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">233</span>]: data</span><br><span class="line">Out[<span class="number">233</span>]: <span class="string">b&#x27;Sue\xc3\xb1a el &#x27;</span></span><br></pre></td></tr></table></figure>
<p>取决于文本的编码，你可以将字节解码为str对象，但只有当每个编码的Unicode字符都完全成形时才能这么做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">234</span>]: data.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">Out[<span class="number">234</span>]: <span class="string">&#x27;Sueña el &#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">235</span>]: data[:<span class="number">4</span>].decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">UnicodeDecodeError                        Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">235</span>-300e0af10bb7&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> data[:<span class="number">4</span>].decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">UnicodeDecodeError: <span class="string">&#x27;utf-8&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xc3 in position 3: unexpecte</span></span><br><span class="line"><span class="string">d end of data</span></span><br></pre></td></tr></table></figure>
<p>文本模式结合了open的编码选项，提供了一种更方便的方法将Unicode转换为另一种编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">236</span>]: sink_path = <span class="string">&#x27;sink.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">237</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> source:</span><br><span class="line">   .....:     <span class="keyword">with</span> <span class="built_in">open</span>(sink_path, <span class="string">&#x27;xt&#x27;</span>, encoding=<span class="string">&#x27;iso-8859-1&#x27;</span>) <span class="keyword">as</span> sink:</span><br><span class="line">   .....:         sink.write(source.read())</span><br><span class="line"></span><br><span class="line">In [<span class="number">238</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(sink_path, encoding=<span class="string">&#x27;iso-8859-1&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">   .....:     <span class="built_in">print</span>(f.read(<span class="number">10</span>))</span><br><span class="line">Sueña el r</span><br></pre></td></tr></table></figure>
<p>注意，不要在二进制模式中使用seek。如果文件位置位于定义Unicode字符的字节的中间位置，读取后面会产生错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">240</span>]: f = <span class="built_in">open</span>(path)</span><br><span class="line"></span><br><span class="line">In [<span class="number">241</span>]: f.read(<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">241</span>]: <span class="string">&#x27;Sueña&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">242</span>]: f.seek(<span class="number">4</span>)</span><br><span class="line">Out[<span class="number">242</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">243</span>]: f.read(<span class="number">1</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">UnicodeDecodeError                        Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">243</span>-<span class="number">7841</span>103e33f5&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> f.read(<span class="number">1</span>)</span><br><span class="line">/miniconda/envs/book-env/lib/python3<span class="number">.6</span>/codecs.py <span class="keyword">in</span> decode(self, <span class="built_in">input</span>, final)</span><br><span class="line">    <span class="number">319</span>         <span class="comment"># decode input (taking the buffer into account)</span></span><br><span class="line">    <span class="number">320</span>         data = self.buffer + <span class="built_in">input</span></span><br><span class="line">--&gt; <span class="number">321</span>         (result, consumed) = self._buffer_decode(data, self.errors, final</span><br><span class="line">)</span><br><span class="line">    <span class="number">322</span>         <span class="comment"># keep undecoded input until the next call</span></span><br><span class="line">    <span class="number">323</span>         self.buffer = data[consumed:]</span><br><span class="line">UnicodeDecodeError: <span class="string">&#x27;utf-8&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xb1 in position 0: invalid s</span></span><br><span class="line"><span class="string">tart byte</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [244]: f.close()</span></span><br></pre></td></tr></table></figure>
<p>如果你经常要对非ASCII字符文本进行数据分析，通晓Python的Unicode功能是非常重要的。更多内容，参阅Python官方文档。</p>
<h2 id="结论">3.4 结论</h2>
<p>我们已经学过了Python的基础、环境和语法，接下来学习NumPy和Python的面向数组计算。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第04章_NumPy基础：数组和矢量计算</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap04/</url>
    <content><![CDATA[<h1 id="第04章-numpy基础数组和矢量计算">第04章 NumPy基础：数组和矢量计算</h1>
<p>NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。</p>
<p>NumPy的部分功能如下：</p>
<ul>
<li>ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。</li>
<li>用于对整组数据进行快速运算的标准数学函数（无需编写循环）。</li>
<li>用于读写磁盘数据的工具以及用于操作内存映射文件的工具。</li>
<li>线性代数、随机数生成以及傅里叶变换功能。</li>
<li>用于集成由C、C++、Fortran等语言编写的代码的A C API。</li>
</ul>
<span id="more"></span>
<p>由于NumPy提供了一个简单易用的C API，因此很容易将数据传递给由低级语言编写的外部库，外部库也能以NumPy数组的形式将数据返回给Python。这个功能使Python成为一种包装C/C++/Fortran历史代码库的选择，并使被包装库拥有一个动态的、易用的接口。</p>
<p>NumPy本身并没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于你更加高效地使用诸如pandas之类的工具。因为NumPy是一个很大的题目，我会在附录A中介绍更多NumPy高级功能，比如广播。</p>
<p>对于大部分数据分析应用而言，我最关注的功能主要集中在：</p>
<ul>
<li>用于数据整理和清理、子集构造和过滤、转换等快速的矢量化数组运算。</li>
<li>常用的数组算法，如排序、唯一化、集合运算等。</li>
<li>高效的描述统计和数据聚合/摘要运算。</li>
<li>用于异构数据集的合并/连接运算的数据对齐和关系型数据运算。</li>
<li>将条件逻辑表述为数组表达式（而不是带有if-elif-else分支的循环）。</li>
<li>数据的分组运算（聚合、转换、函数应用等）。。</li>
</ul>
<p>虽然NumPy提供了通用的数值数据处理的计算基础，但大多数读者可能还是想将pandas作为统计和分析工作的基础，尤其是处理表格数据时。pandas还提供了一些NumPy所没有的领域特定的功能，如时间序列处理等。</p>
<blockquote>
<p>笔记：Python的面向数组计算可以追溯到1995年，Jim Hugunin创建了Numeric库。接下来的10年，许多科学编程社区纷纷开始使用Python的数组编程，但是进入21世纪，库的生态系统变得碎片化了。2005年，Travis Oliphant从Numeric和Numarray项目整了出了NumPy项目，进而所有社区都集合到了这个框架下。</p>
</blockquote>
<p>NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。这是因为：</p>
<ul>
<li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li>
<li>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</li>
</ul>
<p>要搞明白具体的性能差距，考察一个包含一百万整数的数组，和一个等价的Python列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: my_arr = np.arange(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: my_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure>
<p>各个序列分别乘以2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: %time <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): my_arr2 = my_arr * <span class="number">2</span></span><br><span class="line">CPU times: user <span class="number">20</span> ms, sys: <span class="number">50</span> ms, total: <span class="number">70</span> ms</span><br><span class="line">Wall time: <span class="number">72.4</span> ms</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: %time <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): my_list2 = [x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> my_list]</span><br><span class="line">CPU times: user <span class="number">760</span> ms, sys: <span class="number">290</span> ms, total: <span class="number">1.05</span> s</span><br><span class="line">Wall time: <span class="number">1.05</span> s</span><br></pre></td></tr></table></figure>
<p>基于NumPy的算法要比纯Python快10到100倍（甚至更快），并且使用的内存更少。</p>
<h2 id="numpy的ndarray一种多维数组对象">4.1 NumPy的ndarray：一种多维数组对象</h2>
<p>NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。你可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。</p>
<p>要明白Python是如何利用与标量值类似的语法进行批次计算，我先引入NumPy，然后生成一个包含随机数据的小数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">## Generate some random data</span></span><br><span class="line">In [<span class="number">13</span>]: data = np.random.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: data</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">array([[-<span class="number">0.2047</span>,  <span class="number">0.4789</span>, -<span class="number">0.5194</span>],</span><br><span class="line">       [-<span class="number">0.5557</span>,  <span class="number">1.9658</span>,  <span class="number">1.3934</span>]])</span><br></pre></td></tr></table></figure>
<p>然后进行数学运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: data * <span class="number">10</span></span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">array([[ -<span class="number">2.0471</span>,   <span class="number">4.7894</span>,  -<span class="number">5.1944</span>],</span><br><span class="line">       [ -<span class="number">5.5573</span>,  <span class="number">19.6578</span>,  <span class="number">13.9341</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: data + data</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">array([[-<span class="number">0.4094</span>,  <span class="number">0.9579</span>, -<span class="number">1.0389</span>],</span><br><span class="line">       [-<span class="number">1.1115</span>,  <span class="number">3.9316</span>,  <span class="number">2.7868</span>]])</span><br></pre></td></tr></table></figure>
<p>第一个例子中，所有的元素都乘以10。第二个例子中，每个元素都与自身相加。</p>
<blockquote>
<p>笔记：在本章及全书中，我会使用标准的NumPy惯用法<code>import numpy as np</code>。你当然也可以在代码中使用<code>from numpy import *</code>，但不建议这么做。<code>numpy</code>的命名空间很大，包含许多函数，其中一些的名字与Python的内置函数重名（比如min和max）。</p>
</blockquote>
<p>ndarray是一个通用的同构数据多维容器，也就是说，其中的所有元素必须是相同类型的。每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个用于说明数组数据类型的对象）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: data.shape</span><br><span class="line">Out[<span class="number">17</span>]: (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: data.dtype</span><br><span class="line">Out[<span class="number">18</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>本章将会介绍NumPy数组的基本用法，这对于本书后面各章的理解基本够用。虽然大多数数据分析工作不需要深入理解NumPy，但是精通面向数组的编程和思维方式是成为Python科学计算牛人的一大关键步骤。</p>
<blockquote>
<p>笔记：当你在本书中看到“数组”、“NumPy数组”、"ndarray"时，基本上都指的是同一样东西，即ndarray对象。</p>
</blockquote>
<h3 id="创建ndarray">4.1.1 创建ndarray</h3>
<p>创建数组最简单的办法就是使用array函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。以一个列表的转换为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">19</span>]: data1 = [<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: arr1 = np.array(data1)</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: arr1</span><br><span class="line">Out[<span class="number">21</span>]: array([ <span class="number">6.</span> ,  <span class="number">7.5</span>,  <span class="number">8.</span> ,  <span class="number">0.</span> ,  <span class="number">1.</span> ])</span><br></pre></td></tr></table></figure>
<p>嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: data2 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: arr2 = np.array(data2)</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: arr2</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure>
<p>因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: arr2.ndim</span><br><span class="line">Out[<span class="number">25</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: arr2.shape</span><br><span class="line">Out[<span class="number">26</span>]: (<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>除非特别说明（稍后将会详细介绍），np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。数据类型保存在一个特殊的dtype对象中。比如说，在上面的两个例子中，我们有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: arr1.dtype</span><br><span class="line">Out[<span class="number">27</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: arr2.dtype</span><br><span class="line">Out[<span class="number">28</span>]: dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>除np.array之外，还有一些函数也可以新建数组。比如，zeros和ones分别可以创建指定长度或形状的全0或全1数组。empty可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: np.zeros(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">29</span>]: array([ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: np.zeros((<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: np.empty((<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">array([[[ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>]],</span><br><span class="line">       [[ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">0.</span>]]])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：认为np.empty会返回全0数组的想法是不安全的。很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。</p>
</blockquote>
<p>arange是Python内置函数range的数组版：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: np.arange(<span class="number">15</span>)</span><br><span class="line">Out[<span class="number">32</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br></pre></td></tr></table></figure>
<p>表4-1列出了一些数组创建函数。由于NumPy关注的是数值计算，因此，如果没有特别指定，数据类型基本都是float64（浮点数）。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-78ab11f67e7077a6.png" class="" title="表4-1 数组创建函数">
<h3 id="ndarray的数据类型">4.1.2 ndarray的数据类型</h3>
<p>dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: arr2 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.int32)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: arr1.dtype</span><br><span class="line">Out[<span class="number">35</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: arr2.dtype</span><br><span class="line">Out[<span class="number">36</span>]: dtype(<span class="string">&#x27;int32&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>dtype是NumPy灵活交互其它系统的源泉之一。多数情况下，它们直接映射到相应的机器表示，这使得“读写磁盘上的二进制数据流”以及“集成低级语言代码（如C、Fortran）”等工作变得更加简单。数值型dtype的命名方式相同：一个类型名（如float或int），后面跟一个用于表示各元素位长的数字。标准的双精度浮点值（即Python中的float对象）需要占用8字节（即64位）。因此，该类型在NumPy中就记作float64。表4-2列出了NumPy所支持的全部数据类型。</p>
<blockquote>
<p>笔记：记不住这些NumPy的dtype也没关系，新手更是如此。通常只需要知道你所处理的数据的大致类型是浮点数、复数、整数、布尔值、字符串，还是普通的Python对象即可。当你需要控制数据在内存和磁盘中的存储方式时（尤其是对大数据集），那就得了解如何控制存储类型。</p>
</blockquote>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-2f2d7406a8bc076c.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-5cc31115615737b7.png" class="">
<p>你可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: arr.dtype</span><br><span class="line">Out[<span class="number">38</span>]: dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: float_arr = arr.astype(np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: float_arr.dtype</span><br><span class="line">Out[<span class="number">40</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在本例中，整数被转换成了浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: arr = np.array([<span class="number">3.7</span>, -<span class="number">1.2</span>, -<span class="number">2.6</span>, <span class="number">0.5</span>, <span class="number">12.9</span>, <span class="number">10.1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: arr</span><br><span class="line">Out[<span class="number">42</span>]: array([  <span class="number">3.7</span>,  -<span class="number">1.2</span>,  -<span class="number">2.6</span>,   <span class="number">0.5</span>,  <span class="number">12.9</span>,  <span class="number">10.1</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: arr.astype(np.int32)</span><br><span class="line">Out[<span class="number">43</span>]: array([ <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">2</span>,  <span class="number">0</span>, <span class="number">12</span>, <span class="number">10</span>], dtype=int32)</span><br></pre></td></tr></table></figure>
<p>如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: numeric_strings = np.array([<span class="string">&#x27;1.25&#x27;</span>, <span class="string">&#x27;-9.6&#x27;</span>, <span class="string">&#x27;42&#x27;</span>], dtype=np.string_)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: numeric_strings.astype(<span class="built_in">float</span>)</span><br><span class="line">Out[<span class="number">45</span>]: array([  <span class="number">1.25</span>,  -<span class="number">9.6</span> ,  <span class="number">42.</span>  ])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：使用numpy.string_类型时，一定要小心，因为NumPy的字符串数据是大小固定的，发生截取时，不会发出警告。pandas提供了更多非数值数据的便利的处理方法。</p>
</blockquote>
<p>如果转换过程因为某种原因而失败了（比如某个不能被转换为float64的字符串），就会引发一个ValueError。这里，我比较懒，写的是float而不是np.float64；NumPy很聪明，它会将Python类型映射到等价的dtype上。</p>
<p>数组的dtype还有另一个属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: int_array = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: calibers = np.array([<span class="number">.22</span>, <span class="number">.270</span>, <span class="number">.357</span>, <span class="number">.380</span>, <span class="number">.44</span>, <span class="number">.50</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: int_array.astype(calibers.dtype)</span><br><span class="line">Out[<span class="number">48</span>]: array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>])</span><br></pre></td></tr></table></figure>
<p>你还可以用简洁的类型代码来表示dtype：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: empty_uint32 = np.empty(<span class="number">8</span>, dtype=<span class="string">&#x27;u4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: empty_uint32</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">array([         <span class="number">0</span>, <span class="number">1075314688</span>,          <span class="number">0</span>, <span class="number">1075707904</span>,          <span class="number">0</span>,</span><br><span class="line">       <span class="number">1075838976</span>,          <span class="number">0</span>, <span class="number">1072693248</span>], dtype=uint32)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。</p>
</blockquote>
<h3 id="numpy数组的运算">4.1.3 NumPy数组的运算</h3>
<p>数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy用户称其为矢量化（vectorization）。大小相等的数组之间的任何算术运算都会将运算应用到元素级：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: arr = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: arr</span><br><span class="line">Out[<span class="number">52</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: arr * arr</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">array([[  <span class="number">1.</span>,   <span class="number">4.</span>,   <span class="number">9.</span>],</span><br><span class="line">       [ <span class="number">16.</span>,  <span class="number">25.</span>,  <span class="number">36.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: arr - arr</span><br><span class="line">Out[<span class="number">54</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>
<p>数组与标量的算术运算会将标量值传播到各个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: <span class="number">1</span> / arr</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>    ,  <span class="number">0.5</span>   ,  <span class="number">0.3333</span>],</span><br><span class="line">       [ <span class="number">0.25</span>  ,  <span class="number">0.2</span>   ,  <span class="number">0.1667</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: arr ** <span class="number">0.5</span></span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>    ,  <span class="number">1.4142</span>,  <span class="number">1.7321</span>],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.2361</span>,  <span class="number">2.4495</span>]])</span><br></pre></td></tr></table></figure>
<p>大小相同的数组之间的比较会生成布尔值数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: arr2 = np.array([[<span class="number">0.</span>, <span class="number">4.</span>, <span class="number">1.</span>], [<span class="number">7.</span>, <span class="number">2.</span>, <span class="number">12.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: arr2</span><br><span class="line">Out[<span class="number">58</span>]: </span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">4.</span>,   <span class="number">1.</span>],</span><br><span class="line">       [  <span class="number">7.</span>,   <span class="number">2.</span>,  <span class="number">12.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: arr2 &gt; arr</span><br><span class="line">Out[<span class="number">59</span>]:</span><br><span class="line">array([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>]], dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure>
<p>不同大小的数组之间的运算叫做广播（broadcasting），将在附录A中对其进行详细讨论。本书的内容不需要对广播机制有多深的理解。</p>
<h3 id="基本的索引和切片">4.1.4 基本的索引和切片</h3>
<p>NumPy数组的索引是一个内容丰富的主题，因为选取数据子集或单个元素的方式有很多。一维数组很简单。从表面上看，它们跟Python列表的功能差不多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: arr</span><br><span class="line">Out[<span class="number">61</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: arr[<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">62</span>]: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">Out[<span class="number">63</span>]: array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: arr[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: arr</span><br><span class="line">Out[<span class="number">65</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<p>如上所示，当你将一个标量值赋值给一个切片时（如arr[5:8]=12），该值会自动传播（也就说后面将会讲到的“广播”）到整个选区。跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。</p>
<p>作为例子，先创建一个arr的切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: arr_slice = arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: arr_slice</span><br><span class="line">Out[<span class="number">67</span>]: array([<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br></pre></td></tr></table></figure>
<p>现在，当我修稿arr_slice中的值，变动也会体现在原始数组arr中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: arr_slice[<span class="number">1</span>] = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: arr</span><br><span class="line">Out[<span class="number">69</span>]: array([    <span class="number">0</span>,     <span class="number">1</span>,     <span class="number">2</span>,     <span class="number">3</span>,     <span class="number">4</span>,    <span class="number">12</span>, <span class="number">12345</span>,    <span class="number">12</span>,     <span class="number">8</span>,   </span><br><span class="line">  <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<p>切片[ : ]会给数组中的所有值赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">70</span>]: arr_slice[:] = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: arr</span><br><span class="line">Out[<span class="number">71</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<p>如果你刚开始接触NumPy，可能会对此感到惊讶（尤其是当你曾经用过其他热衷于复制数组数据的编程语言）。由于NumPy的设计目的是处理大数据，所以你可以想象一下，假如NumPy坚持要将数据复制来复制去的话会产生何等的性能和内存问题。</p>
<blockquote>
<p>注意：如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如<code>arr[5:8].copy()</code>。</p>
</blockquote>
<p>对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: arr2d[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">73</span>]: array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<p>因此，可以对各个元素进行递归访问，但这样需要做的事情有点多。你可以传入一个以逗号隔开的索引列表来选取单个元素。也就是说，下面两种方式是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: arr2d[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">74</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: arr2d[<span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">75</span>]: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>图4-1说明了二维数组的索引方式。轴0作为行，轴1作为列。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-0a641536f73f560e.png" class="" title="图4-1 NumPy数组中的元素索引">
<p>在多维数组中，如果省略了后面的索引，则返回对象会是一个维度低一点的ndarray（它含有高一级维度上的所有数据）。因此，在2×2×3数组arr3d中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: arr3d = np.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], [[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: arr3d</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">array([[[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>]],</span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br></pre></td></tr></table></figure>
<p>arr3d[0]是一个2×3数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: arr3d[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure>
<p>标量值和数组都可以被赋值给arr3d[0]：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: old_values = arr3d[<span class="number">0</span>].copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: arr3d[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: arr3d</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">array([[[<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>],</span><br><span class="line">        [<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>]],</span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: arr3d[<span class="number">0</span>] = old_values</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: arr3d</span><br><span class="line">Out[<span class="number">83</span>]: </span><br><span class="line">array([[[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>]],</span><br><span class="line">       [[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br></pre></td></tr></table></figure>
<p>相似的，arr3d[1,0]可以访问索引以(1,0)开头的那些值（以一维数组的形式返回）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">84</span>]: arr3d[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">84</span>]: array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<p>虽然是用两步进行索引的，表达式是相同的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: x = arr3d[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: x</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">array([[ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: x[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">87</span>]: array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<p>注意，在上面所有这些选取数组子集的例子中，返回的数组都是视图。</p>
<h3 id="切片索引">4.1.5 切片索引</h3>
<p>ndarray的切片语法跟Python列表这样的一维对象差不多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">88</span>]: arr</span><br><span class="line">Out[<span class="number">88</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: arr[<span class="number">1</span>:<span class="number">6</span>]</span><br><span class="line">Out[<span class="number">89</span>]: array([ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">64</span>])</span><br></pre></td></tr></table></figure>
<p>对于之前的二维数组arr2d，其切片方式稍显不同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">90</span>]: arr2d</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: arr2d[:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">91</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure>
<p>可以看出，它是沿着第0轴（即第一个轴）切片的。也就是说，切片是沿着一个轴向选取元素的。表达式arr2d[:2]可以被认为是“选取arr2d的前两行”。</p>
<p>你可以一次传入多个切片，就像传入多个索引那样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">92</span>]: arr2d[:<span class="number">2</span>, <span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure>
<p>像这样进行切片时，只能得到相同维数的数组视图。通过将整数索引和切片混合，可以得到低维度的切片。</p>
<p>例如，我可以选取第二行的前两列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: arr2d[<span class="number">1</span>, :<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">93</span>]: array([<span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p>相似的，还可以选择第三列的前两行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: arr2d[:<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">94</span>]: array([<span class="number">3</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<p>图4-2对此进行了说明。注意，“只有冒号”表示选取整个轴，因此你可以像下面这样只对高维轴进行切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: arr2d[:, :<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line">array([[<span class="number">1</span>],</span><br><span class="line">       [<span class="number">4</span>],</span><br><span class="line">       [<span class="number">7</span>]])</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-9da32d2f4629c304.png" class="" title="图4-2 二维数组切片">
<p>自然，对切片表达式的赋值操作也会被扩散到整个选区：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: arr2d[:<span class="number">2</span>, <span class="number">1</span>:] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: arr2d</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="布尔型索引">4.1.6 布尔型索引</h3>
<p>来看这样一个例子，假设我们有一个用于存储数据的数组以及一个存储姓名的数组（含有重复项）。在这里，我将使用numpy.random中的randn函数生成一些正态分布的随机数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: names = np.array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: data = np.random.randn(<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: names</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>],</span><br><span class="line">      dtype=<span class="string">&#x27;&lt;U4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: data</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.0072</span>, -<span class="number">1.2962</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [-<span class="number">0.7135</span>, -<span class="number">0.8312</span>, -<span class="number">2.3702</span>, -<span class="number">1.8608</span>]])</span><br></pre></td></tr></table></figure>
<p>假设每个名字都对应data数组中的一行，而我们想要选出对应于名字"Bob"的所有行。跟算术运算一样，数组的比较运算（如==）也是矢量化的。因此，对names和字符串"Bob"的比较运算将会产生一个布尔型数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: names == <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">Out[<span class="number">102</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure>
<p>这个布尔型数组可用于数组索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">103</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ]])</span><br></pre></td></tr></table></figure>
<p>布尔型数组的长度必须跟被索引的轴长度一致。此外，还可以将布尔型数组跟切片、整数（或整数序列，稍后将对此进行详细讲解）混合使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">103</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ]])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果布尔型数组的长度不对，布尔型选择就会出错，因此一定要小心。</p>
</blockquote>
<p>下面的例子，我选取了<code>names == 'Bob'</code>的行，并索引了列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">104</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>, <span class="number">2</span>:]</span><br><span class="line">Out[<span class="number">104</span>]: </span><br><span class="line">array([[ <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [-<span class="number">0.5397</span>,  <span class="number">0.477</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: data[names == <span class="string">&#x27;Bob&#x27;</span>, <span class="number">3</span>]</span><br><span class="line">Out[<span class="number">105</span>]: array([ <span class="number">1.2464</span>,  <span class="number">0.477</span> ])</span><br></pre></td></tr></table></figure>
<p>要选择除"Bob"以外的其他值，既可以使用不等于符号（!=），也可以通过~对条件进行否定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: names != <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">Out[<span class="number">106</span>]: array([<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: data[~(names == <span class="string">&#x27;Bob&#x27;</span>)]</span><br><span class="line">Out[<span class="number">107</span>]:</span><br><span class="line">array([[ <span class="number">1.0072</span>, -<span class="number">1.2962</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [-<span class="number">0.7135</span>, -<span class="number">0.8312</span>, -<span class="number">2.3702</span>, -<span class="number">1.8608</span>]])</span><br></pre></td></tr></table></figure>
<p>~操作符用来反转条件很好用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: cond = names == <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: data[~cond]</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">array([[ <span class="number">1.0072</span>, -<span class="number">1.2962</span>,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [-<span class="number">0.7135</span>, -<span class="number">0.8312</span>, -<span class="number">2.3702</span>, -<span class="number">1.8608</span>]])</span><br></pre></td></tr></table></figure>
<p>选取这三个名字中的两个需要组合应用多个布尔条件，使用&amp;（和）、|（或）之类的布尔算术运算符即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: mask = (names == <span class="string">&#x27;Bob&#x27;</span>) | (names == <span class="string">&#x27;Will&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: mask</span><br><span class="line">Out[<span class="number">111</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: data[mask]</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>, -<span class="number">2.0016</span>, -<span class="number">0.3718</span>],</span><br><span class="line">       [ <span class="number">1.669</span> , -<span class="number">0.4386</span>, -<span class="number">0.5397</span>,  <span class="number">0.477</span> ],</span><br><span class="line">       [ <span class="number">3.2489</span>, -<span class="number">1.0212</span>, -<span class="number">0.5771</span>,  <span class="number">0.1241</span>]])</span><br></pre></td></tr></table></figure>
<p>通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。</p>
<blockquote>
<p>注意：Python关键字and和or在布尔型数组中无效。要使用&amp;与|。</p>
</blockquote>
<p>通过布尔型数组设置值是一种经常用到的手段。为了将data中的所有负值都设置为0，我们只需：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">113</span>]: data[data &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: data</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">array([[ <span class="number">0.0929</span>,  <span class="number">0.2817</span>,  <span class="number">0.769</span> ,  <span class="number">1.2464</span>],</span><br><span class="line">       [ <span class="number">1.0072</span>,  <span class="number">0.</span>    ,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">1.3529</span>,  <span class="number">0.8864</span>,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ],</span><br><span class="line">       [ <span class="number">1.669</span> ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.477</span> ],</span><br><span class="line">       [ <span class="number">3.2489</span>,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.1241</span>],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ]])</span><br></pre></td></tr></table></figure>
<p>通过一维布尔数组设置整行或列的值也很简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: data[names != <span class="string">&#x27;Joe&#x27;</span>] = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: data</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line">array([[ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">1.0072</span>,  <span class="number">0.</span>    ,  <span class="number">0.275</span> ,  <span class="number">0.2289</span>],</span><br><span class="line">       [ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ,  <span class="number">7.</span>    ],</span><br><span class="line">       [ <span class="number">0.3026</span>,  <span class="number">0.5238</span>,  <span class="number">0.0009</span>,  <span class="number">1.3438</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ]])</span><br></pre></td></tr></table></figure>
<p>后面会看到，这类二维数据的操作也可以用pandas方便的来做。</p>
<h3 id="花式索引">4.1.7 花式索引</h3>
<p>花式索引（Fancy indexing）是一个NumPy术语，它指的是利用整数数组进行索引。假设我们有一个8×4数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: arr = np.empty((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">   .....:     arr[i] = i</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: arr</span><br><span class="line">Out[<span class="number">119</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>],</span><br><span class="line">       [ <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">7.</span>]])</span><br></pre></td></tr></table></figure>
<p>为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或ndarray即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">120</span>]: arr[[<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>]]</span><br><span class="line">Out[<span class="number">120</span>]: </span><br><span class="line">array([[ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>]])</span><br></pre></td></tr></table></figure>
<p>这段代码确实达到我们的要求了！使用负数索引将会从末尾开始选取行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">121</span>]: arr[[-<span class="number">3</span>, -<span class="number">5</span>, -<span class="number">7</span>]]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">array([[ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>
<p>一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">122</span>]: arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: arr</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">       [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>],</span><br><span class="line">       [<span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">Out[<span class="number">124</span>]: array([ <span class="number">4</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure>
<p>附录A中会详细介绍reshape方法。</p>
<p>最终选出的是元素(1,0)、(5,3)、(7,1)和(2,2)。无论数组是多少维的，花式索引总是一维的。</p>
<p>这个花式索引的行为可能会跟某些用户的预期不一样（包括我在内），选取矩阵的行列子集应该是矩形区域的形式才对。下面是得到该结果的一个办法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">125</span>]: arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>]][:, [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">Out[<span class="number">125</span>]: </span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">7</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">22</span>],</span><br><span class="line">       [<span class="number">28</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">11</span>,  <span class="number">9</span>, <span class="number">10</span>]])</span><br></pre></td></tr></table></figure>
<p>记住，花式索引跟切片不一样，它总是将数据复制到新数组中。</p>
<h3 id="数组转置和轴对换">4.1.8 数组转置和轴对换</h3>
<p>转置是重塑的一种特殊形式，它返回的是源数据的视图（不会进行任何复制操作）。数组不仅有transpose方法，还有一个特殊的T属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">126</span>]: arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: arr</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: arr.T</span><br><span class="line">Out[<span class="number">128</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">6</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">7</span>, <span class="number">12</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">8</span>, <span class="number">13</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">9</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure>
<p>在进行矩阵计算时，经常需要用到该操作，比如利用np.dot计算矩阵内积：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">129</span>]: arr = np.random.randn(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: arr</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">array([[-<span class="number">0.8608</span>,  <span class="number">0.5601</span>, -<span class="number">1.2659</span>],</span><br><span class="line">       [ <span class="number">0.1198</span>, -<span class="number">1.0635</span>,  <span class="number">0.3329</span>],</span><br><span class="line">       [-<span class="number">2.3594</span>, -<span class="number">0.1995</span>, -<span class="number">1.542</span> ],</span><br><span class="line">       [-<span class="number">0.9707</span>, -<span class="number">1.307</span> ,  <span class="number">0.2863</span>],</span><br><span class="line">       [ <span class="number">0.378</span> , -<span class="number">0.7539</span>,  <span class="number">0.3313</span>],</span><br><span class="line">       [ <span class="number">1.3497</span>,  <span class="number">0.0699</span>,  <span class="number">0.2467</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: np.dot(arr.T, arr)</span><br><span class="line">Out[<span class="number">131</span>]:</span><br><span class="line">array([[ <span class="number">9.2291</span>,  <span class="number">0.9394</span>,  <span class="number">4.948</span> ],</span><br><span class="line">       [ <span class="number">0.9394</span>,  <span class="number">3.7662</span>, -<span class="number">1.3622</span>],</span><br><span class="line">       [ <span class="number">4.948</span> , -<span class="number">1.3622</span>,  <span class="number">4.3437</span>]])</span><br></pre></td></tr></table></figure>
<p>对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置（比较费脑子）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">132</span>]: arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: arr</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure>
<p>这里，第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。</p>
<p>简单的转置可以使用.T，它其实就是进行轴对换而已。ndarray还有一个swapaxes方法，它需要接受一对轴编号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">135</span>]: arr</span><br><span class="line">Out[<span class="number">135</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: arr.swapaxes(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">7</span>]],</span><br><span class="line">       [[ <span class="number">8</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure>
<p>swapaxes也是返回源数据的视图（不会进行任何复制操作）。</p>
<h2 id="通用函数快速的元素级数组函数">4.2 通用函数：快速的元素级数组函数</h2>
<p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。</p>
<p>许多ufunc都是简单的元素级变体，如sqrt和exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">137</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">138</span>]: arr</span><br><span class="line">Out[<span class="number">138</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: np.sqrt(arr)</span><br><span class="line">Out[<span class="number">139</span>]: </span><br><span class="line">array([ <span class="number">0.</span>    ,  <span class="number">1.</span>    ,  <span class="number">1.4142</span>,  <span class="number">1.7321</span>,  <span class="number">2.</span>    ,  <span class="number">2.2361</span>,  <span class="number">2.4495</span>,</span><br><span class="line">        <span class="number">2.6458</span>,  <span class="number">2.8284</span>,  <span class="number">3.</span>    ])</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: np.exp(arr)</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">array([    <span class="number">1.</span>    ,     <span class="number">2.7183</span>,     <span class="number">7.3891</span>,    <span class="number">20.0855</span>,    <span class="number">54.5982</span>,</span><br><span class="line">         <span class="number">148.4132</span>,   <span class="number">403.4288</span>,  <span class="number">1096.6332</span>,  <span class="number">2980.958</span> ,  <span class="number">8103.0839</span>])</span><br></pre></td></tr></table></figure>
<p>这些都是一元（unary）ufunc。另外一些（如add或maximum）接受2个数组（因此也叫二元（binary）ufunc），并返回一个结果数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: x = np.random.randn(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: y = np.random.randn(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: x</span><br><span class="line">Out[<span class="number">143</span>]: </span><br><span class="line">array([-<span class="number">0.0119</span>,  <span class="number">1.0048</span>,  <span class="number">1.3272</span>, -<span class="number">0.9193</span>, -<span class="number">1.5491</span>,  <span class="number">0.0222</span>,  <span class="number">0.7584</span>,</span><br><span class="line">       -<span class="number">0.6605</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: y</span><br><span class="line">Out[<span class="number">144</span>]: </span><br><span class="line">array([ <span class="number">0.8626</span>, -<span class="number">0.01</span>  ,  <span class="number">0.05</span>  ,  <span class="number">0.6702</span>,  <span class="number">0.853</span> , -<span class="number">0.9559</span>, -<span class="number">0.0235</span>,</span><br><span class="line">       -<span class="number">2.3042</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: np.maximum(x, y)</span><br><span class="line">Out[<span class="number">145</span>]: </span><br><span class="line">array([ <span class="number">0.8626</span>,  <span class="number">1.0048</span>,  <span class="number">1.3272</span>,  <span class="number">0.6702</span>,  <span class="number">0.853</span> ,  <span class="number">0.0222</span>,  <span class="number">0.7584</span>,   </span><br><span class="line">       -<span class="number">0.6605</span>])</span><br></pre></td></tr></table></figure>
<p>这里，numpy.maximum计算了x和y中元素级别最大的元素。</p>
<p>虽然并不常见，但有些ufunc的确可以返回多个数组。modf就是一个例子，它是Python内置函数divmod的矢量化版本，它会返回浮点数数组的小数和整数部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">146</span>]: arr = np.random.randn(<span class="number">7</span>) * <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">147</span>]: arr</span><br><span class="line">Out[<span class="number">147</span>]: array([-<span class="number">3.2623</span>, -<span class="number">6.0915</span>, -<span class="number">6.663</span> ,  <span class="number">5.3731</span>,  <span class="number">3.6182</span>,  <span class="number">3.45</span>  ,  <span class="number">5.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: remainder, whole_part = np.modf(arr)</span><br><span class="line"></span><br><span class="line">In [<span class="number">149</span>]: remainder</span><br><span class="line">Out[<span class="number">149</span>]: array([-<span class="number">0.2623</span>, -<span class="number">0.0915</span>, -<span class="number">0.663</span> ,  <span class="number">0.3731</span>,</span><br><span class="line"><span class="number">0.6182</span>,  <span class="number">0.45</span>  ,  <span class="number">0.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: whole_part</span><br><span class="line">Out[<span class="number">150</span>]: array([-<span class="number">3.</span>, -<span class="number">6.</span>, -<span class="number">6.</span>,  <span class="number">5.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">5.</span>])</span><br></pre></td></tr></table></figure>
<p>Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">151</span>]: arr</span><br><span class="line">Out[<span class="number">151</span>]: array([-<span class="number">3.2623</span>, -<span class="number">6.0915</span>, -<span class="number">6.663</span> ,  <span class="number">5.3731</span>,  <span class="number">3.6182</span>,  <span class="number">3.45</span>  ,  <span class="number">5.0077</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: np.sqrt(arr)</span><br><span class="line">Out[<span class="number">152</span>]: array([    nan,     nan,     nan,  <span class="number">2.318</span> ,  <span class="number">1.9022</span>,  <span class="number">1.8574</span>,  <span class="number">2.2378</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: np.sqrt(arr, arr)</span><br><span class="line">Out[<span class="number">153</span>]: array([    nan,     nan,     nan,  <span class="number">2.318</span> ,  <span class="number">1.9022</span>,  <span class="number">1.8574</span>,  <span class="number">2.2378</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">154</span>]: arr</span><br><span class="line">Out[<span class="number">154</span>]: array([    nan,     nan,     nan,  <span class="number">2.318</span> ,  <span class="number">1.9022</span>,  <span class="number">1.8574</span>,  <span class="number">2.2378</span>])</span><br></pre></td></tr></table></figure>
<p>表4-3和表4-4分别列出了一些一元和二元ufunc。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-1d494e73b61c7ced.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-2be79faf68ab6ff8.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-4e38d02a66481530.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-eff1e61e5464159f.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-236dba83b6a420cc.png" class="">
<h2 id="利用数组进行数据处理">4.3 利用数组进行数据处理</h2>
<p>NumPy数组使你可以将许多种数据处理任务表述为简洁的数组表达式（否则需要编写循环）。用数组表达式代替循环的做法，通常被称为矢量化。一般来说，矢量化数组运算要比等价的纯Python方式快上一两个数量级（甚至更多），尤其是各种数值计算。在后面内容中（见附录A）我将介绍广播，这是一种针对矢量化计算的强大手段。</p>
<p>作为简单的例子，假设我们想要在一组值（网格型）上计算函数<code>sqrt(x^2+y^2)</code>。np.meshgrid函数接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的(x,y)对）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">155</span>]: points = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.01</span>) <span class="comment"># 1000 equally spaced points</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: xs, ys = np.meshgrid(points, points)</span><br><span class="line">In [<span class="number">157</span>]: ys</span><br><span class="line">Out[<span class="number">157</span>]: </span><br><span class="line">array([[-<span class="number">5.</span>  , -<span class="number">5.</span>  , -<span class="number">5.</span>  , ..., -<span class="number">5.</span>  , -<span class="number">5.</span>  , -<span class="number">5.</span>  ],</span><br><span class="line">       [-<span class="number">4.99</span>, -<span class="number">4.99</span>, -<span class="number">4.99</span>, ..., -<span class="number">4.99</span>, -<span class="number">4.99</span>, -<span class="number">4.99</span>],</span><br><span class="line">       [-<span class="number">4.98</span>, -<span class="number">4.98</span>, -<span class="number">4.98</span>, ..., -<span class="number">4.98</span>, -<span class="number">4.98</span>, -<span class="number">4.98</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [ <span class="number">4.97</span>,  <span class="number">4.97</span>,  <span class="number">4.97</span>, ...,  <span class="number">4.97</span>,  <span class="number">4.97</span>,  <span class="number">4.97</span>],</span><br><span class="line">       [ <span class="number">4.98</span>,  <span class="number">4.98</span>,  <span class="number">4.98</span>, ...,  <span class="number">4.98</span>,  <span class="number">4.98</span>,  <span class="number">4.98</span>],</span><br><span class="line">       [ <span class="number">4.99</span>,  <span class="number">4.99</span>,  <span class="number">4.99</span>, ...,  <span class="number">4.99</span>,  <span class="number">4.99</span>,  <span class="number">4.99</span>]])</span><br></pre></td></tr></table></figure>
<p>现在，对该函数的求值运算就好办了，把这两个数组当做两个浮点数那样编写表达式即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">158</span>]: z = np.sqrt(xs ** <span class="number">2</span> + ys ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: z</span><br><span class="line">Out[<span class="number">159</span>]: </span><br><span class="line">array([[ <span class="number">7.0711</span>,  <span class="number">7.064</span> ,  <span class="number">7.0569</span>, ...,  <span class="number">7.0499</span>,  <span class="number">7.0569</span>,  <span class="number">7.064</span> ],</span><br><span class="line">       [ <span class="number">7.064</span> ,  <span class="number">7.0569</span>,  <span class="number">7.0499</span>, ...,  <span class="number">7.0428</span>,  <span class="number">7.0499</span>,  <span class="number">7.0569</span>],</span><br><span class="line">       [ <span class="number">7.0569</span>,  <span class="number">7.0499</span>,  <span class="number">7.0428</span>, ...,  <span class="number">7.0357</span>,  <span class="number">7.0428</span>, <span class="number">7.0499</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [ <span class="number">7.0499</span>,  <span class="number">7.0428</span>,  <span class="number">7.0357</span>, ...,  <span class="number">7.0286</span>,  <span class="number">7.0357</span>,  <span class="number">7.0428</span>],</span><br><span class="line">       [ <span class="number">7.0569</span>,  <span class="number">7.0499</span>,  <span class="number">7.0428</span>, ...,  <span class="number">7.0357</span>,  <span class="number">7.0428</span>,  <span class="number">7.0499</span>],</span><br><span class="line">       [ <span class="number">7.064</span> ,  <span class="number">7.0569</span>,  <span class="number">7.0499</span>, ...,  <span class="number">7.0428</span>,  <span class="number">7.0499</span>,  <span class="number">7.0569</span>]])</span><br></pre></td></tr></table></figure>
<p>作为第9章的先导，我用matplotlib创建了这个二维数组的可视化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">160</span>]: <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()</span><br><span class="line">Out[<span class="number">161</span>]: &lt;matplotlib.colorbar.Colorbar at <span class="number">0x7f715e3fa630</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: plt.title(<span class="string">&quot;Image plot of $\sqrt&#123;x^2 + y^2&#125;$ for a grid of values&quot;</span>)</span><br><span class="line">Out[<span class="number">162</span>]: &lt;matplotlib.text.Text at <span class="number">0x7f715d2de748</span>&gt;</span><br></pre></td></tr></table></figure>
<p>见图4-3。这张图是用matplotlib的imshow函数创建的。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-3b22000d4cd38650.png" class="" title="图4-3 根据网格对函数求值的结果">
<h3 id="将条件逻辑表述为数组运算">4.3.1 将条件逻辑表述为数组运算</h3>
<p>numpy.where函数是三元表达式x if condition else y的矢量化版本。假设我们有一个布尔数组和两个值数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: cond = np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br></pre></td></tr></table></figure>
<p>假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。列表推导式的写法应该如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">168</span>]: result = [(x <span class="keyword">if</span> c <span class="keyword">else</span> y)</span><br><span class="line">   .....:           <span class="keyword">for</span> x, y, c <span class="keyword">in</span> <span class="built_in">zip</span>(xarr, yarr, cond)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: result</span><br><span class="line">Out[<span class="number">169</span>]: [<span class="number">1.1000000000000001</span>, <span class="number">2.2000000000000002</span>, <span class="number">1.3</span>, <span class="number">1.3999999999999999</span>, <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure>
<p>这有几个问题。第一，它对大数组的处理速度不是很快（因为所有工作都是由纯Python完成的）。第二，无法用于多维数组。若使用np.where，则可以将该功能写得非常简洁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">170</span>]: result = np.where(cond, xarr, yarr)</span><br><span class="line"></span><br><span class="line">In [<span class="number">171</span>]: result</span><br><span class="line">Out[<span class="number">171</span>]: array([ <span class="number">1.1</span>,  <span class="number">2.2</span>,  <span class="number">1.3</span>,  <span class="number">1.4</span>,  <span class="number">2.5</span>])</span><br></pre></td></tr></table></figure>
<p>np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组。假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用np.where，则会非常简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">172</span>]: arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: arr</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">array([[-<span class="number">0.5031</span>, -<span class="number">0.6223</span>, -<span class="number">0.9212</span>, -<span class="number">0.7262</span>],</span><br><span class="line">       [ <span class="number">0.2229</span>,  <span class="number">0.0513</span>, -<span class="number">1.1577</span>,  <span class="number">0.8167</span>],</span><br><span class="line">       [ <span class="number">0.4336</span>,  <span class="number">1.0107</span>,  <span class="number">1.8249</span>, -<span class="number">0.9975</span>],</span><br><span class="line">       [ <span class="number">0.8506</span>, -<span class="number">0.1316</span>,  <span class="number">0.9124</span>,  <span class="number">0.1882</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">174</span>]: arr &gt; <span class="number">0</span></span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">175</span>]: np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, -<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">array([[-<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>, -<span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>使用np.where，可以将标量和数组结合起来。例如，我可用常数2替换arr中所有正的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">176</span>]: np.where(arr &gt; <span class="number">0</span>, <span class="number">2</span>, arr) <span class="comment"># set only positive values to 2</span></span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[-<span class="number">0.5031</span>, -<span class="number">0.6223</span>, -<span class="number">0.9212</span>, -<span class="number">0.7262</span>],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.</span>    , -<span class="number">1.1577</span>,  <span class="number">2.</span>    ],</span><br><span class="line">       [ <span class="number">2.</span>    ,  <span class="number">2.</span>    ,  <span class="number">2.</span>    , -<span class="number">0.9975</span>],</span><br><span class="line">       [ <span class="number">2.</span>    , -<span class="number">0.1316</span>,  <span class="number">2.</span>    ,  <span class="number">2.</span>    ]])</span><br></pre></td></tr></table></figure>
<p>传递给where的数组大小可以不相等，甚至可以是标量值。</p>
<h3 id="数学和统计方法">4.3.2 数学和统计方法</h3>
<p>可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。sum、mean以及标准差std等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。</p>
<p>这里，我生成了一些正态分布随机数据，然后做了聚类统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">177</span>]: arr = np.random.randn(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: arr</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">array([[ <span class="number">2.1695</span>, -<span class="number">0.1149</span>,  <span class="number">2.0037</span>,  <span class="number">0.0296</span>],</span><br><span class="line">       [ <span class="number">0.7953</span>,  <span class="number">0.1181</span>, -<span class="number">0.7485</span>,  <span class="number">0.585</span> ],</span><br><span class="line">       [ <span class="number">0.1527</span>, -<span class="number">1.5657</span>, -<span class="number">0.5625</span>, -<span class="number">0.0327</span>],</span><br><span class="line">       [-<span class="number">0.929</span> , -<span class="number">0.4826</span>, -<span class="number">0.0363</span>,  <span class="number">1.0954</span>],</span><br><span class="line">       [ <span class="number">0.9809</span>, -<span class="number">0.5895</span>,  <span class="number">1.5817</span>, -<span class="number">0.5287</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">179</span>]: arr.mean()</span><br><span class="line">Out[<span class="number">179</span>]: <span class="number">0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: np.mean(arr)</span><br><span class="line">Out[<span class="number">180</span>]: <span class="number">0.19607051119998253</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: arr.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">181</span>]: <span class="number">3.9214102239996507</span></span><br></pre></td></tr></table></figure>
<p>mean和sum这类的函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">182</span>]: arr.mean(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">182</span>]: array([ <span class="number">1.022</span> ,  <span class="number">0.1875</span>, -<span class="number">0.502</span> , -<span class="number">0.0881</span>,  <span class="number">0.3611</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: arr.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">183</span>]: array([ <span class="number">3.1693</span>, -<span class="number">2.6345</span>,  <span class="number">2.2381</span>,  <span class="number">1.1486</span>])</span><br></pre></td></tr></table></figure>
<p>这里，arr.mean(1)是“计算行的平均值”，arr.sum(0)是“计算每列的和”。</p>
<p>其他如cumsum和cumprod之类的方法则不聚合，而是产生一个由中间结果组成的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">184</span>]: arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: arr.cumsum()</span><br><span class="line">Out[<span class="number">185</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>])</span><br></pre></td></tr></table></figure>
<p>在多维数组中，累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">186</span>]: arr = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: arr</span><br><span class="line">Out[<span class="number">187</span>]: </span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">188</span>]: arr.cumsum(axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">188</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: arr.cumprod(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">189</span>]: </span><br><span class="line">array([[  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">       [  <span class="number">3</span>,  <span class="number">12</span>,  <span class="number">60</span>],</span><br><span class="line">       [  <span class="number">6</span>,  <span class="number">42</span>, <span class="number">336</span>]])</span><br></pre></td></tr></table></figure>
<p>表4-5列出了全部的基本数组统计方法。后续章节中有很多例子都会用到这些方法。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-a6c6df3ca8e0b98e.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-866fcde885b1d357.png" class="">
<h3 id="用于布尔型数组的方法">4.3.3 用于布尔型数组的方法</h3>
<p>在上面这些方法中，布尔值会被强制转换为1（True）和0（False）。因此，sum经常被用来对布尔型数组中的True值计数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">190</span>]: arr = np.random.randn(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: (arr &gt; <span class="number">0</span>).<span class="built_in">sum</span>() <span class="comment"># Number of positive values</span></span><br><span class="line">Out[<span class="number">191</span>]: <span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>另外还有两个方法any和all，它们对布尔型数组非常有用。any用于测试数组中是否存在一个或多个True，而all则检查数组中所有值是否都是True：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">192</span>]: bools = np.array([<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">193</span>]: bools.<span class="built_in">any</span>()</span><br><span class="line">Out[<span class="number">193</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: bools.<span class="built_in">all</span>()</span><br><span class="line">Out[<span class="number">194</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>这两个方法也能用于非布尔型数组，所有非0元素将会被当做True。</p>
<h3 id="排序">4.3.4 排序</h3>
<p>跟Python内置的列表类型一样，NumPy数组也可以通过sort方法就地排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">195</span>]: arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">196</span>]: arr</span><br><span class="line">Out[<span class="number">196</span>]: array([ <span class="number">0.6095</span>, -<span class="number">0.4938</span>,  <span class="number">1.24</span>  , -<span class="number">0.1357</span>,  <span class="number">1.43</span>  , -<span class="number">0.8469</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">197</span>]: arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">198</span>]: arr</span><br><span class="line">Out[<span class="number">198</span>]: array([-<span class="number">0.8469</span>, -<span class="number">0.4938</span>, -<span class="number">0.1357</span>,  <span class="number">0.6095</span>,  <span class="number">1.24</span>  ,  <span class="number">1.43</span>  ])</span><br></pre></td></tr></table></figure>
<p>多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">199</span>]: arr = np.random.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">200</span>]: arr</span><br><span class="line">Out[<span class="number">200</span>]: </span><br><span class="line">array([[ <span class="number">0.6033</span>,  <span class="number">1.2636</span>, -<span class="number">0.2555</span>],</span><br><span class="line">       [-<span class="number">0.4457</span>,  <span class="number">0.4684</span>, -<span class="number">0.9616</span>],</span><br><span class="line">       [-<span class="number">1.8245</span>,  <span class="number">0.6254</span>,  <span class="number">1.0229</span>],</span><br><span class="line">       [ <span class="number">1.1074</span>,  <span class="number">0.0909</span>, -<span class="number">0.3501</span>],</span><br><span class="line">       [ <span class="number">0.218</span> , -<span class="number">0.8948</span>, -<span class="number">1.7415</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">201</span>]: arr.sort(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: arr</span><br><span class="line">Out[<span class="number">202</span>]: </span><br><span class="line">array([[-<span class="number">0.2555</span>,  <span class="number">0.6033</span>,  <span class="number">1.2636</span>],</span><br><span class="line">       [-<span class="number">0.9616</span>, -<span class="number">0.4457</span>,  <span class="number">0.4684</span>],</span><br><span class="line">       [-<span class="number">1.8245</span>,  <span class="number">0.6254</span>,  <span class="number">1.0229</span>],</span><br><span class="line">       [-<span class="number">0.3501</span>,  <span class="number">0.0909</span>,  <span class="number">1.1074</span>],</span><br><span class="line">       [-<span class="number">1.7415</span>, -<span class="number">0.8948</span>,  <span class="number">0.218</span> ]])</span><br></pre></td></tr></table></figure>
<p>顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身。计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">203</span>]: large_arr = np.random.randn(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">204</span>]: large_arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: large_arr[<span class="built_in">int</span>(<span class="number">0.05</span> * <span class="built_in">len</span>(large_arr))] <span class="comment"># 5% quantile</span></span><br><span class="line">Out[<span class="number">205</span>]: -<span class="number">1.5311513550102103</span></span><br></pre></td></tr></table></figure>
<p>更多关于NumPy排序方法以及诸如间接排序之类的高级技术，请参阅附录A。在pandas中还可以找到一些其他跟排序有关的数据操作（比如根据一列或多列对表格型数据进行排序）。</p>
<h3 id="唯一化以及其它的集合逻辑">4.3.5 唯一化以及其它的集合逻辑</h3>
<p>NumPy提供了一些针对一维ndarray的基本集合运算。最常用的可能要数np.unique了，它用于找出数组中的唯一值并返回已排序的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">206</span>]: names = np.array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">207</span>]: np.unique(names)</span><br><span class="line">Out[<span class="number">207</span>]: </span><br><span class="line">array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>],</span><br><span class="line">      dtype=<span class="string">&#x27;&lt;U4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: ints = np.array([<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">209</span>]: np.unique(ints)</span><br><span class="line">Out[<span class="number">209</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>拿跟np.unique等价的纯Python代码来对比一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">210</span>]: <span class="built_in">sorted</span>(<span class="built_in">set</span>(names))</span><br><span class="line">Out[<span class="number">210</span>]: [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">211</span>]: values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: np.in1d(values, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>])</span><br><span class="line">Out[<span class="number">212</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>], dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure>
<p>NumPy中的集合函数请参见表4-6。 <img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-80e85ae6b9c89ada.png" class=""> ## 4.4 用于数组的文件输入输出 NumPy能够读写磁盘上的文本数据或二进制数据。这一小节只讨论NumPy的内置二进制格式，因为更多的用户会使用pandas或其它工具加载文本或表格数据（见第6章）。</p>
<p>np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">213</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: np.save(<span class="string">&#x27;some_array&#x27;</span>, arr)</span><br></pre></td></tr></table></figure>
<p>如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。然后就可以通过np.load读取磁盘上的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">215</span>]: np.load(<span class="string">&#x27;some_array.npy&#x27;</span>)</span><br><span class="line">Out[<span class="number">215</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<p>通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">216</span>]: np.savez(<span class="string">&#x27;array_archive.npz&#x27;</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure>
<p>加载.npz文件时，你会得到一个类似字典的对象，该对象会对各个数组进行延迟加载：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">217</span>]: arch = np.load(<span class="string">&#x27;array_archive.npz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">218</span>]: arch[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">218</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<p>如果要将数据压缩，可以使用numpy.savez_compressed：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">219</span>]: np.savez_compressed(<span class="string">&#x27;arrays_compressed.npz&#x27;</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure>
<h2 id="线性代数">4.5 线性代数</h2>
<p>线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。不像某些语言（如MATLAB），通过*对两个二维数组相乘得到的是一个元素级的积，而不是一个矩阵点积。因此，NumPy提供了一个用于矩阵乘法的dot函数（既是一个数组方法也是numpy命名空间中的一个函数）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">223</span>]: x = np.array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">224</span>]: y = np.array([[<span class="number">6.</span>, <span class="number">23.</span>], [-<span class="number">1</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">225</span>]: x</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">226</span>]: y</span><br><span class="line">Out[<span class="number">226</span>]: </span><br><span class="line">array([[  <span class="number">6.</span>,  <span class="number">23.</span>],</span><br><span class="line">       [ -<span class="number">1.</span>,   <span class="number">7.</span>],</span><br><span class="line">       [  <span class="number">8.</span>,   <span class="number">9.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">227</span>]: x.dot(y)</span><br><span class="line">Out[<span class="number">227</span>]: </span><br><span class="line">array([[  <span class="number">28.</span>,   <span class="number">64.</span>],</span><br><span class="line">       [  <span class="number">67.</span>,  <span class="number">181.</span>]])</span><br></pre></td></tr></table></figure>
<p>x.dot(y)等价于np.dot(x, y)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">228</span>]: np.dot(x, y)</span><br><span class="line">Out[<span class="number">228</span>]: </span><br><span class="line">array([[  <span class="number">28.</span>,   <span class="number">64.</span>],</span><br><span class="line">       [  <span class="number">67.</span>,  <span class="number">181.</span>]])</span><br></pre></td></tr></table></figure>
<p>一个二维数组跟一个大小合适的一维数组的矩阵点积运算之后将会得到一个一维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">229</span>]: np.dot(x, np.ones(<span class="number">3</span>))</span><br><span class="line">Out[<span class="number">229</span>]: array([  <span class="number">6.</span>,  <span class="number">15.</span>])</span><br></pre></td></tr></table></figure>
<p><span class="citation" data-cites="符">@符</span>（类似Python 3.5）也可以用作中缀运算符，进行矩阵乘法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">230</span>]: x @ np.ones(<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">230</span>]: array([  <span class="number">6.</span>,  <span class="number">15.</span>])</span><br></pre></td></tr></table></figure>
<p>numpy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。它们跟MATLAB和R等语言所使用的是相同的行业标准线性代数库，如BLAS、LAPACK、Intel MKL（Math Kernel Library，可能有，取决于你的NumPy版本）等：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">231</span>]: <span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv, qr</span><br><span class="line"></span><br><span class="line">In [<span class="number">232</span>]: X = np.random.randn(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">233</span>]: mat = X.T.dot(X)</span><br><span class="line"></span><br><span class="line">In [<span class="number">234</span>]: inv(mat)</span><br><span class="line">Out[<span class="number">234</span>]: </span><br><span class="line">array([[  <span class="number">933.1189</span>,   <span class="number">871.8258</span>, -<span class="number">1417.6902</span>, -<span class="number">1460.4005</span>,  <span class="number">1782.1391</span>],</span><br><span class="line">       [  <span class="number">871.8258</span>,   <span class="number">815.3929</span>, -<span class="number">1325.9965</span>, -<span class="number">1365.9242</span>,  <span class="number">1666.9347</span>],</span><br><span class="line">       [-<span class="number">1417.6902</span>, -<span class="number">1325.9965</span>,  <span class="number">2158.4424</span>,  <span class="number">2222.0191</span>, -<span class="number">2711.6822</span>],</span><br><span class="line">       [-<span class="number">1460.4005</span>, -<span class="number">1365.9242</span>,  <span class="number">2222.0191</span>,  <span class="number">2289.0575</span>, -<span class="number">2793.422</span> ],</span><br><span class="line">       [ <span class="number">1782.1391</span>,  <span class="number">1666.9347</span>, -<span class="number">2711.6822</span>, -<span class="number">2793.422</span> ,  <span class="number">3409.5128</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">235</span>]: mat.dot(inv(mat))</span><br><span class="line">Out[<span class="number">235</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>, -<span class="number">0.</span>, -<span class="number">0.</span>, -<span class="number">0.</span>],</span><br><span class="line">       [-<span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [-<span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>, -<span class="number">0.</span>],</span><br><span class="line">       [-<span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">236</span>]: q, r = qr(mat)</span><br><span class="line"></span><br><span class="line">In [<span class="number">237</span>]: r</span><br><span class="line">Out[<span class="number">237</span>]: </span><br><span class="line">array([[-<span class="number">1.6914</span>,  <span class="number">4.38</span>  ,  <span class="number">0.1757</span>,  <span class="number">0.4075</span>, -<span class="number">0.7838</span>],</span><br><span class="line">       [ <span class="number">0.</span>    , -<span class="number">2.6436</span>,  <span class="number">0.1939</span>, -<span class="number">3.072</span> , -<span class="number">1.0702</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    , -<span class="number">0.8138</span>,  <span class="number">1.5414</span>,  <span class="number">0.6155</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    , -<span class="number">2.6445</span>, -<span class="number">2.1669</span>],</span><br><span class="line">       [ <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.</span>    ,  <span class="number">0.0002</span>]])</span><br></pre></td></tr></table></figure>
<p>表达式X.T.dot(X)计算X和它的转置X.T的点积。</p>
<p>表4-7中列出了一些最常用的线性代数函数。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-dcdb66e49e5f70ea.png" class="">
<h2 id="伪随机数生成">4.6 伪随机数生成</h2>
<p>numpy.random模块对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。例如，你可以用normal来得到一个标准正态分布的4×4样本数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">238</span>]: samples = np.random.normal(size=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">239</span>]: samples</span><br><span class="line">Out[<span class="number">239</span>]: </span><br><span class="line">array([[ <span class="number">0.5732</span>,  <span class="number">0.1933</span>,  <span class="number">0.4429</span>,  <span class="number">1.2796</span>],</span><br><span class="line">       [ <span class="number">0.575</span> ,  <span class="number">0.4339</span>, -<span class="number">0.7658</span>, -<span class="number">1.237</span> ],</span><br><span class="line">       [-<span class="number">0.5367</span>,  <span class="number">1.8545</span>, -<span class="number">0.92</span>  , -<span class="number">0.1082</span>],</span><br><span class="line">       [ <span class="number">0.1525</span>,  <span class="number">0.9435</span>, -<span class="number">1.0953</span>, -<span class="number">0.144</span> ]])</span><br></pre></td></tr></table></figure>
<p>而Python内置的random模块则只能一次生成一个样本值。从下面的测试结果中可以看出，如果需要产生大量样本值，numpy.random快了不止一个数量级：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">240</span>]: <span class="keyword">from</span> random <span class="keyword">import</span> normalvariate</span><br><span class="line"></span><br><span class="line">In [<span class="number">241</span>]: N = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">242</span>]: %timeit samples = [normalvariate(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="number">1.77</span> s +- <span class="number">126</span> ms per loop (mean +- std. dev. of <span class="number">7</span> runs, <span class="number">1</span> loop each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">243</span>]: %timeit np.random.normal(size=N)</span><br><span class="line"><span class="number">61.7</span> ms +- <span class="number">1.32</span> ms per loop (mean +- std. dev. of <span class="number">7</span> runs, <span class="number">10</span> loops each)</span><br></pre></td></tr></table></figure>
<p>我们说这些都是伪随机数，是因为它们都是通过算法基于随机数生成器种子，在确定性的条件下生成的。你可以用NumPy的np.random.seed更改随机数生成种子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">244</span>]: np.random.seed(<span class="number">1234</span>)</span><br></pre></td></tr></table></figure>
<p>numpy.random的数据生成函数使用了全局的随机种子。要避免全局状态，你可以使用numpy.random.RandomState，创建一个与其它隔离的随机数生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">245</span>]: rng = np.random.RandomState(<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">246</span>]: rng.randn(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">246</span>]: </span><br><span class="line">array([ <span class="number">0.4714</span>, -<span class="number">1.191</span> ,  <span class="number">1.4327</span>, -<span class="number">0.3127</span>, -<span class="number">0.7206</span>,  <span class="number">0.8872</span>,  <span class="number">0.8596</span>,</span><br><span class="line">       -<span class="number">0.6365</span>,  <span class="number">0.0157</span>, -<span class="number">2.2427</span>])</span><br></pre></td></tr></table></figure>
<p>表4-8列出了numpy.random中的部分函数。在下一节中，我将给出一些利用这些函数一次性生成大量样本值的范例。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-97ba09c96dab93a2.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-6ed04fae3d1178e2.png" class="">
<h2 id="示例随机漫步">4.7 示例：随机漫步</h2>
<p>我们通过模拟随机漫步来说明如何运用数组运算。先来看一个简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。</p>
<p>下面是一个通过内置的random模块以纯Python的方式实现1000步的随机漫步：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">247</span>]: <span class="keyword">import</span> random</span><br><span class="line">   .....: position = <span class="number">0</span></span><br><span class="line">   .....: walk = [position]</span><br><span class="line">   .....: steps = <span class="number">1000</span></span><br><span class="line">   .....: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(steps):</span><br><span class="line">   .....:     step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">   .....:     position += step</span><br><span class="line">   .....:     walk.append(position)</span><br><span class="line">   .....:</span><br></pre></td></tr></table></figure>
<p>图4-4是根据前100个随机漫步值生成的折线图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">249</span>]: plt.plot(walk[:<span class="number">100</span>])</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap04/7178691-0833621694f6dda0.png" class="" title="图4-4 简单的随机漫步">
<p>不难看出，这其实就是随机漫步中各步的累计和，可以用一个数组运算来实现。因此，我用np.random模块一次性随机产生1000个“掷硬币”结果（即两个数中任选一个），将其分别设置为1或－1，然后计算累计和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">251</span>]: nsteps = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">252</span>]: draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=nsteps)</span><br><span class="line"></span><br><span class="line">In [<span class="number">253</span>]: steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">254</span>]: walk = steps.cumsum()</span><br></pre></td></tr></table></figure>
<p>有了这些数据之后，我们就可以沿着漫步路径做一些统计工作了，比如求取最大值和最小值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">255</span>]: walk.<span class="built_in">min</span>()</span><br><span class="line">Out[<span class="number">255</span>]: -<span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">256</span>]: walk.<span class="built_in">max</span>()</span><br><span class="line">Out[<span class="number">256</span>]: <span class="number">31</span></span><br></pre></td></tr></table></figure>
<p>现在来看一个复杂点的统计任务——首次穿越时间，即随机漫步过程中第一次到达某个特定值的时间。假设我们想要知道本次随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。np.abs(walk)&gt;=10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引（True就是最大值）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">257</span>]: (np.<span class="built_in">abs</span>(walk) &gt;= <span class="number">10</span>).argmax()</span><br><span class="line">Out[<span class="number">257</span>]: <span class="number">37</span></span><br></pre></td></tr></table></figure>
<p>注意，这里使用argmax并不是很高效，因为它无论如何都会对数组进行完全扫描。在本例中，只要发现了一个True，那我们就知道它是个最大值了。</p>
<h3 id="一次模拟多个随机漫步">4.7.1 一次模拟多个随机漫步</h3>
<p>如果你希望模拟多个随机漫步过程（比如5000个），只需对上面的代码做一点点修改即可生成所有的随机漫步过程。只要给numpy.random的函数传入一个二元元组就可以产生一个二维数组，然后我们就可以一次性计算5000个随机漫步过程（一行一个）的累计和了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">258</span>]: nwalks = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">259</span>]: nsteps = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">260</span>]: draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=(nwalks, nsteps)) <span class="comment"># 0 or 1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">261</span>]: steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">262</span>]: walks = steps.cumsum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">263</span>]: walks</span><br><span class="line">Out[<span class="number">263</span>]: </span><br><span class="line">array([[  <span class="number">1</span>,   <span class="number">0</span>,   <span class="number">1</span>, ...,   <span class="number">8</span>,   <span class="number">7</span>,   <span class="number">8</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">0</span>,  -<span class="number">1</span>, ...,  <span class="number">34</span>,  <span class="number">33</span>,  <span class="number">32</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">0</span>,  -<span class="number">1</span>, ...,   <span class="number">4</span>,   <span class="number">5</span>,   <span class="number">4</span>],</span><br><span class="line">       ..., </span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">1</span>, ...,  <span class="number">24</span>,  <span class="number">25</span>,  <span class="number">26</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>, ...,  <span class="number">14</span>,  <span class="number">13</span>,  <span class="number">14</span>],</span><br><span class="line">       [ -<span class="number">1</span>,  -<span class="number">2</span>,  -<span class="number">3</span>, ..., -<span class="number">24</span>, -<span class="number">23</span>, -<span class="number">22</span>]])</span><br></pre></td></tr></table></figure>
<p>现在，我们来计算所有随机漫步过程的最大值和最小值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">264</span>]: walks.<span class="built_in">max</span>()</span><br><span class="line">Out[<span class="number">264</span>]: <span class="number">138</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">265</span>]: walks.<span class="built_in">min</span>()</span><br><span class="line">Out[<span class="number">265</span>]: -<span class="number">133</span></span><br></pre></td></tr></table></figure>
<p>得到这些数据之后，我们来计算30或－30的最小穿越时间。这里稍微复杂些，因为不是5000个过程都到达了30。我们可以用any方法来对此进行检查：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">266</span>]: hits30 = (np.<span class="built_in">abs</span>(walks) &gt;= <span class="number">30</span>).<span class="built_in">any</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">267</span>]: hits30</span><br><span class="line">Out[<span class="number">267</span>]: array([<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, ..., <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">268</span>]: hits30.<span class="built_in">sum</span>() <span class="comment"># Number that hit 30 or -30</span></span><br><span class="line">Out[<span class="number">268</span>]: <span class="number">3410</span></span><br></pre></td></tr></table></figure>
<p>然后我们利用这个布尔型数组选出那些穿越了30（绝对值）的随机漫步（行），并调用argmax在轴1上获取穿越时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">269</span>]: crossing_times = (np.<span class="built_in">abs</span>(walks[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">270</span>]: crossing_times.mean()</span><br><span class="line">Out[<span class="number">270</span>]: <span class="number">498.88973607038122</span></span><br></pre></td></tr></table></figure>
<p>请尝试用其他分布方式得到漫步数据。只需使用不同的随机数生成函数即可，如normal用于生成指定均值和标准差的正态分布数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">271</span>]: steps = np.random.normal(loc=<span class="number">0</span>, scale=<span class="number">0.25</span>,</span><br><span class="line">   .....:                          size=(nwalks, nsteps))</span><br></pre></td></tr></table></figure>
<h2 id="结论">4.8 结论</h2>
<p>虽然本书剩下的章节大部分是用pandas规整数据，我们还是会用到相似的基于数组的计算。在附录A中，我们会深入挖掘NumPy的特点，进一步学习数组的技巧。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第05章_pandas入门</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap05/</url>
    <content><![CDATA[<h1 id="第05章-pandas入门">第05章 pandas入门</h1>
<p>pandas是本书后续内容的首选库。它含有使数据清洗和分析工作变得更快更简单的数据结构和操作工具。pandas经常和其它工具一同使用，如数值计算工具NumPy和SciPy，分析库statsmodels和scikit-learn，和数据可视化库matplotlib。pandas是基于NumPy数组构建的，特别是基于数组的函数和不使用for循环的数据处理。</p>
<span id="more"></span>
<p>虽然pandas采用了大量的NumPy编码风格，但二者最大的不同是pandas是专门为处理表格和混杂数据设计的。而NumPy更适合处理统一的数值数组数据。</p>
<p>自从2010年pandas开源以来，pandas逐渐成长为一个非常大的库，应用于许多真实案例。开发者社区已经有了800个独立的贡献者，他们在解决日常数据问题的同时为这个项目提供贡献。</p>
<p>在本书后续部分中，我将使用下面这样的pandas引入约定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<p>因此，只要你在代码中看到pd.，就得想到这是pandas。因为Series和DataFrame用的次数非常多，所以将其引入本地命名空间中会更方便：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: <span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br></pre></td></tr></table></figure>
<h2 id="pandas的数据结构介绍">5.1 pandas的数据结构介绍</h2>
<p>要使用pandas，你首先就得熟悉它的两个主要数据结构：Series和DataFrame。虽然它们并不能解决所有问题，但它们为大多数应用提供了一种可靠的、易于使用的基础。</p>
<h3 id="series">5.1.1 Series</h3>
<p>Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: obj</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>Series的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。你可以通过Series 的values和index属性获取其数组表示形式和索引对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: obj.values</span><br><span class="line">Out[<span class="number">13</span>]: array([ <span class="number">4</span>,  <span class="number">7</span>, -<span class="number">5</span>,  <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: obj.index  <span class="comment"># like range(4)</span></span><br><span class="line">Out[<span class="number">14</span>]: RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>通常，我们希望所创建的Series带有一个可以对各个数据点进行标记的索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: obj2 = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>], index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: obj2</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">d    <span class="number">4</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">a   -<span class="number">5</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: obj2.index</span><br><span class="line">Out[<span class="number">17</span>]: Index([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>与普通NumPy数组相比，你可以通过索引的方式选取Series中的单个或一组值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: obj2[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">18</span>]: -<span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: obj2[<span class="string">&#x27;d&#x27;</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: obj2[[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">a   -<span class="number">5</span></span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>['c', 'a', 'd']是索引列表，即使它包含的是字符串而不是整数。</p>
<p>使用NumPy函数或类似NumPy的运算（如根据布尔型数组进行过滤、标量乘法、应用数学函数等）都会保留索引值的链接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: obj2[obj2 &gt; <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: obj2 * <span class="number">2</span></span><br><span class="line">Out[<span class="number">22</span>]:</span><br><span class="line">d    <span class="number">12</span></span><br><span class="line">b    <span class="number">14</span></span><br><span class="line">a   -<span class="number">10</span></span><br><span class="line">c     <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: np.exp(obj2)</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">d     <span class="number">403.428793</span></span><br><span class="line">b    <span class="number">1096.633158</span></span><br><span class="line">a       <span class="number">0.006738</span></span><br><span class="line">c      <span class="number">20.085537</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>还可以将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">24</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: <span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">25</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>如果数据被存放在一个Python字典中，也可以直接通过这个字典来创建Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: sdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>: <span class="number">35000</span>, <span class="string">&#x27;Texas&#x27;</span>: <span class="number">71000</span>, <span class="string">&#x27;Oregon&#x27;</span>: <span class="number">16000</span>, <span class="string">&#x27;Utah&#x27;</span>: <span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: obj3 = pd.Series(sdata)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: obj3</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">Ohio      <span class="number">35000</span></span><br><span class="line">Oregon    <span class="number">16000</span></span><br><span class="line">Texas     <span class="number">71000</span></span><br><span class="line">Utah       <span class="number">5000</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>如果只传入一个字典，则结果Series中的索引就是原字典的键（有序排列）。你可以传入排好序的字典的键以改变顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: states = [<span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: obj4 = pd.Series(sdata, index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: obj4</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>在这个例子中，sdata中跟states索引相匹配的那3个值会被找出来并放到相应的位置上，但由于"California"所对应的sdata值找不到，所以其结果就为NaN（即“非数字”（not a number），在pandas中，它用于表示缺失或NA值）。因为‘Utah’不在states中，它被从结果中除去。</p>
<p>我将使用缺失（missing）或NA表示缺失数据。pandas的isnull和notnull函数可用于检测缺失数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: pd.isnull(obj4)</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">California     <span class="literal">True</span></span><br><span class="line">Ohio          <span class="literal">False</span></span><br><span class="line">Oregon        <span class="literal">False</span></span><br><span class="line">Texas         <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: pd.notnull(obj4)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">California    <span class="literal">False</span></span><br><span class="line">Ohio           <span class="literal">True</span></span><br><span class="line">Oregon         <span class="literal">True</span></span><br><span class="line">Texas          <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>Series也有类似的实例方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: obj4.isnull()</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">California     <span class="literal">True</span></span><br><span class="line">Ohio          <span class="literal">False</span></span><br><span class="line">Oregon        <span class="literal">False</span></span><br><span class="line">Texas         <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>我将在第7章详细讲解如何处理缺失数据。</p>
<p>对于许多应用而言，Series最重要的一个功能是，它会根据运算的索引标签自动对齐数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: obj3</span><br><span class="line">Out[<span class="number">35</span>]: </span><br><span class="line">Ohio      <span class="number">35000</span></span><br><span class="line">Oregon    <span class="number">16000</span></span><br><span class="line">Texas     <span class="number">71000</span></span><br><span class="line">Utah       <span class="number">5000</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: obj4</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: obj3 + obj4</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">California         NaN</span><br><span class="line">Ohio           <span class="number">70000.0</span></span><br><span class="line">Oregon         <span class="number">32000.0</span></span><br><span class="line">Texas         <span class="number">142000.0</span></span><br><span class="line">Utah               NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>数据对齐功能将在后面详细讲解。如果你使用过数据库，你可以认为是类似join的操作。</p>
<p>Series对象本身及其索引都有一个name属性，该属性跟pandas其他的关键功能关系非常密切：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: obj4.name = <span class="string">&#x27;population&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: obj4.index.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: obj4</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">state</span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">Name: population, dtype: float64</span><br></pre></td></tr></table></figure>
<p>Series的索引可以通过赋值的方式就地修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: obj</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: obj.index = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Jeff&#x27;</span>, <span class="string">&#x27;Ryan&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: obj</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">Bob      <span class="number">4</span></span><br><span class="line">Steve    <span class="number">7</span></span><br><span class="line">Jeff    -<span class="number">5</span></span><br><span class="line">Ryan     <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="dataframe">5.1.2 DataFrame</h3>
<p>DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。有关DataFrame内部的技术细节远远超出了本书所讨论的范围。</p>
<blockquote>
<p>笔记：虽然DataFrame是以二维结构保存数据的，但你仍然可以轻松地将其表示为更高维度的数据（层次化索引的表格型结构，这是pandas中许多高级数据处理功能的关键要素，我们会在第8章讨论这个问题）。</p>
</blockquote>
<p>建DataFrame的办法有很多，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;state&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;year&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</span><br><span class="line">        <span class="string">&#x27;pop&#x27;</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br></pre></td></tr></table></figure>
<p>结果DataFrame会自动加上索引（跟Series一样），且全部列会被有序排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: frame</span><br><span class="line">Out[<span class="number">45</span>]: </span><br><span class="line">   pop   state  year</span><br><span class="line"><span class="number">0</span>  <span class="number">1.5</span>    Ohio  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.7</span>    Ohio  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3.6</span>    Ohio  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.4</span>  Nevada  <span class="number">2001</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.9</span>  Nevada  <span class="number">2002</span></span><br><span class="line"><span class="number">5</span>  <span class="number">3.2</span>  Nevada  <span class="number">2003</span></span><br></pre></td></tr></table></figure>
<p>如果你使用的是Jupyter notebook，pandas DataFrame对象会以对浏览器友好的HTML表格的方式呈现。</p>
<p>对于特别大的DataFrame，head方法会选取前五行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: frame.head()</span><br><span class="line">Out[<span class="number">46</span>]: </span><br><span class="line">   pop   state  year</span><br><span class="line"><span class="number">0</span>  <span class="number">1.5</span>    Ohio  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.7</span>    Ohio  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3.6</span>    Ohio  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.4</span>  Nevada  <span class="number">2001</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.9</span>  Nevada  <span class="number">2002</span></span><br></pre></td></tr></table></figure>
<p>如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: pd.DataFrame(data, columns=[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>])</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line">   year   state  pop</span><br><span class="line"><span class="number">0</span>  <span class="number">2000</span>    Ohio  <span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2001</span>    Ohio  <span class="number">1.7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2002</span>    Ohio  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2001</span>  Nevada  <span class="number">2.4</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2002</span>  Nevada  <span class="number">2.9</span></span><br><span class="line"><span class="number">5</span>  <span class="number">2003</span>  Nevada  <span class="number">3.2</span></span><br></pre></td></tr></table></figure>
<p>如果传入的列在数据中找不到，就会在结果中产生缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">48</span>]: frame2 = pd.DataFrame(data, columns=[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>],</span><br><span class="line">   ....:                       index=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>,</span><br><span class="line">   ....:                              <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: frame2</span><br><span class="line">Out[<span class="number">49</span>]: </span><br><span class="line">       year   state  pop debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>  NaN</span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  NaN</span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>  NaN</span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  NaN</span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  NaN</span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>  NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: frame2.columns</span><br><span class="line">Out[<span class="number">50</span>]: Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: frame2[<span class="string">&#x27;state&#x27;</span>]</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">one        Ohio</span><br><span class="line">two        Ohio</span><br><span class="line">three      Ohio</span><br><span class="line">four     Nevada</span><br><span class="line">five     Nevada</span><br><span class="line">six      Nevada</span><br><span class="line">Name: state, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: frame2.year</span><br><span class="line">Out[<span class="number">52</span>]: </span><br><span class="line">one      <span class="number">2000</span></span><br><span class="line">two      <span class="number">2001</span></span><br><span class="line">three    <span class="number">2002</span></span><br><span class="line">four     <span class="number">2001</span></span><br><span class="line">five     <span class="number">2002</span></span><br><span class="line">six      <span class="number">2003</span></span><br><span class="line">Name: year, dtype: int64</span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：IPython提供了类似属性的访问（即frame2.year）和tab补全。 frame2[column]适用于任何列的名，但是frame2.column只有在列名是一个合理的Python变量名时才适用。</p>
</blockquote>
<p>注意，返回的Series拥有原DataFrame相同的索引，且其name属性也已经被相应地设置好了。</p>
<p>行也可以通过位置或名称的方式进行获取，比如用loc属性（稍后将对此进行详细讲解）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">53</span>]: frame2.loc[<span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">year     <span class="number">2002</span></span><br><span class="line">state    Ohio</span><br><span class="line">pop       <span class="number">3.6</span></span><br><span class="line">debt      NaN</span><br><span class="line">Name: three, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>列可以通过赋值的方式进行修改。例如，我们可以给那个空的"debt"列赋上一个标量值或一组值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = <span class="number">16.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: frame2</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>  <span class="number">16.5</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  <span class="number">16.5</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>  <span class="number">16.5</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  <span class="number">16.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  <span class="number">16.5</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>  <span class="number">16.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = np.arange(<span class="number">6.</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: frame2</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   <span class="number">0.0</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>   <span class="number">1.0</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   <span class="number">2.0</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>   <span class="number">3.0</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>   <span class="number">4.0</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   <span class="number">5.0</span></span><br></pre></td></tr></table></figure>
<p>将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: val = pd.Series([-<span class="number">1.2</span>, -<span class="number">1.5</span>, -<span class="number">1.7</span>], index=[<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: frame2[<span class="string">&#x27;debt&#x27;</span>] = val</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: frame2</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   NaN</span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  -<span class="number">1.2</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   NaN</span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  -<span class="number">1.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  -<span class="number">1.7</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   NaN</span><br></pre></td></tr></table></figure>
<p>为不存在的列赋值会创建出一个新列。关键字del用于删除列。</p>
<p>作为del的例子，我先添加一个新的布尔值的列，state是否为'Ohio'：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: frame2[<span class="string">&#x27;eastern&#x27;</span>] = frame2.state == <span class="string">&#x27;Ohio&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: frame2</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">       year   state  pop  debt  eastern</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   NaN     <span class="literal">True</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  -<span class="number">1.2</span>     <span class="literal">True</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   NaN     <span class="literal">True</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  -<span class="number">1.5</span>    <span class="literal">False</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  -<span class="number">1.7</span>    <span class="literal">False</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   NaN    <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：不能用frame2.eastern创建新的列。</p>
</blockquote>
<p>del方法可以用来删除这列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: <span class="keyword">del</span> frame2[<span class="string">&#x27;eastern&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: frame2.columns</span><br><span class="line">Out[<span class="number">64</span>]: Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：通过索引方式返回的列只是相应数据的视图而已，并不是副本。因此，对返回的Series所做的任何就地修改全都会反映到源DataFrame上。通过Series的copy方法即可指定复制列。</p>
</blockquote>
<p>另一种常见的数据形式是嵌套字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: pop = &#123;<span class="string">&#x27;Nevada&#x27;</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;,</span><br><span class="line">....:        <span class="string">&#x27;Ohio&#x27;</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如果嵌套字典传给DataFrame，pandas就会被解释为：外层字典的键作为列，内层键则作为行索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: frame3 = pd.DataFrame(pop)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: frame3</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2000</span>     NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">2.9</span>   <span class="number">3.6</span></span><br></pre></td></tr></table></figure>
<p>你也可以使用类似NumPy数组的方法，对DataFrame进行转置（交换行和列）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: frame3.T</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">        <span class="number">2000</span>  <span class="number">2001</span>  <span class="number">2002</span></span><br><span class="line">Nevada   NaN   <span class="number">2.4</span>   <span class="number">2.9</span></span><br><span class="line">Ohio     <span class="number">1.5</span>   <span class="number">1.7</span>   <span class="number">3.6</span></span><br></pre></td></tr></table></figure>
<p>内层字典的键会被合并、排序以形成最终的索引。如果明确指定了索引，则不会这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: pd.DataFrame(pop, index=[<span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>])</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">2.9</span>   <span class="number">3.6</span></span><br><span class="line"><span class="number">2003</span>     NaN   NaN</span><br></pre></td></tr></table></figure>
<p>由Series组成的字典差不多也是一样的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">70</span>]: pdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>: frame3[<span class="string">&#x27;Ohio&#x27;</span>][:-<span class="number">1</span>],</span><br><span class="line">....:          <span class="string">&#x27;Nevada&#x27;</span>: frame3[<span class="string">&#x27;Nevada&#x27;</span>][:<span class="number">2</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: pd.DataFrame(pdata)</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2000</span>     NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br></pre></td></tr></table></figure>
<p>表5-1列出了DataFrame构造函数所能接受的各种数据。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap05/7178691-106835b28c0cea5a.png" class="">
<p>如果设置了DataFrame的index和columns的name属性，则这些信息也会被显示出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: frame3.index.name = <span class="string">&#x27;year&#x27;</span>; frame3.columns.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: frame3</span><br><span class="line">Out[<span class="number">73</span>]: </span><br><span class="line">state  Nevada  Ohio</span><br><span class="line">year</span><br><span class="line"><span class="number">2000</span>      NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>      <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>      <span class="number">2.9</span>   <span class="number">3.6</span></span><br></pre></td></tr></table></figure>
<p>跟Series一样，values属性也会以二维ndarray的形式返回DataFrame中的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: frame3.values</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">array([[ nan,  <span class="number">1.5</span>],</span><br><span class="line">       [ <span class="number">2.4</span>,  <span class="number">1.7</span>],</span><br><span class="line">       [ <span class="number">2.9</span>,  <span class="number">3.6</span>]])</span><br></pre></td></tr></table></figure>
<p>如果DataFrame各列的数据类型不同，则值数组的dtype就会选用能兼容所有列的数据类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: frame2.values</span><br><span class="line">Out[<span class="number">75</span>]:</span><br><span class="line">array([[<span class="number">2000</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="number">1.5</span>, nan],</span><br><span class="line">       [<span class="number">2001</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="number">1.7</span>, -<span class="number">1.2</span>],</span><br><span class="line">       [<span class="number">2002</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="number">3.6</span>, nan],</span><br><span class="line">       [<span class="number">2001</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="number">2.4</span>, -<span class="number">1.5</span>],</span><br><span class="line">       [<span class="number">2002</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="number">2.9</span>, -<span class="number">1.7</span>],</span><br><span class="line">       [<span class="number">2003</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="number">3.2</span>, nan]], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<h3 id="索引对象">5.1.3 索引对象</h3>
<p>pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: index = obj.index</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: index</span><br><span class="line">Out[<span class="number">78</span>]: Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: index[<span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">79</span>]: Index([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>Index对象是不可变的，因此用户不能对其进行修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index[<span class="number">1</span>] = <span class="string">&#x27;d&#x27;</span>  <span class="comment"># TypeError</span></span><br></pre></td></tr></table></figure>
<p>不可变可以使Index对象在多个数据结构之间安全共享：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">80</span>]: labels = pd.Index(np.arange(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: labels</span><br><span class="line">Out[<span class="number">81</span>]: Int64Index([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], dtype=<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: obj2 = pd.Series([<span class="number">1.5</span>, -<span class="number">2.5</span>, <span class="number">0</span>], index=labels)</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: obj2</span><br><span class="line">Out[<span class="number">83</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">2.5</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: obj2.index <span class="keyword">is</span> labels</span><br><span class="line">Out[<span class="number">84</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：虽然用户不需要经常使用Index的功能，但是因为一些操作会生成包含被索引化的数据，理解它们的工作原理是很重要的。</p>
</blockquote>
<p>除了类似于数组，Index的功能也类似一个固定大小的集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: frame3</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line">state  Nevada  Ohio</span><br><span class="line">year               </span><br><span class="line"><span class="number">2000</span>      NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>      <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>      <span class="number">2.9</span>   <span class="number">3.6</span></span><br><span class="line">In [<span class="number">86</span>]: frame3.columns</span><br><span class="line">Out[<span class="number">86</span>]: Index([<span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>, name=<span class="string">&#x27;state&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: <span class="string">&#x27;Ohio&#x27;</span> <span class="keyword">in</span> frame3.columns</span><br><span class="line">Out[<span class="number">87</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: <span class="number">2003</span> <span class="keyword">in</span> frame3.index</span><br><span class="line">Out[<span class="number">88</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>与python的集合不同，pandas的Index可以包含重复的标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: dup_labels = pd.Index([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: dup_labels</span><br><span class="line">Out[<span class="number">90</span>]: Index([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>选择重复的标签，会显示所有的结果。</p>
<p>每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的常见问题。表5-2列出了这些函数。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap05/7178691-5499d14f0e2cd639.jpg" class="">
<h2 id="基本功能">5.2 基本功能</h2>
<p>本节中，我将介绍操作Series和DataFrame中的数据的基本手段。后续章节将更加深入地挖掘pandas在数据分析和处理方面的功能。本书不是pandas库的详尽文档，主要关注的是最重要的功能，那些不大常用的内容（也就是那些更深奥的内容）就交给你自己去摸索吧。</p>
<h3 id="重新索引">5.2.1 重新索引</h3>
<p>pandas对象的一个重要方法是reindex，其作用是创建一个新对象，它的数据符合新的索引。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: obj = pd.Series([<span class="number">4.5</span>, <span class="number">7.2</span>, -<span class="number">5.3</span>, <span class="number">3.6</span>], index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: obj</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>用该Series的reindex将会根据新索引进行重排。如果某个索引值当前不存在，就引入缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: obj2 = obj.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: obj2</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">e    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>对于时间序列这样的有序数据，重新索引时可能需要做一些插值处理。method选项即可达到此目的，例如，使用ffill可以实现前向值填充：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: obj3 = pd.Series([<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>], index=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: obj3</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: obj3.reindex(<span class="built_in">range</span>(<span class="number">6</span>), method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">1</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">3</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line"><span class="number">5</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>借助DataFrame，reindex可以修改（行）索引和列。只传递一个序列时，会重新索引结果的行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: frame = pd.DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)),</span><br><span class="line">   ....:                      index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                      columns=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;California&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: frame</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a     <span class="number">0</span>      <span class="number">1</span>           <span class="number">2</span></span><br><span class="line">c     <span class="number">3</span>      <span class="number">4</span>           <span class="number">5</span></span><br><span class="line">d     <span class="number">6</span>      <span class="number">7</span>           <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: frame2 = frame.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: frame2</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a   <span class="number">0.0</span>    <span class="number">1.0</span>         <span class="number">2.0</span></span><br><span class="line">b   NaN    NaN         NaN</span><br><span class="line">c   <span class="number">3.0</span>    <span class="number">4.0</span>         <span class="number">5.0</span></span><br><span class="line">d   <span class="number">6.0</span>    <span class="number">7.0</span>         <span class="number">8.0</span></span><br></pre></td></tr></table></figure>
<p>列可以用columns关键字重新索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: states = [<span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;California&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: frame.reindex(columns=states)</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">   Texas  Utah  California</span><br><span class="line">a      <span class="number">1</span>   NaN           <span class="number">2</span></span><br><span class="line">c      <span class="number">4</span>   NaN           <span class="number">5</span></span><br><span class="line">d      <span class="number">7</span>   NaN           <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>表5-3列出了reindex函数的各参数及说明。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap05/7178691-efa3dbd4b83c61ec.jpg" class="">
<h3 id="丢弃指定轴上的项">5.2.2 丢弃指定轴上的项</h3>
<p>丢弃某条轴上的一个或多个项很简单，只要有一个索引数组或列表即可。由于需要执行一些数据整理和集合逻辑，所以drop方法返回的是一个在指定轴上删除了指定值的新对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: obj = pd.Series(np.arange(<span class="number">5.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: obj</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: new_obj = obj.drop(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: new_obj</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: obj.drop([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>对于DataFrame，可以删除任意轴上的索引值。为了演示，先新建一个DataFrame例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: data</span><br><span class="line">Out[<span class="number">111</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>用标签序列调用drop会从行标签（axis 0）删除值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">112</span>]: data.drop([<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>通过传递axis=1或axis='columns'可以删除列的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">113</span>]: data.drop(<span class="string">&#x27;two&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">          one  three  four</span><br><span class="line">Ohio        <span class="number">0</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: data.drop([<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>], axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">          one  three</span><br><span class="line">Ohio        <span class="number">0</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">4</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>许多函数，如drop，会修改Series或DataFrame的大小或形状，可以就地修改对象，不会返回新的对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: obj.drop(<span class="string">&#x27;c&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: obj</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>小心使用inplace，它会销毁所有被删除的数据。</p>
<h3 id="索引选取和过滤">5.2.3 索引、选取和过滤</h3>
<p>Series索引（obj[...]）的工作方式类似于NumPy数组的索引，只不过Series的索引值不只是整数。下面是几个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: obj = pd.Series(np.arange(<span class="number">4.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: obj</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: obj[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">119</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: obj[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">120</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: obj[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: obj[[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">122</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: obj[[<span class="number">1</span>, <span class="number">3</span>]]</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: obj[obj &lt; <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">124</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>利用标签的切片运算与普通的Python切片运算不同，其末端是包含的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">125</span>]: obj[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">Out[<span class="number">125</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>用切片可以对Series的相应部分进行设置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">126</span>]: obj[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: obj</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">5.0</span></span><br><span class="line">c    <span class="number">5.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>用一个值或序列对DataFrame进行索引其实就是获取一个或多个列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: data</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: data[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">Ohio         <span class="number">1</span></span><br><span class="line">Colorado     <span class="number">5</span></span><br><span class="line">Utah         <span class="number">9</span></span><br><span class="line">New York    <span class="number">13</span></span><br><span class="line">Name: two, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: data[[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>]]</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">          three  one</span><br><span class="line">Ohio          <span class="number">2</span>    <span class="number">0</span></span><br><span class="line">Colorado      <span class="number">6</span>    <span class="number">4</span></span><br><span class="line">Utah         <span class="number">10</span>    <span class="number">8</span></span><br><span class="line">New York     <span class="number">14</span>   <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>这种索引方式有几个特殊的情况。首先通过切片或布尔型数组选取数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">132</span>]: data[:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: data[data[<span class="string">&#x27;three&#x27;</span>] &gt; <span class="number">5</span>]</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>选取行的语法data[:2]十分方便。向[ ]传递单一的元素或列表，就可选择列。</p>
<p>另一种用法是通过布尔型DataFrame（比如下面这个由标量比较运算得出的）进行索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">134</span>]: data &lt; <span class="number">5</span></span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">            one    two  three   four</span><br><span class="line">Ohio       <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span></span><br><span class="line">Colorado   <span class="literal">True</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">Utah      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">New York  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: data[data &lt; <span class="number">5</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: data</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>这使得DataFrame的语法与NumPy二维数组的语法很像。</p>
<h3 id="用loc和iloc进行选取">5.2.4 用loc和iloc进行选取</h3>
<p>对于DataFrame的行的标签索引，我引入了特殊的标签运算符loc和iloc。它们可以让你用类似NumPy的标记，使用轴标签（loc）或整数索引（iloc），从DataFrame选择行和列的子集。</p>
<p>作为一个初步示例，让我们通过标签选择一行和多列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">137</span>]: data.loc[<span class="string">&#x27;Colorado&#x27;</span>, [<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]]</span><br><span class="line">Out[<span class="number">137</span>]: </span><br><span class="line">two      <span class="number">5</span></span><br><span class="line">three    <span class="number">6</span></span><br><span class="line">Name: Colorado, dtype: int64</span><br></pre></td></tr></table></figure>
<p>然后用iloc和整数进行选取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">138</span>]: data.iloc[<span class="number">2</span>, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">Out[<span class="number">138</span>]: </span><br><span class="line">four    <span class="number">11</span></span><br><span class="line">one      <span class="number">8</span></span><br><span class="line">two      <span class="number">9</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: data.iloc[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">139</span>]: </span><br><span class="line">one       <span class="number">8</span></span><br><span class="line">two       <span class="number">9</span></span><br><span class="line">three    <span class="number">10</span></span><br><span class="line">four     <span class="number">11</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: data.iloc[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">          four  one  two</span><br><span class="line">Colorado     <span class="number">7</span>    <span class="number">0</span>    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">11</span>    <span class="number">8</span>    <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>这两个索引函数也适用于一个标签或多个标签的切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: data.loc[:<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">141</span>]: </span><br><span class="line">Ohio        <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">9</span></span><br><span class="line">Name: two, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: data.iloc[:, :<span class="number">3</span>][data.three &gt; <span class="number">5</span>]</span><br><span class="line">Out[<span class="number">142</span>]: </span><br><span class="line">          one  two  three</span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>所以，在pandas中，有多个方法可以选取和重新组合数据。对于DataFrame，表5-4进行了总结。后面会看到，还有更多的方法进行层级化索引。</p>
<blockquote>
<p>笔记：在一开始设计pandas时，我觉得用frame[:, col]选取列过于繁琐（也容易出错），因为列的选择是非常常见的操作。我做了些取舍，将花式索引的功能（标签和整数）放到了ix运算符中。在实践中，这会导致许多边缘情况，数据的轴标签是整数，所以pandas团队决定创造loc和iloc运算符分别处理严格基于标签和整数的索引。ix运算符仍然可用，但并不推荐。</p>
</blockquote>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap05/7178691-64354f2ab777bd8c.png" class="" title="表5-4 DataFrame的索引选项">
<h3 id="整数索引">5.2.5 整数索引</h3>
<p>处理整数索引的pandas对象常常难住新手，因为它与Python内置的列表和元组的索引语法不同。例如，你可能不认为下面的代码会出错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ser = pd.Series(np.arange(<span class="number">3.</span>))</span><br><span class="line">ser</span><br><span class="line">ser[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>这里，pandas可以勉强进行整数索引，但是会导致小bug。我们有包含0,1,2的索引，但是引入用户想要的东西（基于标签或位置的索引）很难：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">144</span>]: ser</span><br><span class="line">Out[<span class="number">144</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>另外，对于非整数索引，不会产生歧义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">145</span>]: ser2 = pd.Series(np.arange(<span class="number">3.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: ser2[-<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">146</span>]: <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>为了进行统一，如果轴索引含有整数，数据选取总会使用标签。为了更准确，请使用loc（标签）或iloc（整数）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">147</span>]: ser[:<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">147</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: ser.loc[:<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">148</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">149</span>]: ser.iloc[:<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">149</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="算术运算和数据对齐">5.2.6 算术运算和数据对齐</h3>
<p>pandas最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。对于有数据库经验的用户，这就像在索引标签上进行自动外连接。看一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">150</span>]: s1 = pd.Series([<span class="number">7.3</span>, -<span class="number">2.5</span>, <span class="number">3.4</span>, <span class="number">1.5</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: s2 = pd.Series([-<span class="number">2.1</span>, <span class="number">3.6</span>, -<span class="number">1.5</span>, <span class="number">4</span>, <span class="number">3.1</span>],</span><br><span class="line">   .....:                index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: s1</span><br><span class="line">Out[<span class="number">152</span>]: </span><br><span class="line">a    <span class="number">7.3</span></span><br><span class="line">c   -<span class="number">2.5</span></span><br><span class="line">d    <span class="number">3.4</span></span><br><span class="line">e    <span class="number">1.5</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: s2</span><br><span class="line">Out[<span class="number">153</span>]: </span><br><span class="line">a   -<span class="number">2.1</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">e   -<span class="number">1.5</span></span><br><span class="line">f    <span class="number">4.0</span></span><br><span class="line">g    <span class="number">3.1</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>将它们相加就会产生：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: s1 + s2</span><br><span class="line">Out[<span class="number">154</span>]: </span><br><span class="line">a    <span class="number">5.2</span></span><br><span class="line">c    <span class="number">1.1</span></span><br><span class="line">d    NaN</span><br><span class="line">e    <span class="number">0.0</span></span><br><span class="line">f    NaN</span><br><span class="line">g    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>自动的数据对齐操作在不重叠的索引处引入了NA值。缺失值会在算术运算过程中传播。</p>
<p>对于DataFrame，对齐操作会同时发生在行和列上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">155</span>]: df1 = pd.DataFrame(np.arange(<span class="number">9.</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bcd&#x27;</span>),</span><br><span class="line">   .....:                    index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: df2 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                    index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: df1</span><br><span class="line">Out[<span class="number">157</span>]: </span><br><span class="line">            b    c    d</span><br><span class="line">Ohio      <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span></span><br><span class="line">Texas     <span class="number">3.0</span>  <span class="number">4.0</span>  <span class="number">5.0</span></span><br><span class="line">Colorado  <span class="number">6.0</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: df2</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br></pre></td></tr></table></figure>
<p>把它们相加后将会返回一个新的DataFrame，其索引和列为原来那两个DataFrame的并集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">159</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">159</span>]: </span><br><span class="line">            b   c     d   e</span><br><span class="line">Colorado  NaN NaN   NaN NaN</span><br><span class="line">Ohio      <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Oregon    NaN NaN   NaN NaN</span><br><span class="line">Texas     <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br><span class="line">Utah      NaN NaN   NaN NaN</span><br></pre></td></tr></table></figure>
<p>因为'c'和'e'列均不在两个DataFrame对象中，在结果中以缺省值呈现。行也是同样。</p>
<p>如果DataFrame对象相加，没有共用的列或行标签，结果都会是空：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">160</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;B&#x27;</span>: [<span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: df1</span><br><span class="line">Out[<span class="number">162</span>]: </span><br><span class="line">   A</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: df2</span><br><span class="line">Out[<span class="number">163</span>]: </span><br><span class="line">   B</span><br><span class="line"><span class="number">0</span>  <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">164</span>]: df1 - df2</span><br><span class="line">Out[<span class="number">164</span>]: </span><br><span class="line">    A   B</span><br><span class="line"><span class="number">0</span> NaN NaN</span><br><span class="line"><span class="number">1</span> NaN NaN</span><br></pre></td></tr></table></figure>
<h3 id="在算术方法中填充值">5.2.7 在算术方法中填充值</h3>
<p>在对不同索引的对象进行算术运算时，你可能希望当一个对象中某个轴标签在另一个对象中找不到时填充一个特殊值（比如0）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: df1 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                    columns=<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: df2 = pd.DataFrame(np.arange(<span class="number">20.</span>).reshape((<span class="number">4</span>, <span class="number">5</span>)),</span><br><span class="line">   .....:                    columns=<span class="built_in">list</span>(<span class="string">&#x27;abcde&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: df2.loc[<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">168</span>]: df1</span><br><span class="line">Out[<span class="number">168</span>]: </span><br><span class="line">     a    b     c     d</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: df2</span><br><span class="line">Out[<span class="number">169</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5.0</span>   NaN   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">12.0</span>  <span class="number">13.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br></pre></td></tr></table></figure>
<p>将它们相加时，没有重叠的位置就会产生NA值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">170</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">170</span>]: </span><br><span class="line">      a     b     c     d   e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span> NaN</span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   NaN  <span class="number">13.0</span>  <span class="number">15.0</span> NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span> NaN</span><br><span class="line"><span class="number">3</span>   NaN   NaN   NaN   NaN NaN</span><br></pre></td></tr></table></figure>
<p>使用df1的add方法，传入df2以及一个fill_value参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">171</span>]: df1.add(df2, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">171</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   <span class="number">5.0</span>  <span class="number">13.0</span>  <span class="number">15.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br></pre></td></tr></table></figure>
<p>表5-5列出了Series和DataFrame的算术方法。它们每个都有一个副本，以字母r开头，它会翻转参数。因此这两个语句是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">172</span>]: <span class="number">1</span> / df1</span><br><span class="line">Out[<span class="number">172</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>       inf  <span class="number">1.000000</span>  <span class="number">0.500000</span>  <span class="number">0.333333</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.250000</span>  <span class="number">0.200000</span>  <span class="number">0.166667</span>  <span class="number">0.142857</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.125000</span>  <span class="number">0.111111</span>  <span class="number">0.100000</span>  <span class="number">0.090909</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: df1.rdiv(<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>       inf  <span class="number">1.000000</span>  <span class="number">0.500000</span>  <span class="number">0.333333</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.250000</span>  <span class="number">0.200000</span>  <span class="number">0.166667</span>  <span class="number">0.142857</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.125000</span>  <span class="number">0.111111</span>  <span class="number">0.100000</span>  <span class="number">0.090909</span></span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap05/7178691-16857a1021f98d1f.png" class="" title="表5-5 灵活的算术方法">
<p>与此类似，在对Series或DataFrame重新索引时，也可以指定一个填充值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">174</span>]: df1.reindex(columns=df2.columns, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line">     a    b     c     d  e</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="dataframe和series之间的运算">5.2.8 DataFrame和Series之间的运算</h3>
<p>跟不同维度的NumPy数组一样，DataFrame和Series之间算术运算也是有明确规定的。先来看一个具有启发性的例子，计算一个二维数组与其某行之间的差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">175</span>]: arr = np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">176</span>]: arr</span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">3.</span>],</span><br><span class="line">       [  <span class="number">4.</span>,   <span class="number">5.</span>,   <span class="number">6.</span>,   <span class="number">7.</span>],</span><br><span class="line">       [  <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,  <span class="number">11.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">177</span>]: array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: arr - arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>]])</span><br></pre></td></tr></table></figure>
<p>当我们从arr减去arr[0]，每一行都会执行这个操作。这就叫做广播（broadcasting），附录A将对此进行详细讲解。DataFrame和Series之间的运算差不多也是如此：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">179</span>]: frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">   .....:                      columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: series = frame.iloc[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: frame</span><br><span class="line">Out[<span class="number">181</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">182</span>]: series</span><br><span class="line">Out[<span class="number">182</span>]: </span><br><span class="line">b    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">2.0</span></span><br><span class="line">Name: Utah, dtype: float64</span><br></pre></td></tr></table></figure>
<p>默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">183</span>]: frame - series</span><br><span class="line">Out[<span class="number">183</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah    <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>  <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>  <span class="number">6.0</span>  <span class="number">6.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">9.0</span>  <span class="number">9.0</span></span><br></pre></td></tr></table></figure>
<p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">184</span>]: series2 = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>), index=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: frame + series2</span><br><span class="line">Out[<span class="number">185</span>]: </span><br><span class="line">          b   d     e   f</span><br><span class="line">Utah    <span class="number">0.0</span> NaN   <span class="number">3.0</span> NaN</span><br><span class="line">Ohio    <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Texas   <span class="number">6.0</span> NaN   <span class="number">9.0</span> NaN</span><br><span class="line">Oregon  <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br></pre></td></tr></table></figure>
<p>如果你希望匹配行且在列上广播，则必须使用算术运算方法。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">186</span>]: series3 = frame[<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: frame</span><br><span class="line">Out[<span class="number">187</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">188</span>]: series3</span><br><span class="line">Out[<span class="number">188</span>]: </span><br><span class="line">Utah       <span class="number">1.0</span></span><br><span class="line">Ohio       <span class="number">4.0</span></span><br><span class="line">Texas      <span class="number">7.0</span></span><br><span class="line">Oregon    <span class="number">10.0</span></span><br><span class="line">Name: d, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: frame.sub(series3, axis=<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">Out[<span class="number">189</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah   -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Ohio   -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Texas  -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Oregon -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>传入的轴号就是希望匹配的轴。在本例中，我们的目的是匹配DataFrame的行索引（axis='index' or axis=0）并进行广播。</p>
<h3 id="函数应用和映射">5.2.9 函数应用和映射</h3>
<p>NumPy的ufuncs（元素级数组方法）也可用于操作pandas对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">190</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: frame</span><br><span class="line">Out[<span class="number">191</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah   -<span class="number">0.204708</span>  <span class="number">0.478943</span> -<span class="number">0.519439</span></span><br><span class="line">Ohio   -<span class="number">0.555730</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br><span class="line">Texas   <span class="number">0.092908</span>  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br><span class="line">Oregon  <span class="number">1.246435</span>  <span class="number">1.007189</span> -<span class="number">1.296221</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: np.<span class="built_in">abs</span>(frame)</span><br><span class="line">Out[<span class="number">192</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah    <span class="number">0.204708</span>  <span class="number">0.478943</span>  <span class="number">0.519439</span></span><br><span class="line">Ohio    <span class="number">0.555730</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br><span class="line">Texas   <span class="number">0.092908</span>  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br><span class="line">Oregon  <span class="number">1.246435</span>  <span class="number">1.007189</span>  <span class="number">1.296221</span></span><br></pre></td></tr></table></figure>
<p>另一个常见的操作是，将函数应用到由各列或行所形成的一维数组上。DataFrame的apply方法即可实现此功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">193</span>]: f = <span class="keyword">lambda</span> x: x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>()</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">194</span>]: </span><br><span class="line">b    <span class="number">1.802165</span></span><br><span class="line">d    <span class="number">1.684034</span></span><br><span class="line">e    <span class="number">2.689627</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>这里的函数f，计算了一个Series的最大值和最小值的差，在frame的每列都执行了一次。结果是一个Series，使用frame的列作为索引。</p>
<p>如果传递axis='columns'到apply，这个函数会在每行执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">195</span>]: frame.apply(f, axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">195</span>]:</span><br><span class="line">Utah      <span class="number">0.998382</span></span><br><span class="line">Ohio      <span class="number">2.521511</span></span><br><span class="line">Texas     <span class="number">0.676115</span></span><br><span class="line">Oregon    <span class="number">2.542656</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>许多最为常见的数组统计功能都被实现成DataFrame的方法（如sum和mean），因此无需使用apply方法。</p>
<p>传递到apply的函数不是必须返回一个标量，还可以返回由多个值组成的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">196</span>]: <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">   .....:     <span class="keyword">return</span> pd.Series([x.<span class="built_in">min</span>(), x.<span class="built_in">max</span>()], index=[<span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">197</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">197</span>]: </span><br><span class="line">            b         d         e</span><br><span class="line"><span class="built_in">min</span> -<span class="number">0.555730</span>  <span class="number">0.281746</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="built_in">max</span>  <span class="number">1.246435</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br></pre></td></tr></table></figure>
<p>元素级的Python函数也是可以用的。假如你想得到frame中各个浮点值的格式化字符串，使用applymap即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">198</span>]: <span class="built_in">format</span> = <span class="keyword">lambda</span> x: <span class="string">&#x27;%.2f&#x27;</span> % x</span><br><span class="line"></span><br><span class="line">In [<span class="number">199</span>]: frame.applymap(<span class="built_in">format</span>)</span><br><span class="line">Out[<span class="number">199</span>]: </span><br><span class="line">            b     d      e</span><br><span class="line">Utah    -<span class="number">0.20</span>  <span class="number">0.48</span>  -<span class="number">0.52</span></span><br><span class="line">Ohio    -<span class="number">0.56</span>  <span class="number">1.97</span>   <span class="number">1.39</span></span><br><span class="line">Texas    <span class="number">0.09</span>  <span class="number">0.28</span>   <span class="number">0.77</span></span><br><span class="line">Oregon   <span class="number">1.25</span>  <span class="number">1.01</span>  -<span class="number">1.30</span></span><br></pre></td></tr></table></figure>
<p>之所以叫做applymap，是因为Series有一个用于应用元素级函数的map方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">200</span>]: frame[<span class="string">&#x27;e&#x27;</span>].<span class="built_in">map</span>(<span class="built_in">format</span>)</span><br><span class="line">Out[<span class="number">200</span>]: </span><br><span class="line">Utah      -<span class="number">0.52</span></span><br><span class="line">Ohio       <span class="number">1.39</span></span><br><span class="line">Texas      <span class="number">0.77</span></span><br><span class="line">Oregon    -<span class="number">1.30</span></span><br><span class="line">Name: e, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<h3 id="排序和排名">5.2.10 排序和排名</h3>
<p>根据条件对数据集排序（sorting）也是一种重要的内置运算。要对行或列索引进行排序（按字典顺序），可使用sort_index方法，它将返回一个已排序的新对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">201</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">4</span>), index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: obj.sort_index()</span><br><span class="line">Out[<span class="number">202</span>]:</span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>对于DataFrame，则可以根据任意一个轴上的索引进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">203</span>]: frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                      index=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   .....:                      columns=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">204</span>]: frame.sort_index()</span><br><span class="line">Out[<span class="number">204</span>]: </span><br><span class="line">       d  a  b  c</span><br><span class="line">one    <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line">three  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: frame.sort_index(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">205</span>]:</span><br><span class="line">       a  b  c  d</span><br><span class="line">three  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span></span><br><span class="line">one    <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>数据默认是按升序排序的，但也可以降序排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">206</span>]: frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">206</span>]: </span><br><span class="line">       d  c  b  a</span><br><span class="line">three  <span class="number">0</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">one    <span class="number">4</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>若要按值对Series进行排序，可使用其sort_values方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">207</span>]: obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">208</span>]: </span><br><span class="line"><span class="number">2</span>   -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>在排序时，任何缺失值默认都会被放到Series的末尾：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">209</span>]: obj = pd.Series([<span class="number">4</span>, np.nan, <span class="number">7</span>, np.nan, -<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">210</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">210</span>]: </span><br><span class="line"><span class="number">4</span>   -<span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>当排序一个DataFrame时，你可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给sort_values的by选项即可达到该目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">211</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>: [<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">&#x27;a&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: frame</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">213</span>]: frame.sort_values(by=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">Out[<span class="number">213</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>要根据多个列进行排序，传入名称的列表即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">214</span>]: frame.sort_values(by=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">Out[<span class="number">214</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>排名会从1开始一直到数组中有效数据的数量。接下来介绍Series和DataFrame的rank方法。默认情况下，rank是通过“为各组分配一个平均排名”的方式破坏平级关系的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">215</span>]: obj = pd.Series([<span class="number">7</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">In [<span class="number">216</span>]: obj.rank()</span><br><span class="line">Out[<span class="number">216</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">4.5</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>也可以根据值在原数据中出现的顺序给出排名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">217</span>]: obj.rank(method=<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">Out[<span class="number">217</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">5.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>这里，条目0和2没有使用平均排名6.5，它们被设成了6和7，因为数据中标签0位于标签2的前面。</p>
<p>你也可以按降序进行排名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Assign tie values the maximum rank in the group</span></span><br><span class="line">In [<span class="number">218</span>]: obj.rank(ascending=<span class="literal">False</span>, method=<span class="string">&#x27;max&#x27;</span>)</span><br><span class="line">Out[<span class="number">218</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">5.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>表5-6列出了所有用于破坏平级关系的method选项。DataFrame可以在行或列上计算排名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">219</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>: [<span class="number">4.3</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">&#x27;a&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">   .....:                       <span class="string">&#x27;c&#x27;</span>: [-<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, -<span class="number">2.5</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">220</span>]: frame</span><br><span class="line">Out[<span class="number">220</span>]: </span><br><span class="line">   a    b    c</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4.3</span> -<span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7.0</span>  <span class="number">5.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3.0</span>  <span class="number">8.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2.0</span> -<span class="number">2.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">221</span>]: frame.rank(axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">221</span>]: </span><br><span class="line">     a    b    c</span><br><span class="line"><span class="number">0</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  <span class="number">3.0</span>  <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2.0</span>  <span class="number">1.0</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap05/7178691-7edfab5b4a147581.png" class="" title="表5-6 排名时用于破坏平级关系的方法">
<h3 id="带有重复标签的轴索引">5.2.11 带有重复标签的轴索引</h3>
<p>直到目前为止，我所介绍的所有范例都有着唯一的轴标签（索引值）。虽然许多pandas函数（如reindex）都要求标签唯一，但这并不是强制性的。我们来看看下面这个简单的带有重复索引值的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">222</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">5</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">223</span>]: obj</span><br><span class="line">Out[<span class="number">223</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">b    <span class="number">3</span></span><br><span class="line">c    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>索引的is_unique属性可以告诉你它的值是否是唯一的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">224</span>]: obj.index.is_unique</span><br><span class="line">Out[<span class="number">224</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>对于带有重复值的索引，数据选取的行为将会有些不同。如果某个索引对应多个值，则返回一个Series；而对应单个值的，则返回一个标量值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">225</span>]: obj[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">226</span>]: obj[<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">Out[<span class="number">226</span>]: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这样会使代码变复杂，因为索引的输出类型会根据标签是否有重复发生变化。</p>
<p>对DataFrame的行进行索引时也是如此：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">227</span>]: df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">228</span>]: df</span><br><span class="line">Out[<span class="number">228</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line">a  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line">a  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line">b  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line">b  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">229</span>]: df.loc[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">229</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line">b  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line">b  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br></pre></td></tr></table></figure>
<h2 id="汇总和计算描述统计">5.3 汇总和计算描述统计</h2>
<p>pandas对象拥有一组常用的数学和统计方法。它们大部分都属于约简和汇总统计，用于从Series中提取单个值（如sum或mean）或从DataFrame的行或列中提取一个Series。跟对应的NumPy数组方法相比，它们都是基于没有缺失数据的假设而构建的。看一个简单的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">230</span>]: df = pd.DataFrame([[<span class="number">1.4</span>, np.nan], [<span class="number">7.1</span>, -<span class="number">4.5</span>],</span><br><span class="line">   .....:                    [np.nan, np.nan], [<span class="number">0.75</span>, -<span class="number">1.3</span>]],</span><br><span class="line">   .....:                   index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   .....:                   columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">231</span>]: df</span><br><span class="line">Out[<span class="number">231</span>]: </span><br><span class="line">    one  two</span><br><span class="line">a  <span class="number">1.40</span>  NaN</span><br><span class="line">b  <span class="number">7.10</span> -<span class="number">4.5</span></span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  <span class="number">0.75</span> -<span class="number">1.3</span></span><br></pre></td></tr></table></figure>
<p>调用DataFrame的sum方法将会返回一个含有列的和的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">232</span>]: df.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">232</span>]: </span><br><span class="line">one    <span class="number">9.25</span></span><br><span class="line">two   -<span class="number">5.80</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>传入axis='columns'或axis=1将会按行进行求和运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">233</span>]: df.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">233</span>]:</span><br><span class="line">a    <span class="number">1.40</span></span><br><span class="line">b    <span class="number">2.60</span></span><br><span class="line">c     NaN</span><br><span class="line">d   -<span class="number">0.55</span></span><br></pre></td></tr></table></figure>
<p>NA值会自动被排除，除非整个切片（这里指的是行或列）都是NA。通过skipna选项可以禁用该功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">234</span>]: df.mean(axis=<span class="string">&#x27;columns&#x27;</span>, skipna=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">234</span>]: </span><br><span class="line">a      NaN</span><br><span class="line">b    <span class="number">1.300</span></span><br><span class="line">c      NaN</span><br><span class="line">d   -<span class="number">0.275</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>表5-7列出了这些约简方法的常用选项。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap05/7178691-af35e3809278410e.jpg" class="">
<p>有些方法（如idxmin和idxmax）返回的是间接统计（比如达到最小值或最大值的索引）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">235</span>]: df.idxmax()</span><br><span class="line">Out[<span class="number">235</span>]: </span><br><span class="line">one    b</span><br><span class="line">two    d</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>另一些方法则是累计型的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">236</span>]: df.cumsum()</span><br><span class="line">Out[<span class="number">236</span>]: </span><br><span class="line">    one  two</span><br><span class="line">a  <span class="number">1.40</span>  NaN</span><br><span class="line">b  <span class="number">8.50</span> -<span class="number">4.5</span></span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  <span class="number">9.25</span> -<span class="number">5.8</span></span><br></pre></td></tr></table></figure>
<p>还有一种方法，它既不是约简型也不是累计型。describe就是一个例子，它用于一次性产生多个汇总统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">237</span>]: df.describe()</span><br><span class="line">Out[<span class="number">237</span>]: </span><br><span class="line">            one       two</span><br><span class="line">count  <span class="number">3.000000</span>  <span class="number">2.000000</span></span><br><span class="line">mean   <span class="number">3.083333</span> -<span class="number">2.900000</span></span><br><span class="line">std    <span class="number">3.493685</span>  <span class="number">2.262742</span></span><br><span class="line"><span class="built_in">min</span>    <span class="number">0.750000</span> -<span class="number">4.500000</span></span><br><span class="line"><span class="number">25</span>%    <span class="number">1.075000</span> -<span class="number">3.700000</span></span><br><span class="line"><span class="number">50</span>%    <span class="number">1.400000</span> -<span class="number">2.900000</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">4.250000</span> -<span class="number">2.100000</span></span><br><span class="line"><span class="built_in">max</span>    <span class="number">7.100000</span> -<span class="number">1.300000</span></span><br></pre></td></tr></table></figure>
<p>对于非数值型数据，describe会产生另外一种汇总统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">238</span>]: obj = pd.Series([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] * <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">239</span>]: obj.describe()</span><br><span class="line">Out[<span class="number">239</span>]: </span><br><span class="line">count     <span class="number">16</span></span><br><span class="line">unique     <span class="number">3</span></span><br><span class="line">top        a</span><br><span class="line">freq       <span class="number">8</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>表5-8列出了所有与描述统计相关的方法。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap05/7178691-11fa967f658ac314.jpg" class="">
<h3 id="相关系数与协方差">5.3.1 相关系数与协方差</h3>
<p>有些汇总统计（如相关系数和协方差）是通过参数对计算出来的。我们来看几个DataFrame，它们的数据来自Yahoo!Finance的股票价格和成交量，使用的是pandas-datareader包（可以用conda或pip安装）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda install pandas-datareader</span><br></pre></td></tr></table></figure>
<p>我使用pandas_datareader模块下载了一些股票数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_datareader.data <span class="keyword">as</span> web</span><br><span class="line">all_data = &#123;ticker: web.get_data_yahoo(ticker)</span><br><span class="line">            <span class="keyword">for</span> ticker <span class="keyword">in</span> [<span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;MSFT&#x27;</span>, <span class="string">&#x27;GOOG&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">price = pd.DataFrame(&#123;ticker: data[<span class="string">&#x27;Adj Close&#x27;</span>]</span><br><span class="line">                     <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br><span class="line">volume = pd.DataFrame(&#123;ticker: data[<span class="string">&#x27;Volume&#x27;</span>]</span><br><span class="line">                      <span class="keyword">for</span> ticker, data <span class="keyword">in</span> all_data.items()&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：此时Yahoo! Finance已经不存在了，因为2017年Yahoo!被Verizon收购了。参阅pandas-datareader文档，可以学习最新的功能。</p>
</blockquote>
<p>现在计算价格的百分数变化，时间序列的操作会在第11章介绍：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">242</span>]: returns = price.pct_change()</span><br><span class="line"></span><br><span class="line">In [<span class="number">243</span>]: returns.tail()</span><br><span class="line">Out[<span class="number">243</span>]: </span><br><span class="line">                AAPL      GOOG       IBM      MSFT</span><br><span class="line">Date                                              </span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">17</span> -<span class="number">0.000680</span>  <span class="number">0.001837</span>  <span class="number">0.002072</span> -<span class="number">0.003483</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">18</span> -<span class="number">0.000681</span>  <span class="number">0.019616</span> -<span class="number">0.026168</span>  <span class="number">0.007690</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">19</span> -<span class="number">0.002979</span>  <span class="number">0.007846</span>  <span class="number">0.003583</span> -<span class="number">0.002255</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">20</span> -<span class="number">0.000512</span> -<span class="number">0.005652</span>  <span class="number">0.001719</span> -<span class="number">0.004867</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">10</span>-<span class="number">21</span> -<span class="number">0.003930</span>  <span class="number">0.003011</span> -<span class="number">0.012474</span>  <span class="number">0.042096</span></span><br></pre></td></tr></table></figure>
<p>Series的corr方法用于计算两个Series中重叠的、非NA的、按索引对齐的值的相关系数。与此类似，cov用于计算协方差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">244</span>]: returns[<span class="string">&#x27;MSFT&#x27;</span>].corr(returns[<span class="string">&#x27;IBM&#x27;</span>])</span><br><span class="line">Out[<span class="number">244</span>]: <span class="number">0.49976361144151144</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">245</span>]: returns[<span class="string">&#x27;MSFT&#x27;</span>].cov(returns[<span class="string">&#x27;IBM&#x27;</span>])</span><br><span class="line">Out[<span class="number">245</span>]: <span class="number">8.8706554797035462e-05</span></span><br></pre></td></tr></table></figure>
<p>因为MSTF是一个合理的Python属性，我们还可以用更简洁的语法选择列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">246</span>]: returns.MSFT.corr(returns.IBM)</span><br><span class="line">Out[<span class="number">246</span>]: <span class="number">0.49976361144151144</span></span><br></pre></td></tr></table></figure>
<p>另一方面，DataFrame的corr和cov方法将以DataFrame的形式分别返回完整的相关系数或协方差矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">247</span>]: returns.corr()</span><br><span class="line">Out[<span class="number">247</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="number">1.000000</span>  <span class="number">0.407919</span>  <span class="number">0.386817</span>  <span class="number">0.389695</span></span><br><span class="line">GOOG  <span class="number">0.407919</span>  <span class="number">1.000000</span>  <span class="number">0.405099</span>  <span class="number">0.465919</span></span><br><span class="line">IBM   <span class="number">0.386817</span>  <span class="number">0.405099</span>  <span class="number">1.000000</span>  <span class="number">0.499764</span></span><br><span class="line">MSFT  <span class="number">0.389695</span>  <span class="number">0.465919</span>  <span class="number">0.499764</span>  <span class="number">1.000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">248</span>]: returns.cov()</span><br><span class="line">Out[<span class="number">248</span>]: </span><br><span class="line">          AAPL      GOOG       IBM      MSFT</span><br><span class="line">AAPL  <span class="number">0.000277</span>  <span class="number">0.000107</span>  <span class="number">0.000078</span>  <span class="number">0.000095</span></span><br><span class="line">GOOG  <span class="number">0.000107</span>  <span class="number">0.000251</span>  <span class="number">0.000078</span>  <span class="number">0.000108</span></span><br><span class="line">IBM   <span class="number">0.000078</span>  <span class="number">0.000078</span>  <span class="number">0.000146</span>  <span class="number">0.000089</span></span><br><span class="line">MSFT  <span class="number">0.000095</span>  <span class="number">0.000108</span>  <span class="number">0.000089</span>  <span class="number">0.000215</span></span><br></pre></td></tr></table></figure>
<p>利用DataFrame的corrwith方法，你可以计算其列或行跟另一个Series或DataFrame之间的相关系数。传入一个Series将会返回一个相关系数值Series（针对各列进行计算）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">249</span>]: returns.corrwith(returns.IBM)</span><br><span class="line">Out[<span class="number">249</span>]: </span><br><span class="line">AAPL    <span class="number">0.386817</span></span><br><span class="line">GOOG    <span class="number">0.405099</span></span><br><span class="line">IBM     <span class="number">1.000000</span></span><br><span class="line">MSFT    <span class="number">0.499764</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>传入一个DataFrame则会计算按列名配对的相关系数。这里，我计算百分比变化与成交量的相关系数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">250</span>]: returns.corrwith(volume)</span><br><span class="line">Out[<span class="number">250</span>]: </span><br><span class="line">AAPL   -<span class="number">0.075565</span></span><br><span class="line">GOOG   -<span class="number">0.007067</span></span><br><span class="line">IBM    -<span class="number">0.204849</span></span><br><span class="line">MSFT   -<span class="number">0.092950</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>传入axis='columns'即可按行进行计算。无论如何，在计算相关系数之前，所有的数据项都会按标签对齐。</p>
<h3 id="唯一值值计数以及成员资格">5.3.2 唯一值、值计数以及成员资格</h3>
<p>还有一类方法可以从一维Series的值中抽取信息。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">251</span>]: obj = pd.Series([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>第一个函数是unique，它可以得到Series中的唯一值数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">252</span>]: uniques = obj.unique()</span><br><span class="line"></span><br><span class="line">In [<span class="number">253</span>]: uniques</span><br><span class="line">Out[<span class="number">253</span>]: array([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<p>返回的唯一值是未排序的，如果需要的话，可以对结果再次进行排序（uniques.sort()）。相似的，value_counts用于计算一个Series中各值出现的频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">254</span>]: obj.value_counts()</span><br><span class="line">Out[<span class="number">254</span>]: </span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">a    <span class="number">3</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">d    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>为了便于查看，结果Series是按值频率降序排列的。value_counts还是一个顶级pandas方法，可用于任何数组或序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">255</span>]: pd.value_counts(obj.values, sort=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">255</span>]: </span><br><span class="line">a    <span class="number">3</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>isin用于判断矢量化集合的成员资格，可用于过滤Series中或DataFrame列中数据的子集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">256</span>]: obj</span><br><span class="line">Out[<span class="number">256</span>]: </span><br><span class="line"><span class="number">0</span>    c</span><br><span class="line"><span class="number">1</span>    a</span><br><span class="line"><span class="number">2</span>    d</span><br><span class="line"><span class="number">3</span>    a</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    b</span><br><span class="line"><span class="number">7</span>    c</span><br><span class="line"><span class="number">8</span>    c</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">257</span>]: mask = obj.isin([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">258</span>]: mask</span><br><span class="line">Out[<span class="number">258</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">5</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">6</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">7</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">8</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">259</span>]: obj[mask]</span><br><span class="line">Out[<span class="number">259</span>]: </span><br><span class="line"><span class="number">0</span>    c</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    b</span><br><span class="line"><span class="number">7</span>    c</span><br><span class="line"><span class="number">8</span>    c</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>与isin类似的是Index.get_indexer方法，它可以给你一个索引数组，从可能包含重复值的数组到另一个不同值的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">260</span>]: to_match = pd.Series([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">261</span>]: unique_vals = pd.Series([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">262</span>]: pd.Index(unique_vals).get_indexer(to_match)</span><br><span class="line">Out[<span class="number">262</span>]: array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>表5-9给出了这几个方法的一些参考信息。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap05/7178691-b53c4a9d65a2db32.png" class="" title="表5-9 唯一值、值计数、成员资格方法">
<p>有时，你可能希望得到DataFrame中多个相关列的一张柱状图。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">263</span>]: data = pd.DataFrame(&#123;<span class="string">&#x27;Qu1&#x27;</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">   .....:                      <span class="string">&#x27;Qu2&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">   .....:                      <span class="string">&#x27;Qu3&#x27;</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">264</span>]: data</span><br><span class="line">Out[<span class="number">264</span>]: </span><br><span class="line">   Qu1  Qu2  Qu3</span><br><span class="line"><span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>    <span class="number">4</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">4</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span>    <span class="number">3</span>    <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>将pandas.value_counts传给该DataFrame的apply函数，就会出现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">265</span>]: result = data.apply(pd.value_counts).fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">266</span>]: result</span><br><span class="line">Out[<span class="number">266</span>]: </span><br><span class="line">   Qu1  Qu2  Qu3</span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.0</span>  <span class="number">2.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.0</span>  <span class="number">2.0</span>  <span class="number">0.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.0</span>  <span class="number">0.0</span>  <span class="number">2.0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>这里，结果中的行标签是所有列的唯一值。后面的频率值是每个列中这些值的相应计数。</p>
<h2 id="总结">5.4 总结</h2>
<p>在下一章，我们将讨论用pandas读取（或加载）和写入数据集的工具。</p>
<p>之后，我们将更深入地研究使用pandas进行数据清洗、规整、分析和可视化工具。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第06章_数据加载、存储与文件格式</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap06/</url>
    <content><![CDATA[<h1 id="第06章-数据加载存储与文件格式">第06章 数据加载、存储与文件格式</h1>
<p>访问数据是使用本书所介绍的这些工具的第一步。我会着重介绍pandas的数据输入与输出，虽然别的库中也有不少以此为目的的工具。</p>
<span id="more"></span>
<p>输入输出通常可以划分为几个大类：读取文本文件和其他更高效的磁盘存储格式，加载数据库中的数据，利用Web API操作网络资源。</p>
<h2 id="读写文本格式的数据">6.1 读写文本格式的数据</h2>
<p>pandas提供了一些用于将表格型数据读取为DataFrame对象的函数。表6-1对它们进行了总结，其中read_csv和read_table可能会是你今后用得最多的。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap06/7178691-958f849e6067b19b.png" class="" title="表6-1 pandas中的解析函数">
<p>我将大致介绍一下这些函数在将文本数据转换为DataFrame时所用到的一些技术。这些函数的选项可以划分为以下几个大类：</p>
<ul>
<li>索引：将一个或多个列当做返回的DataFrame处理，以及是否从文件、用户获取列名。</li>
<li>类型推断和数据转换：包括用户定义值的转换、和自定义的缺失值标记列表等。</li>
<li>日期解析：包括组合功能，比如将分散在多个列中的日期时间信息组合成结果中的单个列。</li>
<li>迭代：支持对大文件进行逐块迭代。</li>
<li>不规整数据问题：跳过一些行、页脚、注释或其他一些不重要的东西（比如由成千上万个逗号隔开的数值数据）。</li>
</ul>
<p>因为工作中实际碰到的数据可能十分混乱，一些数据加载函数（尤其是read_csv）的选项逐渐变得复杂起来。面对不同的参数，感到头痛很正常（read_csv有超过50个参数）。pandas文档有这些参数的例子，如果你感到阅读某个文件很难，可以通过相似的足够多的例子找到正确的参数。</p>
<p>其中一些函数，比如pandas.read_csv，有类型推断功能，因为列数据的类型不属于数据类型。也就是说，你不需要指定列的类型到底是数值、整数、布尔值，还是字符串。其它的数据格式，如HDF5、Feather和msgpack，会在格式中存储数据类型。</p>
<p>日期和其他自定义类型的处理需要多花点工夫才行。首先我们来看一个以逗号分隔的（CSV）文本文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: !cat examples/ex1.csv</span><br><span class="line">a,b,c,d,message</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,hello</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,world</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：这里，我用的是Unix的cat shell命令将文件的原始内容打印到屏幕上。如果你用的是Windows，你可以使用type达到同样的效果。</p>
</blockquote>
<p>由于该文件以逗号分隔，所以我们可以使用read_csv将其读入一个DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: df = pd.read_csv(<span class="string">&#x27;examples/ex1.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: df</span><br><span class="line">Out[<span class="number">10</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>我们还可以使用read_table，并指定分隔符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: pd.read_table(<span class="string">&#x27;examples/ex1.csv&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>并不是所有文件都有标题行。看看下面这个文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: !cat examples/ex2.csv</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,hello</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,world</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure>
<p>读入该文件的办法有两个。你可以让pandas为其分配默认的列名，也可以自己定义列名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: pd.read_csv(<span class="string">&#x27;examples/ex2.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>      <span class="number">4</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>  hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>  world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>    foo</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: pd.read_csv(<span class="string">&#x27;examples/ex2.csv&#x27;</span>, names=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;message&#x27;</span>])</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>假设你希望将message列做成DataFrame的索引。你可以明确表示要将该列放到索引4的位置上，也可以通过index_col参数指定"message"：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: names = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;message&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: pd.read_csv(<span class="string">&#x27;examples/ex2.csv&#x27;</span>, names=names, index_col=<span class="string">&#x27;message&#x27;</span>)</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">         a   b   c   d</span><br><span class="line">message               </span><br><span class="line">hello    <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line">world    <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line">foo      <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>如果希望将多个列做成一个层次化索引，只需传入由列编号或列名组成的列表即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: !cat examples/csv_mindex.csv</span><br><span class="line">key1,key2,value1,value2</span><br><span class="line">one,a,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">one,b,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">one,c,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">one,d,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">two,a,<span class="number">9</span>,<span class="number">10</span></span><br><span class="line">two,b,<span class="number">11</span>,<span class="number">12</span></span><br><span class="line">two,c,<span class="number">13</span>,<span class="number">14</span></span><br><span class="line">two,d,<span class="number">15</span>,<span class="number">16</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: parsed = pd.read_csv(<span class="string">&#x27;examples/csv_mindex.csv&#x27;</span>,</span><br><span class="line">   ....:                      index_col=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: parsed</span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line">           value1  value2</span><br><span class="line">key1 key2                </span><br><span class="line">one  a          <span class="number">1</span>       <span class="number">2</span></span><br><span class="line">     b          <span class="number">3</span>       <span class="number">4</span></span><br><span class="line">     c          <span class="number">5</span>       <span class="number">6</span></span><br><span class="line">     d          <span class="number">7</span>       <span class="number">8</span></span><br><span class="line">two  a          <span class="number">9</span>      <span class="number">10</span></span><br><span class="line">     b         <span class="number">11</span>      <span class="number">12</span></span><br><span class="line">     c         <span class="number">13</span>      <span class="number">14</span></span><br><span class="line">     d         <span class="number">15</span>      <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>有些情况下，有些表格可能不是用固定的分隔符去分隔字段的（比如空白符或其它模式）。看看下面这个文本文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: <span class="built_in">list</span>(<span class="built_in">open</span>(<span class="string">&#x27;examples/ex3.txt&#x27;</span>))</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">[<span class="string">&#x27;            A         B         C\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;aaa -0.264438 -1.026059 -0.619500\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;bbb  0.927272  0.302904 -0.032399\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ccc -0.264273 -0.386314 -0.217601\n&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ddd -0.871858 -0.348382  1.100491\n&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>虽然可以手动对数据进行规整，这里的字段是被数量不同的空白字符间隔开的。这种情况下，你可以传递一个正则表达式作为read_table的分隔符。可以用正则表达式表达为+，于是有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: result = pd.read_table(<span class="string">&#x27;examples/ex3.txt&#x27;</span>, sep=<span class="string">&#x27;\s+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: result</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">            A         B         C</span><br><span class="line">aaa -<span class="number">0.264438</span> -<span class="number">1.026059</span> -<span class="number">0.619500</span></span><br><span class="line">bbb  <span class="number">0.927272</span>  <span class="number">0.302904</span> -<span class="number">0.032399</span></span><br><span class="line">ccc -<span class="number">0.264273</span> -<span class="number">0.386314</span> -<span class="number">0.217601</span></span><br><span class="line">ddd -<span class="number">0.871858</span> -<span class="number">0.348382</span>  <span class="number">1.100491</span></span><br></pre></td></tr></table></figure>
<p>这里，由于列名比数据行的数量少，所以read_table推断第一列应该是DataFrame的索引。</p>
<p>这些解析器函数还有许多参数可以帮助你处理各种各样的异形文件格式（表6-2列出了一些）。比如说，你可以用skiprows跳过文件的第一行、第三行和第四行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: !cat examples/ex4.csv</span><br><span class="line"><span class="comment">## hey!</span></span><br><span class="line">a,b,c,d,message</span><br><span class="line"><span class="comment">## just wanted to make things more difficult for you</span></span><br><span class="line"><span class="comment">## who reads CSV files with computers, anyway?</span></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,hello</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,world</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br><span class="line">In [<span class="number">24</span>]: pd.read_csv(<span class="string">&#x27;examples/ex4.csv&#x27;</span>, skiprows=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>缺失值处理是文件解析任务中的一个重要组成部分。缺失数据经常是要么没有（空字符串），要么用某个标记值表示。默认情况下，pandas会用一组经常出现的标记值进行识别，比如NA及NULL：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: !cat examples/ex5.csv</span><br><span class="line">something,a,b,c,d,message</span><br><span class="line">one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,NA</span><br><span class="line">two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line">three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br><span class="line">In [<span class="number">26</span>]: result = pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: result</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">  something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       two  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     foo</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: pd.isnull(result)</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">   something      a      b      c      d  message</span><br><span class="line"><span class="number">0</span>      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>   <span class="literal">True</span>  <span class="literal">False</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>    <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>na_values可以用一个列表或集合的字符串表示缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: result = pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>, na_values=[<span class="string">&#x27;NULL&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: result</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">  something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       two  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>字典的各列可以使用不同的NA标记值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: sentinels = &#123;<span class="string">&#x27;message&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;NA&#x27;</span>], <span class="string">&#x27;something&#x27;</span>: [<span class="string">&#x27;two&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>, na_values=sentinels)</span><br><span class="line">Out[<span class="number">32</span>]:</span><br><span class="line">something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       NaN  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     NaN</span><br></pre></td></tr></table></figure>
<p>表6-2列出了pandas.read_csv和pandas.read_table常用的选项。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap06/7178691-082daf4a00ed9494.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap06/7178691-f2bcc0a703c7236f.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap06/7178691-597327ade3e94c7a.png" class="">
<h3 id="逐块读取文本文件">6.1.1 逐块读取文本文件</h3>
<p>在处理很大的文件时，或找出大文件中的参数集以便于后续处理时，你可能只想读取文件的一小部分或逐块对文件进行迭代。</p>
<p>在看大文件之前，我们先设置pandas显示地更紧些：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: pd.options.display.max_rows = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>然后有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: result = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: result</span><br><span class="line">Out[<span class="number">35</span>]: </span><br><span class="line">           one       two     three      four key</span><br><span class="line"><span class="number">0</span>     <span class="number">0.467976</span> -<span class="number">0.038649</span> -<span class="number">0.295344</span> -<span class="number">1.824726</span>   L</span><br><span class="line"><span class="number">1</span>    -<span class="number">0.358893</span>  <span class="number">1.404453</span>  <span class="number">0.704965</span> -<span class="number">0.200638</span>   B</span><br><span class="line"><span class="number">2</span>    -<span class="number">0.501840</span>  <span class="number">0.659254</span> -<span class="number">0.421691</span> -<span class="number">0.057688</span>   G</span><br><span class="line"><span class="number">3</span>     <span class="number">0.204886</span>  <span class="number">1.074134</span>  <span class="number">1.388361</span> -<span class="number">0.982404</span>   R</span><br><span class="line"><span class="number">4</span>     <span class="number">0.354628</span> -<span class="number">0.133116</span>  <span class="number">0.283763</span> -<span class="number">0.837063</span>   Q</span><br><span class="line"><span class="meta">... </span>       ...       ...       ...       ...  ..</span><br><span class="line"><span class="number">9995</span>  <span class="number">2.311896</span> -<span class="number">0.417070</span> -<span class="number">1.409599</span> -<span class="number">0.515821</span>   L</span><br><span class="line"><span class="number">9996</span> -<span class="number">0.479893</span> -<span class="number">0.650419</span>  <span class="number">0.745152</span> -<span class="number">0.646038</span>   E</span><br><span class="line"><span class="number">9997</span>  <span class="number">0.523331</span>  <span class="number">0.787112</span>  <span class="number">0.486066</span>  <span class="number">1.093156</span>   K</span><br><span class="line"><span class="number">9998</span> -<span class="number">0.362559</span>  <span class="number">0.598894</span> -<span class="number">1.843201</span>  <span class="number">0.887292</span>   G</span><br><span class="line"><span class="number">9999</span> -<span class="number">0.096376</span> -<span class="number">1.012999</span> -<span class="number">0.657431</span> -<span class="number">0.573315</span>   <span class="number">0</span></span><br><span class="line">[<span class="number">10000</span> rows x <span class="number">5</span> columns]</span><br><span class="line">If you want to only read a small</span><br></pre></td></tr></table></figure>
<p>如果只想读取几行（避免读取整个文件），通过nrows进行指定即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">36</span>]: pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>, nrows=<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">        one       two     three      four key</span><br><span class="line"><span class="number">0</span>  <span class="number">0.467976</span> -<span class="number">0.038649</span> -<span class="number">0.295344</span> -<span class="number">1.824726</span>   L</span><br><span class="line"><span class="number">1</span> -<span class="number">0.358893</span>  <span class="number">1.404453</span>  <span class="number">0.704965</span> -<span class="number">0.200638</span>   B</span><br><span class="line"><span class="number">2</span> -<span class="number">0.501840</span>  <span class="number">0.659254</span> -<span class="number">0.421691</span> -<span class="number">0.057688</span>   G</span><br><span class="line"><span class="number">3</span>  <span class="number">0.204886</span>  <span class="number">1.074134</span>  <span class="number">1.388361</span> -<span class="number">0.982404</span>   R</span><br><span class="line"><span class="number">4</span>  <span class="number">0.354628</span> -<span class="number">0.133116</span>  <span class="number">0.283763</span> -<span class="number">0.837063</span>   Q</span><br></pre></td></tr></table></figure>
<p>要逐块读取文件，可以指定chunksize（行数）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">874</span>]: chunker = pd.read_csv(<span class="string">&#x27;ch06/ex6.csv&#x27;</span>, chunksize=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">875</span>]: chunker</span><br><span class="line">Out[<span class="number">875</span>]: &lt;pandas.io.parsers.TextParser at <span class="number">0x8398150</span>&gt;</span><br></pre></td></tr></table></figure>
<p>read_csv所返回的这个TextParser对象使你可以根据chunksize对文件进行逐块迭代。比如说，我们可以迭代处理ex6.csv，将值计数聚合到"key"列中，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chunker = pd.read_csv(<span class="string">&#x27;examples/ex6.csv&#x27;</span>, chunksize=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">tot = pd.Series([])</span><br><span class="line"><span class="keyword">for</span> piece <span class="keyword">in</span> chunker:</span><br><span class="line">    tot = tot.add(piece[<span class="string">&#x27;key&#x27;</span>].value_counts(), fill_value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">tot = tot.sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>然后有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: tot[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">E    <span class="number">368.0</span></span><br><span class="line">X    <span class="number">364.0</span></span><br><span class="line">L    <span class="number">346.0</span></span><br><span class="line">O    <span class="number">343.0</span></span><br><span class="line">Q    <span class="number">340.0</span></span><br><span class="line">M    <span class="number">338.0</span></span><br><span class="line">J    <span class="number">337.0</span></span><br><span class="line">F    <span class="number">335.0</span></span><br><span class="line">K    <span class="number">334.0</span></span><br><span class="line">H    <span class="number">330.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>TextParser还有一个get_chunk方法，它使你可以读取任意大小的块。</p>
<h3 id="将数据写出到文本格式">6.1.2 将数据写出到文本格式</h3>
<p>数据也可以被输出为分隔符格式的文本。我们再来看看之前读过的一个CSV文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: data = pd.read_csv(<span class="string">&#x27;examples/ex5.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: data</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">  something  a   b     c   d message</span><br><span class="line"><span class="number">0</span>       one  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3.0</span>   <span class="number">4</span>     NaN</span><br><span class="line"><span class="number">1</span>       two  <span class="number">5</span>   <span class="number">6</span>   NaN   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>     three  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11.0</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>利用DataFrame的to_csv方法，我们可以将数据写到一个以逗号分隔的文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: data.to_csv(<span class="string">&#x27;examples/out.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: !cat examples/out.csv</span><br><span class="line">,something,a,b,c,d,message</span><br><span class="line"><span class="number">0</span>,one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span>,<span class="number">4</span>,</span><br><span class="line"><span class="number">1</span>,two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line"><span class="number">2</span>,three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure>
<p>当然，还可以使用其他分隔符（由于这里直接写出到sys.stdout，所以仅仅是打印出文本结果而已）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: data.to_csv(sys.stdout, sep=<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">|something|a|b|c|d|message</span><br><span class="line"><span class="number">0</span>|one|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3.0</span>|<span class="number">4</span>|</span><br><span class="line"><span class="number">1</span>|two|<span class="number">5</span>|<span class="number">6</span>||<span class="number">8</span>|world</span><br><span class="line"><span class="number">2</span>|three|<span class="number">9</span>|<span class="number">10</span>|<span class="number">11.0</span>|<span class="number">12</span>|foo</span><br></pre></td></tr></table></figure>
<p>缺失值在输出结果中会被表示为空字符串。你可能希望将其表示为别的标记值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: data.to_csv(sys.stdout, na_rep=<span class="string">&#x27;NULL&#x27;</span>)</span><br><span class="line">,something,a,b,c,d,message</span><br><span class="line"><span class="number">0</span>,one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span>,<span class="number">4</span>,NULL</span><br><span class="line"><span class="number">1</span>,two,<span class="number">5</span>,<span class="number">6</span>,NULL,<span class="number">8</span>,world</span><br><span class="line"><span class="number">2</span>,three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure>
<p>如果没有设置其他选项，则会写出行和列的标签。当然，它们也都可以被禁用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">48</span>]: data.to_csv(sys.stdout, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br><span class="line">one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span>,<span class="number">4</span>,</span><br><span class="line">two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line">three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span>,<span class="number">12</span>,foo</span><br></pre></td></tr></table></figure>
<p>此外，你还可以只写出一部分的列，并以你指定的顺序排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: data.to_csv(sys.stdout, index=<span class="literal">False</span>, columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">a,b,c</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11.0</span></span><br></pre></td></tr></table></figure>
<p>Series也有一个to_csv方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: dates = pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: ts = pd.Series(np.arange(<span class="number">7</span>), index=dates)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: ts.to_csv(<span class="string">&#x27;examples/tseries.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: !cat examples/tseries.csv</span><br><span class="line"><span class="number">2000</span>-01-01,<span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-02,<span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-03,<span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-04,<span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-05,<span class="number">4</span></span><br><span class="line"><span class="number">2000</span>-01-06,<span class="number">5</span></span><br><span class="line"><span class="number">2000</span>-01-07,<span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="处理分隔符格式">6.1.3 处理分隔符格式</h3>
<p>大部分存储在磁盘上的表格型数据都能用pandas.read_table进行加载。然而，有时还是需要做一些手工处理。由于接收到含有畸形行的文件而使read_table出毛病的情况并不少见。为了说明这些基本工具，看看下面这个简单的CSV文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: !cat examples/ex7.csv</span><br><span class="line"><span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于任何单字符分隔符文件，可以直接使用Python内置的csv模块。将任意已打开的文件或文件型的对象传给csv.reader：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;examples/ex7.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">reader = csv.reader(f)</span><br></pre></td></tr></table></figure>
<p>对这个reader进行迭代将会为每行产生一个元组（并移除了所有的引号）：对这个reader进行迭代将会为每行产生一个元组（并移除了所有的引号）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">   ....:     <span class="built_in">print</span>(line)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>现在，为了使数据格式合乎要求，你需要对其做一些整理工作。我们一步一步来做。首先，读取文件到一个多行的列表中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;examples/ex7.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">   ....:     lines = <span class="built_in">list</span>(csv.reader(f))</span><br></pre></td></tr></table></figure>
<p>然后，我们将这些行分为标题行和数据行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: header, values = lines[<span class="number">0</span>], lines[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<p>然后，我们可以用字典构造式和zip(*values)，后者将行转置为列，创建数据列的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">59</span>]: data_dict = &#123;h: v <span class="keyword">for</span> h, v <span class="keyword">in</span> <span class="built_in">zip</span>(header, <span class="built_in">zip</span>(*values))&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: data_dict</span><br><span class="line">Out[<span class="number">60</span>]: &#123;<span class="string">&#x27;a&#x27;</span>: (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>), <span class="string">&#x27;b&#x27;</span>: (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2&#x27;</span>), <span class="string">&#x27;c&#x27;</span>: (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>CSV文件的形式有很多。只需定义csv.Dialect的一个子类即可定义出新格式（如专门的分隔符、字符串引用约定、行结束符等）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_dialect</span>(csv.Dialect):</span><br><span class="line">    lineterminator = <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    delimiter = <span class="string">&#x27;;&#x27;</span></span><br><span class="line">    quotechar = <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    quoting = csv.QUOTE_MINIMAL</span><br><span class="line">reader = csv.reader(f, dialect=my_dialect)</span><br></pre></td></tr></table></figure>
<p>各个CSV语支的参数也可以用关键字的形式提供给csv.reader，而无需定义子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reader = csv.reader(f, delimiter=<span class="string">&#x27;|&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可用的选项（csv.Dialect的属性）及其功能如表6-3所示。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap06/7178691-7a1cee622459072b.png" class="">
<blockquote>
<p>笔记：对于那些使用复杂分隔符或多字符分隔符的文件，csv模块就无能为力了。这种情况下，你就只能使用字符串的split方法或正则表达式方法re.split进行行拆分和其他整理工作了。</p>
</blockquote>
<p>要手工输出分隔符文件，你可以使用csv.writer。它接受一个已打开且可写的文件对象以及跟csv.reader相同的那些语支和格式化选项：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;mydata.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    writer = csv.writer(f, dialect=my_dialect)</span><br><span class="line">    writer.writerow((<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>))</span><br><span class="line">    writer.writerow((<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>))</span><br><span class="line">    writer.writerow((<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>))</span><br><span class="line">    writer.writerow((<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="json数据">6.1.4 JSON数据</h3>
<p>JSON（JavaScript Object Notation的简称）已经成为通过HTTP请求在Web浏览器和其他应用程序之间发送数据的标准格式之一。它是一种比表格型文本格式（如CSV）灵活得多的数据格式。下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;&quot;name&quot;: &quot;Wes&quot;,</span></span><br><span class="line"><span class="string"> &quot;places_lived&quot;: [&quot;United States&quot;, &quot;Spain&quot;, &quot;Germany&quot;],</span></span><br><span class="line"><span class="string"> &quot;pet&quot;: null,</span></span><br><span class="line"><span class="string"> &quot;siblings&quot;: [&#123;&quot;name&quot;: &quot;Scott&quot;, &quot;age&quot;: 30, &quot;pets&quot;: [&quot;Zeus&quot;, &quot;Zuko&quot;]&#125;,</span></span><br><span class="line"><span class="string">              &#123;&quot;name&quot;: &quot;Katie&quot;, &quot;age&quot;: 38,</span></span><br><span class="line"><span class="string">               &quot;pets&quot;: [&quot;Sixes&quot;, &quot;Stache&quot;, &quot;Cisco&quot;]&#125;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>除其空值null和一些其他的细微差别（如列表末尾不允许存在多余的逗号）之外，JSON非常接近于有效的Python代码。基本类型有对象（字典）、数组（列表）、字符串、数值、布尔值以及null。对象中所有的键都必须是字符串。许多Python库都可以读写JSON数据。我将使用json，因为它是构建于Python标准库中的。通过json.loads即可将JSON字符串转换成Python形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">62</span>]: <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: result = json.loads(obj)</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: result</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Wes&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;pet&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;places_lived&#x27;</span>: [<span class="string">&#x27;United States&#x27;</span>, <span class="string">&#x27;Spain&#x27;</span>, <span class="string">&#x27;Germany&#x27;</span>],</span><br><span class="line"> <span class="string">&#x27;siblings&#x27;</span>: [&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Scott&#x27;</span>, <span class="string">&#x27;pets&#x27;</span>: [<span class="string">&#x27;Zeus&#x27;</span>, <span class="string">&#x27;Zuko&#x27;</span>]&#125;,</span><br><span class="line">  &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">38</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Katie&#x27;</span>, <span class="string">&#x27;pets&#x27;</span>: [<span class="string">&#x27;Sixes&#x27;</span>, <span class="string">&#x27;Stache&#x27;</span>, <span class="string">&#x27;Cisco&#x27;</span>]&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p>json.dumps则将Python对象转换成JSON格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: asjson = json.dumps(result)</span><br></pre></td></tr></table></figure>
<p>如何将（一个或一组）JSON对象转换为DataFrame或其他便于分析的数据结构就由你决定了。最简单方便的方式是：向DataFrame构造器传入一个字典的列表（就是原先的JSON对象），并选取数据字段的子集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: siblings = pd.DataFrame(result[<span class="string">&#x27;siblings&#x27;</span>], columns=[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: siblings</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">    name  age</span><br><span class="line"><span class="number">0</span>  Scott   <span class="number">30</span></span><br><span class="line"><span class="number">1</span>  Katie   <span class="number">38</span></span><br></pre></td></tr></table></figure>
<p>pandas.read_json可以自动将特别格式的JSON数据集转换为Series或DataFrame。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: !cat examples/example.json</span><br><span class="line">[&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;a&quot;</span>: <span class="number">4</span>, <span class="string">&quot;b&quot;</span>: <span class="number">5</span>, <span class="string">&quot;c&quot;</span>: <span class="number">6</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;a&quot;</span>: <span class="number">7</span>, <span class="string">&quot;b&quot;</span>: <span class="number">8</span>, <span class="string">&quot;c&quot;</span>: <span class="number">9</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>pandas.read_json的默认选项假设JSON数组中的每个对象是表格中的一行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: data = pd.read_json(<span class="string">&#x27;examples/example.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: data</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">   a  b  c</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>第7章中关于USDA Food Database的那个例子进一步讲解了JSON数据的读取和处理（包括嵌套记录）。</p>
<p>如果你需要将数据从pandas输出到JSON，可以使用to_json方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: <span class="built_in">print</span>(data.to_json())</span><br><span class="line">&#123;<span class="string">&quot;a&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>:<span class="number">1</span>,<span class="string">&quot;1&quot;</span>:<span class="number">4</span>,<span class="string">&quot;2&quot;</span>:<span class="number">7</span>&#125;,<span class="string">&quot;b&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>:<span class="number">2</span>,<span class="string">&quot;1&quot;</span>:<span class="number">5</span>,<span class="string">&quot;2&quot;</span>:<span class="number">8</span>&#125;,<span class="string">&quot;c&quot;</span>:&#123;<span class="string">&quot;0&quot;</span>:<span class="number">3</span>,<span class="string">&quot;1&quot;</span>:<span class="number">6</span>,<span class="string">&quot;2&quot;</span>:<span class="number">9</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: <span class="built_in">print</span>(data.to_json(orient=<span class="string">&#x27;records&#x27;</span>))</span><br><span class="line">[&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>,<span class="string">&quot;b&quot;</span>:<span class="number">2</span>,<span class="string">&quot;c&quot;</span>:<span class="number">3</span>&#125;,&#123;<span class="string">&quot;a&quot;</span>:<span class="number">4</span>,<span class="string">&quot;b&quot;</span>:<span class="number">5</span>,<span class="string">&quot;c&quot;</span>:<span class="number">6</span>&#125;,&#123;<span class="string">&quot;a&quot;</span>:<span class="number">7</span>,<span class="string">&quot;b&quot;</span>:<span class="number">8</span>,<span class="string">&quot;c&quot;</span>:<span class="number">9</span>&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="xml和htmlweb信息收集">6.1.5 XML和HTML：Web信息收集</h3>
<p>Python有许多可以读写常见的HTML和XML格式数据的库，包括lxml、Beautiful Soup和html5lib。lxml的速度比较快，但其它的库处理有误的HTML或XML文件更好。</p>
<p>pandas有一个内置的功能，read_html，它可以使用lxml和Beautiful Soup自动将HTML文件中的表格解析为DataFrame对象。为了进行展示，我从美国联邦存款保险公司下载了一个HTML文件（pandas文档中也使用过），它记录了银行倒闭的情况。首先，你需要安装read_html用到的库： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install lxml</span><br><span class="line">pip install beautifulsoup4 html5lib</span><br></pre></td></tr></table></figure></p>
<p>如果你用的不是conda，可以使用<code>pip install lxml</code>。</p>
pandas.read_html有一些选项，默认条件下，它会搜索、尝试解析
<table>
<p>标签内的的表格数据。结果是一个列表的DataFrame对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: tables = pd.read_html(<span class="string">&#x27;examples/fdic_failed_bank_list.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: <span class="built_in">len</span>(tables)</span><br><span class="line">Out[<span class="number">74</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: failures = tables[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: failures.head()</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">                      Bank Name             City  ST   CERT  \</span><br><span class="line"><span class="number">0</span>                   Allied Bank         Mulberry  AR     <span class="number">91</span>   </span><br><span class="line"><span class="number">1</span>  The Woodbury Banking Company         Woodbury  GA  <span class="number">11297</span>   </span><br><span class="line"><span class="number">2</span>        First CornerStone Bank  King of Prussia  PA  <span class="number">35312</span>   </span><br><span class="line"><span class="number">3</span>            Trust Company Bank          Memphis  TN   <span class="number">9956</span>   </span><br><span class="line"><span class="number">4</span>    North Milwaukee State Bank        Milwaukee  WI  <span class="number">20364</span>   </span><br><span class="line">                 Acquiring Institution        Closing Date       Updated Date  </span><br><span class="line"><span class="number">0</span>                         Today<span class="string">&#x27;s Bank  September 23, 2016  November 17, 2016  </span></span><br><span class="line"><span class="string">1                          United Bank     August 19, 2016  November 17, 2016  </span></span><br><span class="line"><span class="string">2  First-Citizens Bank &amp; Trust Company         May 6, 2016  September 6, 2016  </span></span><br><span class="line"><span class="string">3           The Bank of Fayette County      April 29, 2016  September 6, 2016  </span></span><br><span class="line"><span class="string">4  First-Citizens Bank &amp; Trust Company      March 11, 2016      June 16, 2016</span></span><br></pre></td></tr></table></figure>
<p>因为failures有许多列，pandas插入了一个换行符。</p>
<p>这里，我们可以做一些数据清洗和分析（后面章节会进一步讲解），比如计算按年份计算倒闭的银行数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: close_timestamps = pd.to_datetime(failures[<span class="string">&#x27;Closing Date&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: close_timestamps.dt.year.value_counts()</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line"><span class="number">2010</span>    <span class="number">157</span></span><br><span class="line"><span class="number">2009</span>    <span class="number">140</span></span><br><span class="line"><span class="number">2011</span>     <span class="number">92</span></span><br><span class="line"><span class="number">2012</span>     <span class="number">51</span></span><br><span class="line"><span class="number">2008</span>     <span class="number">25</span></span><br><span class="line">       ... </span><br><span class="line"><span class="number">2004</span>      <span class="number">4</span></span><br><span class="line"><span class="number">2001</span>      <span class="number">4</span></span><br><span class="line"><span class="number">2007</span>      <span class="number">3</span></span><br><span class="line"><span class="number">2003</span>      <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>      <span class="number">2</span></span><br><span class="line">Name: Closing Date, Length: <span class="number">15</span>, dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="利用lxml.objectify解析xml">6.1.6 利用lxml.objectify解析XML</h3>
<p>XML（Extensible Markup Language）是另一种常见的支持分层、嵌套数据以及元数据的结构化数据格式。本书所使用的这些文件实际上来自于一个很大的XML文档。</p>
<p>前面，我介绍了pandas.read_html函数，它可以使用lxml或Beautiful Soup从HTML解析数据。XML和HTML的结构很相似，但XML更为通用。这里，我会用一个例子演示如何利用lxml从XML格式解析数据。</p>
<p>纽约大都会运输署发布了一些有关其公交和列车服务的数据资料（http://www.mta.info/developers/download.html）。这里，我们将看看包含在一组XML文件中的运行情况数据。每项列车或公交服务都有各自的文件（如Metro-North Railroad的文件是Performance_MNR.xml），其中每条XML记录就是一条月度数据，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">INDICATOR</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">INDICATOR_SEQ</span>&gt;</span>373889<span class="tag">&lt;/<span class="name">INDICATOR_SEQ</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PARENT_SEQ</span>&gt;</span><span class="tag">&lt;/<span class="name">PARENT_SEQ</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">AGENCY_NAME</span>&gt;</span>Metro-North Railroad<span class="tag">&lt;/<span class="name">AGENCY_NAME</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">INDICATOR_NAME</span>&gt;</span>Escalator Availability<span class="tag">&lt;/<span class="name">INDICATOR_NAME</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DESCRIPTION</span>&gt;</span>Percent of the time that escalators are operational</span><br><span class="line">  systemwide. The availability rate is based on physical observations performed</span><br><span class="line">  the morning of regular business days only. This is a new indicator the agency</span><br><span class="line">  began reporting in 2009.<span class="tag">&lt;/<span class="name">DESCRIPTION</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PERIOD_YEAR</span>&gt;</span>2011<span class="tag">&lt;/<span class="name">PERIOD_YEAR</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PERIOD_MONTH</span>&gt;</span>12<span class="tag">&lt;/<span class="name">PERIOD_MONTH</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CATEGORY</span>&gt;</span>Service Indicators<span class="tag">&lt;/<span class="name">CATEGORY</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FREQUENCY</span>&gt;</span>M<span class="tag">&lt;/<span class="name">FREQUENCY</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DESIRED_CHANGE</span>&gt;</span>U<span class="tag">&lt;/<span class="name">DESIRED_CHANGE</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">INDICATOR_UNIT</span>&gt;</span>%<span class="tag">&lt;/<span class="name">INDICATOR_UNIT</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">DECIMAL_PLACES</span>&gt;</span>1<span class="tag">&lt;/<span class="name">DECIMAL_PLACES</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">YTD_TARGET</span>&gt;</span>97.00<span class="tag">&lt;/<span class="name">YTD_TARGET</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">YTD_ACTUAL</span>&gt;</span><span class="tag">&lt;/<span class="name">YTD_ACTUAL</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MONTHLY_TARGET</span>&gt;</span>97.00<span class="tag">&lt;/<span class="name">MONTHLY_TARGET</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MONTHLY_ACTUAL</span>&gt;</span><span class="tag">&lt;/<span class="name">MONTHLY_ACTUAL</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">INDICATOR</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们先用lxml.objectify解析该文件，然后通过getroot得到该XML文件的根节点的引用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> objectify</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;datasets/mta_perf/Performance_MNR.xml&#x27;</span></span><br><span class="line">parsed = objectify.parse(<span class="built_in">open</span>(path))</span><br><span class="line">root = parsed.getroot()</span><br></pre></td></tr></table></figure>
<p>root.INDICATOR返回一个用于产生各个<INDICATOR>XML元素的生成器。对于每条记录，我们可以用标记名（如YTD_ACTUAL）和数据值填充一个字典（排除几个标记）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = []</span><br><span class="line"></span><br><span class="line">skip_fields = [<span class="string">&#x27;PARENT_SEQ&#x27;</span>, <span class="string">&#x27;INDICATOR_SEQ&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;DESIRED_CHANGE&#x27;</span>, <span class="string">&#x27;DECIMAL_PLACES&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> elt <span class="keyword">in</span> root.INDICATOR:</span><br><span class="line">    el_data = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> elt.getchildren():</span><br><span class="line">        <span class="keyword">if</span> child.tag <span class="keyword">in</span> skip_fields:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        el_data[child.tag] = child.pyval</span><br><span class="line">    data.append(el_data)</span><br></pre></td></tr></table></figure>
<p>最后，将这组字典转换为一个DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: perf = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: perf.head()</span><br><span class="line">Out[<span class="number">82</span>]:</span><br><span class="line">Empty DataFrame</span><br><span class="line">Columns: []</span><br><span class="line">Index: []</span><br></pre></td></tr></table></figure>
<p>XML数据可以比本例复杂得多。每个标记都可以有元数据。看看下面这个HTML的链接标签（它也算是一段有效的XML）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line">tag = <span class="string">&#x27;&lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;&#x27;</span></span><br><span class="line">root = objectify.parse(StringIO(tag)).getroot()</span><br></pre></td></tr></table></figure>
<p>现在就可以访问标签或链接文本中的任何字段了（如href）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">84</span>]: root</span><br><span class="line">Out[<span class="number">84</span>]: &lt;Element a at <span class="number">0x7f6b15817748</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: root.get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">Out[<span class="number">85</span>]: <span class="string">&#x27;http://www.google.com&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: root.text</span><br><span class="line">Out[<span class="number">86</span>]: <span class="string">&#x27;Google&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="二进制数据格式">6.2 二进制数据格式</h2>
<p>实现数据的高效二进制格式存储最简单的办法之一是使用Python内置的pickle序列化。pandas对象都有一个用于将数据以pickle格式保存到磁盘上的to_pickle方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: frame = pd.read_csv(<span class="string">&#x27;examples/ex1.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: frame</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: frame.to_pickle(<span class="string">&#x27;examples/frame_pickle&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>你可以通过pickle直接读取被pickle化的数据，或是使用更为方便的pandas.read_pickle：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">90</span>]: pd.read_pickle(<span class="string">&#x27;examples/frame_pickle&#x27;</span>)</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：pickle仅建议用于短期存储格式。其原因是很难保证该格式永远是稳定的；今天pickle的对象可能无法被后续版本的库unpickle出来。虽然我尽力保证这种事情不会发生在pandas中，但是今后的某个时候说不定还是得“打破”该pickle格式。</p>
</blockquote>
<p>pandas内置支持两个二进制数据格式：HDF5和MessagePack。下一节，我会给出几个HDF5的例子，但我建议你尝试下不同的文件格式，看看它们的速度以及是否适合你的分析工作。pandas或NumPy数据的其它存储格式有：</p>
<ul>
<li>bcolz：一种可压缩的列存储二进制格式，基于Blosc压缩库。</li>
<li>Feather：我与R语言社区的Hadley Wickham设计的一种跨语言的列存储文件格式。Feather使用了Apache Arrow的列式内存格式。</li>
</ul>
<h3 id="使用hdf5格式">6.2.1 使用HDF5格式</h3>
<p>HDF5是一种存储大规模科学数组数据的非常好的文件格式。它可以被作为C标准库，带有许多语言的接口，如Java、Python和MATLAB等。HDF5中的HDF指的是层次型数据格式（hierarchical data format）。每个HDF5文件都含有一个文件系统式的节点结构，它使你能够存储多个数据集并支持元数据。与其他简单格式相比，HDF5支持多种压缩器的即时压缩，还能更高效地存储重复模式数据。对于那些非常大的无法直接放入内存的数据集，HDF5就是不错的选择，因为它可以高效地分块读写。</p>
<p>虽然可以用PyTables或h5py库直接访问HDF5文件，pandas提供了更为高级的接口，可以简化存储Series和DataFrame对象。HDFStore类可以像字典一样，处理低级的细节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">92</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: np.random.randn(<span class="number">100</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: store = pd.HDFStore(<span class="string">&#x27;mydata.h5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: store[<span class="string">&#x27;obj1&#x27;</span>] = frame</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: store[<span class="string">&#x27;obj1_col&#x27;</span>] = frame[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: store</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.io.pytables.HDFStore&#x27;</span>&gt;</span><br><span class="line">File path: mydata.h5</span><br><span class="line">/obj1                frame        (shape-&gt;[<span class="number">100</span>,<span class="number">1</span>])                               </span><br><span class="line">        </span><br><span class="line">/obj1_col            series       (shape-&gt;[<span class="number">100</span>])                                 </span><br><span class="line">        </span><br><span class="line">/obj2                frame_table  (typ-&gt;appendable,nrows-&gt;<span class="number">100</span>,ncols-&gt;<span class="number">1</span>,indexers-&gt;</span><br><span class="line">[index])</span><br><span class="line">/obj3                frame_table  (typ-&gt;appendable,nrows-&gt;<span class="number">100</span>,ncols-&gt;<span class="number">1</span>,indexers-&gt;</span><br><span class="line">[index])</span><br></pre></td></tr></table></figure>
<p>HDF5文件中的对象可以通过与字典一样的API进行获取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">97</span>]: store[<span class="string">&#x27;obj1&#x27;</span>]</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line">           a</span><br><span class="line"><span class="number">0</span>  -<span class="number">0.204708</span></span><br><span class="line"><span class="number">1</span>   <span class="number">0.478943</span></span><br><span class="line"><span class="number">2</span>  -<span class="number">0.519439</span></span><br><span class="line"><span class="number">3</span>  -<span class="number">0.555730</span></span><br><span class="line"><span class="number">4</span>   <span class="number">1.965781</span></span><br><span class="line">..       ...</span><br><span class="line"><span class="number">95</span>  <span class="number">0.795253</span></span><br><span class="line"><span class="number">96</span>  <span class="number">0.118110</span></span><br><span class="line"><span class="number">97</span> -<span class="number">0.748532</span></span><br><span class="line"><span class="number">98</span>  <span class="number">0.584970</span></span><br><span class="line"><span class="number">99</span>  <span class="number">0.152677</span></span><br><span class="line">[<span class="number">100</span> rows x <span class="number">1</span> columns]</span><br></pre></td></tr></table></figure>
<p>HDFStore支持两种存储模式，'fixed'和'table'。后者通常会更慢，但是支持使用特殊语法进行查询操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: store.put(<span class="string">&#x27;obj2&#x27;</span>, frame, <span class="built_in">format</span>=<span class="string">&#x27;table&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: store.select(<span class="string">&#x27;obj2&#x27;</span>, where=[<span class="string">&#x27;index &gt;= 10 and index &lt;= 15&#x27;</span>])</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">           a</span><br><span class="line"><span class="number">10</span>  <span class="number">1.007189</span></span><br><span class="line"><span class="number">11</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="number">12</span>  <span class="number">0.274992</span></span><br><span class="line"><span class="number">13</span>  <span class="number">0.228913</span></span><br><span class="line"><span class="number">14</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">15</span>  <span class="number">0.886429</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: store.close()</span><br></pre></td></tr></table></figure>
<p>put是store['obj2'] = frame方法的显示版本，允许我们设置其它的选项，比如格式。</p>
<p>pandas.read_hdf函数可以快捷使用这些工具：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: frame.to_hdf(<span class="string">&#x27;mydata.h5&#x27;</span>, <span class="string">&#x27;obj3&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;table&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: pd.read_hdf(<span class="string">&#x27;mydata.h5&#x27;</span>, <span class="string">&#x27;obj3&#x27;</span>, where=[<span class="string">&#x27;index &lt; 5&#x27;</span>])</span><br><span class="line">Out[<span class="number">102</span>]: </span><br><span class="line">          a</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：如果你要处理的数据位于远程服务器，比如Amazon S3或HDFS，使用专门为分布式存储（比如Apache Parquet）的二进制格式也许更加合适。Python的Parquet和其它存储格式还在不断的发展之中，所以这本书中没有涉及。</p>
</blockquote>
<p>如果需要本地处理海量数据，我建议你好好研究一下PyTables和h5py，看看它们能满足你的哪些需求。。由于许多数据分析问题都是IO密集型（而不是CPU密集型），利用HDF5这样的工具能显著提升应用程序的效率。</p>
<blockquote>
<p>注意：HDF5不是数据库。它最适合用作“一次写多次读”的数据集。虽然数据可以在任何时候被添加到文件中，但如果同时发生多个写操作，文件就可能会被破坏。</p>
</blockquote>
<h3 id="读取microsoft-excel文件">6.2.2 读取Microsoft Excel文件</h3>
<p>pandas的ExcelFile类或pandas.read_excel函数支持读取存储在Excel 2003（或更高版本）中的表格型数据。这两个工具分别使用扩展包xlrd和openpyxl读取XLS和XLSX文件。你可以用pip或conda安装它们。</p>
<p>要使用ExcelFile，通过传递xls或xlsx路径创建一个实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">104</span>]: xlsx = pd.ExcelFile(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>存储在表单中的数据可以read_excel读取到DataFrame（原书这里写的是用parse解析，但代码中用的是read_excel，是个笔误：只换了代码，没有改文字）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: pd.read_excel(xlsx, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">Out[<span class="number">105</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>如果要读取一个文件中的多个表单，创建ExcelFile会更快，但你也可以将文件名传递到pandas.read_excel：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: frame = pd.read_excel(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: frame</span><br><span class="line">Out[<span class="number">107</span>]: </span><br><span class="line">   a   b   c   d message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>     foo</span><br></pre></td></tr></table></figure>
<p>如果要将pandas数据写入为Excel格式，你必须首先创建一个ExcelWriter，然后使用pandas对象的to_excel方法将数据写入到其中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: writer = pd.ExcelWriter(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: frame.to_excel(writer, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: writer.save()</span><br></pre></td></tr></table></figure>
<p>你还可以不使用ExcelWriter，而是传递文件的路径到to_excel：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">111</span>]: frame.to_excel(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="web-apis交互">6.3 Web APIs交互</h2>
<p>许多网站都有一些通过JSON或其他格式提供数据的公共API。通过Python访问这些API的办法有不少。一个简单易用的办法（推荐）是requests包（http://docs.python-requests.org）。</p>
<p>为了搜索最新的30个GitHub上的pandas主题，我们可以发一个HTTP GET请求，使用requests扩展库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">113</span>]: <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: url = <span class="string">&#x27;https://api.github.com/repos/pandas-dev/pandas/issues&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: resp = requests.get(url)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: resp</span><br><span class="line">Out[<span class="number">116</span>]: &lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>
<p>响应对象的json方法会返回一个包含被解析过的JSON字典，加载到一个Python对象中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: data = resp.json()</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: data[<span class="number">0</span>][<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">Out[<span class="number">118</span>]: <span class="string">&#x27;Period does not round down for frequencies less that 1 hour&#x27;</span></span><br></pre></td></tr></table></figure>
<p>data中的每个元素都是一个包含所有GitHub主题页数据（不包含评论）的字典。我们可以直接传递数据到DataFrame，并提取感兴趣的字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">119</span>]: issues = pd.DataFrame(data, columns=[<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">   .....:                                      <span class="string">&#x27;labels&#x27;</span>, <span class="string">&#x27;state&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: issues</span><br><span class="line">Out[<span class="number">120</span>]:</span><br><span class="line">    number                                              title  \</span><br><span class="line"><span class="number">0</span>    <span class="number">17666</span>  Period does <span class="keyword">not</span> <span class="built_in">round</span> down <span class="keyword">for</span> frequencies les...   </span><br><span class="line"><span class="number">1</span>    <span class="number">17665</span>           DOC: improve docstring of function where   </span><br><span class="line"><span class="number">2</span>    <span class="number">17664</span>               COMPAT: skip <span class="number">32</span>-bit test on <span class="built_in">int</span> <span class="built_in">repr</span>   </span><br><span class="line"><span class="number">3</span>    <span class="number">17662</span>                          implement Delegator <span class="keyword">class</span></span><br><span class="line"><span class="number">4</span>    <span class="number">17654</span>  BUG: Fix series rename called <span class="keyword">with</span> <span class="built_in">str</span> alterin...   </span><br><span class="line">..     ...                                                ...   </span><br><span class="line"><span class="number">25</span>   <span class="number">17603</span>  BUG: Correctly localize naive datetime strings...   </span><br><span class="line"><span class="number">26</span>   <span class="number">17599</span>                     core.dtypes.generic --&gt; cython   </span><br><span class="line"><span class="number">27</span>   <span class="number">17596</span>   Merge cdate_range functionality into bdate_range   </span><br><span class="line"><span class="number">28</span>   <span class="number">17587</span>  Time Grouper bug fix when applied <span class="keyword">for</span> <span class="built_in">list</span> gro...   </span><br><span class="line"><span class="number">29</span>   <span class="number">17583</span>  BUG: fix tz-aware DatetimeIndex + TimedeltaInd...   </span><br><span class="line">                                               labels state  </span><br><span class="line"><span class="number">0</span>                                                  []  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">1</span>   [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">134699</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.com...  open  </span></span><br><span class="line"><span class="string">2   [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 563047854, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github....  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">3</span>                                                  []  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">4</span>   [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">76811</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.com/...  open  </span></span><br><span class="line"><span class="string">..                                                ...   ...  </span></span><br><span class="line"><span class="string">25  [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 76811, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github.com/...  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">26</span>  [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">49094459</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.c...  open  </span></span><br><span class="line"><span class="string">27  [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 35818298, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github.c...  <span class="built_in">open</span>  </span><br><span class="line"><span class="number">28</span>  [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">233160</span>, <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://api.github.com...  open  </span></span><br><span class="line"><span class="string">29  [&#123;&#x27;</span><span class="built_in">id</span><span class="string">&#x27;: 76811, &#x27;</span>url<span class="string">&#x27;: &#x27;</span>https://api.github.com/...  <span class="built_in">open</span>  </span><br><span class="line">[<span class="number">30</span> rows x <span class="number">4</span> columns]</span><br></pre></td></tr></table></figure>
<p>花费一些精力，你就可以创建一些更高级的常见的Web API的接口，返回DataFrame对象，方便进行分析。</p>
<h2 id="数据库交互">6.4 数据库交互</h2>
<p>在商业场景下，大多数数据可能不是存储在文本或Excel文件中。基于SQL的关系型数据库（如SQL Server、PostgreSQL和MySQL等）使用非常广泛，其它一些数据库也很流行。数据库的选择通常取决于性能、数据完整性以及应用程序的伸缩性需求。</p>
<p>将数据从SQL加载到DataFrame的过程很简单，此外pandas还有一些能够简化该过程的函数。例如，我将使用SQLite数据库（通过Python内置的sqlite3驱动器）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">121</span>]: <span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: query = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   .....: CREATE TABLE test</span></span><br><span class="line"><span class="string">   .....: (a VARCHAR(20), b VARCHAR(20),</span></span><br><span class="line"><span class="string">   .....:  c REAL,        d INTEGER</span></span><br><span class="line"><span class="string">   .....: );&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: con = sqlite3.connect(<span class="string">&#x27;mydata.sqlite&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: con.execute(query)</span><br><span class="line">Out[<span class="number">124</span>]: &lt;sqlite3.Cursor at <span class="number">0x7f6b12a50f10</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: con.commit()</span><br></pre></td></tr></table></figure>
<p>然后插入几行数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">126</span>]: data = [(<span class="string">&#x27;Atlanta&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="number">1.25</span>, <span class="number">6</span>),</span><br><span class="line">   .....:         (<span class="string">&#x27;Tallahassee&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>, <span class="number">2.6</span>, <span class="number">3</span>),</span><br><span class="line">   .....:         (<span class="string">&#x27;Sacramento&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="number">1.7</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: stmt = <span class="string">&quot;INSERT INTO test VALUES(?, ?, ?, ?)&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: con.executemany(stmt, data)</span><br><span class="line">Out[<span class="number">128</span>]: &lt;sqlite3.Cursor at <span class="number">0x7f6b15c66ce0</span>&gt;</span><br></pre></td></tr></table></figure>
<p>从表中选取数据时，大部分Python SQL驱动器（PyODBC、psycopg2、MySQLdb、pymssql等）都会返回一个元组列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">130</span>]: cursor = con.execute(<span class="string">&#x27;select * from test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: rows = cursor.fetchall()</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: rows</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">[(<span class="string">&#x27;Atlanta&#x27;</span>, <span class="string">&#x27;Georgia&#x27;</span>, <span class="number">1.25</span>, <span class="number">6</span>),</span><br><span class="line"> (<span class="string">&#x27;Tallahassee&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>, <span class="number">2.6</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="string">&#x27;Sacramento&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="number">1.7</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>
<p>你可以将这个元组列表传给DataFrame构造器，但还需要列名（位于光标的description属性中）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">133</span>]: cursor.description</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">((<span class="string">&#x27;a&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line"> (<span class="string">&#x27;b&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line"> (<span class="string">&#x27;c&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line"> (<span class="string">&#x27;d&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: pd.DataFrame(rows, columns=[x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> cursor.description])</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">             a           b     c  d</span><br><span class="line"><span class="number">0</span>      Atlanta     Georgia  <span class="number">1.25</span>  <span class="number">6</span></span><br><span class="line"><span class="number">1</span>  Tallahassee     Florida  <span class="number">2.60</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>   Sacramento  California  <span class="number">1.70</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这种数据规整操作相当多，你肯定不想每查一次数据库就重写一次。<a href="http://www.sqlalchemy.org/">SQLAlchemy项目</a>是一个流行的Python SQL工具，它抽象出了SQL数据库中的许多常见差异。pandas有一个read_sql函数，可以让你轻松的从SQLAlchemy连接读取数据。这里，我们用SQLAlchemy连接SQLite数据库，并从之前创建的表读取数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">135</span>]: <span class="keyword">import</span> sqlalchemy <span class="keyword">as</span> sqla</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: db = sqla.create_engine(<span class="string">&#x27;sqlite:///mydata.sqlite&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: pd.read_sql(<span class="string">&#x27;select * from test&#x27;</span>, db)</span><br><span class="line">Out[<span class="number">137</span>]: </span><br><span class="line">             a           b     c  d</span><br><span class="line"><span class="number">0</span>      Atlanta     Georgia  <span class="number">1.25</span>  <span class="number">6</span></span><br><span class="line"><span class="number">1</span>  Tallahassee     Florida  <span class="number">2.60</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>   Sacramento  California  <span class="number">1.70</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">6.5 总结</h2>
<p>访问数据通常是数据分析的第一步。在本章中，我们已经学了一些有用的工具。在接下来的章节中，我们将深入研究数据规整、数据可视化、时间序列分析和其它主题。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第07章_数据清洗和准备</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap07/</url>
    <content><![CDATA[<h1 id="第07章-数据清洗和准备">第07章 数据清洗和准备</h1>
<p>在数据分析和建模的过程中，相当多的时间要用在数据准备上：加载、清理、转换以及重塑。这些工作会占到分析师时间的80%或更多。有时，存储在文件和数据库中的数据的格式不适合某个特定的任务。许多研究者都选择使用通用编程语言（如Python、Perl、R或Java）或UNIX文本处理工具（如sed或awk）对数据格式进行专门处理。幸运的是，pandas和内置的Python标准库提供了一组高级的、灵活的、快速的工具，可以让你轻松地将数据规整为想要的格式。</p>
<span id="more"></span>
<p>如果你发现了一种本书或pandas库中没有的数据操作方式，请在邮件列表或GitHub网站上提出。实际上，pandas的许多设计和实现都是由真实应用的需求所驱动的。</p>
<p>在本章中，我会讨论处理缺失数据、重复数据、字符串操作和其它分析数据转换的工具。下一章，我会关注于用多种方法合并、重塑数据集。</p>
<h2 id="处理缺失数据">7.1 处理缺失数据</h2>
<p>在许多数据分析工作中，缺失数据是经常发生的。pandas的目标之一就是尽量轻松地处理缺失数据。例如，pandas对象的所有描述性统计默认都不包括缺失数据。</p>
<p>缺失数据在pandas中呈现的方式有些不完美，但对于大多数用户可以保证功能正常。对于数值数据，pandas使用浮点值NaN（Not a Number）表示缺失数据。我们称其为哨兵值，可以方便的检测出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: string_data = pd.Series([<span class="string">&#x27;aardvark&#x27;</span>, <span class="string">&#x27;artichoke&#x27;</span>, np.nan, <span class="string">&#x27;avocado&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: string_data</span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line"><span class="number">0</span>     aardvark</span><br><span class="line"><span class="number">1</span>    artichoke</span><br><span class="line"><span class="number">2</span>          NaN</span><br><span class="line"><span class="number">3</span>      avocado</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: string_data.isnull()</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>在pandas中，我们采用了R语言中的惯用法，即将缺失值表示为NA，它表示不可用not available。在统计应用中，NA数据可能是不存在的数据或者虽然存在，但是没有观察到（例如，数据采集中发生了问题）。当进行数据清洗以进行分析时，最好直接对缺失数据进行分析，以判断数据采集的问题或缺失数据可能导致的偏差。</p>
<p>Python内置的None值在对象数组中也可以作为NA：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: string_data[<span class="number">0</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: string_data.isnull()</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>pandas项目中还在不断优化内部细节以更好处理缺失数据，像用户API功能，例如pandas.isnull，去除了许多恼人的细节。表7-1列出了一些关于缺失数据处理的函数。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap07/7178691-1a0f73e5bb26ea21.png" class="" title="表7-1 NA处理方法">
<h3 id="滤除缺失数据">7.1.1 滤除缺失数据</h3>
<p>过滤掉缺失数据的办法有很多种。你可以通过pandas.isnull或布尔索引的手工方法，但dropna可能会更实用一些。对于一个Series，dropna返回一个仅含非空数据和索引值的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: <span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: data = pd.Series([<span class="number">1</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: data.dropna()</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">7.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>这等价于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: data[data.notnull()]</span><br><span class="line">Out[<span class="number">18</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">7.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>而对于DataFrame对象，事情就有点复杂了。你可能希望丢弃全NA或含有NA的行或列。dropna默认丢弃任何含有缺失值的行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">19</span>]: data = pd.DataFrame([[<span class="number">1.</span>, <span class="number">6.5</span>, <span class="number">3.</span>], [<span class="number">1.</span>, NA, NA],</span><br><span class="line">   ....:                      [NA, NA, NA], [NA, <span class="number">6.5</span>, <span class="number">3.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: cleaned = data.dropna()</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: data</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: cleaned</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>传入how='all'将只丢弃全为NA的那些行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: data.dropna(how=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>用这种方式丢弃列，只需传入axis=1即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: data[<span class="number">4</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: data</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span> NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span> NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: data.dropna(axis=<span class="number">1</span>, how=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">Out[<span class="number">26</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>另一个滤除DataFrame行的问题涉及时间序列数据。假设你只想留下一部分观测数据，可以用thresh参数实现此目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: df = pd.DataFrame(np.random.randn(<span class="number">7</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: df.iloc[:<span class="number">4</span>, <span class="number">1</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: df.iloc[:<span class="number">2</span>, <span class="number">2</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: df</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>       NaN       NaN</span><br><span class="line"><span class="number">1</span> -<span class="number">0.555730</span>       NaN       NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>       NaN  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>       NaN -<span class="number">1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: df.dropna()</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: df.dropna(thresh=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>       NaN  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>       NaN -<span class="number">1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br></pre></td></tr></table></figure>
<h3 id="填充缺失数据">7.1.2 填充缺失数据</h3>
<p>你可能不想滤除缺失数据（有可能会丢弃跟它有关的其他数据），而是希望通过其他方式填补那些“空洞”。对于大多数情况而言，fillna方法是最主要的函数。通过一个常数调用fillna就会将缺失值替换为那个常数值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: df.fillna(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.555730</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>  <span class="number">0.000000</span>  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>  <span class="number">0.000000</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br></pre></td></tr></table></figure>
<p>若是通过一个字典调用fillna，就可以实现对不同的列填充不同的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: df.fillna(&#123;<span class="number">1</span>: <span class="number">0.5</span>, <span class="number">2</span>: <span class="number">0</span>&#125;)</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">0.500000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.555730</span>  <span class="number">0.500000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>  <span class="number">0.500000</span>  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>  <span class="number">0.500000</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br></pre></td></tr></table></figure>
<p>fillna默认会返回新对象，但也可以对现有对象进行就地修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: _ = df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: df</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.555730</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>  <span class="number">0.000000</span>  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>  <span class="number">0.000000</span> -<span class="number">1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br></pre></td></tr></table></figure>
<p>对reindexing有效的那些插值方法也可用于fillna：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: df = pd.DataFrame(np.random.randn(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: df.iloc[<span class="number">2</span>:, <span class="number">1</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: df.iloc[<span class="number">4</span>:, <span class="number">2</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: df</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.577087</span>  <span class="number">0.124121</span>  <span class="number">0.302614</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.523772</span>       NaN  <span class="number">1.343810</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.713544</span>       NaN -<span class="number">2.370232</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.860761</span>       NaN       NaN</span><br><span class="line"><span class="number">5</span> -<span class="number">1.265934</span>       NaN       NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: df.fillna(method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.577087</span>  <span class="number">0.124121</span>  <span class="number">0.302614</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.523772</span>  <span class="number">0.124121</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.713544</span>  <span class="number">0.124121</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.860761</span>  <span class="number">0.124121</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">5</span> -<span class="number">1.265934</span>  <span class="number">0.124121</span> -<span class="number">2.370232</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: df.fillna(method=<span class="string">&#x27;ffill&#x27;</span>, limit=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.577087</span>  <span class="number">0.124121</span>  <span class="number">0.302614</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.523772</span>  <span class="number">0.124121</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.713544</span>  <span class="number">0.124121</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.860761</span>       NaN -<span class="number">2.370232</span></span><br><span class="line"><span class="number">5</span> -<span class="number">1.265934</span>       NaN -<span class="number">2.370232</span></span><br></pre></td></tr></table></figure>
<p>只要有些创新，你就可以利用fillna实现许多别的功能。比如说，你可以传入Series的平均值或中位数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: data = pd.Series([<span class="number">1.</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: data.fillna(data.mean())</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.000000</span></span><br><span class="line"><span class="number">1</span>    <span class="number">3.833333</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3.500000</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3.833333</span></span><br><span class="line"><span class="number">4</span>    <span class="number">7.000000</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>表7-2列出了fillna的参考。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap07/7178691-0bf235386a64c3b5.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap07/7178691-4edd39e68f4dc530.png" class="" title="fillna函数参数">
<h2 id="数据转换">7.2 数据转换</h2>
<p>本章到目前为止介绍的都是数据的重排。另一类重要操作则是过滤、清理以及其他的转换工作。</p>
<h3 id="移除重复数据">7.2.1 移除重复数据</h3>
<p>DataFrame中出现重复行有多种原因。下面就是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: data = pd.DataFrame(&#123;<span class="string">&#x27;k1&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>] * <span class="number">3</span> + [<span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">   ....:                      <span class="string">&#x27;k2&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: data</span><br><span class="line">Out[<span class="number">46</span>]: </span><br><span class="line">    k1  k2</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  one   <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  two   <span class="number">4</span></span><br><span class="line"><span class="number">6</span>  two   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>DataFrame的duplicated方法返回一个布尔型Series，表示各行是否是重复行（前面出现过的行）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: data.duplicated()</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">5</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">6</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>还有一个与此相关的drop_duplicates方法，它会返回一个DataFrame，重复的数组会标为False：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">48</span>]: data.drop_duplicates()</span><br><span class="line">Out[<span class="number">48</span>]: </span><br><span class="line">    k1  k2</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  one   <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  two   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这两个方法默认会判断全部列，你也可以指定部分列进行重复项判断。假设我们还有一列值，且只希望根据k1列过滤重复项：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: data[<span class="string">&#x27;v1&#x27;</span>] = <span class="built_in">range</span>(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: data.drop_duplicates([<span class="string">&#x27;k1&#x27;</span>])</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">    k1  k2  v1</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span>   <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>duplicated和drop_duplicates默认保留的是第一个出现的值组合。传入keep='last'则保留最后一个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: data.drop_duplicates([<span class="string">&#x27;k1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>], keep=<span class="string">&#x27;last&#x27;</span>)</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">    k1  k2  v1</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span>   <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one   <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two   <span class="number">3</span>   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  one   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line"><span class="number">6</span>  two   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="利用函数或映射进行数据转换">7.2.2 利用函数或映射进行数据转换</h3>
<p>对于许多数据集，你可能希望根据数组、Series或DataFrame列中的值来实现转换工作。我们来看看下面这组有关肉类的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">52</span>]: data = pd.DataFrame(&#123;<span class="string">&#x27;food&#x27;</span>: [<span class="string">&#x27;bacon&#x27;</span>, <span class="string">&#x27;pulled pork&#x27;</span>, <span class="string">&#x27;bacon&#x27;</span>,</span><br><span class="line">   ....:                               <span class="string">&#x27;Pastrami&#x27;</span>, <span class="string">&#x27;corned beef&#x27;</span>, <span class="string">&#x27;Bacon&#x27;</span>,</span><br><span class="line">   ....:                               <span class="string">&#x27;pastrami&#x27;</span>, <span class="string">&#x27;honey ham&#x27;</span>, <span class="string">&#x27;nova lox&#x27;</span>],</span><br><span class="line">   ....:                      <span class="string">&#x27;ounces&#x27;</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: data</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">          food  ounces</span><br><span class="line"><span class="number">0</span>        bacon     <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>  pulled pork     <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>        bacon    <span class="number">12.0</span></span><br><span class="line"><span class="number">3</span>     Pastrami     <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  corned beef     <span class="number">7.5</span></span><br><span class="line"><span class="number">5</span>        Bacon     <span class="number">8.0</span></span><br><span class="line"><span class="number">6</span>     pastrami     <span class="number">3.0</span></span><br><span class="line"><span class="number">7</span>    honey ham     <span class="number">5.0</span></span><br><span class="line"><span class="number">8</span>     nova lox     <span class="number">6.0</span></span><br></pre></td></tr></table></figure>
<p>假设你想要添加一列表示该肉类食物来源的动物类型。我们先编写一个不同肉类到动物的映射：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">meat_to_animal = &#123;</span><br><span class="line">  <span class="string">&#x27;bacon&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pulled pork&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pastrami&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;corned beef&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;honey ham&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;nova lox&#x27;</span>: <span class="string">&#x27;salmon&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Series的map方法可以接受一个函数或含有映射关系的字典型对象，但是这里有一个小问题，即有些肉类的首字母大写了，而另一些则没有。因此，我们还需要使用Series的str.lower方法，将各个值转换为小写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: lowercased = data[<span class="string">&#x27;food&#x27;</span>].<span class="built_in">str</span>.lower()</span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: lowercased</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line"><span class="number">0</span>          bacon</span><br><span class="line"><span class="number">1</span>    pulled pork</span><br><span class="line"><span class="number">2</span>          bacon</span><br><span class="line"><span class="number">3</span>       pastrami</span><br><span class="line"><span class="number">4</span>    corned beef</span><br><span class="line"><span class="number">5</span>          bacon</span><br><span class="line"><span class="number">6</span>       pastrami</span><br><span class="line"><span class="number">7</span>      honey ham</span><br><span class="line"><span class="number">8</span>       nova lox</span><br><span class="line">Name: food, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: data[<span class="string">&#x27;animal&#x27;</span>] = lowercased.<span class="built_in">map</span>(meat_to_animal)</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: data</span><br><span class="line">Out[<span class="number">58</span>]: </span><br><span class="line">          food  ounces  animal</span><br><span class="line"><span class="number">0</span>        bacon     <span class="number">4.0</span>     pig</span><br><span class="line"><span class="number">1</span>  pulled pork     <span class="number">3.0</span>     pig</span><br><span class="line"><span class="number">2</span>        bacon    <span class="number">12.0</span>     pig</span><br><span class="line"><span class="number">3</span>     Pastrami     <span class="number">6.0</span>     cow</span><br><span class="line"><span class="number">4</span>  corned beef     <span class="number">7.5</span>     cow</span><br><span class="line"><span class="number">5</span>        Bacon     <span class="number">8.0</span>     pig</span><br><span class="line"><span class="number">6</span>     pastrami     <span class="number">3.0</span>     cow</span><br><span class="line"><span class="number">7</span>    honey ham     <span class="number">5.0</span>     pig</span><br><span class="line"><span class="number">8</span>     nova lox     <span class="number">6.0</span>  salmon</span><br></pre></td></tr></table></figure>
<p>我们也可以传入一个能够完成全部这些工作的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">59</span>]: data[<span class="string">&#x27;food&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: meat_to_animal[x.lower()])</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line"><span class="number">0</span>       pig</span><br><span class="line"><span class="number">1</span>       pig</span><br><span class="line"><span class="number">2</span>       pig</span><br><span class="line"><span class="number">3</span>       cow</span><br><span class="line"><span class="number">4</span>       cow</span><br><span class="line"><span class="number">5</span>       pig</span><br><span class="line"><span class="number">6</span>       cow</span><br><span class="line"><span class="number">7</span>       pig</span><br><span class="line"><span class="number">8</span>    salmon</span><br><span class="line">Name: food, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>使用map是一种实现元素级转换以及其他数据清理工作的便捷方式。</p>
<h3 id="替换值">7.2.3 替换值</h3>
<p>利用fillna方法填充缺失数据可以看做值替换的一种特殊情况。前面已经看到，map可用于修改对象的数据子集，而replace则提供了一种实现该功能的更简单、更灵活的方式。我们来看看下面这个Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: data = pd.Series([<span class="number">1.</span>, -<span class="number">999.</span>, <span class="number">2.</span>, -<span class="number">999.</span>, -<span class="number">1000.</span>, <span class="number">3.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: data</span><br><span class="line">Out[<span class="number">61</span>]: </span><br><span class="line"><span class="number">0</span>       <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">999.0</span></span><br><span class="line"><span class="number">2</span>       <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">999.0</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">1000.0</span></span><br><span class="line"><span class="number">5</span>       <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>-999这个值可能是一个表示缺失数据的标记值。要将其替换为pandas能够理解的NA值，我们可以利用replace来产生一个新的Series（除非传入inplace=True）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">62</span>]: data.replace(-<span class="number">999</span>, np.nan)</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line"><span class="number">0</span>       <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>       NaN</span><br><span class="line"><span class="number">2</span>       <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>       NaN</span><br><span class="line"><span class="number">4</span>   -<span class="number">1000.0</span></span><br><span class="line"><span class="number">5</span>       <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>如果你希望一次性替换多个值，可以传入一个由待替换值组成的列表以及一个替换值：：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: data.replace([-<span class="number">999</span>, -<span class="number">1000</span>], np.nan)</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line"><span class="number">4</span>    NaN</span><br><span class="line"><span class="number">5</span>    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>要让每个值有不同的替换值，可以传递一个替换列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: data.replace([-<span class="number">999</span>, -<span class="number">1000</span>], [np.nan, <span class="number">0</span>])</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line"><span class="number">4</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>传入的参数也可以是字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: data.replace(&#123;-<span class="number">999</span>: np.nan, -<span class="number">1000</span>: <span class="number">0</span>&#125;)</span><br><span class="line">Out[<span class="number">65</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line"><span class="number">4</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：data.replace方法与data.str.replace不同，后者做的是字符串的元素级替换。我们会在后面学习Series的字符串方法。</p>
</blockquote>
<h3 id="重命名轴索引">7.2.4 重命名轴索引</h3>
<p>跟Series中的值一样，轴标签也可以通过函数或映射进行转换，从而得到一个新的不同标签的对象。轴还可以被就地修改，而无需新建一个数据结构。接下来看看下面这个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: data = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">   ....:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">   ....:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>跟Series一样，轴索引也有一个map方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: transform = <span class="keyword">lambda</span> x: x[:<span class="number">4</span>].upper()</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: data.index.<span class="built_in">map</span>(transform)</span><br><span class="line">Out[<span class="number">68</span>]: Index([<span class="string">&#x27;OHIO&#x27;</span>, <span class="string">&#x27;COLO&#x27;</span>, <span class="string">&#x27;NEW &#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>你可以将其赋值给index，这样就可以对DataFrame进行就地修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: data.index = data.index.<span class="built_in">map</span>(transform)</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: data</span><br><span class="line">Out[<span class="number">70</span>]:</span><br><span class="line">one  two  three  four</span><br><span class="line">OHIO    <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">COLO    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">NEW     <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>如果想要创建数据集的转换版（而不是修改原始数据），比较实用的方法是rename：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: data.rename(index=<span class="built_in">str</span>.title, columns=<span class="built_in">str</span>.upper)</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">      ONE  TWO  THREE  FOUR</span><br><span class="line">Ohio    <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colo    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">New     <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>特别说明一下，rename可以结合字典型对象实现对部分轴标签的更新：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: data.rename(index=&#123;<span class="string">&#x27;OHIO&#x27;</span>: <span class="string">&#x27;INDIANA&#x27;</span>&#125;,</span><br><span class="line">   ....:             columns=&#123;<span class="string">&#x27;three&#x27;</span>: <span class="string">&#x27;peekaboo&#x27;</span>&#125;)</span><br><span class="line">Out[<span class="number">72</span>]:</span><br><span class="line">one  two  peekaboo  four</span><br><span class="line">INDIANA    <span class="number">0</span>    <span class="number">1</span>         <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">COLO       <span class="number">4</span>    <span class="number">5</span>         <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">NEW        <span class="number">8</span>    <span class="number">9</span>        <span class="number">10</span>    <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>rename可以实现复制DataFrame并对其索引和列标签进行赋值。如果希望就地修改某个数据集，传入inplace=True即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: data.rename(index=&#123;<span class="string">&#x27;OHIO&#x27;</span>: <span class="string">&#x27;INDIANA&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: data</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">         one  two  three  four</span><br><span class="line">INDIANA    <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">COLO       <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">NEW        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br></pre></td></tr></table></figure>
<h3 id="离散化和面元划分">7.2.5 离散化和面元划分</h3>
<p>为了便于分析，连续数据常常被离散化或拆分为“面元”（bin）。假设有一组人员数据，而你希望将它们划分为不同的年龄组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: ages = [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">31</span>, <span class="number">61</span>, <span class="number">45</span>, <span class="number">41</span>, <span class="number">32</span>]</span><br></pre></td></tr></table></figure>
<p>接下来将这些数据划分为“18到25”、“26到35”、“35到60”以及“60以上”几个面元。要实现该功能，你需要使用pandas的cut函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: bins = [<span class="number">18</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">60</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: cats = pd.cut(ages, bins)</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: cats</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">[(<span class="number">18</span>, <span class="number">25</span>], (<span class="number">18</span>, <span class="number">25</span>], (<span class="number">18</span>, <span class="number">25</span>], (<span class="number">25</span>, <span class="number">35</span>], (<span class="number">18</span>, <span class="number">25</span>], ..., (<span class="number">25</span>, <span class="number">35</span>], (<span class="number">60</span>, <span class="number">100</span>], (<span class="number">35</span>,<span class="number">60</span>], (<span class="number">35</span>, <span class="number">60</span>], (<span class="number">25</span>, <span class="number">35</span>]]</span><br><span class="line">Length: <span class="number">12</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[int64]): [(<span class="number">18</span>, <span class="number">25</span>] &lt; (<span class="number">25</span>, <span class="number">35</span>] &lt; (<span class="number">35</span>, <span class="number">60</span>] &lt; (<span class="number">60</span>, <span class="number">100</span>]]</span><br></pre></td></tr></table></figure>
<p>pandas返回的是一个特殊的Categorical对象。结果展示了pandas.cut划分的面元。你可以将其看做一组表示面元名称的字符串。它的底层含有一个表示不同分类名称的类型数组，以及一个codes属性中的年龄数据的标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: cats.codes</span><br><span class="line">Out[<span class="number">79</span>]: array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], dtype=int8)</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: cats.categories</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">IntervalIndex([(<span class="number">18</span>, <span class="number">25</span>], (<span class="number">25</span>, <span class="number">35</span>], (<span class="number">35</span>, <span class="number">60</span>], (<span class="number">60</span>, <span class="number">100</span>]]</span><br><span class="line">              closed=<span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">              dtype=<span class="string">&#x27;interval[int64]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: pd.value_counts(cats)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">(<span class="number">18</span>, <span class="number">25</span>]     <span class="number">5</span></span><br><span class="line">(<span class="number">35</span>, <span class="number">60</span>]     <span class="number">3</span></span><br><span class="line">(<span class="number">25</span>, <span class="number">35</span>]     <span class="number">3</span></span><br><span class="line">(<span class="number">60</span>, <span class="number">100</span>]    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>pd.value_counts(cats)是pandas.cut结果的面元计数。</p>
<p>跟“区间”的数学符号一样，圆括号表示开端，而方括号则表示闭端（包括）。哪边是闭端可以通过right=False进行修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: pd.cut(ages, [<span class="number">18</span>, <span class="number">26</span>, <span class="number">36</span>, <span class="number">61</span>, <span class="number">100</span>], right=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">82</span>]: </span><br><span class="line">[[<span class="number">18</span>, <span class="number">26</span>), [<span class="number">18</span>, <span class="number">26</span>), [<span class="number">18</span>, <span class="number">26</span>), [<span class="number">26</span>, <span class="number">36</span>), [<span class="number">18</span>, <span class="number">26</span>), ..., [<span class="number">26</span>, <span class="number">36</span>), [<span class="number">61</span>, <span class="number">100</span>), [<span class="number">36</span>,</span><br><span class="line"> <span class="number">61</span>), [<span class="number">36</span>, <span class="number">61</span>), [<span class="number">26</span>, <span class="number">36</span>)]</span><br><span class="line">Length: <span class="number">12</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[int64]): [[<span class="number">18</span>, <span class="number">26</span>) &lt; [<span class="number">26</span>, <span class="number">36</span>) &lt; [<span class="number">36</span>, <span class="number">61</span>) &lt; [<span class="number">61</span>, <span class="number">100</span>)]</span><br></pre></td></tr></table></figure>
<p>你可 以通过传递一个列表或数组到labels，设置自己的面元名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: group_names = [<span class="string">&#x27;Youth&#x27;</span>, <span class="string">&#x27;YoungAdult&#x27;</span>, <span class="string">&#x27;MiddleAged&#x27;</span>, <span class="string">&#x27;Senior&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: pd.cut(ages, bins, labels=group_names)</span><br><span class="line">Out[<span class="number">84</span>]: </span><br><span class="line">[Youth, Youth, Youth, YoungAdult, Youth, ..., YoungAdult, Senior, MiddleAged, Mid</span><br><span class="line">dleAged, YoungAdult]</span><br><span class="line">Length: <span class="number">12</span></span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [Youth &lt; YoungAdult &lt; MiddleAged &lt; Senior]</span><br></pre></td></tr></table></figure>
<p>如果向cut传入的是面元的数量而不是确切的面元边界，则它会根据数据的最小值和最大值计算等长面元。下面这个例子中，我们将一些均匀分布的数据分成四组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: data = np.random.rand(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: pd.cut(data, <span class="number">4</span>, precision=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">[(<span class="number">0.34</span>, <span class="number">0.55</span>], (<span class="number">0.34</span>, <span class="number">0.55</span>], (<span class="number">0.76</span>, <span class="number">0.97</span>], (<span class="number">0.76</span>, <span class="number">0.97</span>], (<span class="number">0.34</span>, <span class="number">0.55</span>], ..., (<span class="number">0.34</span></span><br><span class="line">, <span class="number">0.55</span>], (<span class="number">0.34</span>, <span class="number">0.55</span>], (<span class="number">0.55</span>, <span class="number">0.76</span>], (<span class="number">0.34</span>, <span class="number">0.55</span>], (<span class="number">0.12</span>, <span class="number">0.34</span>]]</span><br><span class="line">Length: <span class="number">20</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(<span class="number">0.12</span>, <span class="number">0.34</span>] &lt; (<span class="number">0.34</span>, <span class="number">0.55</span>] &lt; (<span class="number">0.55</span>, <span class="number">0.76</span>] &lt; </span><br><span class="line">(<span class="number">0.76</span>, <span class="number">0.97</span>]]</span><br></pre></td></tr></table></figure>
<p>选项precision=2，限定小数只有两位。</p>
<p>qcut是一个非常类似于cut的函数，它可以根据样本分位数对数据进行面元划分。根据数据的分布情况，cut可能无法使各个面元中含有相同数量的数据点。而qcut由于使用的是样本分位数，因此可以得到大小基本相等的面元：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: data = np.random.randn(<span class="number">1000</span>)  <span class="comment"># Normally distributed</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: cats = pd.qcut(data, <span class="number">4</span>)  <span class="comment"># Cut into quartiles</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: cats</span><br><span class="line">Out[<span class="number">89</span>]: </span><br><span class="line">[(-<span class="number">0.0265</span>, <span class="number">0.62</span>], (<span class="number">0.62</span>, <span class="number">3.928</span>], (-<span class="number">0.68</span>, -<span class="number">0.0265</span>], (<span class="number">0.62</span>, <span class="number">3.928</span>], (-<span class="number">0.0265</span>, <span class="number">0.62</span>]</span><br><span class="line">, ..., (-<span class="number">0.68</span>, -<span class="number">0.0265</span>], (-<span class="number">0.68</span>, -<span class="number">0.0265</span>], (-<span class="number">2.95</span>, -<span class="number">0.68</span>], (<span class="number">0.62</span>, <span class="number">3.928</span>], (-<span class="number">0.68</span>,</span><br><span class="line"> -<span class="number">0.0265</span>]]</span><br><span class="line">Length: <span class="number">1000</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(-<span class="number">2.95</span>, -<span class="number">0.68</span>] &lt; (-<span class="number">0.68</span>, -<span class="number">0.0265</span>] &lt; (-<span class="number">0.0265</span>,</span><br><span class="line"> <span class="number">0.62</span>] &lt;</span><br><span class="line">                                    (<span class="number">0.62</span>, <span class="number">3.928</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: pd.value_counts(cats)</span><br><span class="line">Out[<span class="number">90</span>]:</span><br><span class="line">(<span class="number">0.62</span>, <span class="number">3.928</span>]       <span class="number">250</span></span><br><span class="line">(-<span class="number">0.0265</span>, <span class="number">0.62</span>]     <span class="number">250</span></span><br><span class="line">(-<span class="number">0.68</span>, -<span class="number">0.0265</span>]    <span class="number">250</span></span><br><span class="line">(-<span class="number">2.95</span>, -<span class="number">0.68</span>]      <span class="number">250</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>与cut类似，你也可以传递自定义的分位数（0到1之间的数值，包含端点）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: pd.qcut(data, [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.9</span>, <span class="number">1.</span>])</span><br><span class="line">Out[<span class="number">91</span>]: </span><br><span class="line">[(-<span class="number">0.0265</span>, <span class="number">1.286</span>], (-<span class="number">0.0265</span>, <span class="number">1.286</span>], (-<span class="number">1.187</span>, -<span class="number">0.0265</span>], (-<span class="number">0.0265</span>, <span class="number">1.286</span>], (-<span class="number">0.026</span></span><br><span class="line"><span class="number">5</span>, <span class="number">1.286</span>], ..., (-<span class="number">1.187</span>, -<span class="number">0.0265</span>], (-<span class="number">1.187</span>, -<span class="number">0.0265</span>], (-<span class="number">2.95</span>, -<span class="number">1.187</span>], (-<span class="number">0.0265</span>, </span><br><span class="line"><span class="number">1.286</span>], (-<span class="number">1.187</span>, -<span class="number">0.0265</span>]]</span><br><span class="line">Length: <span class="number">1000</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(-<span class="number">2.95</span>, -<span class="number">1.187</span>] &lt; (-<span class="number">1.187</span>, -<span class="number">0.0265</span>] &lt; (-<span class="number">0.026</span></span><br><span class="line"><span class="number">5</span>, <span class="number">1.286</span>] &lt;</span><br><span class="line">                                    (<span class="number">1.286</span>, <span class="number">3.928</span>]]</span><br></pre></td></tr></table></figure>
<p>本章稍后在讲解聚合和分组运算时会再次用到cut和qcut，因为这两个离散化函数对分位和分组分析非常重要。</p>
<h3 id="检测和过滤异常值">7.2.6 检测和过滤异常值</h3>
<p>过滤或变换异常值（outlier）在很大程度上就是运用数组运算。来看一个含有正态分布数据的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">92</span>]: data = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: data.describe()</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line">                 <span class="number">0</span>            <span class="number">1</span>            <span class="number">2</span>            <span class="number">3</span></span><br><span class="line">count  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span></span><br><span class="line">mean      <span class="number">0.049091</span>     <span class="number">0.026112</span>    -<span class="number">0.002544</span>    -<span class="number">0.051827</span></span><br><span class="line">std       <span class="number">0.996947</span>     <span class="number">1.007458</span>     <span class="number">0.995232</span>     <span class="number">0.998311</span></span><br><span class="line"><span class="built_in">min</span>      -<span class="number">3.645860</span>    -<span class="number">3.184377</span>    -<span class="number">3.745356</span>    -<span class="number">3.428254</span></span><br><span class="line"><span class="number">25</span>%      -<span class="number">0.599807</span>    -<span class="number">0.612162</span>    -<span class="number">0.687373</span>    -<span class="number">0.747478</span></span><br><span class="line"><span class="number">50</span>%       <span class="number">0.047101</span>    -<span class="number">0.013609</span>    -<span class="number">0.022158</span>    -<span class="number">0.088274</span></span><br><span class="line"><span class="number">75</span>%       <span class="number">0.756646</span>     <span class="number">0.695298</span>     <span class="number">0.699046</span>     <span class="number">0.623331</span></span><br><span class="line"><span class="built_in">max</span>       <span class="number">2.653656</span>     <span class="number">3.525865</span>     <span class="number">2.735527</span>     <span class="number">3.366626</span></span><br></pre></td></tr></table></figure>
<p>假设你想要找出某列中绝对值大小超过3的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: col = data[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: col[np.<span class="built_in">abs</span>(col) &gt; <span class="number">3</span>]</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line"><span class="number">41</span>    -<span class="number">3.399312</span></span><br><span class="line"><span class="number">136</span>   -<span class="number">3.745356</span></span><br><span class="line">Name: <span class="number">2</span>, dtype: float64</span><br></pre></td></tr></table></figure>
<p>要选出全部含有“超过3或－3的值”的行，你可以在布尔型DataFrame中使用any方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: data[(np.<span class="built_in">abs</span>(data) &gt; <span class="number">3</span>).<span class="built_in">any</span>(<span class="number">1</span>)]</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line">            <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">41</span>   <span class="number">0.457246</span> -<span class="number">0.025907</span> -<span class="number">3.399312</span> -<span class="number">0.974657</span></span><br><span class="line"><span class="number">60</span>   <span class="number">1.951312</span>  <span class="number">3.260383</span>  <span class="number">0.963301</span>  <span class="number">1.201206</span></span><br><span class="line"><span class="number">136</span>  <span class="number">0.508391</span> -<span class="number">0.196713</span> -<span class="number">3.745356</span> -<span class="number">1.520113</span></span><br><span class="line"><span class="number">235</span> -<span class="number">0.242459</span> -<span class="number">3.056990</span>  <span class="number">1.918403</span> -<span class="number">0.578828</span></span><br><span class="line"><span class="number">258</span>  <span class="number">0.682841</span>  <span class="number">0.326045</span>  <span class="number">0.425384</span> -<span class="number">3.428254</span></span><br><span class="line"><span class="number">322</span>  <span class="number">1.179227</span> -<span class="number">3.184377</span>  <span class="number">1.369891</span> -<span class="number">1.074833</span></span><br><span class="line"><span class="number">544</span> -<span class="number">3.548824</span>  <span class="number">1.553205</span> -<span class="number">2.186301</span>  <span class="number">1.277104</span></span><br><span class="line"><span class="number">635</span> -<span class="number">0.578093</span>  <span class="number">0.193299</span>  <span class="number">1.397822</span>  <span class="number">3.366626</span></span><br><span class="line"><span class="number">782</span> -<span class="number">0.207434</span>  <span class="number">3.525865</span>  <span class="number">0.283070</span>  <span class="number">0.544635</span></span><br><span class="line"><span class="number">803</span> -<span class="number">3.645860</span>  <span class="number">0.255475</span> -<span class="number">0.549574</span> -<span class="number">1.907459</span></span><br></pre></td></tr></table></figure>
<p>根据这些条件，就可以对值进行设置。下面的代码可以将值限制在区间－3到3以内：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">97</span>]: data[np.<span class="built_in">abs</span>(data) &gt; <span class="number">3</span>] = np.sign(data) * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: data.describe()</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">                 <span class="number">0</span>            <span class="number">1</span>            <span class="number">2</span>            <span class="number">3</span></span><br><span class="line">count  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span></span><br><span class="line">mean      <span class="number">0.050286</span>     <span class="number">0.025567</span>    -<span class="number">0.001399</span>    -<span class="number">0.051765</span></span><br><span class="line">std       <span class="number">0.992920</span>     <span class="number">1.004214</span>     <span class="number">0.991414</span>     <span class="number">0.995761</span></span><br><span class="line"><span class="built_in">min</span>      -<span class="number">3.000000</span>    -<span class="number">3.000000</span>    -<span class="number">3.000000</span>    -<span class="number">3.000000</span></span><br><span class="line"><span class="number">25</span>%      -<span class="number">0.599807</span>    -<span class="number">0.612162</span>    -<span class="number">0.687373</span>    -<span class="number">0.747478</span></span><br><span class="line"><span class="number">50</span>%       <span class="number">0.047101</span>    -<span class="number">0.013609</span>    -<span class="number">0.022158</span>    -<span class="number">0.088274</span></span><br><span class="line"><span class="number">75</span>%       <span class="number">0.756646</span>     <span class="number">0.695298</span>     <span class="number">0.699046</span>     <span class="number">0.623331</span></span><br><span class="line"><span class="built_in">max</span>       <span class="number">2.653656</span>     <span class="number">3.000000</span>     <span class="number">2.735527</span>     <span class="number">3.000000</span></span><br></pre></td></tr></table></figure>
<p>根据数据的值是正还是负，np.sign(data)可以生成1和-1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">99</span>]: np.sign(data).head()</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"><span class="number">0</span> -<span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span> -<span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span></span><br><span class="line"><span class="number">3</span> -<span class="number">1.0</span> -<span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span> -<span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<h3 id="排列和随机采样">7.2.7 排列和随机采样</h3>
<p>利用numpy.random.permutation函数可以轻松实现对Series或DataFrame的列的排列工作（permuting，随机重排序）。通过需要排列的轴的长度调用permutation，可产生一个表示新顺序的整数数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">100</span>]: df = pd.DataFrame(np.arange(<span class="number">5</span> * <span class="number">4</span>).reshape((<span class="number">5</span>, <span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: sampler = np.random.permutation(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: sampler</span><br><span class="line">Out[<span class="number">102</span>]: array([<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>然后就可以在基于iloc的索引操作或take函数中使用该数组了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">103</span>]: df</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"><span class="number">3</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line"><span class="number">4</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: df.take(sampler)</span><br><span class="line">Out[<span class="number">104</span>]: </span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line"><span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">4</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>如果不想用替换的方式选取随机子集，可以在Series和DataFrame上使用sample方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: df.sample(n=<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">105</span>]: </span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line"><span class="number">4</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>要通过替换的方式产生样本（允许重复选择），可以传递replace=True到sample：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: choices = pd.Series([<span class="number">5</span>, <span class="number">7</span>, -<span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: draws = choices.sample(n=<span class="number">10</span>, replace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: draws</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line"><span class="number">4</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">1</span></span><br><span class="line"><span class="number">0</span>    <span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">6</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span></span><br><span class="line"><span class="number">0</span>    <span class="number">5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="计算指标哑变量">7.2.8 计算指标/哑变量</h3>
<p>另一种常用于统计建模或机器学习的转换方式是：将分类变量（categorical variable）转换为“哑变量”或“指标矩阵”。</p>
<p>如果DataFrame的某一列中含有k个不同的值，则可以派生出一个k列矩阵或DataFrame（其值全为1和0）。pandas有一个get_dummies函数可以实现该功能（其实自己动手做一个也不难）。使用之前的一个DataFrame例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: pd.get_dummies(df[<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line">Out[<span class="number">110</span>]: </span><br><span class="line">   a  b  c</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>有时候，你可能想给指标DataFrame的列加上一个前缀，以便能够跟其他数据进行合并。get_dummies的prefix参数可以实现该功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">111</span>]: dummies = pd.get_dummies(df[<span class="string">&#x27;key&#x27;</span>], prefix=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: df_with_dummy = df[[<span class="string">&#x27;data1&#x27;</span>]].join(dummies)</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: df_with_dummy</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">   data1  key_a  key_b  key_c</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果DataFrame中的某行同属于多个分类，则事情就会有点复杂。看一下MovieLens 1M数据集，14章会更深入地研究它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">114</span>]: mnames = [<span class="string">&#x27;movie_id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;genres&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: movies = pd.read_table(<span class="string">&#x27;datasets/movielens/movies.dat&#x27;</span>, sep=<span class="string">&#x27;::&#x27;</span>,</span><br><span class="line">   .....:                        header=<span class="literal">None</span>, names=mnames)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: movies[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line">   movie_id                               title                        genres</span><br><span class="line"><span class="number">0</span>         <span class="number">1</span>                    Toy Story (<span class="number">1995</span>)   Animation|Children<span class="string">&#x27;s|Comedy</span></span><br><span class="line"><span class="string">1         2                      Jumanji (1995)  Adventure|Children&#x27;</span>s|Fantasy</span><br><span class="line"><span class="number">2</span>         <span class="number">3</span>             Grumpier Old Men (<span class="number">1995</span>)                Comedy|Romance</span><br><span class="line"><span class="number">3</span>         <span class="number">4</span>            Waiting to Exhale (<span class="number">1995</span>)                  Comedy|Drama</span><br><span class="line"><span class="number">4</span>         <span class="number">5</span>  Father of the Bride Part II (<span class="number">1995</span>)                        Comedy</span><br><span class="line"><span class="number">5</span>         <span class="number">6</span>                         Heat (<span class="number">1995</span>)         Action|Crime|Thriller</span><br><span class="line"><span class="number">6</span>         <span class="number">7</span>                      Sabrina (<span class="number">1995</span>)                Comedy|Romance</span><br><span class="line"><span class="number">7</span>         <span class="number">8</span>                 Tom <span class="keyword">and</span> Huck (<span class="number">1995</span>)          Adventure|Children<span class="string">&#x27;s</span></span><br><span class="line"><span class="string">8         9                 Sudden Death (1995)</span></span><br><span class="line"><span class="string">Action</span></span><br><span class="line"><span class="string">9        10                    GoldenEye (1995)     Action|Adventure|Thriller</span></span><br></pre></td></tr></table></figure>
<p>要为每个genre添加指标变量就需要做一些数据规整操作。首先，我们从数据集中抽取出不同的genre值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: all_genres = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: <span class="keyword">for</span> x <span class="keyword">in</span> movies.genres:</span><br><span class="line">   .....:     all_genres.extend(x.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: genres = pd.unique(all_genres)</span><br></pre></td></tr></table></figure>
<p>现在有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">120</span>]: genres</span><br><span class="line">Out[<span class="number">120</span>]: </span><br><span class="line">array([<span class="string">&#x27;Animation&#x27;</span>, <span class="string">&quot;Children&#x27;s&quot;</span>, <span class="string">&#x27;Comedy&#x27;</span>, <span class="string">&#x27;Adventure&#x27;</span>, <span class="string">&#x27;Fantasy&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Romance&#x27;</span>, <span class="string">&#x27;Drama&#x27;</span>, <span class="string">&#x27;Action&#x27;</span>, <span class="string">&#x27;Crime&#x27;</span>, <span class="string">&#x27;Thriller&#x27;</span>,<span class="string">&#x27;Horror&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Sci-Fi&#x27;</span>, <span class="string">&#x27;Documentary&#x27;</span>, <span class="string">&#x27;War&#x27;</span>, <span class="string">&#x27;Musical&#x27;</span>, <span class="string">&#x27;Mystery&#x27;</span>, <span class="string">&#x27;Film-Noir&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Western&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<p>构建指标DataFrame的方法之一是从一个全零DataFrame开始：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">121</span>]: zero_matrix = np.zeros((<span class="built_in">len</span>(movies), <span class="built_in">len</span>(genres)))</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: dummies = pd.DataFrame(zero_matrix, columns=genres)</span><br></pre></td></tr></table></figure>
<p>现在，迭代每一部电影，并将dummies各行的条目设为1。要这么做，我们使用dummies.columns来计算每个类型的列索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">123</span>]: gen = movies.genres[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: gen.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">Out[<span class="number">124</span>]: [<span class="string">&#x27;Animation&#x27;</span>, <span class="string">&quot;Children&#x27;s&quot;</span>, <span class="string">&#x27;Comedy&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: dummies.columns.get_indexer(gen.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">Out[<span class="number">125</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>然后，根据索引，使用.iloc设定值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">126</span>]: <span class="keyword">for</span> i, gen <span class="keyword">in</span> <span class="built_in">enumerate</span>(movies.genres):</span><br><span class="line">   .....:     indices = dummies.columns.get_indexer(gen.split(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">   .....:     dummies.iloc[i, indices] = <span class="number">1</span></span><br><span class="line">   .....:</span><br></pre></td></tr></table></figure>
<p>然后，和以前一样，再将其与movies合并起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">127</span>]: movies_windic = movies.join(dummies.add_prefix(<span class="string">&#x27;Genre_&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: movies_windic.iloc[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">128</span>]: </span><br><span class="line">movie_id                                       <span class="number">1</span></span><br><span class="line">title                           Toy Story (<span class="number">1995</span>)</span><br><span class="line">genres               Animation|Children<span class="string">&#x27;s|Comedy</span></span><br><span class="line"><span class="string">Genre_Animation                                1</span></span><br><span class="line"><span class="string">Genre_Children&#x27;</span>s                               <span class="number">1</span></span><br><span class="line">Genre_Comedy                                   <span class="number">1</span></span><br><span class="line">Genre_Adventure                                <span class="number">0</span></span><br><span class="line">Genre_Fantasy                                  <span class="number">0</span></span><br><span class="line">Genre_Romance                                  <span class="number">0</span></span><br><span class="line">Genre_Drama                                    <span class="number">0</span></span><br><span class="line">                                ...             </span><br><span class="line">Genre_Crime                                    <span class="number">0</span></span><br><span class="line">Genre_Thriller                                 <span class="number">0</span></span><br><span class="line">Genre_Horror                                   <span class="number">0</span></span><br><span class="line">Genre_Sci-Fi                                   <span class="number">0</span></span><br><span class="line">Genre_Documentary                              <span class="number">0</span></span><br><span class="line">Genre_War                                      <span class="number">0</span></span><br><span class="line">Genre_Musical                                  <span class="number">0</span></span><br><span class="line">Genre_Mystery                                  <span class="number">0</span></span><br><span class="line">Genre_Film-Noir                                <span class="number">0</span></span><br><span class="line">Genre_Western                                  <span class="number">0</span></span><br><span class="line">Name: <span class="number">0</span>, Length: <span class="number">21</span>, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：对于很大的数据，用这种方式构建多成员指标变量就会变得非常慢。最好使用更低级的函数，将其写入NumPy数组，然后结果包装在DataFrame中。</p>
</blockquote>
<p>一个对统计应用有用的秘诀是：结合get_dummies和诸如cut之类的离散化函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">129</span>]: np.random.seed(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: values = np.random.rand(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: values</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">array([ <span class="number">0.9296</span>,  <span class="number">0.3164</span>,  <span class="number">0.1839</span>,  <span class="number">0.2046</span>,  <span class="number">0.5677</span>,  <span class="number">0.5955</span>,  <span class="number">0.9645</span>,</span><br><span class="line">        <span class="number">0.6532</span>,  <span class="number">0.7489</span>,  <span class="number">0.6536</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: bins = [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: pd.get_dummies(pd.cut(values, bins))</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">   (<span class="number">0.0</span>, <span class="number">0.2</span>]  (<span class="number">0.2</span>, <span class="number">0.4</span>]  (<span class="number">0.4</span>, <span class="number">0.6</span>]  (<span class="number">0.6</span>, <span class="number">0.8</span>]  (<span class="number">0.8</span>, <span class="number">1.0</span>]</span><br><span class="line"><span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span></span><br><span class="line"><span class="number">1</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">2</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">3</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">4</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">5</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span>           <span class="number">0</span></span><br><span class="line"><span class="number">6</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span></span><br><span class="line"><span class="number">7</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">8</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">9</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>我们用numpy.random.seed，使这个例子具有确定性。本书后面会介绍pandas.get_dummies。</p>
<h2 id="字符串操作">7.3 字符串操作</h2>
<p>Python能够成为流行的数据处理语言，部分原因是其简单易用的字符串和文本处理功能。大部分文本运算都直接做成了字符串对象的内置方法。对于更为复杂的模式匹配和文本操作，则可能需要用到正则表达式。pandas对此进行了加强，它使你能够对整组数据应用字符串表达式和正则表达式，而且能处理烦人的缺失数据。</p>
<h3 id="字符串对象方法">7.3.1 字符串对象方法</h3>
<p>对于许多字符串处理和脚本应用，内置的字符串方法已经能够满足要求了。例如，以逗号分隔的字符串可以用split拆分成数段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">134</span>]: val = <span class="string">&#x27;a,b,  guido&#x27;</span></span><br><span class="line">In [<span class="number">135</span>]: val.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">Out[<span class="number">135</span>]: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;  guido&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>split常常与strip一起使用，以去除空白符（包括换行符）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">136</span>]: pieces = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> val.split(<span class="string">&#x27;,&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: pieces</span><br><span class="line">Out[<span class="number">137</span>]: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;guido&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>利用加法，可以将这些子字符串以双冒号分隔符的形式连接起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">138</span>]: first, second, third = pieces</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: first + <span class="string">&#x27;::&#x27;</span> + second + <span class="string">&#x27;::&#x27;</span> + third</span><br><span class="line">Out[<span class="number">139</span>]: <span class="string">&#x27;a::b::guido&#x27;</span></span><br></pre></td></tr></table></figure>
<p>但这种方式并不是很实用。一种更快更符合Python风格的方式是，向字符串"::"的join方法传入一个列表或元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">140</span>]: <span class="string">&#x27;::&#x27;</span>.join(pieces)</span><br><span class="line">Out[<span class="number">140</span>]: <span class="string">&#x27;a::b::guido&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其它方法关注的是子串定位。检测子串的最佳方式是利用Python的in关键字，还可以使用index和find：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: <span class="string">&#x27;guido&#x27;</span> <span class="keyword">in</span> val</span><br><span class="line">Out[<span class="number">141</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: val.index(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">Out[<span class="number">142</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: val.find(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">Out[<span class="number">143</span>]: -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意find和index的区别：如果找不到字符串，index将会引发一个异常（而不是返回－1）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">144</span>]: val.index(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">144</span>-280f8b2856ce&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> val.index(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">ValueError: substring <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>
<p>与此相关，count可以返回指定子串的出现次数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">145</span>]: val.count(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">Out[<span class="number">145</span>]: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>replace用于将指定模式替换为另一个模式。通过传入空字符串，它也常常用于删除模式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">146</span>]: val.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;::&#x27;</span>)</span><br><span class="line">Out[<span class="number">146</span>]: <span class="string">&#x27;a::b::  guido&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">147</span>]: val.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">Out[<span class="number">147</span>]: <span class="string">&#x27;ab  guido&#x27;</span></span><br></pre></td></tr></table></figure>
<p>表7-3列出了Python内置的字符串方法。</p>
<p>这些运算大部分都能使用正则表达式实现（马上就会看到）。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap07/7178691-087fe67bf6db0701.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap07/7178691-d1f0d4ed3e895016.png" class="">
<p>casefold 将字符转换为小写，并将任何特定区域的变量字符组合转换成一个通用的可比较形式。</p>
<h3 id="正则表达式">7.3.2 正则表达式</h3>
<p>正则表达式提供了一种灵活的在文本中搜索或匹配（通常比前者复杂）字符串模式的方式。正则表达式，常称作regex，是根据正则表达式语言编写的字符串。Python内置的re模块负责对字符串应用正则表达式。我将通过一些例子说明其使用方法。</p>
<blockquote>
<p>笔记：正则表达式的编写技巧可以自成一章，超出了本书的范围。从网上和其它书可以找到许多非常不错的教程和参考资料。</p>
</blockquote>
<p>re模块的函数可以分为三个大类：模式匹配、替换以及拆分。当然，它们之间是相辅相成的。一个regex描述了需要在文本中定位的一个模式，它可以用于许多目的。我们先来看一个简单的例子：假设我想要拆分一个字符串，分隔符为数量不定的一组空白符（制表符、空格、换行符等）。描述一个或多个空白符的regex是+：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">148</span>]: <span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">In [<span class="number">149</span>]: text = <span class="string">&quot;foo    bar\t baz  \tqux&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: re.split(<span class="string">&#x27;\s+&#x27;</span>, text)</span><br><span class="line">Out[<span class="number">150</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>调用re.split('+',text)时，正则表达式会先被编译，然后再在text上调用其split方法。你可以用re.compile自己编译regex以得到一个可重用的regex对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">151</span>]: regex = re.<span class="built_in">compile</span>(<span class="string">&#x27;\s+&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: regex.split(text)</span><br><span class="line">Out[<span class="number">152</span>]: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>如果只希望得到匹配regex的所有模式，则可以使用findall方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">153</span>]: regex.findall(text)</span><br><span class="line">Out[<span class="number">153</span>]: [<span class="string">&#x27;    &#x27;</span>, <span class="string">&#x27;\t &#x27;</span>, <span class="string">&#x27;  \t&#x27;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：如果想避免正则表达式中不需要的转义（），则可以使用原始字符串字面量如r'C:'（也可以编写其等价式'C:\x'）。</p>
</blockquote>
<p>如果打算对许多字符串应用同一条正则表达式，强烈建议通过re.compile创建regex对象。这样将可以节省大量的CPU时间。</p>
<p>match和search跟findall功能类似。findall返回的是字符串中所有的匹配项，而search则只返回第一个匹配项。match更加严格，它只匹配字符串的首部。来看一个小例子，假设我们有一段文本以及一条能够识别大部分电子邮件地址的正则表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;&quot;&quot;Dave dave@google.com</span></span><br><span class="line"><span class="string">Steve steve@gmail.com</span></span><br><span class="line"><span class="string">Rob rob@gmail.com</span></span><br><span class="line"><span class="string">Ryan ryan@yahoo.com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">pattern = <span class="string">r&#x27;[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## re.IGNORECASE makes the regex case-insensitive</span></span><br><span class="line">regex = re.<span class="built_in">compile</span>(pattern, flags=re.IGNORECASE)</span><br></pre></td></tr></table></figure>
<p>对text使用findall将得到一组电子邮件地址：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">155</span>]: regex.findall(text)</span><br><span class="line">Out[<span class="number">155</span>]: </span><br><span class="line">[<span class="string">&#x27;dave@google.com&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;steve@gmail.com&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;rob@gmail.com&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ryan@yahoo.com&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>search返回的是文本中第一个电子邮件地址（以特殊的匹配项对象形式返回）。对于上面那个regex，匹配项对象只能告诉我们模式在原字符串中的起始和结束位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">156</span>]: m = regex.search(text)</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: m</span><br><span class="line">Out[<span class="number">157</span>]: &lt;_sre.SRE_Match <span class="built_in">object</span>; span=(<span class="number">5</span>, <span class="number">20</span>), <span class="keyword">match</span>=<span class="string">&#x27;dave@google.com&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: text[m.start():m.end()]</span><br><span class="line">Out[<span class="number">158</span>]: <span class="string">&#x27;dave@google.com&#x27;</span></span><br></pre></td></tr></table></figure>
<p>regex.match则将返回None，因为它只匹配出现在字符串开头的模式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">159</span>]: <span class="built_in">print</span>(regex.<span class="keyword">match</span>(text))</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>相关的，sub方法可以将匹配到的模式替换为指定字符串，并返回所得到的新字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">160</span>]: <span class="built_in">print</span>(regex.sub(<span class="string">&#x27;REDACTED&#x27;</span>, text))</span><br><span class="line">Dave REDACTED</span><br><span class="line">Steve REDACTED</span><br><span class="line">Rob REDACTED</span><br><span class="line">Ryan REDACTED</span><br></pre></td></tr></table></figure>
<p>假设你不仅想要找出电子邮件地址，还想将各个地址分成3个部分：用户名、域名以及域后缀。要实现此功能，只需将待分段的模式的各部分用圆括号包起来即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">161</span>]: pattern = <span class="string">r&#x27;([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]&#123;2,4&#125;)&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: regex = re.<span class="built_in">compile</span>(pattern, flags=re.IGNORECASE)</span><br></pre></td></tr></table></figure>
<p>由这种修改过的正则表达式所产生的匹配项对象，可以通过其groups方法返回一个由模式各段组成的元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">163</span>]: m = regex.<span class="keyword">match</span>(<span class="string">&#x27;wesm@bright.net&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">164</span>]: m.groups()</span><br><span class="line">Out[<span class="number">164</span>]: (<span class="string">&#x27;wesm&#x27;</span>, <span class="string">&#x27;bright&#x27;</span>, <span class="string">&#x27;net&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>对于带有分组功能的模式，findall会返回一个元组列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: regex.findall(text)</span><br><span class="line">Out[<span class="number">165</span>]:</span><br><span class="line">[(<span class="string">&#x27;dave&#x27;</span>, <span class="string">&#x27;google&#x27;</span>, <span class="string">&#x27;com&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;steve&#x27;</span>, <span class="string">&#x27;gmail&#x27;</span>, <span class="string">&#x27;com&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;rob&#x27;</span>, <span class="string">&#x27;gmail&#x27;</span>, <span class="string">&#x27;com&#x27;</span>),</span><br><span class="line"> (<span class="string">&#x27;ryan&#x27;</span>, <span class="string">&#x27;yahoo&#x27;</span>, <span class="string">&#x27;com&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>sub还能通过诸如\1、\2之类的特殊符号访问各匹配项中的分组。符号\1对应第一个匹配的组，\2对应第二个匹配的组，以此类推：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">166</span>]: <span class="built_in">print</span>(regex.sub(<span class="string">r&#x27;Username: \1, Domain: \2, Suffix: \3&#x27;</span>, text))</span><br><span class="line">Dave Username: dave, Domain: google, Suffix: com</span><br><span class="line">Steve Username: steve, Domain: gmail, Suffix: com</span><br><span class="line">Rob Username: rob, Domain: gmail, Suffix: com</span><br><span class="line">Ryan Username: ryan, Domain: yahoo, Suffix: com</span><br></pre></td></tr></table></figure>
<p>Python中还有许多的正则表达式，但大部分都超出了本书的范围。表7-4是一个简要概括。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap07/7178691-efbb80a793759fc0.png" class="">
<h3 id="pandas的矢量化字符串函数">7.3.3 pandas的矢量化字符串函数</h3>
<p>清理待分析的散乱数据时，常常需要做一些字符串规整化工作。更为复杂的情况是，含有字符串的列有时还含有缺失数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">167</span>]: data = &#123;<span class="string">&#x27;Dave&#x27;</span>: <span class="string">&#x27;dave@google.com&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>: <span class="string">&#x27;steve@gmail.com&#x27;</span>,</span><br><span class="line">   .....:         <span class="string">&#x27;Rob&#x27;</span>: <span class="string">&#x27;rob@gmail.com&#x27;</span>, <span class="string">&#x27;Wes&#x27;</span>: np.nan&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">168</span>]: data = pd.Series(data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: data</span><br><span class="line">Out[<span class="number">169</span>]: </span><br><span class="line">Dave     dave@google.com</span><br><span class="line">Rob        rob@gmail.com</span><br><span class="line">Steve    steve@gmail.com</span><br><span class="line">Wes                  NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">170</span>]: data.isnull()</span><br><span class="line">Out[<span class="number">170</span>]: </span><br><span class="line">Dave     <span class="literal">False</span></span><br><span class="line">Rob      <span class="literal">False</span></span><br><span class="line">Steve    <span class="literal">False</span></span><br><span class="line">Wes       <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>
<p>通过data.map，所有字符串和正则表达式方法都能被应用于（传入lambda表达式或其他函数）各个值，但是如果存在NA（null）就会报错。为了解决这个问题，Series有一些能够跳过NA值的面向数组方法，进行字符串操作。通过Series的str属性即可访问这些方法。例如，我们可以通过str.contains检查各个电子邮件地址是否含有"gmail"：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">171</span>]: data.<span class="built_in">str</span>.contains(<span class="string">&#x27;gmail&#x27;</span>)</span><br><span class="line">Out[<span class="number">171</span>]: </span><br><span class="line">Dave     <span class="literal">False</span></span><br><span class="line">Rob       <span class="literal">True</span></span><br><span class="line">Steve     <span class="literal">True</span></span><br><span class="line">Wes        NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>也可以使用正则表达式，还可以加上任意re选项（如IGNORECASE）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">172</span>]: pattern</span><br><span class="line">Out[<span class="number">172</span>]: <span class="string">&#x27;([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\\.([A-Z]&#123;2,4&#125;)&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: data.<span class="built_in">str</span>.findall(pattern, flags=re.IGNORECASE)</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line">Dave     [(dave, google, com)]</span><br><span class="line">Rob        [(rob, gmail, com)]</span><br><span class="line">Steve    [(steve, gmail, com)]</span><br><span class="line">Wes                        NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>有两个办法可以实现矢量化的元素获取操作：要么使用str.get，要么在str属性上使用索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">174</span>]: matches = data.<span class="built_in">str</span>.<span class="keyword">match</span>(pattern, flags=re.IGNORECASE)</span><br><span class="line"></span><br><span class="line">In [<span class="number">175</span>]: matches</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">Dave     <span class="literal">True</span></span><br><span class="line">Rob      <span class="literal">True</span></span><br><span class="line">Steve    <span class="literal">True</span></span><br><span class="line">Wes       NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>要访问嵌入列表中的元素，我们可以传递索引到这两个函数中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">176</span>]: matches.<span class="built_in">str</span>.get(<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">Dave    NaN</span><br><span class="line">Rob     NaN</span><br><span class="line">Steve   NaN</span><br><span class="line">Wes     NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: matches.<span class="built_in">str</span>[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">177</span>]: </span><br><span class="line">Dave    NaN</span><br><span class="line">Rob     NaN</span><br><span class="line">Steve   NaN</span><br><span class="line">Wes     NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>你可以利用这种方法对字符串进行截取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">178</span>]: data.<span class="built_in">str</span>[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">Dave     dave@</span><br><span class="line">Rob      rob@g</span><br><span class="line">Steve    steve</span><br><span class="line">Wes        NaN</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>表7-5介绍了更多的pandas字符串方法。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap07/7178691-a634364ed6d5d5c5.png" class="" title="表7-5 部分矢量化字符串方法">
<h2 id="总结">7.4 总结</h2>
<p>高效的数据准备可以让你将更多的时间用于数据分析，花较少的时间用于准备工作，这样就可以极大地提高生产力。我们在本章中学习了许多工具，但覆盖并不全面。下一章，我们会学习pandas的聚合与分组。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第09章_绘图和可视化</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap09/</url>
    <content><![CDATA[<h1 id="第09章-绘图和可视化">第09章 绘图和可视化</h1>
<p>信息可视化（也叫绘图）是数据分析中最重要的工作之一。它可能是探索过程的一部分，例如，帮助我们找出异常值、必要的数据转换、得出有关模型的idea等。另外，做一个可交互的数据可视化也许是工作的最终目标。Python有许多库进行静态或动态的数据可视化，但我这里重要关注于matplotlib（http://matplotlib.org/）和基于它的库。</p>
<span id="more"></span>
<p>matplotlib是一个用于创建出版质量图表的桌面绘图包（主要是2D方面）。该项目是由John Hunter于2002年启动的，其目的是为Python构建一个MATLAB式的绘图接口。matplotlib和IPython社区进行合作，简化了从IPython shell（包括现在的Jupyter notebook）进行交互式绘图。matplotlib支持各种操作系统上许多不同的GUI后端，而且还能将图片导出为各种常见的矢量（vector）和光栅（raster）图：PDF、SVG、JPG、PNG、BMP、GIF等。除了几张，本书中的大部分图都是用它生成的。</p>
<p>随着时间的发展，matplotlib衍生出了多个数据可视化的工具集，它们使用matplotlib作为底层。其中之一是seaborn（http://seaborn.pydata.org/），本章后面会学习它。</p>
<p>学习本章代码案例的最简单方法是在Jupyter notebook进行交互式绘图。在Jupyter notebook中执行下面的语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib notebook</span><br></pre></td></tr></table></figure>
<h2 id="matplotlib-api入门">9.1 matplotlib API入门</h2>
<p>matplotlib的通常引入约定是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<p>在Jupyter中运行%matplotlib notebook（或在IPython中运行%matplotlib），就可以创建一个简单的图形。如果一切设置正确，会看到图9-1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: data = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: data</span><br><span class="line">Out[<span class="number">14</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: plt.plot(data)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-7032e333a6ecdd37.png" class="" title="图9-1 简单的线图">
<p>虽然seaborn这样的库和pandas的内置绘图函数能够处理许多普通的绘图任务，但如果需要自定义一些高级功能的话就必须学习matplotlib API。</p>
<blockquote>
<p>笔记：虽然本书没有详细地讨论matplotlib的各种功能，但足以将你引入门。matplotlib的示例库和文档是学习高级特性的最好资源。</p>
</blockquote>
<h3 id="figure和subplot">9.1.1 Figure和Subplot</h3>
<p>matplotlib的图像都位于Figure对象中。你可以用plt.figure创建一个新的Figure：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: fig = plt.figure()</span><br></pre></td></tr></table></figure>
<p>如果用的是IPython，这时会弹出一个空窗口，但在Jupyter中，必须再输入更多命令才能看到。plt.figure有一些选项，特别是figsize，它用于确保当图片保存到磁盘时具有一定的大小和纵横比。</p>
<p>不能通过空Figure绘图。必须用add_subplot创建一个或多个subplot才行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这条代码的意思是：图像应该是2×2的（即最多4张图），且当前选中的是4个subplot中的第一个（编号从1开始）。如果再把后面两个subplot也创建出来，最终得到的图像如图9-2所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: ax2 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: ax3 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-b8cff158e64eae74.png" class="" title="图9-2 带有三个subplot的Figure">
<blockquote>
<p>提示：使用Jupyter notebook有一点不同，即每个小窗重新执行后，图形会被重置。因此，对于复杂的图形，，你必须将所有的绘图命令存在一个小窗里。</p>
</blockquote>
<p>这里，我们运行同一个小窗里的所有命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>如果这时执行一条绘图命令（如plt.plot([1.5, 3.5, -2, 1.6])），matplotlib就会在最后一个用过的subplot（如果没有则创建一个）上进行绘制，隐藏创建figure和subplot的过程。因此，如果我们执行下列命令，你就会得到如图9-3所示的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: plt.plot(np.random.randn(<span class="number">50</span>).cumsum(), <span class="string">&#x27;k--&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-7bcbd5e56fdbbd92.png" class="" title="图9-3 绘制一次之后的图像">
<p>"k--"是一个线型选项，用于告诉matplotlib绘制黑色虚线图。上面那些由fig.add_subplot所返回的对象是AxesSubplot对象，直接调用它们的实例方法就可以在其它空着的格子里面画图了，如图9-4所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: ax1.hist(np.random.randn(<span class="number">100</span>), bins=<span class="number">20</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: ax2.scatter(np.arange(<span class="number">30</span>), np.arange(<span class="number">30</span>) + <span class="number">3</span> * np.random.randn(<span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-2297bcaf355db24c.png" class="" title="图9-4 继续绘制两次之后的图像">
<p>你可以在matplotlib的文档中找到各种图表类型。</p>
<p>创建包含subplot网格的figure是一个非常常见的任务，matplotlib有一个更为方便的方法plt.subplots，它可以创建一个新的Figure，并返回一个含有已创建的subplot对象的NumPy数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: axes</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">array([[&lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb626374048</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb62625db00</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb6262f6c88</span>&gt;],</span><br><span class="line">       [&lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb6261a36a0</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb626181860</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x7fb6260fd4e0</span>&gt;]], dtype</span><br><span class="line">=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<p>这是非常实用的，因为可以轻松地对axes数组进行索引，就好像是一个二维数组一样，例如axes[0,1]。你还可以通过sharex和sharey指定subplot应该具有相同的X轴或Y轴。在比较相同范围的数据时，这也是非常实用的，否则，matplotlib会自动缩放各图表的界限。有关该方法的更多信息，请参见表9-1。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-88bb55faca7d01ba.png" class="" title="表9-1 pyplot.subplots的选项">
<h3 id="调整subplot周围的间距">9.1.2 调整subplot周围的间距</h3>
<p>默认情况下，matplotlib会在subplot外围留下一定的边距，并在subplot之间留下一定的间距。间距跟图像的高度和宽度有关，因此，如果你调整了图像大小（不管是编程还是手工），间距也会自动调整。利用Figure的subplots_adjust方法可以轻而易举地修改间距，此外，它也是个顶级函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">subplots_adjust(left=<span class="literal">None</span>, bottom=<span class="literal">None</span>, right=<span class="literal">None</span>, top=<span class="literal">None</span>,</span><br><span class="line">                wspace=<span class="literal">None</span>, hspace=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>wspace和hspace用于控制宽度和高度的百分比，可以用作subplot之间的间距。下面是一个简单的例子，其中我将间距收缩到了0（如图9-5所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        axes[i, j].hist(np.random.randn(<span class="number">500</span>), bins=<span class="number">50</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.subplots_adjust(wspace=<span class="number">0</span>, hspace=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-80be7ffc3dec88a5.png" class="" title="图9-5 各subplot之间没有间距">
<p>不难看出，其中的轴标签重叠了。matplotlib不会检查标签是否重叠，所以对于这种情况，你只能自己设定刻度位置和刻度标签。后面几节将会详细介绍该内容。</p>
<h3 id="颜色标记和线型">9.1.3 颜色、标记和线型</h3>
<p>matplotlib的plot函数接受一组X和Y坐标，还可以接受一个表示颜色和线型的字符串缩写。例如，要根据x和y绘制绿色虚线，你可以执行如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.plot(x, y, <span class="string">&#x27;g--&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这种在一个字符串中指定颜色和线型的方式非常方便。在实际中，如果你是用代码绘图，你可能不想通过处理字符串来获得想要的格式。通过下面这种更为明确的方式也能得到同样的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.plot(x, y, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>常用的颜色可以使用颜色缩写，你也可以指定颜色码（例如，'#CECECE'）。你可以通过查看plot的文档字符串查看所有线型的合集（在IPython和Jupyter中使用plot?）。</p>
<p>线图可以使用标记强调数据点。因为matplotlib可以创建连续线图，在点之间进行插值，因此有时可能不太容易看出真实数据点的位置。标记也可以放到格式字符串中，但标记类型和线型必须放在颜色后面（见图9-6）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: <span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: plt.plot(randn(<span class="number">30</span>).cumsum(), <span class="string">&#x27;ko--&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-404d816f3e1d6621.png" class="" title="图9-6 带有标记的线型图示例">
<p>还可以将其写成更为明确的形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plot(randn(<span class="number">30</span>).cumsum(), color=<span class="string">&#x27;k&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在线型图中，非实际数据点默认是按线性方式插值的。可以通过drawstyle选项修改（见图9-7）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: data = np.random.randn(<span class="number">30</span>).cumsum()</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: plt.plot(data, <span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;Default&#x27;</span>)</span><br><span class="line">Out[<span class="number">34</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624d86160</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: plt.plot(data, <span class="string">&#x27;k-&#x27;</span>, drawstyle=<span class="string">&#x27;steps-post&#x27;</span>, label=<span class="string">&#x27;steps-post&#x27;</span>)</span><br><span class="line">Out[<span class="number">35</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624d869e8</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-3ec7642e1a592f08.png" class="" title="图9-7 不同drawstyle选项的线型图">
<p>你可能注意到运行上面代码时有输出&lt;matplotlib.lines.Line2D at ...&gt;。matplotlib会返回引用了新添加的子组件的对象。大多数时候，你可以放心地忽略这些输出。这里，因为我们传递了label参数到plot，我们可以创建一个plot图例，指明每条使用plt.legend的线。</p>
<blockquote>
<p>笔记：你必须调用plt.legend（或使用ax.legend，如果引用了轴的话）来创建图例，无论你绘图时是否传递label标签选项。</p>
</blockquote>
<h3 id="刻度标签和图例">9.1.4 刻度、标签和图例</h3>
<p>对于大多数的图表装饰项，其主要实现方式有二：使用过程型的pyplot接口（例如，matplotlib.pyplot）以及更为面向对象的原生matplotlib API。</p>
<p>pyplot接口的设计目的就是交互式使用，含有诸如xlim、xticks和xticklabels之类的方法。它们分别控制图表的范围、刻度位置、刻度标签等。其使用方式有以下两种：</p>
<ul>
<li>调用时不带参数，则返回当前的参数值（例如，plt.xlim()返回当前的X轴绘图范围）。</li>
<li>调用时带参数，则设置参数值（例如，plt.xlim([0,10])会将X轴的范围设置为0到10）。</li>
</ul>
<p>所有这些方法都是对当前或最近创建的AxesSubplot起作用的。它们各自对应subplot对象上的两个方法，以xlim为例，就是ax.get_xlim和ax.set_xlim。我更喜欢使用subplot的实例方法（因为我喜欢明确的事情，而且在处理多个subplot时这样也更清楚一些）。当然你完全可以选择自己觉得方便的那个。</p>
<h3 id="设置标题轴标签刻度以及刻度标签">9.1.5 设置标题、轴标签、刻度以及刻度标签</h3>
<p>为了说明自定义轴，我将创建一个简单的图像并绘制一段随机漫步（如图9-8所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: fig = plt.figure()</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: ax.plot(np.random.randn(<span class="number">1000</span>).cumsum())</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-caf9300dacb61fa4.png" class="" title="图9-8 用于演示xticks的简单线型图（带有标签）">
<p>要改变x轴刻度，最简单的办法是使用set_xticks和set_xticklabels。前者告诉matplotlib要将刻度放在数据范围中的哪些位置，默认情况下，这些位置也就是刻度标签。但我们可以通过set_xticklabels将任何其他的值用作标签：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: ticks = ax.set_xticks([<span class="number">0</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, <span class="number">1000</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: labels = ax.set_xticklabels([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>],</span><br><span class="line">   ....:                             rotation=<span class="number">30</span>, fontsize=<span class="string">&#x27;small&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>rotation选项设定x刻度标签倾斜30度。最后，再用set_xlabel为X轴设置一个名称，并用set_title设置一个标题（见图9-9的结果）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">42</span>]: ax.set_title(<span class="string">&#x27;My first matplotlib plot&#x27;</span>)</span><br><span class="line">Out[<span class="number">42</span>]: &lt;matplotlib.text.Text at <span class="number">0x7fb624d055f8</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: ax.set_xlabel(<span class="string">&#x27;Stages&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-741f968323bd818f.png" class="" title="图9-9 用于演示xticks的简单线型图">
<p>Y轴的修改方式与此类似，只需将上述代码中的x替换为y即可。轴的类有集合方法，可以批量设定绘图选项。前面的例子，也可以写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">props = &#123;</span><br><span class="line">    <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;My first matplotlib plot&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;xlabel&#x27;</span>: <span class="string">&#x27;Stages&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">ax.<span class="built_in">set</span>(**props)</span><br></pre></td></tr></table></figure>
<h3 id="添加图例">9.1.6 添加图例</h3>
<p>图例（legend）是另一种用于标识图表元素的重要工具。添加图例的方式有多种。最简单的是在添加subplot的时候传入label参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: <span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: fig = plt.figure(); ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k&#x27;</span>, label=<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">Out[<span class="number">46</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624bdf860</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">Out[<span class="number">47</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624be90f0</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k.&#x27;</span>, label=<span class="string">&#x27;three&#x27;</span>)</span><br><span class="line">Out[<span class="number">48</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x7fb624be9160</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>在此之后，你可以调用ax.legend()或plt.legend()来自动创建图例（结果见图9-10）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-651ff89750c0a89b.png" class="" title="图9-10 带有三条线以及图例的简单线型图">
<p>legend方法有几个其它的loc位置参数选项。请查看文档字符串（使用ax.legend?）。</p>
<p>loc告诉matplotlib要将图例放在哪。如果你不是吹毛求疵的话，"best"是不错的选择，因为它会选择最不碍事的位置。要从图例中去除一个或多个元素，不传入label或传入label='<em>nolegend</em>'即可。（中文第一版这里把best错写成了beat）</p>
<h3 id="注解以及在subplot上绘图">9.1.7 注解以及在Subplot上绘图</h3>
<p>除标准的绘图类型，你可能还希望绘制一些子集的注解，可能是文本、箭头或其他图形等。注解和文字可以通过text、arrow和annotate函数进行添加。text可以将文本绘制在图表的指定坐标(x,y)，还可以加上一些自定义格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.text(x, y, <span class="string">&#x27;Hello world!&#x27;</span>,</span><br><span class="line">        family=<span class="string">&#x27;monospace&#x27;</span>, fontsize=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>注解中可以既含有文本也含有箭头。例如，我们根据最近的标准普尔500指数价格（来自Yahoo!Finance）绘制一张曲线图，并标出2008年到2009年金融危机期间的一些重要日期。你可以在Jupyter notebook的一个小窗中试验这段代码（图9-11是结果）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;examples/spx.csv&#x27;</span>, index_col=<span class="number">0</span>, parse_dates=<span class="literal">True</span>)</span><br><span class="line">spx = data[<span class="string">&#x27;SPX&#x27;</span>]</span><br><span class="line"></span><br><span class="line">spx.plot(ax=ax, style=<span class="string">&#x27;k-&#x27;</span>)</span><br><span class="line"></span><br><span class="line">crisis_data = [</span><br><span class="line">    (datetime(<span class="number">2007</span>, <span class="number">10</span>, <span class="number">11</span>), <span class="string">&#x27;Peak of bull market&#x27;</span>),</span><br><span class="line">    (datetime(<span class="number">2008</span>, <span class="number">3</span>, <span class="number">12</span>), <span class="string">&#x27;Bear Stearns Fails&#x27;</span>),</span><br><span class="line">    (datetime(<span class="number">2008</span>, <span class="number">9</span>, <span class="number">15</span>), <span class="string">&#x27;Lehman Bankruptcy&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> date, label <span class="keyword">in</span> crisis_data:</span><br><span class="line">    ax.annotate(label, xy=(date, spx.asof(date) + <span class="number">75</span>),</span><br><span class="line">                xytext=(date, spx.asof(date) + <span class="number">225</span>),</span><br><span class="line">                arrowprops=<span class="built_in">dict</span>(facecolor=<span class="string">&#x27;black&#x27;</span>, headwidth=<span class="number">4</span>, width=<span class="number">2</span>,</span><br><span class="line">                                headlength=<span class="number">4</span>),</span><br><span class="line">                horizontalalignment=<span class="string">&#x27;left&#x27;</span>, verticalalignment=<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Zoom in on 2007-2010</span></span><br><span class="line">ax.set_xlim([<span class="string">&#x27;1/1/2007&#x27;</span>, <span class="string">&#x27;1/1/2011&#x27;</span>])</span><br><span class="line">ax.set_ylim([<span class="number">600</span>, <span class="number">1800</span>])</span><br><span class="line"></span><br><span class="line">ax.set_title(<span class="string">&#x27;Important dates in the 2008-2009 financial crisis&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-3127eaa51f5e4c2c.png" class="" title="图9-11 2008-2009年金融危机期间的重要日期">
<p>这张图中有几个重要的点要强调：ax.annotate方法可以在指定的x和y坐标轴绘制标签。我们使用set_xlim和set_ylim人工设定起始和结束边界，而不使用matplotlib的默认方法。最后，用ax.set_title添加图标标题。</p>
<p>更多有关注解的示例，请访问matplotlib的在线示例库。</p>
<p>图形的绘制要麻烦一些。matplotlib有一些表示常见图形的对象。这些对象被称为块（patch）。其中有些（如Rectangle和Circle），可以在matplotlib.pyplot中找到，但完整集合位于matplotlib.patches。</p>
<p>要在图表中添加一个图形，你需要创建一个块对象shp，然后通过ax.add_patch(shp)将其添加到subplot中（如图9-12所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">rect = plt.Rectangle((<span class="number">0.2</span>, <span class="number">0.75</span>), <span class="number">0.4</span>, <span class="number">0.15</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">circ = plt.Circle((<span class="number">0.7</span>, <span class="number">0.2</span>), <span class="number">0.15</span>, color=<span class="string">&#x27;b&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">pgon = plt.Polygon([[<span class="number">0.15</span>, <span class="number">0.15</span>], [<span class="number">0.35</span>, <span class="number">0.4</span>], [<span class="number">0.2</span>, <span class="number">0.6</span>]],</span><br><span class="line">                   color=<span class="string">&#x27;g&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.add_patch(rect)</span><br><span class="line">ax.add_patch(circ)</span><br><span class="line">ax.add_patch(pgon)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-1f8a3d7a3a02d7d8.png" class="" title="图9-12 由三个块图形组成的图">
<p>如果查看许多常见图表对象的具体实现代码，你就会发现它们其实就是由块patch组装而成的。</p>
<h3 id="将图表保存到文件">9.1.8 将图表保存到文件</h3>
<p>利用plt.savefig可以将当前图表保存到文件。该方法相当于Figure对象的实例方法savefig。例如，要将图表保存为SVG文件，你只需输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;figpath.svg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>文件类型是通过文件扩展名推断出来的。因此，如果你使用的是.pdf，就会得到一个PDF文件。我在发布图片时最常用到两个重要的选项是dpi（控制“每英寸点数”分辨率）和bbox_inches（可以剪除当前图表周围的空白部分）。要得到一张带有最小白边且分辨率为400DPI的PNG图片，你可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;figpath.png&#x27;</span>, dpi=<span class="number">400</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>savefig并非一定要写入磁盘，也可以写入任何文件型的对象，比如BytesIO：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">buffer = BytesIO()</span><br><span class="line">plt.savefig(buffer)</span><br><span class="line">plot_data = buffer.getvalue()</span><br></pre></td></tr></table></figure>
<p>表9-2列出了savefig的其它选项。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-4bee796bf7262423.png" class="" title="表9-2 Figure.savefig的选项">
<h3 id="matplotlib配置">9.1.9 matplotlib配置</h3>
<p>matplotlib自带一些配色方案，以及为生成出版质量的图片而设定的默认配置信息。幸运的是，几乎所有默认行为都能通过一组全局参数进行自定义，它们可以管理图像大小、subplot边距、配色方案、字体大小、网格类型等。一种Python编程方式配置系统的方法是使用rc方法。例如，要将全局的图像默认大小设置为10×10，你可以执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rc(<span class="string">&#x27;figure&#x27;</span>, figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>rc的第一个参数是希望自定义的对象，如'figure'、'axes'、'xtick'、'ytick'、'grid'、'legend'等。其后可以跟上一系列的关键字参数。一个简单的办法是将这些选项写成一个字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">font_options = &#123;<span class="string">&#x27;family&#x27;</span> : <span class="string">&#x27;monospace&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;weight&#x27;</span> : <span class="string">&#x27;bold&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;size&#x27;</span>   : <span class="string">&#x27;small&#x27;</span>&#125;</span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, **font_options)</span><br></pre></td></tr></table></figure>
<p>要了解全部的自定义选项，请查阅matplotlib的配置文件matplotlibrc（位于matplotlib/mpl-data目录中）。如果对该文件进行了自定义，并将其放在你自己的.matplotlibrc目录中，则每次使用matplotlib时就会加载该文件。</p>
<p>下一节，我们会看到，seaborn包有若干内置的绘图主题或类型，它们使用了matplotlib的内部配置。</p>
<h2 id="使用pandas和seaborn绘图">9.2 使用pandas和seaborn绘图</h2>
<p>matplotlib实际上是一种比较低级的工具。要绘制一张图表，你组装一些基本组件就行：数据展示（即图表类型：线型图、柱状图、盒形图、散布图、等值线图等）、图例、标题、刻度标签以及其他注解型信息。</p>
<p>在pandas中，我们有多列数据，还有行和列标签。pandas自身就有内置的方法，用于简化从DataFrame和Series绘制图形。另一个库seaborn（https://seaborn.pydata.org/），由Michael Waskom创建的静态图形库。Seaborn简化了许多常见可视类型的创建。</p>
<blockquote>
<p>提示：引入seaborn会修改matplotlib默认的颜色方案和绘图类型，以提高可读性和美观度。即使你不使用seaborn API，你可能也会引入seaborn，作为提高美观度和绘制常见matplotlib图形的简化方法。</p>
</blockquote>
<h3 id="线型图">9.2.1 线型图</h3>
<p>Series和DataFrame都有一个用于生成各类图表的plot方法。默认情况下，它们所生成的是线型图（如图9-13所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: s = pd.Series(np.random.randn(<span class="number">10</span>).cumsum(), index=np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: s.plot()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-f28e5ab2ac94c7a2.png" class="" title="图9-13 简单的Series图表示例">
<p>该Series对象的索引会被传给matplotlib，并用以绘制X轴。可以通过use_index=False禁用该功能。X轴的刻度和界限可以通过xticks和xlim选项进行调节，Y轴就用yticks和ylim。plot参数的完整列表请参见表9-3。我只会讲解其中几个，剩下的就留给读者自己去研究了。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-6d9fbf863c09370a.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-44e50562aeb5eb49.png" class="" title="表9-3 Series.plot方法的参数">
<p>pandas的大部分绘图方法都有一个可选的ax参数，它可以是一个matplotlib的subplot对象。这使你能够在网格布局中更为灵活地处理subplot的位置。</p>
<p>DataFrame的plot方法会在一个subplot中为各列绘制一条线，并自动创建图例（如图9-14所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">62</span>]: df = pd.DataFrame(np.random.randn(<span class="number">10</span>, <span class="number">4</span>).cumsum(<span class="number">0</span>),</span><br><span class="line">   ....:                   columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">   ....:                   index=np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: df.plot()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-a1234d5e5ee41a40.png" class="" title="图9-14 简单的DataFrame绘图">
<p>plot属性包含一批不同绘图类型的方法。例如，df.plot()等价于df.plot.line()。后面会学习这些方法。</p>
<blockquote>
<p>笔记：plot的其他关键字参数会被传给相应的matplotlib绘图函数，所以要更深入地自定义图表，就必须学习更多有关matplotlib API的知识。</p>
</blockquote>
<p>DataFrame还有一些用于对列进行灵活处理的选项，例如，是要将所有列都绘制到一个subplot中还是创建各自的subplot。详细信息请参见表9-4。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-96651ecaa90f1c68.png" class="" title="表9-4 专用于DataFrame的plot参数">
<blockquote>
<p>注意： 有关时间序列的绘图，请见第11章。</p>
</blockquote>
<h3 id="柱状图">9.2.2 柱状图</h3>
<p>plot.bar()和plot.barh()分别绘制水平和垂直的柱状图。这时，Series和DataFrame的索引将会被用作X（bar）或Y（barh）刻度（如图9-15所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: data = pd.Series(np.random.rand(<span class="number">16</span>), index=<span class="built_in">list</span>(<span class="string">&#x27;abcdefghijklmnop&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: data.plot.bar(ax=axes[<span class="number">0</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">Out[<span class="number">66</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7fb62493d470</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: data.plot.barh(ax=axes[<span class="number">1</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-cd54c7ccfa3f0687.png" class="" title="图9-15 水平和垂直的柱状图">
<p>color='k'和alpha=0.7设定了图形的颜色为黑色，并使用部分的填充透明度。对于DataFrame，柱状图会将每一行的值分为一组，并排显示，如图9-16所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: df = pd.DataFrame(np.random.rand(<span class="number">6</span>, <span class="number">4</span>),</span><br><span class="line">   ....:                   index=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>],</span><br><span class="line">   ....:                   columns=pd.Index([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>], name=<span class="string">&#x27;Genus&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: df</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">Genus         A         B         C         D</span><br><span class="line">one    <span class="number">0.370670</span>  <span class="number">0.602792</span>  <span class="number">0.229159</span>  <span class="number">0.486744</span></span><br><span class="line">two    <span class="number">0.420082</span>  <span class="number">0.571653</span>  <span class="number">0.049024</span>  <span class="number">0.880592</span></span><br><span class="line">three  <span class="number">0.814568</span>  <span class="number">0.277160</span>  <span class="number">0.880316</span>  <span class="number">0.431326</span></span><br><span class="line">four   <span class="number">0.374020</span>  <span class="number">0.899420</span>  <span class="number">0.460304</span>  <span class="number">0.100843</span></span><br><span class="line">five   <span class="number">0.433270</span>  <span class="number">0.125107</span>  <span class="number">0.494675</span>  <span class="number">0.961825</span></span><br><span class="line">six    <span class="number">0.601648</span>  <span class="number">0.478576</span>  <span class="number">0.205690</span>  <span class="number">0.560547</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: df.plot.bar()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-bfc141acb37d99b5.png" class="" title="图9-16 DataFrame的柱状图">
<p>注意，DataFrame各列的名称"Genus"被用作了图例的标题。</p>
<p>设置stacked=True即可为DataFrame生成堆积柱状图，这样每行的值就会被堆积在一起（如图9-17所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: df.plot.barh(stacked=<span class="literal">True</span>, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-c19e4246eb897978.png" class="" title="图9-17 DataFrame的堆积柱状图">
<blockquote>
<p>笔记：柱状图有一个非常不错的用法：利用value_counts图形化显示Series中各值的出现频率，比如s.value_counts().plot.bar()。</p>
</blockquote>
<p>再以本书前面用过的那个有关小费的数据集为例，假设我们想要做一张堆积柱状图以展示每天各种聚会规模的数据点的百分比。我用read_csv将数据加载进来，然后根据日期和聚会规模创建一张交叉表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: tips = pd.read_csv(<span class="string">&#x27;examples/tips.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: party_counts = pd.crosstab(tips[<span class="string">&#x27;day&#x27;</span>], tips[<span class="string">&#x27;size&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: party_counts</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">size  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">day                      </span><br><span class="line">Fri   <span class="number">1</span>  <span class="number">16</span>   <span class="number">1</span>   <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">Sat   <span class="number">2</span>  <span class="number">53</span>  <span class="number">18</span>  <span class="number">13</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line">Sun   <span class="number">0</span>  <span class="number">39</span>  <span class="number">15</span>  <span class="number">18</span>  <span class="number">3</span>  <span class="number">1</span></span><br><span class="line">Thur  <span class="number">1</span>  <span class="number">48</span>   <span class="number">4</span>   <span class="number">5</span>  <span class="number">1</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Not many 1- and 6-person parties</span></span><br><span class="line">In [<span class="number">78</span>]: party_counts = party_counts.loc[:, <span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>然后进行规格化，使得各行的和为1，并生成图表（如图9-18所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Normalize to sum to 1</span></span><br><span class="line">In [<span class="number">79</span>]: party_pcts = party_counts.div(party_counts.<span class="built_in">sum</span>(<span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: party_pcts</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">size         <span class="number">2</span>         <span class="number">3</span>         <span class="number">4</span>         <span class="number">5</span></span><br><span class="line">day                                         </span><br><span class="line">Fri   <span class="number">0.888889</span>  <span class="number">0.055556</span>  <span class="number">0.055556</span>  <span class="number">0.000000</span></span><br><span class="line">Sat   <span class="number">0.623529</span>  <span class="number">0.211765</span>  <span class="number">0.152941</span>  <span class="number">0.011765</span></span><br><span class="line">Sun   <span class="number">0.520000</span>  <span class="number">0.200000</span>  <span class="number">0.240000</span>  <span class="number">0.040000</span></span><br><span class="line">Thur  <span class="number">0.827586</span>  <span class="number">0.068966</span>  <span class="number">0.086207</span>  <span class="number">0.017241</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: party_pcts.plot.bar()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-2918f67936823834.png" class="" title="图9-18 每天各种聚会规模的比例">
<p>于是，通过该数据集就可以看出，聚会规模在周末会变大。</p>
<p>对于在绘制一个图形之前，需要进行合计的数据，使用seaborn可以减少工作量。用seaborn来看每天的小费比例（图9-19是结果）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: <span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>] = tips[<span class="string">&#x27;tip&#x27;</span>] / (tips[<span class="string">&#x27;total_bill&#x27;</span>] - tips[<span class="string">&#x27;tip&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: tips.head()</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line">   total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="number">0</span>       <span class="number">16.99</span>  <span class="number">1.01</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.063204</span></span><br><span class="line"><span class="number">1</span>       <span class="number">10.34</span>  <span class="number">1.66</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.191244</span></span><br><span class="line"><span class="number">2</span>       <span class="number">21.01</span>  <span class="number">3.50</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.199886</span></span><br><span class="line"><span class="number">3</span>       <span class="number">23.68</span>  <span class="number">3.31</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.162494</span></span><br><span class="line"><span class="number">4</span>       <span class="number">24.59</span>  <span class="number">3.61</span>     No  Sun  Dinner     <span class="number">4</span>  <span class="number">0.172069</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: sns.barplot(x=<span class="string">&#x27;tip_pct&#x27;</span>, y=<span class="string">&#x27;day&#x27;</span>, data=tips, orient=<span class="string">&#x27;h&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-c33e8b3add99904b.png" class="" title="图9-19 小费的每日比例，带有误差条">
<p>seaborn的绘制函数使用data参数，它可能是pandas的DataFrame。其它的参数是关于列的名字。因为一天的每个值有多次观察，柱状图的值是tip_pct的平均值。绘制在柱状图上的黑线代表95%置信区间（可以通过可选参数配置）。</p>
<p>seaborn.barplot有颜色选项，使我们能够通过一个额外的值设置（见图9-20）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">88</span>]: sns.barplot(x=<span class="string">&#x27;tip_pct&#x27;</span>, y=<span class="string">&#x27;day&#x27;</span>, hue=<span class="string">&#x27;time&#x27;</span>, data=tips, orient=<span class="string">&#x27;h&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-06abe2f070222115.png" class="" title="图9-20 根据天和时间的小费比例">
<p>注意，seaborn已经自动修改了图形的美观度：默认调色板，图形背景和网格线的颜色。你可以用seaborn.set在不同的图形外观之间切换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">90</span>]: sns.<span class="built_in">set</span>(style=<span class="string">&quot;whitegrid&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="直方图和密度图">9.2.3 直方图和密度图</h3>
<p>直方图（histogram）是一种可以对值频率进行离散化显示的柱状图。数据点被拆分到离散的、间隔均匀的面元中，绘制的是各面元中数据点的数量。再以前面那个小费数据为例，通过在Series使用plot.hist方法，我们可以生成一张“小费占消费总额百分比”的直方图（如图9-21所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">92</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>].plot.hist(bins=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-255279376f7649a3.png" class="" title="图9-21 小费百分比的直方图">
<p>与此相关的一种图表类型是密度图，它是通过计算“可能会产生观测数据的连续概率分布的估计”而产生的。一般的过程是将该分布近似为一组核（即诸如正态分布之类的较为简单的分布）。因此，密度图也被称作KDE（Kernel Density Estimate，核密度估计）图。使用plot.kde和标准混合正态分布估计即可生成一张密度图（见图9-22）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>].plot.density()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-ee929d033159516a.png" class="" title="图9-22 小费百分比的密度图">
<p>seaborn的distplot方法绘制直方图和密度图更加简单，还可以同时画出直方图和连续密度估计图。作为例子，考虑一个双峰分布，由两个不同的标准正态分布组成（见图9-23）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: comp1 = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, size=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: comp2 = np.random.normal(<span class="number">10</span>, <span class="number">2</span>, size=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: values = pd.Series(np.concatenate([comp1, comp2]))</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: sns.distplot(values, bins=<span class="number">100</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-975f04d750c4efe2.png" class="" title="图9-23 标准混合密度估计的标准直方图">
<h3 id="散布图或点图">9.2.4 散布图或点图</h3>
<p>点图或散布图是观察两个一维数据序列之间的关系的有效手段。在下面这个例子中，我加载了来自statsmodels项目的macrodata数据集，选择了几个变量，然后计算对数差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">100</span>]: macro = pd.read_csv(<span class="string">&#x27;examples/macrodata.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: data = macro[[<span class="string">&#x27;cpi&#x27;</span>, <span class="string">&#x27;m1&#x27;</span>, <span class="string">&#x27;tbilrate&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: trans_data = np.log(data).diff().dropna()</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: trans_data[-<span class="number">5</span>:]</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">          cpi        m1  tbilrate     unemp</span><br><span class="line"><span class="number">198</span> -<span class="number">0.007904</span>  <span class="number">0.045361</span> -<span class="number">0.396881</span>  <span class="number">0.105361</span></span><br><span class="line"><span class="number">199</span> -<span class="number">0.021979</span>  <span class="number">0.066753</span> -<span class="number">2.277267</span>  <span class="number">0.139762</span></span><br><span class="line"><span class="number">200</span>  <span class="number">0.002340</span>  <span class="number">0.010286</span>  <span class="number">0.606136</span>  <span class="number">0.160343</span></span><br><span class="line"><span class="number">201</span>  <span class="number">0.008419</span>  <span class="number">0.037461</span> -<span class="number">0.200671</span>  <span class="number">0.127339</span></span><br><span class="line"><span class="number">202</span>  <span class="number">0.008894</span>  <span class="number">0.012202</span> -<span class="number">0.405465</span>  <span class="number">0.042560</span></span><br></pre></td></tr></table></figure>
<p>然后可以使用seaborn的regplot方法，它可以做一个散布图，并加上一条线性回归的线（见图9-24）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: sns.regplot(<span class="string">&#x27;m1&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>, data=trans_data)</span><br><span class="line">Out[<span class="number">105</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7fb613720be0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: plt.title(<span class="string">&#x27;Changes in log %s versus log %s&#x27;</span> % (<span class="string">&#x27;m1&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>))</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-2133d20739478a80.png" class="" title="图9-24 seaborn的回归&#x2F;散布图">
<p>在探索式数据分析工作中，同时观察一组变量的散布图是很有意义的，这也被称为散布图矩阵（scatter plot matrix）。纯手工创建这样的图表很费工夫，所以seaborn提供了一个便捷的pairplot函数，它支持在对角线上放置每个变量的直方图或密度估计（见图9-25）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: sns.pairplot(trans_data, diag_kind=<span class="string">&#x27;kde&#x27;</span>, plot_kws=&#123;<span class="string">&#x27;alpha&#x27;</span>: <span class="number">0.2</span>&#125;)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-20aa530a44e06f61.png" class="" title="图9-25 statsmodels macro data的散布图矩阵">
<p>你可能注意到了plot_kws参数。它可以让我们传递配置选项到非对角线元素上的图形使用。对于更详细的配置选项，可以查阅seaborn.pairplot文档字符串。</p>
<p>###分面网格（facet grid）和类型数据 要是数据集有额外的分组维度呢？有多个分类变量的数据可视化的一种方法是使用小面网格。seaborn有一个有用的内置函数factorplot，可以简化制作多种分面图（见图9-26）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: sns.factorplot(x=<span class="string">&#x27;day&#x27;</span>, y=<span class="string">&#x27;tip_pct&#x27;</span>, hue=<span class="string">&#x27;time&#x27;</span>, col=<span class="string">&#x27;smoker&#x27;</span>,</span><br><span class="line">  .....:                kind=<span class="string">&#x27;bar&#x27;</span>, data=tips[tips.tip_pct &lt; <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-737ba19a0cbdd46f.png" class="" title="图9-26 按照天&#x2F;时间&#x2F;吸烟者的小费百分比">
<p>除了在分面中用不同的颜色按时间分组，我们还可以通过给每个时间值添加一行来扩展分面网格：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: sns.factorplot(x=<span class="string">&#x27;day&#x27;</span>, y=<span class="string">&#x27;tip_pct&#x27;</span>, row=<span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">   .....:                col=<span class="string">&#x27;smoker&#x27;</span>,</span><br><span class="line">   .....:                kind=<span class="string">&#x27;bar&#x27;</span>, data=tips[tips.tip_pct &lt; <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-4e52192441c609f7.png" class="" title="图9-27 按天的tip_pct，通过time&#x2F;smoker分面">
<p>factorplot支持其它的绘图类型，你可能会用到。例如，盒图（它可以显示中位数，四分位数，和异常值）就是一个有用的可视化类型（见图9-28）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: sns.factorplot(x=<span class="string">&#x27;tip_pct&#x27;</span>, y=<span class="string">&#x27;day&#x27;</span>, kind=<span class="string">&#x27;box&#x27;</span>,</span><br><span class="line">   .....:                data=tips[tips.tip_pct &lt; <span class="number">0.5</span>])</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap09/7178691-356fb27a7c658920.png" class="" title="图9-28 按天的tip_pct的盒图">
<p>使用更通用的seaborn.FacetGrid类，你可以创建自己的分面网格。请查阅seaborn的文档（https://seaborn.pydata.org/）。</p>
<h2 id="其它的python可视化工具">9.3 其它的Python可视化工具</h2>
<p>与其它开源库类似，Python创建图形的方式非常多（根本罗列不完）。自从2010年，许多开发工作都集中在创建交互式图形以便在Web上发布。利用工具如Boken（https://bokeh.pydata.org/en/latest/）和Plotly（https://github.com/plotly/plotly.py），现在可以创建动态交互图形，用于网页浏览器。</p>
<p>对于创建用于打印或网页的静态图形，我建议默认使用matplotlib和附加的库，比如pandas和seaborn。对于其它数据可视化要求，学习其它的可用工具可能是有用的。我鼓励你探索绘图的生态系统，因为它将持续发展。</p>
<h2 id="总结">9.4 总结</h2>
<p>本章的目的是熟悉一些基本的数据可视化操作，使用pandas，matplotlib，和seaborn。如果视觉显示数据分析的结果对你的工作很重要，我鼓励你寻求更多的资源来了解更高效的数据可视化。这是一个活跃的研究领域，你可以通过在线和纸质的形式学习许多优秀的资源。</p>
<p>下一章，我们将重点放在pandas的数据聚合和分组操作上。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第08章_数据规整：聚合、合并和重塑</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap08/</url>
    <content><![CDATA[<h1 id="第08章-数据规整聚合合并和重塑">第08章 数据规整：聚合、合并和重塑</h1>
<p>在许多应用中，数据可能分散在许多文件或数据库中，存储的形式也不利于分析。本章关注可以聚合、合并、重塑数据的方法。</p>
<span id="more"></span>
<p>首先，我会介绍pandas的层次化索引，它广泛用于以上操作。然后，我深入介绍了一些特殊的数据操作。在第14章，你可以看到这些工具的多种应用。</p>
<h2 id="层次化索引">8.1 层次化索引</h2>
<p>层次化索引（hierarchical indexing）是pandas的一项重要功能，它使你能在一个轴上拥有多个（两个以上）索引级别。抽象点说，它使你能以低维度形式处理高维度数据。我们先来看一个简单的例子：创建一个Series，并用一个由列表或数组组成的列表作为索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: data = pd.Series(np.random.randn(<span class="number">9</span>),</span><br><span class="line">   ...:                  index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ...:                         [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: data</span><br><span class="line">Out[<span class="number">10</span>]: </span><br><span class="line">a  <span class="number">1</span>   -<span class="number">0.204708</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.478943</span></span><br><span class="line">   <span class="number">3</span>   -<span class="number">0.519439</span></span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1</span>    <span class="number">1.393406</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.092908</span></span><br><span class="line">d  <span class="number">2</span>    <span class="number">0.281746</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.769023</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>看到的结果是经过美化的带有MultiIndex索引的Series的格式。索引之间的“间隔”表示“直接使用上面的标签”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: data.index</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">MultiIndex(levels=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]],</span><br><span class="line">           labels=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>对于一个层次化索引的对象，可以使用所谓的部分索引，使用它选取数据子集的操作更简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: data[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: data[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1</span>    <span class="number">1.393406</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.092908</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: data.loc[[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]]</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">d  <span class="number">2</span>    <span class="number">0.281746</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.769023</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>有时甚至还可以在“内层”中进行选取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: data.loc[:, <span class="number">2</span>]</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">a    <span class="number">0.478943</span></span><br><span class="line">c    <span class="number">0.092908</span></span><br><span class="line">d    <span class="number">0.281746</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>层次化索引在数据重塑和基于分组的操作（如透视表生成）中扮演着重要的角色。例如，可以通过unstack方法将这段数据重新安排到一个DataFrame中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: data.unstack()</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">          <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line">a -<span class="number">0.204708</span>  <span class="number">0.478943</span> -<span class="number">0.519439</span></span><br><span class="line">b -<span class="number">0.555730</span>       NaN  <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1.393406</span>  <span class="number">0.092908</span>       NaN</span><br><span class="line">d       NaN  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br></pre></td></tr></table></figure>
<p>unstack的逆运算是stack：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: data.unstack().stack()</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">a  <span class="number">1</span>   -<span class="number">0.204708</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.478943</span></span><br><span class="line">   <span class="number">3</span>   -<span class="number">0.519439</span></span><br><span class="line">b  <span class="number">1</span>   -<span class="number">0.555730</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">1.965781</span></span><br><span class="line">c  <span class="number">1</span>    <span class="number">1.393406</span></span><br><span class="line">   <span class="number">2</span>    <span class="number">0.092908</span></span><br><span class="line">d  <span class="number">2</span>    <span class="number">0.281746</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">0.769023</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>stack和unstack将在本章后面详细讲解。</p>
<p>对于一个DataFrame，每条轴都可以有分层索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: frame = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">   ....:                      index=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">   ....:                      columns=[[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>],</span><br><span class="line">   ....:                               [<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: frame</span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line">     Ohio     Colorado</span><br><span class="line">    Green Red    Green</span><br><span class="line">a <span class="number">1</span>     <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">b <span class="number">1</span>     <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>各层都可以有名字（可以是字符串，也可以是别的Python对象）。如果指定了名称，它们就会显示在控制台输出中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: frame.index.names = [<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: frame.columns.names = [<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;color&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: frame</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key1 key2                   </span><br><span class="line">a    <span class="number">1</span>        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">     <span class="number">2</span>        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">b    <span class="number">1</span>        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line">     <span class="number">2</span>        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：小心区分索引名state、color与行标签。</p>
</blockquote>
<p>有了部分列索引，因此可以轻松选取列分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: frame[<span class="string">&#x27;Ohio&#x27;</span>]</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">color      Green  Red</span><br><span class="line">key1 key2            </span><br><span class="line">a    <span class="number">1</span>         <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>         <span class="number">3</span>    <span class="number">4</span></span><br><span class="line">b    <span class="number">1</span>         <span class="number">6</span>    <span class="number">7</span></span><br><span class="line">     <span class="number">2</span>         <span class="number">9</span>   <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>可以单独创建MultiIndex然后复用。上面那个DataFrame中的（带有分级名称）列可以这样创建：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MultiIndex.from_arrays([[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>], [<span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Red&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>]],</span><br><span class="line">                       names=[<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;color&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="重排与分级排序">8.1.1 重排与分级排序</h3>
<p>有时，你需要重新调整某条轴上各级别的顺序，或根据指定级别上的值对数据进行排序。swaplevel接受两个级别编号或名称，并返回一个互换了级别的新对象（但数据不会发生变化）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: frame.swaplevel(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>)</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key2 key1                   </span><br><span class="line"><span class="number">1</span>    a        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line"><span class="number">2</span>    a        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line"><span class="number">1</span>    b        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line"><span class="number">2</span>    b        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>而sort_index则根据单个级别中的值对数据进行排序。交换级别时，常常也会用到sort_index，这样最终结果就是按照指定顺序进行字母排序了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: frame.sort_index(level=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key1 key2                   </span><br><span class="line">a    <span class="number">1</span>        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">b    <span class="number">1</span>        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line">a    <span class="number">2</span>        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">b    <span class="number">2</span>        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: frame.swaplevel(<span class="number">0</span>, <span class="number">1</span>).sort_index(level=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">26</span>]: </span><br><span class="line">state      Ohio     Colorado</span><br><span class="line">color     Green Red    Green</span><br><span class="line">key2 key1                   </span><br><span class="line"><span class="number">1</span>    a        <span class="number">0</span>   <span class="number">1</span>        <span class="number">2</span></span><br><span class="line">     b        <span class="number">6</span>   <span class="number">7</span>        <span class="number">8</span></span><br><span class="line"><span class="number">2</span>    a        <span class="number">3</span>   <span class="number">4</span>        <span class="number">5</span></span><br><span class="line">     b        <span class="number">9</span>  <span class="number">10</span>       <span class="number">11</span></span><br></pre></td></tr></table></figure>
<h3 id="根据级别汇总统计">8.1.2 根据级别汇总统计</h3>
<p>许多对DataFrame和Series的描述和汇总统计都有一个level选项，它用于指定在某条轴上求和的级别。再以上面那个DataFrame为例，我们可以根据行或列上的级别来进行求和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: frame.<span class="built_in">sum</span>(level=<span class="string">&#x27;key2&#x27;</span>)</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">state  Ohio     Colorado</span><br><span class="line">color Green Red    Green</span><br><span class="line">key2                    </span><br><span class="line"><span class="number">1</span>         <span class="number">6</span>   <span class="number">8</span>       <span class="number">10</span></span><br><span class="line"><span class="number">2</span>        <span class="number">12</span>  <span class="number">14</span>       <span class="number">16</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: frame.<span class="built_in">sum</span>(level=<span class="string">&#x27;color&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">color      Green  Red</span><br><span class="line">key1 key2            </span><br><span class="line">a    <span class="number">1</span>         <span class="number">2</span>    <span class="number">1</span></span><br><span class="line">     <span class="number">2</span>         <span class="number">8</span>    <span class="number">4</span></span><br><span class="line">b    <span class="number">1</span>        <span class="number">14</span>    <span class="number">7</span></span><br><span class="line">     <span class="number">2</span>        <span class="number">20</span>   <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>这其实是利用了pandas的groupby功能，本书稍后将对其进行详细讲解。</p>
<h3 id="使用dataframe的列进行索引">8.1.3 使用DataFrame的列进行索引</h3>
<p>人们经常想要将DataFrame的一个或多个列当做行索引来用，或者可能希望将行索引变成DataFrame的列。以下面这个DataFrame为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>), <span class="string">&#x27;b&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>, <span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">   ....:                       <span class="string">&#x27;c&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">   ....:                             <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;d&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: frame</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">   a  b    c  d</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span>  one  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span>  one  <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span>  one  <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3</span>  <span class="number">4</span>  two  <span class="number">0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">4</span>  <span class="number">3</span>  two  <span class="number">1</span></span><br><span class="line"><span class="number">5</span>  <span class="number">5</span>  <span class="number">2</span>  two  <span class="number">2</span></span><br><span class="line"><span class="number">6</span>  <span class="number">6</span>  <span class="number">1</span>  two  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>DataFrame的set_index函数会将其一个或多个列转换为行索引，并创建一个新的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: frame2 = frame.set_index([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: frame2</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">       a  b</span><br><span class="line">c   d      </span><br><span class="line">one <span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line">two <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">5</span>  <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>  <span class="number">6</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，那些列会从DataFrame中移除，但也可以将其保留下来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: frame.set_index([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], drop=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">       a  b    c  d</span><br><span class="line">c   d              </span><br><span class="line">one <span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span>  one  <span class="number">0</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span>  one  <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span>  one  <span class="number">2</span></span><br><span class="line">two <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span>  two  <span class="number">0</span></span><br><span class="line">    <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span>  two  <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>  <span class="number">5</span>  <span class="number">2</span>  two  <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>  <span class="number">6</span>  <span class="number">1</span>  two  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>reset_index的功能跟set_index刚好相反，层次化索引的级别会被转移到列里面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: frame2.reset_index()</span><br><span class="line">Out[<span class="number">34</span>]:</span><br><span class="line">c  d  a  b</span><br><span class="line"><span class="number">0</span>  one  <span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span></span><br><span class="line"><span class="number">1</span>  one  <span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  one  <span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span></span><br><span class="line"><span class="number">3</span>  two  <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  two  <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  two  <span class="number">2</span>  <span class="number">5</span>  <span class="number">2</span></span><br><span class="line"><span class="number">6</span>  two  <span class="number">3</span>  <span class="number">6</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="合并数据集">8.2 合并数据集</h2>
<p>pandas对象中的数据可以通过一些方式进行合并：</p>
<ul>
<li>pandas.merge可根据一个或多个键将不同DataFrame中的行连接起来。SQL或其他关系型数据库的用户对此应该会比较熟悉，因为它实现的就是数据库的join操作。</li>
<li>pandas.concat可以沿着一条轴将多个对象堆叠到一起。</li>
<li>实例方法combine_first可以将重复数据拼接在一起，用一个对象中的值填充另一个对象中的缺失值。</li>
</ul>
<p>我将分别对它们进行讲解，并给出一些例子。本书剩余部分的示例中将经常用到它们。</p>
<p>###数据库风格的DataFrame合并</p>
<p>数据集的合并（merge）或连接（join）运算是通过一个或多个键将行连接起来的。这些运算是关系型数据库（基于SQL）的核心。pandas的merge函数是对数据应用这些算法的主要切入点。</p>
<p>以一个简单的例子开始：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: df1</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">   data1 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   c</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a</span><br><span class="line"><span class="number">6</span>      <span class="number">6</span>   b</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: df2</span><br><span class="line">Out[<span class="number">38</span>]: </span><br><span class="line">   data2 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   a</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   d</span><br></pre></td></tr></table></figure>
<p>这是一种多对一的合并。df1中的数据有多个被标记为a和b的行，而df2中key列的每个值则仅对应一行。对这些对象调用merge即可得到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: pd.merge(df1, df2)</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a      <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>注意，我并没有指明要用哪个列进行连接。如果没有指定，merge就会将重叠列的列名当做键。不过，最好明确指定一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a      <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果两个对象的列名不同，也可以分别进行指定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: df3 = pd.DataFrame(&#123;<span class="string">&#x27;lkey&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: df4 = pd.DataFrame(&#123;<span class="string">&#x27;rkey&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: pd.merge(df3, df4, left_on=<span class="string">&#x27;lkey&#x27;</span>, right_on=<span class="string">&#x27;rkey&#x27;</span>)</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">   data1 lkey  data2 rkey</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>    a      <span class="number">0</span>    a</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>    a      <span class="number">0</span>    a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>    a      <span class="number">0</span>    a</span><br></pre></td></tr></table></figure>
<p>可能你已经注意到了，结果里面c和d以及与之相关的数据消失了。默认情况下，merge做的是“内连接”；结果中的键是交集。其他方式还有"left"、"right"以及"outer"。外连接求取的是键的并集，组合了左连接和右连接的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: pd.merge(df1, df2, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">5.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">3.0</span>   c    NaN</span><br><span class="line"><span class="number">7</span>    NaN   d    <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>表8-1对这些选项进行了总结。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap08/7178691-e49b3341f4a3c90e.png" class="" title="表8-1 不同的连接类型">
<p>多对多的合并有些不直观。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">   ....:                     <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: df1</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line">   data1 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   c</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   b</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: df2</span><br><span class="line">Out[<span class="number">48</span>]: </span><br><span class="line">   data2 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   a</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   b</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   d</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">Out[<span class="number">49</span>]: </span><br><span class="line">    data1 key  data2</span><br><span class="line"><span class="number">0</span>       <span class="number">0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>       <span class="number">0</span>   b    <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>       <span class="number">1</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>       <span class="number">1</span>   b    <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>       <span class="number">2</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>       <span class="number">2</span>   a    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>       <span class="number">3</span>   c    NaN</span><br><span class="line"><span class="number">7</span>       <span class="number">4</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">8</span>       <span class="number">4</span>   a    <span class="number">2.0</span></span><br><span class="line"><span class="number">9</span>       <span class="number">5</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">10</span>      <span class="number">5</span>   b    <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>多对多连接产生的是行的笛卡尔积。由于左边的DataFrame有3个"b"行，右边的有2个，所以最终结果中就有6个"b"行。连接方式只影响出现在结果中的不同的键的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: pd.merge(df1, df2, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>   b      <span class="number">3</span></span><br><span class="line"><span class="number">2</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">1</span>   b      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>      <span class="number">5</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   b      <span class="number">3</span></span><br><span class="line"><span class="number">6</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">7</span>      <span class="number">2</span>   a      <span class="number">2</span></span><br><span class="line"><span class="number">8</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">9</span>      <span class="number">4</span>   a      <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>要根据多个键进行合并，传入一个由列名组成的列表即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: left = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">   ....:                      <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   ....:                      <span class="string">&#x27;lval&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: right = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;rval&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: pd.merge(left, right, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">  key1 key2  lval  rval</span><br><span class="line"><span class="number">0</span>  foo  one   <span class="number">1.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>  foo  one   <span class="number">1.0</span>   <span class="number">5.0</span></span><br><span class="line"><span class="number">2</span>  foo  two   <span class="number">2.0</span>   NaN</span><br><span class="line"><span class="number">3</span>  bar  one   <span class="number">3.0</span>   <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  bar  two   NaN   <span class="number">7.0</span></span><br></pre></td></tr></table></figure>
<p>结果中会出现哪些键组合取决于所选的合并方式，你可以这样来理解：多个键形成一系列元组，并将其当做单个连接键（当然，实际上并不是这么回事）。</p>
<blockquote>
<p>注意：在进行列－列连接时，DataFrame对象中的索引会被丢弃。</p>
</blockquote>
<p>对于合并运算需要考虑的最后一个问题是对重复列名的处理。虽然你可以手工处理列名重叠的问题（查看前面介绍的重命名轴标签），但merge有一个更实用的suffixes选项，用于指定附加到左右两个DataFrame对象的重叠列名上的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: pd.merge(left, right, on=<span class="string">&#x27;key1&#x27;</span>)</span><br><span class="line">Out[<span class="number">54</span>]: </span><br><span class="line">  key1 key2_x  lval key2_y  rval</span><br><span class="line"><span class="number">0</span>  foo    one     <span class="number">1</span>    one     <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  foo    one     <span class="number">1</span>    one     <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  foo    two     <span class="number">2</span>    one     <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  foo    two     <span class="number">2</span>    one     <span class="number">5</span></span><br><span class="line"><span class="number">4</span>  bar    one     <span class="number">3</span>    one     <span class="number">6</span></span><br><span class="line"><span class="number">5</span>  bar    one     <span class="number">3</span>    two     <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: pd.merge(left, right, on=<span class="string">&#x27;key1&#x27;</span>, suffixes=(<span class="string">&#x27;_left&#x27;</span>, <span class="string">&#x27;_right&#x27;</span>))</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">  key1 key2_left  lval key2_right  rval</span><br><span class="line"><span class="number">0</span>  foo       one     <span class="number">1</span>        one     <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  foo       one     <span class="number">1</span>        one     <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  foo       two     <span class="number">2</span>        one     <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  foo       two     <span class="number">2</span>        one     <span class="number">5</span></span><br><span class="line"><span class="number">4</span>  bar       one     <span class="number">3</span>        one     <span class="number">6</span></span><br><span class="line"><span class="number">5</span>  bar       one     <span class="number">3</span>        two     <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>merge的参数请参见表8-2。使用DataFrame的行索引合并是下一节的主题。</p>
<p>表8-2 merge函数的参数</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap08/7178691-35ca716a4f1b8475.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap08/7178691-c86672e733ceccd9.png" class="">
<p>indicator 添加特殊的列_merge，它可以指明每个行的来源，它的值有left_only、right_only或both，根据每行的合并数据的来源。</p>
<h3 id="索引上的合并">8.2.1 索引上的合并</h3>
<p>有时候，DataFrame中的连接键位于其索引中。在这种情况下，你可以传入left_index=True或right_index=True（或两个都传）以说明索引应该被用作连接键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: left1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;value&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: right1 = pd.DataFrame(&#123;<span class="string">&#x27;group_val&#x27;</span>: [<span class="number">3.5</span>, <span class="number">7</span>]&#125;, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: left1</span><br><span class="line">Out[<span class="number">58</span>]:</span><br><span class="line"></span><br><span class="line">  key  value</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span></span><br><span class="line"><span class="number">5</span>   c      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: right1</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line">   group_val</span><br><span class="line">a        <span class="number">3.5</span></span><br><span class="line">b        <span class="number">7.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">  key  value  group_val</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span>        <span class="number">7.0</span></span><br></pre></td></tr></table></figure>
<p>由于默认的merge方法是求取连接键的交集，因此你可以通过外连接的方式得到它们的并集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>, right_index=<span class="literal">True</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">61</span>]: </span><br><span class="line">  key  value  group_val</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">5</span>   c      <span class="number">5</span>        NaN</span><br></pre></td></tr></table></figure>
<p>对于层次化索引的数据，事情就有点复杂了，因为索引的合并默认是多键合并：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">62</span>]: lefth = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>,</span><br><span class="line">   ....:                                <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;key2&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>],</span><br><span class="line">   ....:                       <span class="string">&#x27;data&#x27;</span>: np.arange(<span class="number">5.</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: righth = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">6</span>, <span class="number">2</span>)),</span><br><span class="line">   ....:                       index=[[<span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>,</span><br><span class="line">   ....:                               <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>],</span><br><span class="line">   ....:                              [<span class="number">2001</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>]],</span><br><span class="line">   ....:                       columns=[<span class="string">&#x27;event1&#x27;</span>, <span class="string">&#x27;event2&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: lefth</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">   data    key1  key2</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>    Ohio  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>    Ohio  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>   <span class="number">3.0</span>  Nevada  <span class="number">2001</span></span><br><span class="line"><span class="number">4</span>   <span class="number">4.0</span>  Nevada  <span class="number">2002</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: righth</span><br><span class="line">Out[<span class="number">65</span>]: </span><br><span class="line">             event1  event2</span><br><span class="line">Nevada <span class="number">2001</span>       <span class="number">0</span>       <span class="number">1</span></span><br><span class="line">       <span class="number">2000</span>       <span class="number">2</span>       <span class="number">3</span></span><br><span class="line">Ohio   <span class="number">2000</span>       <span class="number">4</span>       <span class="number">5</span></span><br><span class="line">       <span class="number">2000</span>       <span class="number">6</span>       <span class="number">7</span></span><br><span class="line">       <span class="number">2001</span>       <span class="number">8</span>       <span class="number">9</span></span><br><span class="line">       <span class="number">2002</span>      <span class="number">10</span>      <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，你必须以列表的形式指明用作合并键的多个列（注意用how='outer'对重复索引值的处理）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: pd.merge(lefth, righth, left_on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], right_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">66</span>]: </span><br><span class="line">   data    key1  key2  event1  event2</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>       <span class="number">4</span>       <span class="number">5</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>       <span class="number">6</span>       <span class="number">7</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>    Ohio  <span class="number">2001</span>       <span class="number">8</span>       <span class="number">9</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>    Ohio  <span class="number">2002</span>      <span class="number">10</span>      <span class="number">11</span></span><br><span class="line"><span class="number">3</span>   <span class="number">3.0</span>  Nevada  <span class="number">2001</span>       <span class="number">0</span>       <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: pd.merge(lefth, righth, left_on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>],</span><br><span class="line">   ....:          right_index=<span class="literal">True</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">   data    key1  key2  event1  event2</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>     <span class="number">4.0</span>     <span class="number">5.0</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>    Ohio  <span class="number">2000</span>     <span class="number">6.0</span>     <span class="number">7.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1.0</span>    Ohio  <span class="number">2001</span>     <span class="number">8.0</span>     <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2.0</span>    Ohio  <span class="number">2002</span>    <span class="number">10.0</span>    <span class="number">11.0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">3.0</span>  Nevada  <span class="number">2001</span>     <span class="number">0.0</span>     <span class="number">1.0</span></span><br><span class="line"><span class="number">4</span>   <span class="number">4.0</span>  Nevada  <span class="number">2002</span>     NaN     NaN</span><br><span class="line"><span class="number">4</span>   NaN  Nevada  <span class="number">2000</span>     <span class="number">2.0</span>     <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<p>同时使用合并双方的索引也没问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: left2 = pd.DataFrame([[<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">3.</span>, <span class="number">4.</span>], [<span class="number">5.</span>, <span class="number">6.</span>]],</span><br><span class="line">   ....:                      index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">   ....:                      columns=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: right2 = pd.DataFrame([[<span class="number">7.</span>, <span class="number">8.</span>], [<span class="number">9.</span>, <span class="number">10.</span>], [<span class="number">11.</span>, <span class="number">12.</span>], [<span class="number">13</span>, <span class="number">14</span>]],</span><br><span class="line">   ....:                       index=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">   ....:                       columns=[<span class="string">&#x27;Missouri&#x27;</span>, <span class="string">&#x27;Alabama&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: left2</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">   Ohio  Nevada</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: right2</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">   Missouri  Alabama</span><br><span class="line">b       <span class="number">7.0</span>      <span class="number">8.0</span></span><br><span class="line">c       <span class="number">9.0</span>     <span class="number">10.0</span></span><br><span class="line">d      <span class="number">11.0</span>     <span class="number">12.0</span></span><br><span class="line">e      <span class="number">13.0</span>     <span class="number">14.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: pd.merge(left2, right2, how=<span class="string">&#x27;outer&#x27;</span>, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN</span><br><span class="line">b   NaN     NaN       <span class="number">7.0</span>      <span class="number">8.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span></span><br><span class="line">d   NaN     NaN      <span class="number">11.0</span>     <span class="number">12.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span></span><br></pre></td></tr></table></figure>
<p>DataFrame还有一个便捷的join实例方法，它能更为方便地实现按索引合并。它还可用于合并多个带有相同或相似索引的DataFrame对象，但要求没有重叠的列。在上面那个例子中，我们可以编写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: left2.join(right2, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">73</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN</span><br><span class="line">b   NaN     NaN       <span class="number">7.0</span>      <span class="number">8.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span></span><br><span class="line">d   NaN     NaN      <span class="number">11.0</span>     <span class="number">12.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span></span><br></pre></td></tr></table></figure>
<p>因为一些历史版本的遗留原因，DataFrame的join方法默认使用的是左连接，保留左边表的行索引。它还支持在调用的DataFrame的列上，连接传递的DataFrame索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: left1.join(right1, on=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">  key  value  group_val</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">5</span>   c      <span class="number">5</span>        NaN</span><br></pre></td></tr></table></figure>
<p>最后，对于简单的索引合并，你还可以向join传入一组DataFrame，下一节会介绍更为通用的concat函数，也能实现此功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: another = pd.DataFrame([[<span class="number">7.</span>, <span class="number">8.</span>], [<span class="number">9.</span>, <span class="number">10.</span>], [<span class="number">11.</span>, <span class="number">12.</span>], [<span class="number">16.</span>, <span class="number">17.</span>]],</span><br><span class="line">   ....:                        index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>],</span><br><span class="line">   ....:                        columns=[<span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: another</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">   New York  Oregon</span><br><span class="line">a       <span class="number">7.0</span>     <span class="number">8.0</span></span><br><span class="line">c       <span class="number">9.0</span>    <span class="number">10.0</span></span><br><span class="line">e      <span class="number">11.0</span>    <span class="number">12.0</span></span><br><span class="line">f      <span class="number">16.0</span>    <span class="number">17.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: left2.join([right2, another])</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama  New York  Oregon</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN       <span class="number">7.0</span>     <span class="number">8.0</span></span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span>       <span class="number">9.0</span>    <span class="number">10.0</span></span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span>      <span class="number">11.0</span>    <span class="number">12.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: left2.join([right2, another], how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">   Ohio  Nevada  Missouri  Alabama  New York  Oregon</span><br><span class="line">a   <span class="number">1.0</span>     <span class="number">2.0</span>       NaN      NaN       <span class="number">7.0</span>     <span class="number">8.0</span></span><br><span class="line">b   NaN     NaN       <span class="number">7.0</span>      <span class="number">8.0</span>       NaN     NaN</span><br><span class="line">c   <span class="number">3.0</span>     <span class="number">4.0</span>       <span class="number">9.0</span>     <span class="number">10.0</span>       <span class="number">9.0</span>    <span class="number">10.0</span></span><br><span class="line">d   NaN     NaN      <span class="number">11.0</span>     <span class="number">12.0</span>       NaN     NaN</span><br><span class="line">e   <span class="number">5.0</span>     <span class="number">6.0</span>      <span class="number">13.0</span>     <span class="number">14.0</span>      <span class="number">11.0</span>    <span class="number">12.0</span></span><br><span class="line">f   NaN     NaN       NaN      NaN      <span class="number">16.0</span>    <span class="number">17.0</span></span><br></pre></td></tr></table></figure>
<h3 id="轴向连接">8.2.2 轴向连接</h3>
<p>另一种数据合并运算也被称作连接（concatenation）、绑定（binding）或堆叠（stacking）。NumPy的concatenation函数可以用NumPy数组来做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: arr</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: np.concatenate([arr, arr], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>
<p>对于pandas对象（如Series和DataFrame），带有标签的轴使你能够进一步推广数组的连接运算。具体点说，你还需要考虑以下这些东西：</p>
<ul>
<li>如果对象在其它轴上的索引不同，我们应该合并这些轴的不同元素还是只使用交集？</li>
<li>连接的数据集是否需要在结果对象中可识别？</li>
<li>连接轴中保存的数据是否需要保留？许多情况下，DataFrame默认的整数标签最好在连接时删掉。</li>
</ul>
<p>pandas的concat函数提供了一种能够解决这些问题的可靠方式。我将给出一些例子来讲解其使用方式。假设有三个没有重叠索引的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: s2 = pd.Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: s3 = pd.Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>对这些对象调用concat可以将值和索引粘合在一起：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: pd.concat([s1, s2, s3])</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">b    <span class="number">1</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">d    <span class="number">3</span></span><br><span class="line">e    <span class="number">4</span></span><br><span class="line">f    <span class="number">5</span></span><br><span class="line">g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>默认情况下，concat是在axis=0上工作的，最终产生一个新的Series。如果传入axis=1，则结果就会变成一个DataFrame（axis=1是列）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">86</span>]: pd.concat([s1, s2, s3], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">a  <span class="number">0.0</span>  NaN  NaN</span><br><span class="line">b  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line">c  NaN  <span class="number">2.0</span>  NaN</span><br><span class="line">d  NaN  <span class="number">3.0</span>  NaN</span><br><span class="line">e  NaN  <span class="number">4.0</span>  NaN</span><br><span class="line">f  NaN  NaN  <span class="number">5.0</span></span><br><span class="line">g  NaN  NaN  <span class="number">6.0</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，另外的轴上没有重叠，从索引的有序并集（外连接）上就可以看出来。传入join='inner'即可得到它们的交集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: s4 = pd.concat([s1, s3])</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: s4</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">b    <span class="number">1</span></span><br><span class="line">f    <span class="number">5</span></span><br><span class="line">g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: pd.concat([s1, s4], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">89</span>]: </span><br><span class="line">     <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">a  <span class="number">0.0</span>  <span class="number">0</span></span><br><span class="line">b  <span class="number">1.0</span>  <span class="number">1</span></span><br><span class="line">f  NaN  <span class="number">5</span></span><br><span class="line">g  NaN  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: pd.concat([s1, s4], axis=<span class="number">1</span>, join=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">a  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">b  <span class="number">1</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，f和g标签消失了，是因为使用的是join='inner'选项。</p>
<p>你可以通过join_axes指定要在其它轴上使用的索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: pd.concat([s1, s4], axis=<span class="number">1</span>, join_axes=[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]])</span><br><span class="line">Out[<span class="number">91</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">a  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">c  NaN  NaN</span><br><span class="line">b  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line">e  NaN  NaN</span><br></pre></td></tr></table></figure>
<p>不过有个问题，参与连接的片段在结果中区分不开。假设你想要在连接轴上创建一个层次化索引。使用keys参数即可达到这个目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">92</span>]: result = pd.concat([s1, s1, s3], keys=[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: result</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line">one    a    <span class="number">0</span></span><br><span class="line">       b    <span class="number">1</span></span><br><span class="line">two    a    <span class="number">0</span></span><br><span class="line">       b    <span class="number">1</span></span><br><span class="line">three  f    <span class="number">5</span></span><br><span class="line">       g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: result.unstack()</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line">         a    b    f    g</span><br><span class="line">one    <span class="number">0.0</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line">two    <span class="number">0.0</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line">three  NaN  NaN  <span class="number">5.0</span>  <span class="number">6.0</span></span><br></pre></td></tr></table></figure>
<p>如果沿着axis=1对Series进行合并，则keys就会成为DataFrame的列头：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: pd.concat([s1, s2, s3], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line">   one  two  three</span><br><span class="line">a  <span class="number">0.0</span>  NaN    NaN</span><br><span class="line">b  <span class="number">1.0</span>  NaN    NaN</span><br><span class="line">c  NaN  <span class="number">2.0</span>    NaN</span><br><span class="line">d  NaN  <span class="number">3.0</span>    NaN</span><br><span class="line">e  NaN  <span class="number">4.0</span>    NaN</span><br><span class="line">f  NaN  NaN    <span class="number">5.0</span></span><br><span class="line">g  NaN  NaN    <span class="number">6.0</span></span><br></pre></td></tr></table></figure>
<p>同样的逻辑也适用于DataFrame对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: df1 = pd.DataFrame(np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">   ....:                    columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: df2 = pd.DataFrame(<span class="number">5</span> + np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">   ....:                    columns=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: df1</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">   one  two</span><br><span class="line">a    <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">c    <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: df2</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">   three  four</span><br><span class="line">a      <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">c      <span class="number">7</span>     <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;level1&#x27;</span>, <span class="string">&#x27;level2&#x27;</span>])</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">  level1     level2     </span><br><span class="line">     one two  three four</span><br><span class="line">a      <span class="number">0</span>   <span class="number">1</span>    <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line">b      <span class="number">2</span>   <span class="number">3</span>    NaN  NaN</span><br><span class="line">c      <span class="number">4</span>   <span class="number">5</span>    <span class="number">7.0</span>  <span class="number">8.0</span></span><br></pre></td></tr></table></figure>
<p>如果传入的不是列表而是一个字典，则字典的键就会被当做keys选项的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: pd.concat(&#123;<span class="string">&#x27;level1&#x27;</span>: df1, <span class="string">&#x27;level2&#x27;</span>: df2&#125;, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">  level1     level2     </span><br><span class="line">     one two  three four</span><br><span class="line">a      <span class="number">0</span>   <span class="number">1</span>    <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line">b      <span class="number">2</span>   <span class="number">3</span>    NaN  NaN</span><br><span class="line">c      <span class="number">4</span>   <span class="number">5</span>    <span class="number">7.0</span>  <span class="number">8.0</span></span><br></pre></td></tr></table></figure>
<p>此外还有两个用于管理层次化索引创建方式的参数（参见表8-3）。举个例子，我们可以用names参数命名创建的轴级别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;level1&#x27;</span>, <span class="string">&#x27;level2&#x27;</span>],</span><br><span class="line">   .....:           names=[<span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>])</span><br><span class="line">Out[<span class="number">102</span>]: </span><br><span class="line">upper level1     level2     </span><br><span class="line">lower    one two  three four</span><br><span class="line">a          <span class="number">0</span>   <span class="number">1</span>    <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line">b          <span class="number">2</span>   <span class="number">3</span>    NaN  NaN</span><br><span class="line">c          <span class="number">4</span>   <span class="number">5</span>    <span class="number">7.0</span>  <span class="number">8.0</span></span><br></pre></td></tr></table></figure>
<p>最后一个关于DataFrame的问题是，DataFrame的行索引不包含任何相关数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">103</span>]: df1 = pd.DataFrame(np.random.randn(<span class="number">3</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: df2 = pd.DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">3</span>), columns=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: df1</span><br><span class="line">Out[<span class="number">105</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>  <span class="number">1.246435</span>  <span class="number">1.007189</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: df2</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">          b         d         a</span><br><span class="line"><span class="number">0</span>  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.577087</span>  <span class="number">0.124121</span>  <span class="number">0.302614</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，传入ignore_index=True即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: pd.concat([df1, df2], ignore_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">107</span>]: </span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span>  <span class="number">1.246435</span>  <span class="number">1.007189</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span> -<span class="number">0.539741</span></span><br><span class="line"><span class="number">3</span> -<span class="number">1.021228</span>  <span class="number">0.476985</span>       NaN  <span class="number">3.248944</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.302614</span> -<span class="number">0.577087</span>       NaN  <span class="number">0.124121</span></span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap08/7178691-339436563b519415.png" class="" title="表8-3 concat函数的参数">
<h3 id="合并重叠数据">8.2.3 合并重叠数据</h3>
<p>还有一种数据组合问题不能用简单的合并（merge）或连接（concatenation）运算来处理。比如说，你可能有索引全部或部分重叠的两个数据集。举个有启发性的例子，我们使用NumPy的where函数，它表示一种等价于面向数组的if-else：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: a = pd.Series([np.nan, <span class="number">2.5</span>, np.nan, <span class="number">3.5</span>, <span class="number">4.5</span>, np.nan],</span><br><span class="line">   .....:               index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: b = pd.Series(np.arange(<span class="built_in">len</span>(a), dtype=np.float64),</span><br><span class="line">   .....:               index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: b[-<span class="number">1</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: a</span><br><span class="line">Out[<span class="number">111</span>]: </span><br><span class="line">f    NaN</span><br><span class="line">e    <span class="number">2.5</span></span><br><span class="line">d    NaN</span><br><span class="line">c    <span class="number">3.5</span></span><br><span class="line">b    <span class="number">4.5</span></span><br><span class="line">a    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: b</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">f    <span class="number">0.0</span></span><br><span class="line">e    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">2.0</span></span><br><span class="line">c    <span class="number">3.0</span></span><br><span class="line">b    <span class="number">4.0</span></span><br><span class="line">a    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: np.where(pd.isnull(a), b, a)</span><br><span class="line">Out[<span class="number">113</span>]: array([ <span class="number">0.</span> ,  <span class="number">2.5</span>,  <span class="number">2.</span> ,  <span class="number">3.5</span>,  <span class="number">4.5</span>,  nan])</span><br></pre></td></tr></table></figure>
<p>Series有一个combine_first方法，实现的也是一样的功能，还带有pandas的数据对齐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">114</span>]: b[:-<span class="number">2</span>].combine_first(a[<span class="number">2</span>:])</span><br><span class="line">Out[<span class="number">114</span>]: </span><br><span class="line">a    NaN</span><br><span class="line">b    <span class="number">4.5</span></span><br><span class="line">c    <span class="number">3.0</span></span><br><span class="line">d    <span class="number">2.0</span></span><br><span class="line">e    <span class="number">1.0</span></span><br><span class="line">f    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>对于DataFrame，combine_first自然也会在列上做同样的事情，因此你可以将其看做：用传递对象中的数据为调用对象的缺失数据“打补丁”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1.</span>, np.nan, <span class="number">5.</span>, np.nan],</span><br><span class="line">   .....:                     <span class="string">&#x27;b&#x27;</span>: [np.nan, <span class="number">2.</span>, np.nan, <span class="number">6.</span>],</span><br><span class="line">   .....:                     <span class="string">&#x27;c&#x27;</span>: <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">18</span>, <span class="number">4</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">5.</span>, <span class="number">4.</span>, np.nan, <span class="number">3.</span>, <span class="number">7.</span>],</span><br><span class="line">   .....:                     <span class="string">&#x27;b&#x27;</span>: [np.nan, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">6.</span>, <span class="number">8.</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: df1</span><br><span class="line">Out[<span class="number">117</span>]: </span><br><span class="line">     a    b   c</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  NaN   <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  NaN  <span class="number">2.0</span>   <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  <span class="number">5.0</span>  NaN  <span class="number">10</span></span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.0</span>  <span class="number">14</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: df2</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">     a    b</span><br><span class="line"><span class="number">0</span>  <span class="number">5.0</span>  NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>  NaN  <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3.0</span>  <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: df1.combine_first(df2)</span><br><span class="line">Out[<span class="number">119</span>]: </span><br><span class="line">     a    b     c</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  NaN   <span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">2.0</span>   <span class="number">6.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">5.0</span>  <span class="number">4.0</span>  <span class="number">10.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3.0</span>  <span class="number">6.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">7.0</span>  <span class="number">8.0</span>   NaN</span><br></pre></td></tr></table></figure>
<h2 id="重塑和轴向旋转">8.3 重塑和轴向旋转</h2>
<p>有许多用于重新排列表格型数据的基础运算。这些函数也称作重塑（reshape）或轴向旋转（pivot）运算。</p>
<h3 id="重塑层次化索引">8.3.1 重塑层次化索引</h3>
<p>层次化索引为DataFrame数据的重排任务提供了一种具有良好一致性的方式。主要功能有二：</p>
<ul>
<li>stack：将数据的列“旋转”为行。</li>
<li>unstack：将数据的行“旋转”为列。</li>
</ul>
<p>我将通过一系列的范例来讲解这些操作。接下来看一个简单的DataFrame，其中的行列索引均为字符串数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">120</span>]: data = pd.DataFrame(np.arange(<span class="number">6</span>).reshape((<span class="number">2</span>, <span class="number">3</span>)),</span><br><span class="line">   .....:                     index=pd.Index([<span class="string">&#x27;Ohio&#x27;</span>,<span class="string">&#x27;Colorado&#x27;</span>], name=<span class="string">&#x27;state&#x27;</span>),</span><br><span class="line">   .....:                     columns=pd.Index([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">   .....:                     name=<span class="string">&#x27;number&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: data</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">number    one  two  three</span><br><span class="line">state                    </span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">3</span>    <span class="number">4</span>      <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>对该数据使用stack方法即可将列转换为行，得到一个Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">122</span>]: result = data.stack()</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: result</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line">state     number</span><br><span class="line">Ohio      one       <span class="number">0</span></span><br><span class="line">          two       <span class="number">1</span></span><br><span class="line">          three     <span class="number">2</span></span><br><span class="line">Colorado  one       <span class="number">3</span></span><br><span class="line">          two       <span class="number">4</span></span><br><span class="line">          three     <span class="number">5</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>对于一个层次化索引的Series，你可以用unstack将其重排为一个DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">124</span>]: result.unstack()</span><br><span class="line">Out[<span class="number">124</span>]: </span><br><span class="line">number    one  two  three</span><br><span class="line">state                    </span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">3</span>    <span class="number">4</span>      <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，unstack操作的是最内层（stack也是如此）。传入分层级别的编号或名称即可对其它级别进行unstack操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">125</span>]: result.unstack(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">125</span>]: </span><br><span class="line">state   Ohio  Colorado</span><br><span class="line">number                </span><br><span class="line">one        <span class="number">0</span>         <span class="number">3</span></span><br><span class="line">two        <span class="number">1</span>         <span class="number">4</span></span><br><span class="line">three      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: result.unstack(<span class="string">&#x27;state&#x27;</span>)</span><br><span class="line">Out[<span class="number">126</span>]: </span><br><span class="line">state   Ohio  Colorado</span><br><span class="line">number                </span><br><span class="line">one        <span class="number">0</span>         <span class="number">3</span></span><br><span class="line">two        <span class="number">1</span>         <span class="number">4</span></span><br><span class="line">three      <span class="number">2</span>         <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>如果不是所有的级别值都能在各分组中找到的话，则unstack操作可能会引入缺失数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">127</span>]: s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: s2 = pd.Series([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: data2 = pd.concat([s1, s2], keys=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: data2</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">one  a    <span class="number">0</span></span><br><span class="line">     b    <span class="number">1</span></span><br><span class="line">     c    <span class="number">2</span></span><br><span class="line">     d    <span class="number">3</span></span><br><span class="line">two  c    <span class="number">4</span></span><br><span class="line">     d    <span class="number">5</span></span><br><span class="line">     e    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">131</span>]: data2.unstack()</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">       a    b    c    d    e</span><br><span class="line">one  <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  NaN</span><br><span class="line">two  NaN  NaN  <span class="number">4.0</span>  <span class="number">5.0</span>  <span class="number">6.0</span></span><br></pre></td></tr></table></figure>
<p>stack默认会滤除缺失数据，因此该运算是可逆的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">132</span>]: data2.unstack()</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">       a    b    c    d    e</span><br><span class="line">one  <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span>  <span class="number">3.0</span>  NaN</span><br><span class="line">two  NaN  NaN  <span class="number">4.0</span>  <span class="number">5.0</span>  <span class="number">6.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: data2.unstack().stack()</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">one  a    <span class="number">0.0</span></span><br><span class="line">     b    <span class="number">1.0</span></span><br><span class="line">     c    <span class="number">2.0</span></span><br><span class="line">     d    <span class="number">3.0</span></span><br><span class="line">two  c    <span class="number">4.0</span></span><br><span class="line">     d    <span class="number">5.0</span></span><br><span class="line">     e    <span class="number">6.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: data2.unstack().stack(dropna=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">one  a    <span class="number">0.0</span></span><br><span class="line">     b    <span class="number">1.0</span></span><br><span class="line">     c    <span class="number">2.0</span></span><br><span class="line">     d    <span class="number">3.0</span></span><br><span class="line">     e    NaN</span><br><span class="line">two  a    NaN</span><br><span class="line">     b    NaN</span><br><span class="line">     c    <span class="number">4.0</span></span><br><span class="line">     d    <span class="number">5.0</span></span><br><span class="line">     e    <span class="number">6.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>在对DataFrame进行unstack操作时，作为旋转轴的级别将会成为结果中的最低级别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">135</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;left&#x27;</span>: result, <span class="string">&#x27;right&#x27;</span>: result + <span class="number">5</span>&#125;,</span><br><span class="line">   .....:                   columns=pd.Index([<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;right&#x27;</span>], name=<span class="string">&#x27;side&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: df</span><br><span class="line">Out[<span class="number">136</span>]: </span><br><span class="line">side             left  right</span><br><span class="line">state    number             </span><br><span class="line">Ohio     one        <span class="number">0</span>      <span class="number">5</span></span><br><span class="line">         two        <span class="number">1</span>      <span class="number">6</span></span><br><span class="line">         three      <span class="number">2</span>      <span class="number">7</span></span><br><span class="line">Colorado one        <span class="number">3</span>      <span class="number">8</span></span><br><span class="line">         two        <span class="number">4</span>      <span class="number">9</span></span><br><span class="line">         three      <span class="number">5</span>     <span class="number">10</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: df.unstack(<span class="string">&#x27;state&#x27;</span>)</span><br><span class="line">Out[<span class="number">137</span>]: </span><br><span class="line">side   left          right</span><br><span class="line">state  Ohio Colorado  Ohio Colorado</span><br><span class="line">number                             </span><br><span class="line">one       <span class="number">0</span>        <span class="number">3</span>     <span class="number">5</span>        <span class="number">8</span></span><br><span class="line">two       <span class="number">1</span>        <span class="number">4</span>     <span class="number">6</span>        <span class="number">9</span></span><br><span class="line">three     <span class="number">2</span>        <span class="number">5</span>     <span class="number">7</span>       <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>当调用stack，我们可以指明轴的名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">138</span>]: df.unstack(<span class="string">&#x27;state&#x27;</span>).stack(<span class="string">&#x27;side&#x27;</span>)</span><br><span class="line">Out[<span class="number">138</span>]: </span><br><span class="line">state         Colorado  Ohio</span><br><span class="line">number side                 </span><br><span class="line">one    left          <span class="number">3</span>     <span class="number">0</span></span><br><span class="line">       right         <span class="number">8</span>     <span class="number">5</span></span><br><span class="line">two    left          <span class="number">4</span>     <span class="number">1</span></span><br><span class="line">       right         <span class="number">9</span>     <span class="number">6</span></span><br><span class="line">three  left          <span class="number">5</span>     <span class="number">2</span></span><br><span class="line">       right        <span class="number">10</span>     <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h3 id="将长格式旋转为宽格式">8.3.2 将“长格式”旋转为“宽格式”</h3>
<p>多个时间序列数据通常是以所谓的“长格式”（long）或“堆叠格式”（stacked）存储在数据库和CSV中的。我们先加载一些示例数据，做一些时间序列规整和数据清洗：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">139</span>]: data = pd.read_csv(<span class="string">&#x27;examples/macrodata.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: data.head()</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">     year  quarter   realgdp  realcons  realinv  realgovt  realdpi    cpi  \</span><br><span class="line"><span class="number">0</span>  <span class="number">1959.0</span>      <span class="number">1.0</span>  <span class="number">2710.349</span>    <span class="number">1707.4</span>  <span class="number">286.898</span>   <span class="number">470.045</span>   <span class="number">1886.9</span>  <span class="number">28.98</span>   </span><br><span class="line"><span class="number">1</span>  <span class="number">1959.0</span>      <span class="number">2.0</span>  <span class="number">2778.801</span>    <span class="number">1733.7</span>  <span class="number">310.859</span>   <span class="number">481.301</span>   <span class="number">1919.7</span>  <span class="number">29.15</span>   </span><br><span class="line"><span class="number">2</span>  <span class="number">1959.0</span>      <span class="number">3.0</span>  <span class="number">2775.488</span>    <span class="number">1751.8</span>  <span class="number">289.226</span>   <span class="number">491.260</span>   <span class="number">1916.4</span>  <span class="number">29.35</span>   </span><br><span class="line"><span class="number">3</span>  <span class="number">1959.0</span>      <span class="number">4.0</span>  <span class="number">2785.204</span>    <span class="number">1753.7</span>  <span class="number">299.356</span>   <span class="number">484.052</span>   <span class="number">1931.3</span>  <span class="number">29.37</span>   </span><br><span class="line"><span class="number">4</span>  <span class="number">1960.0</span>      <span class="number">1.0</span>  <span class="number">2847.699</span>    <span class="number">1770.5</span>  <span class="number">331.722</span>   <span class="number">462.199</span>   <span class="number">1955.5</span>  <span class="number">29.54</span>   </span><br><span class="line">      m1  tbilrate  unemp      pop  infl  realint  </span><br><span class="line"><span class="number">0</span>  <span class="number">139.7</span>      <span class="number">2.82</span>    <span class="number">5.8</span>  <span class="number">177.146</span>  <span class="number">0.00</span>     <span class="number">0.00</span></span><br><span class="line"><span class="number">1</span>  <span class="number">141.7</span>      <span class="number">3.08</span>    <span class="number">5.1</span>  <span class="number">177.830</span>  <span class="number">2.34</span>     <span class="number">0.74</span>  </span><br><span class="line"><span class="number">2</span>  <span class="number">140.5</span>      <span class="number">3.82</span>    <span class="number">5.3</span>  <span class="number">178.657</span>  <span class="number">2.74</span>     <span class="number">1.09</span>  </span><br><span class="line"><span class="number">3</span>  <span class="number">140.0</span>      <span class="number">4.33</span>    <span class="number">5.6</span>  <span class="number">179.386</span>  <span class="number">0.27</span>     <span class="number">4.06</span>  </span><br><span class="line"><span class="number">4</span>  <span class="number">139.6</span>      <span class="number">3.50</span>    <span class="number">5.2</span>  <span class="number">180.007</span>  <span class="number">2.31</span>     <span class="number">1.19</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="number">141</span>]: periods = pd.PeriodIndex(year=data.year, quarter=data.quarter,</span><br><span class="line">   .....:                          name=<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: columns = pd.Index([<span class="string">&#x27;realgdp&#x27;</span>, <span class="string">&#x27;infl&#x27;</span>, <span class="string">&#x27;unemp&#x27;</span>], name=<span class="string">&#x27;item&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: data = data.reindex(columns=columns)</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: data.index = periods.to_timestamp(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: ldata = data.stack().reset_index().rename(columns=&#123;<span class="number">0</span>: <span class="string">&#x27;value&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>这就是多个时间序列（或者其它带有两个或多个键的可观察数据，这里，我们的键是date和item）的长格式。表中的每行代表一次观察。</p>
<p>关系型数据库（如MySQL）中的数据经常都是这样存储的，因为固定架构（即列名和数据类型）有一个好处：随着表中数据的添加，item列中的值的种类能够增加。在前面的例子中，date和item通常就是主键（用关系型数据库的说法），不仅提供了关系完整性，而且提供了更为简单的查询支持。有的情况下，使用这样的数据会很麻烦，你可能会更喜欢DataFrame，不同的item值分别形成一列，date列中的时间戳则用作索引。DataFrame的pivot方法完全可以实现这个转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">147</span>]: pivoted = ldata.pivot(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: pivoted</span><br><span class="line">Out[<span class="number">148</span>]: </span><br><span class="line">item        infl    realgdp  unemp</span><br><span class="line">date                              </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>   <span class="number">2710.349</span>    <span class="number">5.8</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>   <span class="number">2778.801</span>    <span class="number">5.1</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>   <span class="number">2775.488</span>    <span class="number">5.3</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>   <span class="number">2785.204</span>    <span class="number">5.6</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>   <span class="number">2847.699</span>    <span class="number">5.2</span></span><br><span class="line"><span class="number">1960</span>-06-<span class="number">30</span>  <span class="number">0.14</span>   <span class="number">2834.390</span>    <span class="number">5.2</span></span><br><span class="line"><span class="number">1960</span>-09-<span class="number">30</span>  <span class="number">2.70</span>   <span class="number">2839.022</span>    <span class="number">5.6</span></span><br><span class="line"><span class="number">1960</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">1.21</span>   <span class="number">2802.616</span>    <span class="number">6.3</span></span><br><span class="line"><span class="number">1961</span>-03-<span class="number">31</span> -<span class="number">0.40</span>   <span class="number">2819.264</span>    <span class="number">6.8</span></span><br><span class="line"><span class="number">1961</span>-06-<span class="number">30</span>  <span class="number">1.47</span>   <span class="number">2872.005</span>    <span class="number">7.0</span></span><br><span class="line"><span class="meta">... </span>         ...        ...    ...</span><br><span class="line"><span class="number">2007</span>-06-<span class="number">30</span>  <span class="number">2.75</span>  <span class="number">13203.977</span>    <span class="number">4.5</span></span><br><span class="line"><span class="number">2007</span>-09-<span class="number">30</span>  <span class="number">3.45</span>  <span class="number">13321.109</span>    <span class="number">4.7</span></span><br><span class="line"><span class="number">2007</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">6.38</span>  <span class="number">13391.249</span>    <span class="number">4.8</span></span><br><span class="line"><span class="number">2008</span>-03-<span class="number">31</span>  <span class="number">2.82</span>  <span class="number">13366.865</span>    <span class="number">4.9</span></span><br><span class="line"><span class="number">2008</span>-06-<span class="number">30</span>  <span class="number">8.53</span>  <span class="number">13415.266</span>    <span class="number">5.4</span></span><br><span class="line"><span class="number">2008</span>-09-<span class="number">30</span> -<span class="number">3.16</span>  <span class="number">13324.600</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">2008</span>-<span class="number">12</span>-<span class="number">31</span> -<span class="number">8.79</span>  <span class="number">13141.920</span>    <span class="number">6.9</span></span><br><span class="line"><span class="number">2009</span>-03-<span class="number">31</span>  <span class="number">0.94</span>  <span class="number">12925.410</span>    <span class="number">8.1</span></span><br><span class="line"><span class="number">2009</span>-06-<span class="number">30</span>  <span class="number">3.37</span>  <span class="number">12901.504</span>    <span class="number">9.2</span></span><br><span class="line"><span class="number">2009</span>-09-<span class="number">30</span>  <span class="number">3.56</span>  <span class="number">12990.341</span>    <span class="number">9.6</span></span><br><span class="line">[<span class="number">203</span> rows x <span class="number">3</span> columns]</span><br></pre></td></tr></table></figure>
<p>前两个传递的值分别用作行和列索引，最后一个可选值则是用于填充DataFrame的数据列。假设有两个需要同时重塑的数据列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">149</span>]: ldata[<span class="string">&#x27;value2&#x27;</span>] = np.random.randn(<span class="built_in">len</span>(ldata))</span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: ldata[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">150</span>]: </span><br><span class="line">        date     item     value    value2</span><br><span class="line"><span class="number">0</span> <span class="number">1959</span>-03-<span class="number">31</span>  realgdp  <span class="number">2710.349</span>  <span class="number">0.523772</span></span><br><span class="line"><span class="number">1</span> <span class="number">1959</span>-03-<span class="number">31</span>     infl     <span class="number">0.000</span>  <span class="number">0.000940</span></span><br><span class="line"><span class="number">2</span> <span class="number">1959</span>-03-<span class="number">31</span>    unemp     <span class="number">5.800</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">3</span> <span class="number">1959</span>-06-<span class="number">30</span>  realgdp  <span class="number">2778.801</span> -<span class="number">0.713544</span></span><br><span class="line"><span class="number">4</span> <span class="number">1959</span>-06-<span class="number">30</span>     infl     <span class="number">2.340</span> -<span class="number">0.831154</span></span><br><span class="line"><span class="number">5</span> <span class="number">1959</span>-06-<span class="number">30</span>    unemp     <span class="number">5.100</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">6</span> <span class="number">1959</span>-09-<span class="number">30</span>  realgdp  <span class="number">2775.488</span> -<span class="number">1.860761</span></span><br><span class="line"><span class="number">7</span> <span class="number">1959</span>-09-<span class="number">30</span>     infl     <span class="number">2.740</span> -<span class="number">0.860757</span></span><br><span class="line"><span class="number">8</span> <span class="number">1959</span>-09-<span class="number">30</span>    unemp     <span class="number">5.300</span>  <span class="number">0.560145</span></span><br><span class="line"><span class="number">9</span> <span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  realgdp  <span class="number">2785.204</span> -<span class="number">1.265934</span></span><br></pre></td></tr></table></figure>
<p>如果忽略最后一个参数，得到的DataFrame就会带有层次化的列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">151</span>]: pivoted = ldata.pivot(<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: pivoted[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">152</span>]: </span><br><span class="line">           value                    value2                    </span><br><span class="line">item        infl   realgdp unemp      infl   realgdp     unemp</span><br><span class="line">date                                                          </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>  <span class="number">2710.349</span>   <span class="number">5.8</span>  <span class="number">0.000940</span>  <span class="number">0.523772</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>  <span class="number">2778.801</span>   <span class="number">5.1</span> -<span class="number">0.831154</span> -<span class="number">0.713544</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>  <span class="number">2775.488</span>   <span class="number">5.3</span> -<span class="number">0.860757</span> -<span class="number">1.860761</span>  <span class="number">0.560145</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>  <span class="number">2785.204</span>   <span class="number">5.6</span>  <span class="number">0.119827</span> -<span class="number">1.265934</span> -<span class="number">1.063512</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>  <span class="number">2847.699</span>   <span class="number">5.2</span> -<span class="number">2.359419</span>  <span class="number">0.332883</span> -<span class="number">0.199543</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: pivoted[<span class="string">&#x27;value&#x27;</span>][:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">153</span>]: </span><br><span class="line">item        infl   realgdp  unemp</span><br><span class="line">date                             </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>  <span class="number">2710.349</span>    <span class="number">5.8</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>  <span class="number">2778.801</span>    <span class="number">5.1</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>  <span class="number">2775.488</span>    <span class="number">5.3</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>  <span class="number">2785.204</span>    <span class="number">5.6</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>  <span class="number">2847.699</span>    <span class="number">5.2</span></span><br></pre></td></tr></table></figure>
<p>注意，pivot其实就是用set_index创建层次化索引，再用unstack重塑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: unstacked = ldata.set_index([<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;item&#x27;</span>]).unstack(<span class="string">&#x27;item&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: unstacked[:<span class="number">7</span>]</span><br><span class="line">Out[<span class="number">155</span>]: </span><br><span class="line">           value                    value2                    </span><br><span class="line">item        infl   realgdp unemp      infl   realgdp     unemp</span><br><span class="line">date                                                          </span><br><span class="line"><span class="number">1959</span>-03-<span class="number">31</span>  <span class="number">0.00</span>  <span class="number">2710.349</span>   <span class="number">5.8</span>  <span class="number">0.000940</span>  <span class="number">0.523772</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">1959</span>-06-<span class="number">30</span>  <span class="number">2.34</span>  <span class="number">2778.801</span>   <span class="number">5.1</span> -<span class="number">0.831154</span> -<span class="number">0.713544</span> -<span class="number">2.370232</span></span><br><span class="line"><span class="number">1959</span>-09-<span class="number">30</span>  <span class="number">2.74</span>  <span class="number">2775.488</span>   <span class="number">5.3</span> -<span class="number">0.860757</span> -<span class="number">1.860761</span>  <span class="number">0.560145</span></span><br><span class="line"><span class="number">1959</span>-<span class="number">12</span>-<span class="number">31</span>  <span class="number">0.27</span>  <span class="number">2785.204</span>   <span class="number">5.6</span>  <span class="number">0.119827</span> -<span class="number">1.265934</span> -<span class="number">1.063512</span></span><br><span class="line"><span class="number">1960</span>-03-<span class="number">31</span>  <span class="number">2.31</span>  <span class="number">2847.699</span>   <span class="number">5.2</span> -<span class="number">2.359419</span>  <span class="number">0.332883</span> -<span class="number">0.199543</span></span><br><span class="line"><span class="number">1960</span>-06-<span class="number">30</span>  <span class="number">0.14</span>  <span class="number">2834.390</span>   <span class="number">5.2</span> -<span class="number">0.970736</span> -<span class="number">1.541996</span> -<span class="number">1.307030</span></span><br><span class="line"><span class="number">1960</span>-09-<span class="number">30</span>  <span class="number">2.70</span>  <span class="number">2839.022</span>   <span class="number">5.6</span>  <span class="number">0.377984</span>  <span class="number">0.286350</span> -<span class="number">0.753887</span></span><br></pre></td></tr></table></figure>
<h3 id="将宽格式旋转为长格式">8.3.3 将“宽格式”旋转为“长格式”</h3>
<p>旋转DataFrame的逆运算是pandas.melt。它不是将一列转换到多个新的DataFrame，而是合并多个列成为一个，产生一个比输入长的DataFrame。看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">157</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;B&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;C&#x27;</span>: [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: df</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">   A  B  C  key</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span>  foo</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span>  bar</span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span>  baz</span><br></pre></td></tr></table></figure>
<p>key列可能是分组指标，其它的列是数据值。当使用pandas.melt，我们必须指明哪些列是分组指标。下面使用key作为唯一的分组指标：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">159</span>]: melted = pd.melt(df, [<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">160</span>]: melted</span><br><span class="line">Out[<span class="number">160</span>]: </span><br><span class="line">   key variable  value</span><br><span class="line"><span class="number">0</span>  foo        A      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  bar        A      <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  baz        A      <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  foo        B      <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  bar        B      <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  baz        B      <span class="number">6</span></span><br><span class="line"><span class="number">6</span>  foo        C      <span class="number">7</span></span><br><span class="line"><span class="number">7</span>  bar        C      <span class="number">8</span></span><br><span class="line"><span class="number">8</span>  baz        C      <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>使用pivot，可以重塑回原来的样子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">161</span>]: reshaped = melted.pivot(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;variable&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: reshaped</span><br><span class="line">Out[<span class="number">162</span>]: </span><br><span class="line">variable  A  B  C</span><br><span class="line">key              </span><br><span class="line">bar       <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span></span><br><span class="line">baz       <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span></span><br><span class="line">foo       <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>因为pivot的结果从列创建了一个索引，用作行标签，我们可以使用reset_index将数据移回列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">163</span>]: reshaped.reset_index()</span><br><span class="line">Out[<span class="number">163</span>]: </span><br><span class="line">variable  key  A  B  C</span><br><span class="line"><span class="number">0</span>         bar  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span></span><br><span class="line"><span class="number">1</span>         baz  <span class="number">3</span>  <span class="number">6</span>  <span class="number">9</span></span><br><span class="line"><span class="number">2</span>         foo  <span class="number">1</span>  <span class="number">4</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>你还可以指定列的子集，作为值的列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">164</span>]: pd.melt(df, id_vars=[<span class="string">&#x27;key&#x27;</span>], value_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">Out[<span class="number">164</span>]: </span><br><span class="line">   key variable  value</span><br><span class="line"><span class="number">0</span>  foo        A      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  bar        A      <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  baz        A      <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  foo        B      <span class="number">4</span></span><br><span class="line"><span class="number">4</span>  bar        B      <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  baz        B      <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>pandas.melt也可以不用分组指标：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: pd.melt(df, value_vars=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>])</span><br><span class="line">Out[<span class="number">165</span>]: </span><br><span class="line">  variable  value</span><br><span class="line"><span class="number">0</span>        A      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>        A      <span class="number">2</span></span><br><span class="line"><span class="number">2</span>        A      <span class="number">3</span></span><br><span class="line"><span class="number">3</span>        B      <span class="number">4</span></span><br><span class="line"><span class="number">4</span>        B      <span class="number">5</span></span><br><span class="line"><span class="number">5</span>        B      <span class="number">6</span></span><br><span class="line"><span class="number">6</span>        C      <span class="number">7</span></span><br><span class="line"><span class="number">7</span>        C      <span class="number">8</span></span><br><span class="line"><span class="number">8</span>        C      <span class="number">9</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: pd.melt(df, value_vars=[<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">Out[<span class="number">166</span>]: </span><br><span class="line">  variable value</span><br><span class="line"><span class="number">0</span>      key   foo</span><br><span class="line"><span class="number">1</span>      key   bar</span><br><span class="line"><span class="number">2</span>      key   baz</span><br><span class="line"><span class="number">3</span>        A     <span class="number">1</span></span><br><span class="line"><span class="number">4</span>        A     <span class="number">2</span></span><br><span class="line"><span class="number">5</span>        A     <span class="number">3</span></span><br><span class="line"><span class="number">6</span>        B     <span class="number">4</span></span><br><span class="line"><span class="number">7</span>        B     <span class="number">5</span></span><br><span class="line"><span class="number">8</span>        B     <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">8.4 总结</h2>
<p>现在你已经掌握了pandas数据导入、清洗、重塑，我们可以进一步学习matplotlib数据可视化。我们在稍后会回到pandas，学习更高级的分析。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第10章_数据聚合与分组运算</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap10/</url>
    <content><![CDATA[<h1 id="第10章-数据聚合与分组运算">第10章 数据聚合与分组运算</h1>
<p>对数据集进行分组并对各组应用一个函数（无论是聚合还是转换），通常是数据分析工作中的重要环节。在将数据集加载、融合、准备好之后，通常就是计算分组统计或生成透视表。pandas提供了一个灵活高效的gruopby功能，它使你能以一种自然的方式对数据集进行切片、切块、摘要等操作。</p>
<span id="more"></span>
<p>关系型数据库和SQL（Structured Query Language，结构化查询语言）能够如此流行的原因之一就是其能够方便地对数据进行连接、过滤、转换和聚合。但是，像SQL这样的查询语言所能执行的分组运算的种类很有限。在本章中你将会看到，由于Python和pandas强大的表达能力，我们可以执行复杂得多的分组运算（利用任何可以接受pandas对象或NumPy数组的函数）。在本章中，你将会学到：</p>
<ul>
<li>使用一个或多个键（形式可以是函数、数组或DataFrame列名）分割pandas对象。</li>
<li>计算分组的概述统计，比如数量、平均值或标准差，或是用户定义的函数。</li>
<li>应用组内转换或其他运算，如规格化、线性回归、排名或选取子集等。</li>
<li>计算透视表或交叉表。</li>
<li>执行分位数分析以及其它统计分组分析。</li>
</ul>
<blockquote>
<p>笔记：对时间序列数据的聚合（groupby的特殊用法之一）也称作重采样（resampling），本书将在第11章中单独对其进行讲解。</p>
</blockquote>
<h2 id="groupby机制">10.1 GroupBy机制</h2>
<p>Hadley Wickham（许多热门R语言包的作者）创造了一个用于表示分组运算的术语"split-apply-combine"（拆分－应用－合并）。第一个阶段，pandas对象（无论是Series、DataFrame还是其他的）中的数据会根据你所提供的一个或多个键被拆分（split）为多组。拆分操作是在对象的特定轴上执行的。例如，DataFrame可以在其行（axis=0）或列（axis=1）上进行分组。然后，将一个函数应用（apply）到各个分组并产生一个新值。最后，所有这些函数的执行结果会被合并（combine）到最终的结果对象中。结果对象的形式一般取决于数据上所执行的操作。图10-1大致说明了一个简单的分组聚合过程。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap10/7178691-e5c671e09ecf94be.png" class="" title="图10-1 分组聚合演示">
<p>分组键可以有多种形式，且类型不必相同：</p>
<ul>
<li>列表或数组，其长度与待分组的轴一样。</li>
<li>表示DataFrame某个列名的值。</li>
<li>字典或Series，给出待分组轴上的值与分组名之间的对应关系。</li>
<li>函数，用于处理轴索引或索引中的各个标签。</li>
</ul>
<p>注意，后三种都只是快捷方式而已，其最终目的仍然是产生一组用于拆分对象的值。如果觉得这些东西看起来很抽象，不用担心，我将在本章中给出大量有关于此的示例。首先来看看下面这个非常简单的表格型数据集（以DataFrame的形式）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span> : [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;key2&#x27;</span> : [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;data1&#x27;</span> : np.random.randn(<span class="number">5</span>),</span><br><span class="line">   ....:                    <span class="string">&#x27;data2&#x27;</span> : np.random.randn(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: df</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br></pre></td></tr></table></figure>
<p>假设你想要按key1进行分组，并计算data1列的平均值。实现该功能的方式有很多，而我们这里要用的是：访问data1，并根据key1调用groupby：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: grouped = df[<span class="string">&#x27;data1&#x27;</span>].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: grouped</span><br><span class="line">Out[<span class="number">13</span>]: &lt;pandas.core.groupby.SeriesGroupBy <span class="built_in">object</span> at <span class="number">0x7faa31537390</span>&gt;</span><br></pre></td></tr></table></figure>
<p>变量grouped是一个GroupBy对象。它实际上还没有进行任何计算，只是含有一些有关分组键df['key1']的中间数据而已。换句话说，该对象已经有了接下来对各分组执行运算所需的一切信息。例如，我们可以调用GroupBy的mean方法来计算分组平均值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: grouped.mean()</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">key1</span><br><span class="line">a    <span class="number">0.746672</span></span><br><span class="line">b   -<span class="number">0.537585</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>
<p>稍后我将详细讲解.mean()的调用过程。这里最重要的是，数据（Series）根据分组键进行了聚合，产生了一个新的Series，其索引为key1列中的唯一值。之所以结果中索引的名称为key1，是因为原始DataFrame的列df['key1']就叫这个名字。</p>
<p>如果我们一次传入多个数组的列表，就会得到不同的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: means = df[<span class="string">&#x27;data1&#x27;</span>].groupby([df[<span class="string">&#x27;key1&#x27;</span>], df[<span class="string">&#x27;key2&#x27;</span>]]).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: means</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">0.880536</span></span><br><span class="line">      two     <span class="number">0.478943</span></span><br><span class="line">b     one    -<span class="number">0.519439</span></span><br><span class="line">      two    -<span class="number">0.555730</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>
<p>这里，我通过两个键对数据进行了分组，得到的Series具有一个层次化索引（由唯一的键对组成）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: means.unstack()</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">key2       one       two</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="number">0.880536</span>  <span class="number">0.478943</span></span><br><span class="line">b    -<span class="number">0.519439</span> -<span class="number">0.555730</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，分组键均为Series。实际上，分组键可以是任何长度适当的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: states = np.array([<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: years = np.array([<span class="number">2005</span>, <span class="number">2005</span>, <span class="number">2006</span>, <span class="number">2005</span>, <span class="number">2006</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: df[<span class="string">&#x27;data1&#x27;</span>].groupby([states, years]).mean()</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">California  <span class="number">2005</span>    <span class="number">0.478943</span></span><br><span class="line">            <span class="number">2006</span>   -<span class="number">0.519439</span></span><br><span class="line">Ohio        <span class="number">2005</span>   -<span class="number">0.380219</span></span><br><span class="line">            <span class="number">2006</span>    <span class="number">1.965781</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>
<p>通常，分组信息就位于相同的要处理DataFrame中。这里，你还可以将列名（可以是字符串、数字或其他Python对象）用作分组键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: df.groupby(<span class="string">&#x27;key1&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     <span class="number">0.746672</span>  <span class="number">0.910916</span></span><br><span class="line">b    -<span class="number">0.537585</span>  <span class="number">0.525384</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]).mean()</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">              data1     data2</span><br><span class="line">key1 key2                    </span><br><span class="line">a    one   <span class="number">0.880536</span>  <span class="number">1.319920</span></span><br><span class="line">     two   <span class="number">0.478943</span>  <span class="number">0.092908</span></span><br><span class="line">b    one  -<span class="number">0.519439</span>  <span class="number">0.281746</span></span><br><span class="line">     two  -<span class="number">0.555730</span>  <span class="number">0.769023</span></span><br></pre></td></tr></table></figure>
<p>你可能已经注意到了，第一个例子在执行df.groupby('key1').mean()时，结果中没有key2列。这是因为df['key2']不是数值数据（俗称“麻烦列”），所以被从结果中排除了。默认情况下，所有数值列都会被聚合，虽然有时可能会被过滤为一个子集，稍后就会碰到。</p>
<p>无论你准备拿groupby做什么，都有可能会用到GroupBy的size方法，它可以返回一个含有分组大小的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]).size()</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">2</span></span><br><span class="line">      two     <span class="number">1</span></span><br><span class="line">b     one     <span class="number">1</span></span><br><span class="line">      two     <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>注意，任何分组关键词中的缺失值，都会被从结果中除去。</p>
<h3 id="对分组进行迭代">10.1.1 对分组进行迭代</h3>
<p>GroupBy对象支持迭代，可以产生一组二元元组（由分组名和数据块组成）。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="keyword">for</span> name, group <span class="keyword">in</span> df.groupby(<span class="string">&#x27;key1&#x27;</span>):</span><br><span class="line">   ....:     <span class="built_in">print</span>(name)</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">a</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line">b</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>
<p>对于多重键的情况，元组的第一个元素将会是由键值组成的元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: <span class="keyword">for</span> (k1, k2), group <span class="keyword">in</span> df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]):</span><br><span class="line">   ....:     <span class="built_in">print</span>((k1, k2))</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">     data1     data2 key1 key2</span><br><span class="line"><span class="number">3</span> -<span class="number">0.55573</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>
<p>当然，你可以对这些数据片段做任何操作。有一个你可能会觉得有用的运算：将这些数据片段做成一个字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: pieces = <span class="built_in">dict</span>(<span class="built_in">list</span>(df.groupby(<span class="string">&#x27;key1&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: pieces[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>
<p>groupby默认是在axis=0上进行分组的，通过设置也可以在其他任何轴上进行分组。拿上面例子中的df来说，我们可以根据dtype对列进行分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">28</span>]: df.dtypes</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">data1    float64</span><br><span class="line">data2    float64</span><br><span class="line">key1      <span class="built_in">object</span></span><br><span class="line">key2      <span class="built_in">object</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: grouped = df.groupby(df.dtypes, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>可以如下打印分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: <span class="keyword">for</span> dtype, group <span class="keyword">in</span> grouped:</span><br><span class="line">   ....:     <span class="built_in">print</span>(dtype)</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">float64</span><br><span class="line">      data1     data2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span></span><br><span class="line"><span class="built_in">object</span></span><br><span class="line">  key1 key2</span><br><span class="line"><span class="number">0</span>    a  one</span><br><span class="line"><span class="number">1</span>    a  two</span><br><span class="line"><span class="number">2</span>    b  one</span><br><span class="line"><span class="number">3</span>    b  two</span><br><span class="line"><span class="number">4</span>    a  one</span><br></pre></td></tr></table></figure>
<h3 id="选取一列或列的子集">10.1.2 选取一列或列的子集</h3>
<p>对于由DataFrame产生的GroupBy对象，如果用一个（单个字符串）或一组（字符串数组）列名对其进行索引，就能实现选取部分列进行聚合的目的。也就是说：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;key1&#x27;</span>)[<span class="string">&#x27;data1&#x27;</span>]</span><br><span class="line">df.groupby(<span class="string">&#x27;key1&#x27;</span>)[[<span class="string">&#x27;data2&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>是以下代码的语法糖：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;data1&#x27;</span>].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br><span class="line">df[[<span class="string">&#x27;data2&#x27;</span>]].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>尤其对于大数据集，很可能只需要对部分列进行聚合。例如，在前面那个数据集中，如果只需计算data2列的平均值并以DataFrame形式得到结果，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])[[<span class="string">&#x27;data2&#x27;</span>]].mean()</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">              data2</span><br><span class="line">key1 key2          </span><br><span class="line">a    one   <span class="number">1.319920</span></span><br><span class="line">     two   <span class="number">0.092908</span></span><br><span class="line">b    one   <span class="number">0.281746</span></span><br><span class="line">     two   <span class="number">0.769023</span></span><br></pre></td></tr></table></figure>
<p>这种索引操作所返回的对象是一个已分组的DataFrame（如果传入的是列表或数组）或已分组的Series（如果传入的是标量形式的单个列名）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: s_grouped = df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])[<span class="string">&#x27;data2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: s_grouped</span><br><span class="line">Out[<span class="number">33</span>]: &lt;pandas.core.groupby.SeriesGroupBy <span class="built_in">object</span> at <span class="number">0x7faa30c78da0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: s_grouped.mean()</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">1.319920</span></span><br><span class="line">      two     <span class="number">0.092908</span></span><br><span class="line">b     one     <span class="number">0.281746</span></span><br><span class="line">      two     <span class="number">0.769023</span></span><br><span class="line">Name: data2, dtype: float64</span><br></pre></td></tr></table></figure>
<p>###通过字典或Series进行分组</p>
<p>除数组以外，分组信息还可以其他形式存在。来看另一个示例DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: people = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">   ....:                       columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">   ....:                       index=[<span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Wes&#x27;</span>, <span class="string">&#x27;Jim&#x27;</span>, <span class="string">&#x27;Travis&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: people.iloc[<span class="number">2</span>:<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]] = np.nan <span class="comment"># Add a few NA values</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: people</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">               a         b         c         d         e</span><br><span class="line">Joe     <span class="number">1.007189</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line">Steve   <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line">Wes    -<span class="number">0.539741</span>       NaN       NaN -<span class="number">1.021228</span> -<span class="number">0.577087</span></span><br><span class="line">Jim     <span class="number">0.124121</span>  <span class="number">0.302614</span>  <span class="number">0.523772</span>  <span class="number">0.000940</span>  <span class="number">1.343810</span></span><br><span class="line">Travis -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br></pre></td></tr></table></figure>
<p>现在，假设已知列的分组关系，并希望根据分组计算列的和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: mapping = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">   ....:            <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;f&#x27;</span> : <span class="string">&#x27;orange&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你可以将这个字典传给groupby，来构造数组，但我们可以直接传递字典（我包含了键“f”来强调，存在未使用的分组键是可以的）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: by_column = people.groupby(mapping, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: by_column.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">            blue       red</span><br><span class="line">Joe     <span class="number">0.503905</span>  <span class="number">1.063885</span></span><br><span class="line">Steve   <span class="number">1.297183</span> -<span class="number">1.553778</span></span><br><span class="line">Wes    -<span class="number">1.021228</span> -<span class="number">1.116829</span></span><br><span class="line">Jim     <span class="number">0.524712</span>  <span class="number">1.770545</span></span><br><span class="line">Travis -<span class="number">4.230992</span> -<span class="number">2.405455</span></span><br></pre></td></tr></table></figure>
<p>Series也有同样的功能，它可以被看做一个固定大小的映射：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: map_series = pd.Series(mapping)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: map_series</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">a       red</span><br><span class="line">b       red</span><br><span class="line">c      blue</span><br><span class="line">d      blue</span><br><span class="line">e       red</span><br><span class="line">f    orange</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: people.groupby(map_series, axis=<span class="number">1</span>).count()</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">        blue  red</span><br><span class="line">Joe        <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Steve      <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Wes        <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">Jim        <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Travis     <span class="number">2</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>###通过函数进行分组</p>
<p>比起使用字典或Series，使用Python函数是一种更原生的方法定义分组映射。任何被当做分组键的函数都会在各个索引值上被调用一次，其返回值就会被用作分组名称。具体点说，以上一小节的示例DataFrame为例，其索引值为人的名字。你可以计算一个字符串长度的数组，更简单的方法是传入len函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: people.groupby(<span class="built_in">len</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">          a         b         c         d         e</span><br><span class="line"><span class="number">3</span>  <span class="number">0.591569</span> -<span class="number">0.993608</span>  <span class="number">0.798764</span> -<span class="number">0.791374</span>  <span class="number">2.119639</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line"><span class="number">6</span> -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br></pre></td></tr></table></figure>
<p>将函数跟数组、列表、字典、Series混合使用也不是问题，因为任何东西在内部都会被转换为数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: key_list = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: people.groupby([<span class="built_in">len</span>, key_list]).<span class="built_in">min</span>()</span><br><span class="line">Out[<span class="number">46</span>]: </span><br><span class="line">              a         b         c         d         e</span><br><span class="line"><span class="number">3</span> one -<span class="number">0.539741</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span> -<span class="number">1.021228</span> -<span class="number">0.577087</span></span><br><span class="line">  two  <span class="number">0.124121</span>  <span class="number">0.302614</span>  <span class="number">0.523772</span>  <span class="number">0.000940</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">5</span> one  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line"><span class="number">6</span> two -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br></pre></td></tr></table></figure>
<h3 id="根据索引级别分组">10.1.3 根据索引级别分组</h3>
<p>层次化索引数据集最方便的地方就在于它能够根据轴索引的一个级别进行聚合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: columns = pd.MultiIndex.from_arrays([[<span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>],</span><br><span class="line">   ....:                                     [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]],</span><br><span class="line">   ....:                                     names=[<span class="string">&#x27;cty&#x27;</span>, <span class="string">&#x27;tenor&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: hier_df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">5</span>), columns=columns)</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: hier_df</span><br><span class="line">Out[<span class="number">49</span>]: </span><br><span class="line">cty          US                            JP          </span><br><span class="line">tenor         <span class="number">1</span>         <span class="number">3</span>         <span class="number">5</span>         <span class="number">1</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0.560145</span> -<span class="number">1.265934</span>  <span class="number">0.119827</span> -<span class="number">1.063512</span>  <span class="number">0.332883</span></span><br><span class="line"><span class="number">1</span>     -<span class="number">2.359419</span> -<span class="number">0.199543</span> -<span class="number">1.541996</span> -<span class="number">0.970736</span> -<span class="number">1.307030</span></span><br><span class="line"><span class="number">2</span>      <span class="number">0.286350</span>  <span class="number">0.377984</span> -<span class="number">0.753887</span>  <span class="number">0.331286</span>  <span class="number">1.349742</span></span><br><span class="line"><span class="number">3</span>      <span class="number">0.069877</span>  <span class="number">0.246674</span> -<span class="number">0.011862</span>  <span class="number">1.004812</span>  <span class="number">1.327195</span></span><br></pre></td></tr></table></figure>
<p>要根据级别分组，使用level关键字传递级别序号或名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: hier_df.groupby(level=<span class="string">&#x27;cty&#x27;</span>, axis=<span class="number">1</span>).count()</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">cty  JP  US</span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">3</span>     <span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="数据聚合">10.2 数据聚合</h2>
<p>聚合指的是任何能够从数组产生标量值的数据转换过程。之前的例子已经用过一些，比如mean、count、min以及sum等。你可能想知道在GroupBy对象上调用mean()时究竟发生了什么。许多常见的聚合运算（如表10-1所示）都有进行优化。然而，除了这些方法，你还可以使用其它的。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap10/7178691-ba8de524e08b1b6f.png" class="" title="表10-1 经过优化的groupby方法">
<p>你可以使用自己发明的聚合运算，还可以调用分组对象上已经定义好的任何方法。例如，quantile可以计算Series或DataFrame列的样本分位数。</p>
<p>虽然quantile并没有明确地实现于GroupBy，但它是一个Series方法，所以这里是能用的。实际上，GroupBy会高效地对Series进行切片，然后对各片调用piece.quantile(0.9)，最后将这些结果组装成最终结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: df</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: grouped = df.groupby(<span class="string">&#x27;key1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: grouped[<span class="string">&#x27;data1&#x27;</span>].quantile(<span class="number">0.9</span>)</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">key1</span><br><span class="line">a    <span class="number">1.668413</span></span><br><span class="line">b   -<span class="number">0.523068</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>
<p>如果要使用你自己的聚合函数，只需将其传入aggregate或agg方法即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: <span class="keyword">def</span> <span class="title function_">peak_to_peak</span>(<span class="params">arr</span>):</span><br><span class="line">   ....:     <span class="keyword">return</span> arr.<span class="built_in">max</span>() - arr.<span class="built_in">min</span>()</span><br><span class="line">In [<span class="number">55</span>]: grouped.agg(peak_to_peak)</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="number">2.170488</span>  <span class="number">1.300498</span></span><br><span class="line">b     <span class="number">0.036292</span>  <span class="number">0.487276</span></span><br></pre></td></tr></table></figure>
<p>你可能注意到注意，有些方法（如describe）也是可以用在这里的，即使严格来讲，它们并非聚合运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: grouped.describe()</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line">     data1                                                              \</span><br><span class="line">     count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%       <span class="number">75</span>%   </span><br><span class="line">key1                                                                     </span><br><span class="line">a      <span class="number">3.0</span>  <span class="number">0.746672</span>  <span class="number">1.109736</span> -<span class="number">0.204708</span>  <span class="number">0.137118</span>  <span class="number">0.478943</span>  <span class="number">1.222362</span>   </span><br><span class="line">b      <span class="number">2.0</span> -<span class="number">0.537585</span>  <span class="number">0.025662</span> -<span class="number">0.555730</span> -<span class="number">0.546657</span> -<span class="number">0.537585</span> -<span class="number">0.528512</span>   </span><br><span class="line">               data2                                                    \</span><br><span class="line"><span class="built_in">max</span> count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%   </span><br><span class="line">key1                                                                     </span><br><span class="line">a     <span class="number">1.965781</span>   <span class="number">3.0</span>  <span class="number">0.910916</span>  <span class="number">0.712217</span>  <span class="number">0.092908</span>  <span class="number">0.669671</span>  <span class="number">1.246435</span>   </span><br><span class="line">b    -<span class="number">0.519439</span>   <span class="number">2.0</span>  <span class="number">0.525384</span>  <span class="number">0.344556</span>  <span class="number">0.281746</span>  <span class="number">0.403565</span>  <span class="number">0.525384</span>   </span><br><span class="line">                          </span><br><span class="line">           <span class="number">75</span>%       <span class="built_in">max</span>  </span><br><span class="line">key1                      </span><br><span class="line">a     <span class="number">1.319920</span>  <span class="number">1.393406</span>  </span><br><span class="line">b     <span class="number">0.647203</span>  <span class="number">0.769023</span></span><br></pre></td></tr></table></figure>
<p>在后面的10.3节，我将详细说明这到底是怎么回事。</p>
<blockquote>
<p>笔记：自定义聚合函数要比表10-1中那些经过优化的函数慢得多。这是因为在构造中间分组数据块时存在非常大的开销（函数调用、数据重排等）。</p>
</blockquote>
<h3 id="面向列的多函数应用">10.2.1 面向列的多函数应用</h3>
<p>回到前面小费的例子。使用read_csv导入数据之后，我们添加了一个小费百分比的列tip_pct：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: tips = pd.read_csv(<span class="string">&#x27;examples/tips.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Add tip percentage of total bill</span></span><br><span class="line">In [<span class="number">58</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>] = tips[<span class="string">&#x27;tip&#x27;</span>] / tips[<span class="string">&#x27;total_bill&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: tips[:<span class="number">6</span>]</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line">   total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="number">0</span>       <span class="number">16.99</span>  <span class="number">1.01</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.059447</span></span><br><span class="line"><span class="number">1</span>       <span class="number">10.34</span>  <span class="number">1.66</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.160542</span></span><br><span class="line"><span class="number">2</span>       <span class="number">21.01</span>  <span class="number">3.50</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.166587</span></span><br><span class="line"><span class="number">3</span>       <span class="number">23.68</span>  <span class="number">3.31</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.139780</span></span><br><span class="line"><span class="number">4</span>       <span class="number">24.59</span>  <span class="number">3.61</span>     No  Sun  Dinner     <span class="number">4</span>  <span class="number">0.146808</span></span><br><span class="line"><span class="number">5</span>       <span class="number">25.29</span>  <span class="number">4.71</span>     No  Sun  Dinner     <span class="number">4</span>  <span class="number">0.186240</span></span><br></pre></td></tr></table></figure>
<p>你已经看到，对Series或DataFrame列的聚合运算其实就是使用aggregate（使用自定义函数）或调用诸如mean、std之类的方法。然而，你可能希望对不同的列使用不同的聚合函数，或一次应用多个函数。其实这也好办，我将通过一些示例来进行讲解。首先，我根据天和smoker对tips进行分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: grouped = tips.groupby([<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>注意，对于表10-1中的那些描述统计，可以将函数名以字符串的形式传入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: grouped_pct = grouped[<span class="string">&#x27;tip_pct&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: grouped_pct.agg(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">day   smoker</span><br><span class="line">Fri   No        <span class="number">0.151650</span></span><br><span class="line">      Yes       <span class="number">0.174783</span></span><br><span class="line">Sat   No        <span class="number">0.158048</span></span><br><span class="line">      Yes       <span class="number">0.147906</span></span><br><span class="line">Sun   No        <span class="number">0.160113</span></span><br><span class="line">      Yes       <span class="number">0.187250</span></span><br><span class="line">Thur  No        <span class="number">0.160298</span></span><br><span class="line">      Yes       <span class="number">0.163863</span></span><br><span class="line">Name: tip_pct, dtype: float64</span><br></pre></td></tr></table></figure>
<p>如果传入一组函数或函数名，得到的DataFrame的列就会以相应的函数命名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: grouped_pct.agg([<span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;std&#x27;</span>, peak_to_peak])</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line">                 mean       std  peak_to_peak</span><br><span class="line">day  smoker                                  </span><br><span class="line">Fri  No      <span class="number">0.151650</span>  <span class="number">0.028123</span>      <span class="number">0.067349</span></span><br><span class="line">     Yes     <span class="number">0.174783</span>  <span class="number">0.051293</span>      <span class="number">0.159925</span></span><br><span class="line">Sat  No      <span class="number">0.158048</span>  <span class="number">0.039767</span>      <span class="number">0.235193</span></span><br><span class="line">     Yes     <span class="number">0.147906</span>  <span class="number">0.061375</span>      <span class="number">0.290095</span></span><br><span class="line">Sun  No      <span class="number">0.160113</span>  <span class="number">0.042347</span>      <span class="number">0.193226</span></span><br><span class="line">     Yes     <span class="number">0.187250</span>  <span class="number">0.154134</span>      <span class="number">0.644685</span></span><br><span class="line">Thur No      <span class="number">0.160298</span>  <span class="number">0.038774</span>      <span class="number">0.193350</span></span><br><span class="line">     Yes     <span class="number">0.163863</span>  <span class="number">0.039389</span>      <span class="number">0.151240</span></span><br></pre></td></tr></table></figure>
<p>这里，我们传递了一组聚合函数进行聚合，独立对数据分组进行评估。</p>
<p>你并非一定要接受GroupBy自动给出的那些列名，特别是lambda函数，它们的名称是'<lambda>'，这样的辨识度就很低了（通过函数的__name__属性看看就知道了）。因此，如果传入的是一个由(name,function)元组组成的列表，则各元组的第一个元素就会被用作DataFrame的列名（可以将这种二元元组列表看做一个有序映射）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: grouped_pct.agg([(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>), (<span class="string">&#x27;bar&#x27;</span>, np.std)])</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">                  foo       bar</span><br><span class="line">day  smoker                    </span><br><span class="line">Fri  No      <span class="number">0.151650</span>  <span class="number">0.028123</span></span><br><span class="line">     Yes     <span class="number">0.174783</span>  <span class="number">0.051293</span></span><br><span class="line">Sat  No      <span class="number">0.158048</span>  <span class="number">0.039767</span></span><br><span class="line">     Yes     <span class="number">0.147906</span>  <span class="number">0.061375</span></span><br><span class="line">Sun  No      <span class="number">0.160113</span>  <span class="number">0.042347</span></span><br><span class="line">     Yes     <span class="number">0.187250</span>  <span class="number">0.154134</span></span><br><span class="line">Thur No      <span class="number">0.160298</span>  <span class="number">0.038774</span></span><br><span class="line">     Yes     <span class="number">0.163863</span>  <span class="number">0.039389</span></span><br></pre></td></tr></table></figure>
<p>对于DataFrame，你还有更多选择，你可以定义一组应用于全部列的一组函数，或不同的列应用不同的函数。假设我们想要对tip_pct和total_bill列计算三个统计信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: functions = [<span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;max&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: result = grouped[<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;total_bill&#x27;</span>].agg(functions)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: result</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">            tip_pct                     total_bill                  </span><br><span class="line">              count      mean       <span class="built_in">max</span>      count       mean    <span class="built_in">max</span></span><br><span class="line">day  smoker                                                         </span><br><span class="line">Fri  No           <span class="number">4</span>  <span class="number">0.151650</span>  <span class="number">0.187735</span>          <span class="number">4</span>  <span class="number">18.420000</span>  <span class="number">22.75</span></span><br><span class="line">     Yes         <span class="number">15</span>  <span class="number">0.174783</span>  <span class="number">0.263480</span>         <span class="number">15</span>  <span class="number">16.813333</span>  <span class="number">40.17</span></span><br><span class="line">Sat  No          <span class="number">45</span>  <span class="number">0.158048</span>  <span class="number">0.291990</span>         <span class="number">45</span>  <span class="number">19.661778</span>  <span class="number">48.33</span></span><br><span class="line">     Yes         <span class="number">42</span>  <span class="number">0.147906</span>  <span class="number">0.325733</span>         <span class="number">42</span>  <span class="number">21.276667</span>  <span class="number">50.81</span></span><br><span class="line">Sun  No          <span class="number">57</span>  <span class="number">0.160113</span>  <span class="number">0.252672</span>         <span class="number">57</span>  <span class="number">20.506667</span>  <span class="number">48.17</span></span><br><span class="line">     Yes         <span class="number">19</span>  <span class="number">0.187250</span>  <span class="number">0.710345</span>         <span class="number">19</span>  <span class="number">24.120000</span>  <span class="number">45.35</span></span><br><span class="line">Thur No          <span class="number">45</span>  <span class="number">0.160298</span>  <span class="number">0.266312</span>         <span class="number">45</span>  <span class="number">17.113111</span>  <span class="number">41.19</span></span><br><span class="line">     Yes         <span class="number">17</span>  <span class="number">0.163863</span>  <span class="number">0.241255</span>         <span class="number">17</span>  <span class="number">19.190588</span>  <span class="number">43.11</span></span><br></pre></td></tr></table></figure>
<p>如你所见，结果DataFrame拥有层次化的列，这相当于分别对各列进行聚合，然后用concat将结果组装到一起，使用列名用作keys参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: result[<span class="string">&#x27;tip_pct&#x27;</span>]</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">             count      mean       <span class="built_in">max</span></span><br><span class="line">day  smoker                           </span><br><span class="line">Fri  No          <span class="number">4</span>  <span class="number">0.151650</span>  <span class="number">0.187735</span></span><br><span class="line">     Yes        <span class="number">15</span>  <span class="number">0.174783</span>  <span class="number">0.263480</span></span><br><span class="line">Sat  No         <span class="number">45</span>  <span class="number">0.158048</span>  <span class="number">0.291990</span></span><br><span class="line">     Yes        <span class="number">42</span>  <span class="number">0.147906</span>  <span class="number">0.325733</span></span><br><span class="line">Sun  No         <span class="number">57</span>  <span class="number">0.160113</span>  <span class="number">0.252672</span></span><br><span class="line">     Yes        <span class="number">19</span>  <span class="number">0.187250</span>  <span class="number">0.710345</span></span><br><span class="line">Thur No         <span class="number">45</span>  <span class="number">0.160298</span>  <span class="number">0.266312</span></span><br><span class="line">     Yes        <span class="number">17</span>  <span class="number">0.163863</span>  <span class="number">0.241255</span></span><br></pre></td></tr></table></figure>
<p>跟前面一样，这里也可以传入带有自定义名称的一组元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: ftuples = [(<span class="string">&#x27;Durchschnitt&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>),(<span class="string">&#x27;Abweichung&#x27;</span>, np.var)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: grouped[<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;total_bill&#x27;</span>].agg(ftuples)</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">                 tip_pct              total_bill            </span><br><span class="line">            Durchschnitt Abweichung Durchschnitt  Abweichung</span><br><span class="line">day  smoker                                                 </span><br><span class="line">Fri  No         <span class="number">0.151650</span>   <span class="number">0.000791</span>    <span class="number">18.420000</span>   <span class="number">25.596333</span></span><br><span class="line">     Yes        <span class="number">0.174783</span>   <span class="number">0.002631</span>    <span class="number">16.813333</span>   <span class="number">82.562438</span></span><br><span class="line">Sat  No         <span class="number">0.158048</span>   <span class="number">0.001581</span>    <span class="number">19.661778</span>   <span class="number">79.908965</span></span><br><span class="line">     Yes        <span class="number">0.147906</span>   <span class="number">0.003767</span>    <span class="number">21.276667</span>  <span class="number">101.387535</span></span><br><span class="line">Sun  No         <span class="number">0.160113</span>   <span class="number">0.001793</span>    <span class="number">20.506667</span>   <span class="number">66.099980</span></span><br><span class="line">     Yes        <span class="number">0.187250</span>   <span class="number">0.023757</span>    <span class="number">24.120000</span>  <span class="number">109.046044</span></span><br><span class="line">Thur No         <span class="number">0.160298</span>   <span class="number">0.001503</span>    <span class="number">17.113111</span>   <span class="number">59.625081</span></span><br><span class="line">     Yes        <span class="number">0.163863</span>   <span class="number">0.001551</span>    <span class="number">19.190588</span>   <span class="number">69.808518</span></span><br></pre></td></tr></table></figure>
<p>现在，假设你想要对一个列或不同的列应用不同的函数。具体的办法是向agg传入一个从列名映射到函数的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: grouped.agg(&#123;<span class="string">&#x27;tip&#x27;</span> : np.<span class="built_in">max</span>, <span class="string">&#x27;size&#x27;</span> : <span class="string">&#x27;sum&#x27;</span>&#125;)</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">               tip  size</span><br><span class="line">day  smoker             </span><br><span class="line">Fri  No       <span class="number">3.50</span>     <span class="number">9</span></span><br><span class="line">     Yes      <span class="number">4.73</span>    <span class="number">31</span></span><br><span class="line">Sat  No       <span class="number">9.00</span>   <span class="number">115</span></span><br><span class="line">     Yes     <span class="number">10.00</span>   <span class="number">104</span></span><br><span class="line">Sun  No       <span class="number">6.00</span>   <span class="number">167</span></span><br><span class="line">     Yes      <span class="number">6.50</span>    <span class="number">49</span></span><br><span class="line">Thur No       <span class="number">6.70</span>   <span class="number">112</span></span><br><span class="line">     Yes      <span class="number">5.00</span>    <span class="number">40</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: grouped.agg(&#123;<span class="string">&#x27;tip_pct&#x27;</span> : [<span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;std&#x27;</span>],</span><br><span class="line">   ....:              <span class="string">&#x27;size&#x27;</span> : <span class="string">&#x27;sum&#x27;</span>&#125;)</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line">              tip_pct                               size</span><br><span class="line">                  <span class="built_in">min</span>       <span class="built_in">max</span>      mean       std  <span class="built_in">sum</span></span><br><span class="line">day  smoker                                             </span><br><span class="line">Fri  No      <span class="number">0.120385</span>  <span class="number">0.187735</span>  <span class="number">0.151650</span>  <span class="number">0.028123</span>    <span class="number">9</span></span><br><span class="line">     Yes     <span class="number">0.103555</span>  <span class="number">0.263480</span>  <span class="number">0.174783</span>  <span class="number">0.051293</span>   <span class="number">31</span></span><br><span class="line">Sat  No      <span class="number">0.056797</span>  <span class="number">0.291990</span>  <span class="number">0.158048</span>  <span class="number">0.039767</span>  <span class="number">115</span></span><br><span class="line">     Yes     <span class="number">0.035638</span>  <span class="number">0.325733</span>  <span class="number">0.147906</span>  <span class="number">0.061375</span>  <span class="number">104</span></span><br><span class="line">Sun  No      <span class="number">0.059447</span>  <span class="number">0.252672</span>  <span class="number">0.160113</span>  <span class="number">0.042347</span>  <span class="number">167</span></span><br><span class="line">     Yes     <span class="number">0.065660</span>  <span class="number">0.710345</span>  <span class="number">0.187250</span>  <span class="number">0.154134</span>   <span class="number">49</span></span><br><span class="line">Thur No      <span class="number">0.072961</span>  <span class="number">0.266312</span>  <span class="number">0.160298</span>  <span class="number">0.038774</span>  <span class="number">112</span></span><br><span class="line">     Yes     <span class="number">0.090014</span>  <span class="number">0.241255</span>  <span class="number">0.163863</span>  <span class="number">0.039389</span>   <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>只有将多个函数应用到至少一列时，DataFrame才会拥有层次化的列。</p>
<h3 id="以没有行索引的形式返回聚合数据">10.2.2 以“没有行索引”的形式返回聚合数据</h3>
<p>到目前为止，所有示例中的聚合数据都有由唯一的分组键组成的索引（可能还是层次化的）。由于并不总是需要如此，所以你可以向groupby传入as_index=False以禁用该功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: tips.groupby([<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>], as_index=<span class="literal">False</span>).mean()</span><br><span class="line">Out[<span class="number">73</span>]: </span><br><span class="line">    day smoker  total_bill       tip      size   tip_pct</span><br><span class="line"><span class="number">0</span>   Fri     No   <span class="number">18.420000</span>  <span class="number">2.812500</span>  <span class="number">2.250000</span>  <span class="number">0.151650</span></span><br><span class="line"><span class="number">1</span>   Fri    Yes   <span class="number">16.813333</span>  <span class="number">2.714000</span>  <span class="number">2.066667</span>  <span class="number">0.174783</span></span><br><span class="line"><span class="number">2</span>   Sat     No   <span class="number">19.661778</span>  <span class="number">3.102889</span>  <span class="number">2.555556</span>  <span class="number">0.158048</span></span><br><span class="line"><span class="number">3</span>   Sat    Yes   <span class="number">21.276667</span>  <span class="number">2.875476</span>  <span class="number">2.476190</span>  <span class="number">0.147906</span></span><br><span class="line"><span class="number">4</span>   Sun     No   <span class="number">20.506667</span>  <span class="number">3.167895</span>  <span class="number">2.929825</span>  <span class="number">0.160113</span></span><br><span class="line"><span class="number">5</span>   Sun    Yes   <span class="number">24.120000</span>  <span class="number">3.516842</span>  <span class="number">2.578947</span>  <span class="number">0.187250</span></span><br><span class="line"><span class="number">6</span>  Thur     No   <span class="number">17.113111</span>  <span class="number">2.673778</span>  <span class="number">2.488889</span>  <span class="number">0.160298</span></span><br><span class="line"><span class="number">7</span>  Thur    Yes   <span class="number">19.190588</span>  <span class="number">3.030000</span>  <span class="number">2.352941</span>  <span class="number">0.163863</span></span><br></pre></td></tr></table></figure>
<p>当然，对结果调用reset_index也能得到这种形式的结果。使用as_index=False方法可以避免一些不必要的计算。</p>
<h2 id="apply一般性的拆分应用合并">10.3 apply：一般性的“拆分－应用－合并”</h2>
<p>最通用的GroupBy方法是apply，本节剩余部分将重点讲解它。如图10-2所示，apply会将待处理的对象拆分成多个片段，然后对各片段调用传入的函数，最后尝试将各片段组合到一起。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap10/7178691-7e8bb217f599b4ae.png" class="" title="图10-2 分组聚合示例">
<p>回到之前那个小费数据集，假设你想要根据分组选出最高的5个tip_pct值。首先，编写一个选取指定列具有最大值的行的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">df, n=<span class="number">5</span>, column=<span class="string">&#x27;tip_pct&#x27;</span></span>):</span><br><span class="line">   ....:     <span class="keyword">return</span> df.sort_values(by=column)[-n:]</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: top(tips, n=<span class="number">6</span>)</span><br><span class="line">Out[<span class="number">75</span>]: </span><br><span class="line">     total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes  Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line"><span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes  Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line"><span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No  Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line"><span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes  Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line"><span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes  Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line"><span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes  Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br></pre></td></tr></table></figure>
<p>现在，如果对smoker分组并用该函数调用apply，就会得到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: tips.groupby(<span class="string">&#x27;smoker&#x27;</span>).apply(top)</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">            total_bill   tip smoker   day    time  size   tip_pct</span><br><span class="line">smoker                                                           </span><br><span class="line">No     <span class="number">88</span>        <span class="number">24.71</span>  <span class="number">5.85</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.236746</span></span><br><span class="line">       <span class="number">185</span>       <span class="number">20.69</span>  <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">5</span>  <span class="number">0.241663</span></span><br><span class="line">       <span class="number">51</span>        <span class="number">10.29</span>  <span class="number">2.60</span>     No   Sun  Dinner     <span class="number">2</span>  <span class="number">0.252672</span></span><br><span class="line">       <span class="number">149</span>        <span class="number">7.51</span>  <span class="number">2.00</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.266312</span></span><br><span class="line">       <span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No   Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line">Yes    <span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes   Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line">       <span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes   Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line">       <span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes   Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line">       <span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line">       <span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br></pre></td></tr></table></figure>
<p>这里发生了什么？top函数在DataFrame的各个片段上调用，然后结果由pandas.concat组装到一起，并以分组名称进行了标记。于是，最终结果就有了一个层次化索引，其内层索引值来自原DataFrame。</p>
<p>如果传给apply的函数能够接受其他参数或关键字，则可以将这些内容放在函数名后面一并传入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: tips.groupby([<span class="string">&#x27;smoker&#x27;</span>, <span class="string">&#x27;day&#x27;</span>]).apply(top, n=<span class="number">1</span>, column=<span class="string">&#x27;total_bill&#x27;</span>)</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">                 total_bill    tip smoker   day    time  size   tip_pct</span><br><span class="line">smoker day                                                             </span><br><span class="line">No     Fri  <span class="number">94</span>        <span class="number">22.75</span>   <span class="number">3.25</span>     No   Fri  Dinner     <span class="number">2</span>  <span class="number">0.142857</span></span><br><span class="line">       Sat  <span class="number">212</span>       <span class="number">48.33</span>   <span class="number">9.00</span>     No   Sat  Dinner     <span class="number">4</span>  <span class="number">0.186220</span></span><br><span class="line">       Sun  <span class="number">156</span>       <span class="number">48.17</span>   <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">6</span>  <span class="number">0.103799</span></span><br><span class="line">       Thur <span class="number">142</span>       <span class="number">41.19</span>   <span class="number">5.00</span>     No  Thur   Lunch     <span class="number">5</span>  <span class="number">0.121389</span></span><br><span class="line">Yes    Fri  <span class="number">95</span>        <span class="number">40.17</span>   <span class="number">4.73</span>    Yes   Fri  Dinner     <span class="number">4</span>  <span class="number">0.117750</span></span><br><span class="line">       Sat  <span class="number">170</span>       <span class="number">50.81</span>  <span class="number">10.00</span>    Yes   Sat  Dinner     <span class="number">3</span>  <span class="number">0.196812</span></span><br><span class="line">       Sun  <span class="number">182</span>       <span class="number">45.35</span>   <span class="number">3.50</span>    Yes   Sun  Dinner     <span class="number">3</span>  <span class="number">0.077178</span></span><br><span class="line">       Thur <span class="number">197</span>       <span class="number">43.11</span>   <span class="number">5.00</span>    Yes  Thur   Lunch     <span class="number">4</span>  <span class="number">0.115982</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：除这些基本用法之外，能否充分发挥apply的威力很大程度上取决于你的创造力。传入的那个函数能做什么全由你说了算，它只需返回一个pandas对象或标量值即可。本章后续部分的示例主要用于讲解如何利用groupby解决各种各样的问题。</p>
</blockquote>
<p>可能你已经想起来了，之前我在GroupBy对象上调用过describe：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: result = tips.groupby(<span class="string">&#x27;smoker&#x27;</span>)[<span class="string">&#x27;tip_pct&#x27;</span>].describe()</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: result</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">        count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%       <span class="number">75</span>%  \</span><br><span class="line">smoker                                                                      </span><br><span class="line">No      <span class="number">151.0</span>  <span class="number">0.159328</span>  <span class="number">0.039910</span>  <span class="number">0.056797</span>  <span class="number">0.136906</span>  <span class="number">0.155625</span>  <span class="number">0.185014</span>   </span><br><span class="line">Yes      <span class="number">93.0</span>  <span class="number">0.163196</span>  <span class="number">0.085119</span>  <span class="number">0.035638</span>  <span class="number">0.106771</span>  <span class="number">0.153846</span>  <span class="number">0.195059</span>   </span><br><span class="line">             <span class="built_in">max</span>  </span><br><span class="line">smoker</span><br><span class="line"></span><br><span class="line">No      <span class="number">0.291990</span>  </span><br><span class="line">Yes     <span class="number">0.710345</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: result.unstack(<span class="string">&#x27;smoker&#x27;</span>)</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">       smoker</span><br><span class="line">count  No        <span class="number">151.000000</span></span><br><span class="line">       Yes        <span class="number">93.000000</span></span><br><span class="line">mean   No          <span class="number">0.159328</span></span><br><span class="line">       Yes         <span class="number">0.163196</span></span><br><span class="line">std    No          <span class="number">0.039910</span></span><br><span class="line">       Yes         <span class="number">0.085119</span></span><br><span class="line"><span class="built_in">min</span>    No          <span class="number">0.056797</span></span><br><span class="line">       Yes         <span class="number">0.035638</span></span><br><span class="line"><span class="number">25</span>%    No          <span class="number">0.136906</span></span><br><span class="line">       Yes         <span class="number">0.106771</span></span><br><span class="line"><span class="number">50</span>%    No          <span class="number">0.155625</span></span><br><span class="line">       Yes         <span class="number">0.153846</span></span><br><span class="line"><span class="number">75</span>%    No          <span class="number">0.185014</span></span><br><span class="line">       Yes         <span class="number">0.195059</span></span><br><span class="line"><span class="built_in">max</span>    No          <span class="number">0.291990</span></span><br><span class="line">       Yes         <span class="number">0.710345</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>在GroupBy中，当你调用诸如describe之类的方法时，实际上只是应用了下面两条代码的快捷方式而已：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: x.describe()</span><br><span class="line">grouped.apply(f)</span><br></pre></td></tr></table></figure>
<h3 id="禁止分组键">10.3.1 禁止分组键</h3>
<p>从上面的例子中可以看出，分组键会跟原始对象的索引共同构成结果对象中的层次化索引。将group_keys=False传入groupby即可禁止该效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: tips.groupby(<span class="string">&#x27;smoker&#x27;</span>, group_keys=<span class="literal">False</span>).apply(top)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">     total_bill   tip smoker   day    time  size   tip_pct</span><br><span class="line"><span class="number">88</span>        <span class="number">24.71</span>  <span class="number">5.85</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.236746</span></span><br><span class="line"><span class="number">185</span>       <span class="number">20.69</span>  <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">5</span>  <span class="number">0.241663</span></span><br><span class="line"><span class="number">51</span>        <span class="number">10.29</span>  <span class="number">2.60</span>     No   Sun  Dinner     <span class="number">2</span>  <span class="number">0.252672</span></span><br><span class="line"><span class="number">149</span>        <span class="number">7.51</span>  <span class="number">2.00</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.266312</span></span><br><span class="line"><span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No   Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line"><span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes   Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line"><span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes   Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line"><span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes   Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line"><span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line"><span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br></pre></td></tr></table></figure>
<h3 id="分位数和桶分析">10.3.2 分位数和桶分析</h3>
<p>我曾在第8章中讲过，pandas有一些能根据指定面元或样本分位数将数据拆分成多块的工具（比如cut和qcut）。将这些函数跟groupby结合起来，就能非常轻松地实现对数据集的桶（bucket）或分位数（quantile）分析了。以下面这个简单的随机数据集为例，我们利用cut将其装入长度相等的桶中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;data1&#x27;</span>: np.random.randn(<span class="number">1000</span>),</span><br><span class="line">   ....:                       <span class="string">&#x27;data2&#x27;</span>: np.random.randn(<span class="number">1000</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: quartiles = pd.cut(frame.data1, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: quartiles[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">84</span>]: </span><br><span class="line"><span class="number">0</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">1</span>    (-<span class="number">2.956</span>, -<span class="number">1.23</span>]</span><br><span class="line"><span class="number">2</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">3</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">4</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">5</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">6</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">7</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">8</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">9</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line">Name: data1, dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(-<span class="number">2.956</span>, -<span class="number">1.23</span>] &lt; (-<span class="number">1.23</span>, <span class="number">0.489</span>] &lt; (<span class="number">0.489</span>, <span class="number">2.</span></span><br><span class="line"><span class="number">208</span>] &lt; (<span class="number">2.208</span>, <span class="number">3.928</span>]]</span><br></pre></td></tr></table></figure>
<p>由cut返回的Categorical对象可直接传递到groupby。因此，我们可以像下面这样对data2列做一些统计计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: <span class="keyword">def</span> <span class="title function_">get_stats</span>(<span class="params">group</span>):</span><br><span class="line">   ....:     <span class="keyword">return</span> &#123;<span class="string">&#x27;min&#x27;</span>: group.<span class="built_in">min</span>(), <span class="string">&#x27;max&#x27;</span>: group.<span class="built_in">max</span>(),</span><br><span class="line">   ....:             <span class="string">&#x27;count&#x27;</span>: group.count(), <span class="string">&#x27;mean&#x27;</span>: group.mean()&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: grouped = frame.data2.groupby(quartiles)</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: grouped.apply(get_stats).unstack()</span><br><span class="line">Out[<span class="number">87</span>]: </span><br><span class="line">                 count       <span class="built_in">max</span>      mean       <span class="built_in">min</span></span><br><span class="line">data1                                               </span><br><span class="line">(-<span class="number">2.956</span>, -<span class="number">1.23</span>]   <span class="number">95.0</span>  <span class="number">1.670835</span> -<span class="number">0.039521</span> -<span class="number">3.399312</span></span><br><span class="line">(-<span class="number">1.23</span>, <span class="number">0.489</span>]   <span class="number">598.0</span>  <span class="number">3.260383</span> -<span class="number">0.002051</span> -<span class="number">2.989741</span></span><br><span class="line">(<span class="number">0.489</span>, <span class="number">2.208</span>]   <span class="number">297.0</span>  <span class="number">2.954439</span>  <span class="number">0.081822</span> -<span class="number">3.745356</span></span><br><span class="line">(<span class="number">2.208</span>, <span class="number">3.928</span>]    <span class="number">10.0</span>  <span class="number">1.765640</span>  <span class="number">0.024750</span> -<span class="number">1.929776</span></span><br></pre></td></tr></table></figure>
<p>这些都是长度相等的桶。要根据样本分位数得到大小相等的桶，使用qcut即可。传入labels=False即可只获取分位数的编号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Return quantile numbers</span></span><br><span class="line">In [<span class="number">88</span>]: grouping = pd.qcut(frame.data1, <span class="number">10</span>, labels=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: grouped = frame.data2.groupby(grouping)</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: grouped.apply(get_stats).unstack()</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">       count       <span class="built_in">max</span>      mean       <span class="built_in">min</span></span><br><span class="line">data1                                     </span><br><span class="line"><span class="number">0</span>      <span class="number">100.0</span>  <span class="number">1.670835</span> -<span class="number">0.049902</span> -<span class="number">3.399312</span></span><br><span class="line"><span class="number">1</span>      <span class="number">100.0</span>  <span class="number">2.628441</span>  <span class="number">0.030989</span> -<span class="number">1.950098</span></span><br><span class="line"><span class="number">2</span>      <span class="number">100.0</span>  <span class="number">2.527939</span> -<span class="number">0.067179</span> -<span class="number">2.925113</span></span><br><span class="line"><span class="number">3</span>      <span class="number">100.0</span>  <span class="number">3.260383</span>  <span class="number">0.065713</span> -<span class="number">2.315555</span></span><br><span class="line"><span class="number">4</span>      <span class="number">100.0</span>  <span class="number">2.074345</span> -<span class="number">0.111653</span> -<span class="number">2.047939</span></span><br><span class="line"><span class="number">5</span>      <span class="number">100.0</span>  <span class="number">2.184810</span>  <span class="number">0.052130</span> -<span class="number">2.989741</span></span><br><span class="line"><span class="number">6</span>      <span class="number">100.0</span>  <span class="number">2.458842</span> -<span class="number">0.021489</span> -<span class="number">2.223506</span></span><br><span class="line"><span class="number">7</span>      <span class="number">100.0</span>  <span class="number">2.954439</span> -<span class="number">0.026459</span> -<span class="number">3.056990</span></span><br><span class="line"><span class="number">8</span>      <span class="number">100.0</span>  <span class="number">2.735527</span>  <span class="number">0.103406</span> -<span class="number">3.745356</span></span><br><span class="line"><span class="number">9</span>      <span class="number">100.0</span>  <span class="number">2.377020</span>  <span class="number">0.220122</span> -<span class="number">2.064111</span></span><br></pre></td></tr></table></figure>
<p>我们会在第12章详细讲解pandas的Categorical类型。</p>
<h3 id="示例用特定于分组的值填充缺失值">10.3.3 示例：用特定于分组的值填充缺失值</h3>
<p>对于缺失数据的清理工作，有时你会用dropna将其替换掉，而有时则可能会希望用一个固定值或由数据集本身所衍生出来的值去填充NA值。这时就得使用fillna这个工具了。在下面这个例子中，我用平均值去填充NA值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: s = pd.Series(np.random.randn(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: s[::<span class="number">2</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: s</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line"><span class="number">0</span>         NaN</span><br><span class="line"><span class="number">1</span>   -<span class="number">0.125921</span></span><br><span class="line"><span class="number">2</span>         NaN</span><br><span class="line"><span class="number">3</span>   -<span class="number">0.884475</span></span><br><span class="line"><span class="number">4</span>         NaN</span><br><span class="line"><span class="number">5</span>    <span class="number">0.227290</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: s.fillna(s.mean())</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line"><span class="number">0</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">0.125921</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.884475</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">5</span>    <span class="number">0.227290</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>假设你需要对不同的分组填充不同的值。一种方法是将数据分组，并使用apply和一个能够对各数据块调用fillna的函数即可。下面是一些有关美国几个州的示例数据，这些州又被分为东部和西部：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: states = [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Vermont&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>,</span><br><span class="line">   ....:           <span class="string">&#x27;Oregon&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Idaho&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: group_key = [<span class="string">&#x27;East&#x27;</span>] * <span class="number">4</span> + [<span class="string">&#x27;West&#x27;</span>] * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: data = pd.Series(np.random.randn(<span class="number">8</span>), index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: data</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont      -<span class="number">0.365757</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada        <span class="number">0.981994</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho        -<span class="number">1.613716</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>['East'] * 4产生了一个列表，包括了['East']中元素的四个拷贝。将这些列表串联起来。</p>
<p>将一些值设为缺失：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">99</span>]: data[[<span class="string">&#x27;Vermont&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Idaho&#x27;</span>]] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: data</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont            NaN</span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada             NaN</span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho              NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: data.groupby(group_key).mean()</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">East   -<span class="number">0.535707</span></span><br><span class="line">West    <span class="number">0.717926</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>我们可以用分组平均值去填充NA值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: fill_mean = <span class="keyword">lambda</span> g: g.fillna(g.mean())</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: data.groupby(group_key).apply(fill_mean)</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont      -<span class="number">0.535707</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada        <span class="number">0.717926</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho         <span class="number">0.717926</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>另外，也可以在代码中预定义各组的填充值。由于分组具有一个name属性，所以我们可以拿来用一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">104</span>]: fill_values = &#123;<span class="string">&#x27;East&#x27;</span>: <span class="number">0.5</span>, <span class="string">&#x27;West&#x27;</span>: -<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: fill_func = <span class="keyword">lambda</span> g: g.fillna(fill_values[g.name])</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: data.groupby(group_key).apply(fill_func)</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont       <span class="number">0.500000</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada       -<span class="number">1.000000</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho        -<span class="number">1.000000</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="示例随机采样和排列">10.3.4 示例：随机采样和排列</h3>
<p>假设你想要从一个大数据集中随机抽取（进行替换或不替换）样本以进行蒙特卡罗模拟（Monte Carlo simulation）或其他分析工作。“抽取”的方式有很多，这里使用的方法是对Series使用sample方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Hearts, Spades, Clubs, Diamonds</span></span><br><span class="line">suits = [<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">card_val = (<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)) + [<span class="number">10</span>] * <span class="number">3</span>) * <span class="number">4</span></span><br><span class="line">base_names = [<span class="string">&#x27;A&#x27;</span>] + <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)) + [<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>]</span><br><span class="line">cards = []</span><br><span class="line"><span class="keyword">for</span> suit <span class="keyword">in</span> [<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]:</span><br><span class="line">    cards.extend(<span class="built_in">str</span>(num) + suit <span class="keyword">for</span> num <span class="keyword">in</span> base_names)</span><br><span class="line"></span><br><span class="line">deck = pd.Series(card_val, index=cards)</span><br></pre></td></tr></table></figure>
<p>现在我有了一个长度为52的Series，其索引包括牌名，值则是21点或其他游戏中用于计分的点数（为了简单起见，我当A的点数为1）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: deck[:<span class="number">13</span>]</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line">AH      <span class="number">1</span></span><br><span class="line">2H      <span class="number">2</span></span><br><span class="line">3H      <span class="number">3</span></span><br><span class="line">4H      <span class="number">4</span></span><br><span class="line">5H      <span class="number">5</span></span><br><span class="line">6H      <span class="number">6</span></span><br><span class="line">7H      <span class="number">7</span></span><br><span class="line">8H      <span class="number">8</span></span><br><span class="line">9H      <span class="number">9</span></span><br><span class="line">10H    <span class="number">10</span></span><br><span class="line">JH     <span class="number">10</span></span><br><span class="line">KH     <span class="number">10</span></span><br><span class="line">QH     <span class="number">10</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>现在，根据我上面所讲的，从整副牌中抽出5张，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">deck, n=<span class="number">5</span></span>):</span><br><span class="line">   .....:     <span class="keyword">return</span> deck.sample(n)</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: draw(deck)</span><br><span class="line">Out[<span class="number">110</span>]: </span><br><span class="line">AD     <span class="number">1</span></span><br><span class="line">8C     <span class="number">8</span></span><br><span class="line">5H     <span class="number">5</span></span><br><span class="line">KC    <span class="number">10</span></span><br><span class="line">2C     <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>假设你想要从每种花色中随机抽取两张牌。由于花色是牌名的最后一个字符，所以我们可以据此进行分组，并使用apply：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">111</span>]: get_suit = <span class="keyword">lambda</span> card: card[-<span class="number">1</span>] <span class="comment"># last letter is suit</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: deck.groupby(get_suit).apply(draw, n=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">C  2C     <span class="number">2</span></span><br><span class="line">   3C     <span class="number">3</span></span><br><span class="line">D  KD    <span class="number">10</span></span><br><span class="line">   8D     <span class="number">8</span></span><br><span class="line">H  KH    <span class="number">10</span></span><br><span class="line">   3H     <span class="number">3</span></span><br><span class="line">S  2S     <span class="number">2</span></span><br><span class="line">   4S     <span class="number">4</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>或者，也可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">113</span>]: deck.groupby(get_suit, group_keys=<span class="literal">False</span>).apply(draw, n=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">KC    <span class="number">10</span></span><br><span class="line">JC    <span class="number">10</span></span><br><span class="line">AD     <span class="number">1</span></span><br><span class="line">5D     <span class="number">5</span></span><br><span class="line">5H     <span class="number">5</span></span><br><span class="line">6H     <span class="number">6</span></span><br><span class="line">7S     <span class="number">7</span></span><br><span class="line">KS    <span class="number">10</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="示例分组加权平均数和相关系数">10.3.5 示例：分组加权平均数和相关系数</h3>
<p>根据groupby的“拆分－应用－合并”范式，可以进行DataFrame的列与列之间或两个Series之间的运算（比如分组加权平均）。以下面这个数据集为例，它含有分组键、值以及一些权重值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">114</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;category&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">   .....:                                 <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;data&#x27;</span>: np.random.randn(<span class="number">8</span>),</span><br><span class="line">   .....:                    <span class="string">&#x27;weights&#x27;</span>: np.random.rand(<span class="number">8</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: df</span><br><span class="line">Out[<span class="number">115</span>]: </span><br><span class="line">  category      data   weights</span><br><span class="line"><span class="number">0</span>        a  <span class="number">1.561587</span>  <span class="number">0.957515</span></span><br><span class="line"><span class="number">1</span>        a  <span class="number">1.219984</span>  <span class="number">0.347267</span></span><br><span class="line"><span class="number">2</span>        a -<span class="number">0.482239</span>  <span class="number">0.581362</span></span><br><span class="line"><span class="number">3</span>        a  <span class="number">0.315667</span>  <span class="number">0.217091</span></span><br><span class="line"><span class="number">4</span>        b -<span class="number">0.047852</span>  <span class="number">0.894406</span></span><br><span class="line"><span class="number">5</span>        b -<span class="number">0.454145</span>  <span class="number">0.918564</span></span><br><span class="line"><span class="number">6</span>        b -<span class="number">0.556774</span>  <span class="number">0.277825</span></span><br><span class="line"><span class="number">7</span>        b  <span class="number">0.253321</span>  <span class="number">0.955905</span></span><br></pre></td></tr></table></figure>
<p>然后可以利用category计算分组加权平均数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">116</span>]: grouped = df.groupby(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: get_wavg = <span class="keyword">lambda</span> g: np.average(g[<span class="string">&#x27;data&#x27;</span>], weights=g[<span class="string">&#x27;weights&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: grouped.apply(get_wavg)</span><br><span class="line">Out[<span class="number">118</span>]:</span><br><span class="line">category</span><br><span class="line">a    <span class="number">0.811643</span></span><br><span class="line">b   -<span class="number">0.122262</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>另一个例子，考虑一个来自Yahoo!Finance的数据集，其中含有几只股票和标准普尔500指数（符号SPX）的收盘价：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">119</span>]: close_px = pd.read_csv(<span class="string">&#x27;examples/stock_px_2.csv&#x27;</span>, parse_dates=<span class="literal">True</span>,</span><br><span class="line">   .....:                        index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: close_px.info()</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;</span><br><span class="line">DatetimeIndex: <span class="number">2214</span> entries, <span class="number">2003</span>-01-02 to <span class="number">2011</span>-<span class="number">10</span>-<span class="number">14</span></span><br><span class="line">Data columns (total <span class="number">4</span> columns):</span><br><span class="line">AAPL    <span class="number">2214</span> non-null float64</span><br><span class="line">MSFT    <span class="number">2214</span> non-null float64</span><br><span class="line">XOM     <span class="number">2214</span> non-null float64</span><br><span class="line">SPX     <span class="number">2214</span> non-null float64</span><br><span class="line">dtypes: float64(<span class="number">4</span>)</span><br><span class="line">memory usage: <span class="number">86.5</span> KB</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: close_px[-<span class="number">4</span>:]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">              AAPL   MSFT    XOM      SPX</span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">11</span>  <span class="number">400.29</span>  <span class="number">27.00</span>  <span class="number">76.27</span>  <span class="number">1195.54</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">12</span>  <span class="number">402.19</span>  <span class="number">26.96</span>  <span class="number">77.16</span>  <span class="number">1207.25</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">13</span>  <span class="number">408.43</span>  <span class="number">27.18</span>  <span class="number">76.37</span>  <span class="number">1203.66</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">14</span>  <span class="number">422.00</span>  <span class="number">27.27</span>  <span class="number">78.11</span>  <span class="number">1224.58</span></span><br></pre></td></tr></table></figure>
<p>来做一个比较有趣的任务：计算一个由日收益率（通过百分数变化计算）与SPX之间的年度相关系数组成的DataFrame。下面是一个实现办法，我们先创建一个函数，用它计算每列和SPX列的成对相关系数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">122</span>]: spx_corr = <span class="keyword">lambda</span> x: x.corrwith(x[<span class="string">&#x27;SPX&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>接下来，我们使用pct_change计算close_px的百分比变化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">123</span>]: rets = close_px.pct_change().dropna()</span><br></pre></td></tr></table></figure>
<p>最后，我们用年对百分比变化进行分组，可以用一个一行的函数，从每行的标签返回每个datetime标签的year属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">124</span>]: get_year = <span class="keyword">lambda</span> x: x.year</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: by_year = rets.groupby(get_year)</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: by_year.apply(spx_corr)</span><br><span class="line">Out[<span class="number">126</span>]: </span><br><span class="line">          AAPL      MSFT       XOM  SPX</span><br><span class="line"><span class="number">2003</span>  <span class="number">0.541124</span>  <span class="number">0.745174</span>  <span class="number">0.661265</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2004</span>  <span class="number">0.374283</span>  <span class="number">0.588531</span>  <span class="number">0.557742</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2005</span>  <span class="number">0.467540</span>  <span class="number">0.562374</span>  <span class="number">0.631010</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2006</span>  <span class="number">0.428267</span>  <span class="number">0.406126</span>  <span class="number">0.518514</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2007</span>  <span class="number">0.508118</span>  <span class="number">0.658770</span>  <span class="number">0.786264</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2008</span>  <span class="number">0.681434</span>  <span class="number">0.804626</span>  <span class="number">0.828303</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2009</span>  <span class="number">0.707103</span>  <span class="number">0.654902</span>  <span class="number">0.797921</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2010</span>  <span class="number">0.710105</span>  <span class="number">0.730118</span>  <span class="number">0.839057</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2011</span>  <span class="number">0.691931</span>  <span class="number">0.800996</span>  <span class="number">0.859975</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>当然，你还可以计算列与列之间的相关系数。这里，我们计算Apple和Microsoft的年相关系数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">127</span>]: by_year.apply(<span class="keyword">lambda</span> g: g[<span class="string">&#x27;AAPL&#x27;</span>].corr(g[<span class="string">&#x27;MSFT&#x27;</span>]))</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line"><span class="number">2003</span>    <span class="number">0.480868</span></span><br><span class="line"><span class="number">2004</span>    <span class="number">0.259024</span></span><br><span class="line"><span class="number">2005</span>    <span class="number">0.300093</span></span><br><span class="line"><span class="number">2006</span>    <span class="number">0.161735</span></span><br><span class="line"><span class="number">2007</span>    <span class="number">0.417738</span></span><br><span class="line"><span class="number">2008</span>    <span class="number">0.611901</span></span><br><span class="line"><span class="number">2009</span>    <span class="number">0.432738</span></span><br><span class="line"><span class="number">2010</span>    <span class="number">0.571946</span></span><br><span class="line"><span class="number">2011</span>    <span class="number">0.581987</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="示例组级别的线性回归">10.3.6 示例：组级别的线性回归</h3>
<p>顺着上一个例子继续，你可以用groupby执行更为复杂的分组统计分析，只要函数返回的是pandas对象或标量值即可。例如，我可以定义下面这个regress函数（利用statsmodels计量经济学库）对各数据块执行普通最小二乘法（Ordinary Least Squares，OLS）回归：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regress</span>(<span class="params">data, yvar, xvars</span>):</span><br><span class="line">    Y = data[yvar]</span><br><span class="line">    X = data[xvars]</span><br><span class="line">    X[<span class="string">&#x27;intercept&#x27;</span>] = <span class="number">1.</span></span><br><span class="line">    result = sm.OLS(Y, X).fit()</span><br><span class="line">    <span class="keyword">return</span> result.params</span><br></pre></td></tr></table></figure>
<p>现在，为了按年计算AAPL对SPX收益率的线性回归，执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">129</span>]: by_year.apply(regress, <span class="string">&#x27;AAPL&#x27;</span>, [<span class="string">&#x27;SPX&#x27;</span>])</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">           SPX  intercept</span><br><span class="line"><span class="number">2003</span>  <span class="number">1.195406</span>   <span class="number">0.000710</span></span><br><span class="line"><span class="number">2004</span>  <span class="number">1.363463</span>   <span class="number">0.004201</span></span><br><span class="line"><span class="number">2005</span>  <span class="number">1.766415</span>   <span class="number">0.003246</span></span><br><span class="line"><span class="number">2006</span>  <span class="number">1.645496</span>   <span class="number">0.000080</span></span><br><span class="line"><span class="number">2007</span>  <span class="number">1.198761</span>   <span class="number">0.003438</span></span><br><span class="line"><span class="number">2008</span>  <span class="number">0.968016</span>  -<span class="number">0.001110</span></span><br><span class="line"><span class="number">2009</span>  <span class="number">0.879103</span>   <span class="number">0.002954</span></span><br><span class="line"><span class="number">2010</span>  <span class="number">1.052608</span>   <span class="number">0.001261</span></span><br><span class="line"><span class="number">2011</span>  <span class="number">0.806605</span>   <span class="number">0.001514</span></span><br></pre></td></tr></table></figure>
<h2 id="透视表和交叉表">10.4 透视表和交叉表</h2>
<p>透视表（pivot table）是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上的分组键将数据分配到各个矩形区域中。在Python和pandas中，可以通过本章所介绍的groupby功能以及（能够利用层次化索引的）重塑运算制作透视表。DataFrame有一个pivot_table方法，此外还有一个顶级的pandas.pivot_table函数。除能为groupby提供便利之外，pivot_table还可以添加分项小计，也叫做margins。</p>
<p>回到小费数据集，假设我想要根据day和smoker计算分组平均数（pivot_table的默认聚合类型），并将day和smoker放到行上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">130</span>]: tips.pivot_table(index=[<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>])</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">                 size       tip   tip_pct  total_bill</span><br><span class="line">day  smoker                                          </span><br><span class="line">Fri  No      <span class="number">2.250000</span>  <span class="number">2.812500</span>  <span class="number">0.151650</span>   <span class="number">18.420000</span></span><br><span class="line">     Yes     <span class="number">2.066667</span>  <span class="number">2.714000</span>  <span class="number">0.174783</span>   <span class="number">16.813333</span></span><br><span class="line">Sat  No      <span class="number">2.555556</span>  <span class="number">3.102889</span>  <span class="number">0.158048</span>   <span class="number">19.661778</span></span><br><span class="line">     Yes     <span class="number">2.476190</span>  <span class="number">2.875476</span>  <span class="number">0.147906</span>   <span class="number">21.276667</span></span><br><span class="line">Sun  No      <span class="number">2.929825</span>  <span class="number">3.167895</span>  <span class="number">0.160113</span>   <span class="number">20.506667</span></span><br><span class="line">     Yes     <span class="number">2.578947</span>  <span class="number">3.516842</span>  <span class="number">0.187250</span>   <span class="number">24.120000</span></span><br><span class="line">Thur No      <span class="number">2.488889</span>  <span class="number">2.673778</span>  <span class="number">0.160298</span>   <span class="number">17.113111</span></span><br><span class="line">     Yes     <span class="number">2.352941</span>  <span class="number">3.030000</span>  <span class="number">0.163863</span>   <span class="number">19.190588</span></span><br></pre></td></tr></table></figure>
<p>可以用groupby直接来做。现在，假设我们只想聚合tip_pct和size，而且想根据time进行分组。我将smoker放到列上，把day放到行上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">131</span>]: tips.pivot_table([<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;size&#x27;</span>], index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;day&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;smoker&#x27;</span>)</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">                 size             tip_pct          </span><br><span class="line">smoker             No       Yes        No       Yes</span><br><span class="line">time   day                                         </span><br><span class="line">Dinner Fri   <span class="number">2.000000</span>  <span class="number">2.222222</span>  <span class="number">0.139622</span>  <span class="number">0.165347</span></span><br><span class="line">       Sat   <span class="number">2.555556</span>  <span class="number">2.476190</span>  <span class="number">0.158048</span>  <span class="number">0.147906</span></span><br><span class="line">       Sun   <span class="number">2.929825</span>  <span class="number">2.578947</span>  <span class="number">0.160113</span>  <span class="number">0.187250</span></span><br><span class="line">       Thur  <span class="number">2.000000</span>       NaN  <span class="number">0.159744</span>       NaN</span><br><span class="line">Lunch  Fri   <span class="number">3.000000</span>  <span class="number">1.833333</span>  <span class="number">0.187735</span>  <span class="number">0.188937</span></span><br><span class="line">       Thur  <span class="number">2.500000</span>  <span class="number">2.352941</span>  <span class="number">0.160311</span>  <span class="number">0.163863</span></span><br></pre></td></tr></table></figure>
<p>还可以对这个表作进一步的处理，传入margins=True添加分项小计。这将会添加标签为All的行和列，其值对应于单个等级中所有数据的分组统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">132</span>]: tips.pivot_table([<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;size&#x27;</span>], index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;day&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;smoker&#x27;</span>, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">                 size                       tip_pct                    </span><br><span class="line">smoker             No       Yes       All        No       Yes       All</span><br><span class="line">time   day                                                             </span><br><span class="line">Dinner Fri   <span class="number">2.000000</span>  <span class="number">2.222222</span>  <span class="number">2.166667</span>  <span class="number">0.139622</span>  <span class="number">0.165347</span>  <span class="number">0.158916</span></span><br><span class="line">       Sat   <span class="number">2.555556</span>  <span class="number">2.476190</span>  <span class="number">2.517241</span>  <span class="number">0.158048</span>  <span class="number">0.147906</span>  <span class="number">0.153152</span></span><br><span class="line">       Sun   <span class="number">2.929825</span>  <span class="number">2.578947</span>  <span class="number">2.842105</span>  <span class="number">0.160113</span>  <span class="number">0.187250</span>  <span class="number">0.166897</span></span><br><span class="line">       Thur  <span class="number">2.000000</span>       NaN  <span class="number">2.000000</span>  <span class="number">0.159744</span>       NaN  <span class="number">0.159744</span></span><br><span class="line">Lunch  Fri   <span class="number">3.000000</span>  <span class="number">1.833333</span>  <span class="number">2.000000</span>  <span class="number">0.187735</span>  <span class="number">0.188937</span>  <span class="number">0.188765</span></span><br><span class="line">       Thur  <span class="number">2.500000</span>  <span class="number">2.352941</span>  <span class="number">2.459016</span>  <span class="number">0.160311</span>  <span class="number">0.163863</span>  <span class="number">0.161301</span></span><br><span class="line">All          <span class="number">2.668874</span>  <span class="number">2.408602</span>  <span class="number">2.569672</span>  <span class="number">0.159328</span>  <span class="number">0.163196</span>  <span class="number">0.160803</span></span><br></pre></td></tr></table></figure>
<p>这里，All值为平均数：不单独考虑烟民与非烟民（All列），不单独考虑行分组两个级别中的任何单项（All行）。</p>
<p>要使用其他的聚合函数，将其传给aggfunc即可。例如，使用count或len可以得到有关分组大小的交叉表（计数或频率）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">133</span>]: tips.pivot_table(<span class="string">&#x27;tip_pct&#x27;</span>, index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>], columns=<span class="string">&#x27;day&#x27;</span>,</span><br><span class="line">   .....:                  aggfunc=<span class="built_in">len</span>, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">day             Fri   Sat   Sun  Thur    All</span><br><span class="line">time   smoker                               </span><br><span class="line">Dinner No       <span class="number">3.0</span>  <span class="number">45.0</span>  <span class="number">57.0</span>   <span class="number">1.0</span>  <span class="number">106.0</span></span><br><span class="line">       Yes      <span class="number">9.0</span>  <span class="number">42.0</span>  <span class="number">19.0</span>   NaN   <span class="number">70.0</span></span><br><span class="line">Lunch  No       <span class="number">1.0</span>   NaN   NaN  <span class="number">44.0</span>   <span class="number">45.0</span></span><br><span class="line">       Yes      <span class="number">6.0</span>   NaN   NaN  <span class="number">17.0</span>   <span class="number">23.0</span></span><br><span class="line">All            <span class="number">19.0</span>  <span class="number">87.0</span>  <span class="number">76.0</span>  <span class="number">62.0</span>  <span class="number">244.0</span></span><br></pre></td></tr></table></figure>
<p>如果存在空的组合（也就是NA），你可能会希望设置一个fill_value：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">134</span>]: tips.pivot_table(<span class="string">&#x27;tip_pct&#x27;</span>, index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;size&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;day&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">day                      Fri       Sat       Sun      Thur</span><br><span class="line">time   size smoker                                        </span><br><span class="line">Dinner <span class="number">1</span>    No      <span class="number">0.000000</span>  <span class="number">0.137931</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.325733</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">2</span>    No      <span class="number">0.139622</span>  <span class="number">0.162705</span>  <span class="number">0.168859</span>  <span class="number">0.159744</span></span><br><span class="line">            Yes     <span class="number">0.171297</span>  <span class="number">0.148668</span>  <span class="number">0.207893</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">3</span>    No      <span class="number">0.000000</span>  <span class="number">0.154661</span>  <span class="number">0.152663</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.144995</span>  <span class="number">0.152660</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">4</span>    No      <span class="number">0.000000</span>  <span class="number">0.150096</span>  <span class="number">0.148143</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.117750</span>  <span class="number">0.124515</span>  <span class="number">0.193370</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">5</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.206928</span>  <span class="number">0.000000</span></span><br><span class="line">Yes     <span class="number">0.000000</span>  <span class="number">0.106572</span>  <span class="number">0.065660</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="meta">... </span>                     ...       ...       ...       ...</span><br><span class="line">Lunch  <span class="number">1</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.181728</span></span><br><span class="line">            Yes     <span class="number">0.223776</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">2</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.166005</span></span><br><span class="line">            Yes     <span class="number">0.181969</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.158843</span></span><br><span class="line">       <span class="number">3</span>    No      <span class="number">0.187735</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.084246</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.204952</span></span><br><span class="line">       <span class="number">4</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.138919</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.155410</span></span><br><span class="line">       <span class="number">5</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.121389</span></span><br><span class="line">       <span class="number">6</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.173706</span></span><br><span class="line">[<span class="number">21</span> rows x <span class="number">4</span> columns]</span><br></pre></td></tr></table></figure>
<p>pivot_table的参数说明请参见表10-2。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap10/7178691-c9e01844c4803a42.png" class="" title="表10-2 pivot_table的选项">
<h3 id="交叉表crosstab">10.4.1 交叉表：crosstab</h3>
<p>交叉表（cross-tabulation，简称crosstab）是一种用于计算分组频率的特殊透视表。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">138</span>]: data</span><br><span class="line">Out[<span class="number">138</span>]:</span><br><span class="line">   Sample Nationality    Handedness</span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>         USA  Right-handed</span><br><span class="line"><span class="number">1</span>       <span class="number">2</span>       Japan   Left-handed</span><br><span class="line"><span class="number">2</span>       <span class="number">3</span>         USA  Right-handed</span><br><span class="line"><span class="number">3</span>       <span class="number">4</span>       Japan  Right-handed</span><br><span class="line"><span class="number">4</span>       <span class="number">5</span>       Japan   Left-handed</span><br><span class="line"><span class="number">5</span>       <span class="number">6</span>       Japan  Right-handed</span><br><span class="line"><span class="number">6</span>       <span class="number">7</span>         USA  Right-handed</span><br><span class="line"><span class="number">7</span>       <span class="number">8</span>         USA   Left-handed</span><br><span class="line"><span class="number">8</span>       <span class="number">9</span>       Japan  Right-handed</span><br><span class="line"><span class="number">9</span>      <span class="number">10</span>         USA  Right-handed</span><br></pre></td></tr></table></figure>
<p>作为调查分析的一部分，我们可能想要根据国籍和用手习惯对这段数据进行统计汇总。虽然可以用pivot_table实现该功能，但是pandas.crosstab函数会更方便：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">139</span>]: pd.crosstab(data.Nationality, data.Handedness, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">139</span>]: </span><br><span class="line">Handedness   Left-handed  Right-handed  All</span><br><span class="line">Nationality</span><br><span class="line">Japan                  <span class="number">2</span>             <span class="number">3</span>    <span class="number">5</span></span><br><span class="line">USA                    <span class="number">1</span>             <span class="number">4</span>    <span class="number">5</span></span><br><span class="line">All                    <span class="number">3</span>             <span class="number">7</span>   <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>crosstab的前两个参数可以是数组或Series，或是数组列表。就像小费数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">140</span>]: pd.crosstab([tips.time, tips.day], tips.smoker, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">smoker        No  Yes  All</span><br><span class="line">time   day                </span><br><span class="line">Dinner Fri     <span class="number">3</span>    <span class="number">9</span>   <span class="number">12</span></span><br><span class="line">       Sat    <span class="number">45</span>   <span class="number">42</span>   <span class="number">87</span></span><br><span class="line">       Sun    <span class="number">57</span>   <span class="number">19</span>   <span class="number">76</span></span><br><span class="line">       Thur    <span class="number">1</span>    <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">Lunch  Fri     <span class="number">1</span>    <span class="number">6</span>    <span class="number">7</span></span><br><span class="line">       Thur   <span class="number">44</span>   <span class="number">17</span>   <span class="number">61</span></span><br><span class="line">All          <span class="number">151</span>   <span class="number">93</span>  <span class="number">244</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">10.5 总结</h2>
<p>掌握pandas数据分组工具既有助于数据清理，也有助于建模或统计分析工作。在第14章，我们会看几个例子，对真实数据使用groupby。</p>
<p>在下一章，我们将关注时间序列数据。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第11章_时间序列</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap11/</url>
    <content><![CDATA[<h1 id="第11章-时间序列">第11章 时间序列</h1>
<p>时间序列（time series）数据是一种重要的结构化数据形式，应用于多个领域，包括金融学、经济学、生态学、神经科学、物理学等。在多个时间点观察或测量到的任何事物都可以形成一段时间序列。很多时间序列是固定频率的，也就是说，数据点是根据某种规律定期出现的（比如每15秒、每5分钟、每月出现一次）。时间序列也可以是不定期的，没有固定的时间单位或单位之间的偏移量。时间序列数据的意义取决于具体的应用场景，主要有以下几种：</p>
<ul>
<li>时间戳（timestamp），特定的时刻。</li>
<li>固定时期（period），如2007年1月或2010年全年。</li>
<li>时间间隔（interval），由起始和结束时间戳表示。时期（period）可以被看做间隔（interval）的特例。</li>
<li>实验或过程时间，每个时间点都是相对于特定起始时间的一个度量。例如，从放入烤箱时起，每秒钟饼干的直径。</li>
</ul>
<span id="more"></span>
<p>本章主要讲解前3种时间序列。许多技术都可用于处理实验型时间序列，其索引可能是一个整数或浮点数（表示从实验开始算起已经过去的时间）。最简单也最常见的时间序列都是用时间戳进行索引的。</p>
<blockquote>
<p>提示：pandas也支持基于timedeltas的指数，它可以有效代表实验或经过的时间。这本书不涉及timedelta指数，但你可以学习pandas的文档（http://pandas.pydata.org/）。</p>
</blockquote>
<p>pandas提供了许多内置的时间序列处理工具和数据算法。因此，你可以高效处理非常大的时间序列，轻松地进行切片/切块、聚合、对定期/不定期的时间序列进行重采样等。有些工具特别适合金融和经济应用，你当然也可以用它们来分析服务器日志数据。</p>
<h2 id="日期和时间数据类型及工具">11.1 日期和时间数据类型及工具</h2>
<p>Python标准库包含用于日期（date）和时间（time）数据的数据类型，而且还有日历方面的功能。我们主要会用到datetime、time以及calendar模块。datetime.datetime（也可以简写为datetime）是用得最多的数据类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: now = datetime.now()</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: now</span><br><span class="line">Out[<span class="number">12</span>]: datetime.datetime(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">25</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">52</span>, <span class="number">72973</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: now.year, now.month, now.day</span><br><span class="line">Out[<span class="number">13</span>]: (<span class="number">2017</span>, <span class="number">9</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure>
<p>datetime以毫秒形式存储日期和时间。timedelta表示两个datetime对象之间的时间差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: delta = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>) - datetime(<span class="number">2008</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: delta</span><br><span class="line">Out[<span class="number">15</span>]: datetime.timedelta(<span class="number">926</span>, <span class="number">56700</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: delta.days</span><br><span class="line">Out[<span class="number">16</span>]: <span class="number">926</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: delta.seconds</span><br><span class="line">Out[<span class="number">17</span>]: <span class="number">56700</span></span><br></pre></td></tr></table></figure>
<p>可以给datetime对象加上（或减去）一个或多个timedelta，这样会产生一个新对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: start = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: start + timedelta(<span class="number">12</span>)</span><br><span class="line">Out[<span class="number">20</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: start - <span class="number">2</span> * timedelta(<span class="number">12</span>)</span><br><span class="line">Out[<span class="number">21</span>]: datetime.datetime(<span class="number">2010</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>datetime模块中的数据类型参见表10-1。虽然本章主要讲的是pandas数据类型和高级时间序列处理，但你肯定会在Python的其他地方遇到有关datetime的数据类型。</p>
<p>表11-1 datetime模块中的数据类型</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-4af261a305a70aeb.png" class="">
<p>tzinfo 存储时区信息的基本类型</p>
<h3 id="字符串和datetime的相互转换">11.1.1 字符串和datetime的相互转换</h3>
<p>利用str或strftime方法（传入一个格式化字符串），datetime对象和pandas的Timestamp对象（稍后就会介绍）可以被格式化为字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: stamp = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: <span class="built_in">str</span>(stamp)</span><br><span class="line">Out[<span class="number">23</span>]: <span class="string">&#x27;2011-01-03 00:00:00&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: stamp.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">Out[<span class="number">24</span>]: <span class="string">&#x27;2011-01-03&#x27;</span></span><br></pre></td></tr></table></figure>
<p>表11-2列出了全部的格式化编码。</p>
<p>表11-2 datetime格式定义（兼容ISO C89）</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-50c751823754df58.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-de0181e1f6b45eaf.png" class="">
<p>datetime.strptime可以用这些格式化编码将字符串转换为日期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: value = <span class="string">&#x27;2011-01-03&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: datetime.strptime(value, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">Out[<span class="number">26</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: datestrs = [<span class="string">&#x27;7/6/2011&#x27;</span>, <span class="string">&#x27;8/6/2011&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: [datetime.strptime(x, <span class="string">&#x27;%m/%d/%Y&#x27;</span>) <span class="keyword">for</span> x <span class="keyword">in</span> datestrs]</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">[datetime.datetime(<span class="number">2011</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"> datetime.datetime(<span class="number">2011</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>)]</span><br></pre></td></tr></table></figure>
<p>datetime.strptime是通过已知格式进行日期解析的最佳方式。但是每次都要编写格式定义是很麻烦的事情，尤其是对于一些常见的日期格式。这种情况下，你可以用dateutil这个第三方包中的parser.parse方法（pandas中已经自动安装好了）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: <span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: parse(<span class="string">&#x27;2011-01-03&#x27;</span>)</span><br><span class="line">Out[<span class="number">30</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>dateutil可以解析几乎所有人类能够理解的日期表示形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: parse(<span class="string">&#x27;Jan 31, 1997 10:45 PM&#x27;</span>)</span><br><span class="line">Out[<span class="number">31</span>]: datetime.datetime(<span class="number">1997</span>, <span class="number">1</span>, <span class="number">31</span>, <span class="number">22</span>, <span class="number">45</span>)</span><br></pre></td></tr></table></figure>
<p>在国际通用的格式中，日出现在月的前面很普遍，传入dayfirst=True即可解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: parse(<span class="string">&#x27;6/12/2011&#x27;</span>, dayfirst=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">32</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>pandas通常是用于处理成组日期的，不管这些日期是DataFrame的轴索引还是列。to_datetime方法可以解析多种不同的日期表示形式。对标准日期格式（如ISO8601）的解析非常快：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: datestrs = [<span class="string">&#x27;2011-07-06 12:00:00&#x27;</span>, <span class="string">&#x27;2011-08-06 00:00:00&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: pd.to_datetime(datestrs)</span><br><span class="line">Out[<span class="number">34</span>]: DatetimeIndex([<span class="string">&#x27;2011-07-06 12:00:00&#x27;</span>, <span class="string">&#x27;2011-08-06 00:00:00&#x27;</span>], dtype=<span class="string">&#x27;dat</span></span><br><span class="line"><span class="string">etime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>它还可以处理缺失值（None、空字符串等）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: idx = pd.to_datetime(datestrs + [<span class="literal">None</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: idx</span><br><span class="line">Out[<span class="number">36</span>]: DatetimeIndex([<span class="string">&#x27;2011-07-06 12:00:00&#x27;</span>, <span class="string">&#x27;2011-08-06 00:00:00&#x27;</span>, <span class="string">&#x27;NaT&#x27;</span>], dty</span><br><span class="line">pe=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: idx[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">37</span>]: NaT</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: pd.isnull(idx)</span><br><span class="line">Out[<span class="number">38</span>]: array([<span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>], dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure>
<p>NaT（Not a Time）是pandas中时间戳数据的null值。</p>
<blockquote>
<p>注意：dateutil.parser是一个实用但不完美的工具。比如说，它会把一些原本不是日期的字符串认作是日期（比如"42"会被解析为2042年的今天）。</p>
</blockquote>
<p>datetime对象还有一些特定于当前环境（位于不同国家或使用不同语言的系统）的格式化选项。例如，德语或法语系统所用的月份简写就与英语系统所用的不同。表11-3进行了总结。</p>
<p>表11-3 特定于当前环境的日期格式</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-cf0119398273e2b0.png" class="">
<h2 id="时间序列基础">11.2 时间序列基础</h2>
<p>pandas最基本的时间序列类型就是以时间戳（通常以Python字符串或datatime对象表示）为索引的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: dates = [datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">2</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">   ....:          datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">8</span>),</span><br><span class="line">   ....:          datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">10</span>), datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">12</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: ts = pd.Series(np.random.randn(<span class="number">6</span>), index=dates)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: ts</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>这些datetime对象实际上是被放在一个DatetimeIndex中的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: ts.index</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2011-01-02&#x27;</span>, <span class="string">&#x27;2011-01-05&#x27;</span>, <span class="string">&#x27;2011-01-07&#x27;</span>, <span class="string">&#x27;2011-01-08&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2011-01-10&#x27;</span>, <span class="string">&#x27;2011-01-12&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>跟其他Series一样，不同索引的时间序列之间的算术运算会自动按日期对齐：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: ts + ts[::<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.409415</span></span><br><span class="line"><span class="number">2011</span>-01-05         NaN</span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">1.038877</span></span><br><span class="line"><span class="number">2011</span>-01-08         NaN</span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">3.931561</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>         NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>ts[::2] 是每隔两个取一个。</p>
<p>pandas用NumPy的datetime64数据类型以纳秒形式存储时间戳：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: ts.index.dtype</span><br><span class="line">Out[<span class="number">45</span>]: dtype(<span class="string">&#x27;&lt;M8[ns]&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>DatetimeIndex中的各个标量值是pandas的Timestamp对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: stamp = ts.index[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: stamp</span><br><span class="line">Out[<span class="number">47</span>]: Timestamp(<span class="string">&#x27;2011-01-02 00:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>只要有需要，TimeStamp可以随时自动转换为datetime对象。此外，它还可以存储频率信息（如果有的话），且知道如何执行时区转换以及其他操作。稍后将对此进行详细讲解。</p>
<h3 id="索引选取子集构造">11.2.1 索引、选取、子集构造</h3>
<p>当你根据标签索引选取数据时，时间序列和其它的pandas.Series很像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">48</span>]: stamp = ts.index[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: ts[stamp]</span><br><span class="line">Out[<span class="number">49</span>]: -<span class="number">0.51943871505673811</span></span><br></pre></td></tr></table></figure>
<p>还有一种更为方便的用法：传入一个可以被解释为日期的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: ts[<span class="string">&#x27;1/10/2011&#x27;</span>]</span><br><span class="line">Out[<span class="number">50</span>]: <span class="number">1.9657805725027142</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: ts[<span class="string">&#x27;20110110&#x27;</span>]</span><br><span class="line">Out[<span class="number">51</span>]: <span class="number">1.9657805725027142</span></span><br></pre></td></tr></table></figure>
<p>对于较长的时间序列，只需传入“年”或“年月”即可轻松选取数据的切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">52</span>]: longer_ts = pd.Series(np.random.randn(<span class="number">1000</span>),</span><br><span class="line">   ....:                       index=pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: longer_ts</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0.092908</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">0.281746</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">0.769023</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">1.246435</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">1.007189</span></span><br><span class="line"><span class="number">2000</span>-01-06   -<span class="number">1.296221</span></span><br><span class="line"><span class="number">2000</span>-01-07    <span class="number">0.274992</span></span><br><span class="line"><span class="number">2000</span>-01-08    <span class="number">0.228913</span></span><br><span class="line"><span class="number">2000</span>-01-09    <span class="number">1.352917</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">0.886429</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2002</span>-09-<span class="number">17</span>   -<span class="number">0.139298</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">18</span>   -<span class="number">1.159926</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">19</span>    <span class="number">0.618965</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">20</span>    <span class="number">1.373890</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">21</span>   -<span class="number">0.983505</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">22</span>    <span class="number">0.930944</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">23</span>   -<span class="number">0.811676</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">24</span>   -<span class="number">1.830156</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">25</span>   -<span class="number">0.138730</span></span><br><span class="line"><span class="number">2002</span>-09-<span class="number">26</span>    <span class="number">0.334088</span></span><br><span class="line">Freq: D, Length: <span class="number">1000</span>, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: longer_ts[<span class="string">&#x27;2001&#x27;</span>]</span><br><span class="line">Out[<span class="number">54</span>]: </span><br><span class="line"><span class="number">2001</span>-01-01    <span class="number">1.599534</span></span><br><span class="line"><span class="number">2001</span>-01-02    <span class="number">0.474071</span></span><br><span class="line"><span class="number">2001</span>-01-03    <span class="number">0.151326</span></span><br><span class="line"><span class="number">2001</span>-01-04   -<span class="number">0.542173</span></span><br><span class="line"><span class="number">2001</span>-01-05   -<span class="number">0.475496</span></span><br><span class="line"><span class="number">2001</span>-01-06    <span class="number">0.106403</span></span><br><span class="line"><span class="number">2001</span>-01-07   -<span class="number">1.308228</span></span><br><span class="line"><span class="number">2001</span>-01-08    <span class="number">2.173185</span></span><br><span class="line"><span class="number">2001</span>-01-09    <span class="number">0.564561</span></span><br><span class="line"><span class="number">2001</span>-01-<span class="number">10</span>   -<span class="number">0.190481</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">22</span>    <span class="number">0.000369</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">23</span>    <span class="number">0.900885</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">24</span>   -<span class="number">0.454869</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">25</span>   -<span class="number">0.864547</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">26</span>    <span class="number">1.129120</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">27</span>    <span class="number">0.057874</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">28</span>   -<span class="number">0.433739</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">29</span>    <span class="number">0.092698</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">30</span>   -<span class="number">1.397820</span></span><br><span class="line"><span class="number">2001</span>-<span class="number">12</span>-<span class="number">31</span>    <span class="number">1.457823</span></span><br><span class="line">Freq: D, Length: <span class="number">365</span>, dtype: float64</span><br></pre></td></tr></table></figure>
<p>这里，字符串“2001”被解释成年，并根据它选取时间区间。指定月也同样奏效：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: longer_ts[<span class="string">&#x27;2001-05&#x27;</span>]</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line"><span class="number">2001</span>-05-01   -<span class="number">0.622547</span></span><br><span class="line"><span class="number">2001</span>-05-02    <span class="number">0.936289</span></span><br><span class="line"><span class="number">2001</span>-05-03    <span class="number">0.750018</span></span><br><span class="line"><span class="number">2001</span>-05-04   -<span class="number">0.056715</span></span><br><span class="line"><span class="number">2001</span>-05-05    <span class="number">2.300675</span></span><br><span class="line"><span class="number">2001</span>-05-06    <span class="number">0.569497</span></span><br><span class="line"><span class="number">2001</span>-05-07    <span class="number">1.489410</span></span><br><span class="line"><span class="number">2001</span>-05-08    <span class="number">1.264250</span></span><br><span class="line"><span class="number">2001</span>-05-09   -<span class="number">0.761837</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">10</span>   -<span class="number">0.331617</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2001</span>-05-<span class="number">22</span>    <span class="number">0.503699</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">23</span>   -<span class="number">1.387874</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">24</span>    <span class="number">0.204851</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">25</span>    <span class="number">0.603705</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">26</span>    <span class="number">0.545680</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">27</span>    <span class="number">0.235477</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">28</span>    <span class="number">0.111835</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">29</span>   -<span class="number">1.251504</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">30</span>   -<span class="number">2.949343</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">31</span>    <span class="number">0.634634</span></span><br><span class="line">Freq: D, Length: <span class="number">31</span>, dtype: float64</span><br></pre></td></tr></table></figure>
<p>datetime对象也可以进行切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: ts[datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>):]</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>由于大部分时间序列数据都是按照时间先后排序的，因此你也可以用不存在于该时间序列中的时间戳对其进行切片（即范围查询）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: ts</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: ts[<span class="string">&#x27;1/6/2011&#x27;</span>:<span class="string">&#x27;1/11/2011&#x27;</span>]</span><br><span class="line">Out[<span class="number">58</span>]: </span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>跟之前一样，你可以传入字符串日期、datetime或Timestamp。注意，这样切片所产生的是原时间序列的视图，跟NumPy数组的切片运算是一样的。</p>
<p>这意味着，没有数据被复制，对切片进行修改会反映到原始数据上。</p>
<p>此外，还有一个等价的实例方法也可以截取两个日期之间TimeSeries：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">59</span>]: ts.truncate(after=<span class="string">&#x27;1/9/2011&#x27;</span>)</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>面这些操作对DataFrame也有效。例如，对DataFrame的行进行索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: dates = pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">100</span>, freq=<span class="string">&#x27;W-WED&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: long_df = pd.DataFrame(np.random.randn(<span class="number">100</span>, <span class="number">4</span>),</span><br><span class="line">   ....:                        index=dates,</span><br><span class="line">   ....:                        columns=[<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>,</span><br><span class="line">   ....:                                 <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: long_df.loc[<span class="string">&#x27;5-2001&#x27;</span>]</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2001</span>-05-02 -<span class="number">0.006045</span>  <span class="number">0.490094</span> -<span class="number">0.277186</span> -<span class="number">0.707213</span></span><br><span class="line"><span class="number">2001</span>-05-09 -<span class="number">0.560107</span>  <span class="number">2.735527</span>  <span class="number">0.927335</span>  <span class="number">1.513906</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">16</span>  <span class="number">0.538600</span>  <span class="number">1.273768</span>  <span class="number">0.667876</span> -<span class="number">0.969206</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">23</span>  <span class="number">1.676091</span> -<span class="number">0.817649</span>  <span class="number">0.050188</span>  <span class="number">1.951312</span></span><br><span class="line"><span class="number">2001</span>-05-<span class="number">30</span>  <span class="number">3.260383</span>  <span class="number">0.963301</span>  <span class="number">1.201206</span> -<span class="number">1.852001</span></span><br></pre></td></tr></table></figure>
<h3 id="带有重复索引的时间序列">11.2.2 带有重复索引的时间序列</h3>
<p>在某些应用场景中，可能会存在多个观测数据落在同一个时间点上的情况。下面就是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: dates = pd.DatetimeIndex([<span class="string">&#x27;1/1/2000&#x27;</span>, <span class="string">&#x27;1/2/2000&#x27;</span>, <span class="string">&#x27;1/2/2000&#x27;</span>,</span><br><span class="line">   ....:                           <span class="string">&#x27;1/2/2000&#x27;</span>, <span class="string">&#x27;1/3/2000&#x27;</span>])</span><br><span class="line">In [<span class="number">64</span>]: dup_ts = pd.Series(np.arange(<span class="number">5</span>), index=dates)</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: dup_ts</span><br><span class="line">Out[<span class="number">65</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>通过检查索引的is_unique属性，我们就可以知道它是不是唯一的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: dup_ts.index.is_unique</span><br><span class="line">Out[<span class="number">66</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>对这个时间序列进行索引，要么产生标量值，要么产生切片，具体要看所选的时间点是否重复：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: dup_ts[<span class="string">&#x27;1/3/2000&#x27;</span>]  <span class="comment"># not duplicated</span></span><br><span class="line">Out[<span class="number">67</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: dup_ts[<span class="string">&#x27;1/2/2000&#x27;</span>]  <span class="comment"># duplicated</span></span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>假设你想要对具有非唯一时间戳的数据进行聚合。一个办法是使用groupby，并传入level=0：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: grouped = dup_ts.groupby(level=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: grouped.mean()</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: grouped.count()</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-02    <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-03    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h2 id="日期的范围频率以及移动">11.3 日期的范围、频率以及移动</h2>
<p>pandas中的原生时间序列一般被认为是不规则的，也就是说，它们没有固定的频率。对于大部分应用程序而言，这是无所谓的。但是，它常常需要以某种相对固定的频率进行分析，比如每日、每月、每15分钟等（这样自然会在时间序列中引入缺失值）。幸运的是，pandas有一整套标准时间序列频率以及用于重采样、频率推断、生成固定频率日期范围的工具。例如，我们可以将之前那个时间序列转换为一个具有固定频率（每日）的时间序列，只需调用resample即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: ts</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line"><span class="number">2011</span>-01-02   -<span class="number">0.204708</span></span><br><span class="line"><span class="number">2011</span>-01-05    <span class="number">0.478943</span></span><br><span class="line"><span class="number">2011</span>-01-07   -<span class="number">0.519439</span></span><br><span class="line"><span class="number">2011</span>-01-08   -<span class="number">0.555730</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">10</span>    <span class="number">1.965781</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">12</span>    <span class="number">1.393406</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: resampler = ts.resample(<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>字符串“D”是每天的意思。</p>
<p>频率的转换（或重采样）是一个比较大的主题，稍后将专门用一节来进行讨论（11.6小节）。这里，我将告诉你如何使用基本的频率和它的倍数。</p>
<h3 id="生成日期范围">11.3.1 生成日期范围</h3>
<p>虽然我之前用的时候没有明说，但你可能已经猜到pandas.date_range可用于根据指定的频率生成指定长度的DatetimeIndex：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: index = pd.date_range(<span class="string">&#x27;2012-04-01&#x27;</span>, <span class="string">&#x27;2012-06-01&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: index</span><br><span class="line">Out[<span class="number">75</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-04-01&#x27;</span>, <span class="string">&#x27;2012-04-02&#x27;</span>, <span class="string">&#x27;2012-04-03&#x27;</span>, <span class="string">&#x27;2012-04-04&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-05&#x27;</span>, <span class="string">&#x27;2012-04-06&#x27;</span>, <span class="string">&#x27;2012-04-07&#x27;</span>, <span class="string">&#x27;2012-04-08&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-09&#x27;</span>, <span class="string">&#x27;2012-04-10&#x27;</span>, <span class="string">&#x27;2012-04-11&#x27;</span>, <span class="string">&#x27;2012-04-12&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-13&#x27;</span>, <span class="string">&#x27;2012-04-14&#x27;</span>, <span class="string">&#x27;2012-04-15&#x27;</span>, <span class="string">&#x27;2012-04-16&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-17&#x27;</span>, <span class="string">&#x27;2012-04-18&#x27;</span>, <span class="string">&#x27;2012-04-19&#x27;</span>, <span class="string">&#x27;2012-04-20&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-21&#x27;</span>, <span class="string">&#x27;2012-04-22&#x27;</span>, <span class="string">&#x27;2012-04-23&#x27;</span>, <span class="string">&#x27;2012-04-24&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-25&#x27;</span>, <span class="string">&#x27;2012-04-26&#x27;</span>, <span class="string">&#x27;2012-04-27&#x27;</span>, <span class="string">&#x27;2012-04-28&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-29&#x27;</span>, <span class="string">&#x27;2012-04-30&#x27;</span>, <span class="string">&#x27;2012-05-01&#x27;</span>, <span class="string">&#x27;2012-05-02&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-03&#x27;</span>, <span class="string">&#x27;2012-05-04&#x27;</span>, <span class="string">&#x27;2012-05-05&#x27;</span>, <span class="string">&#x27;2012-05-06&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-07&#x27;</span>, <span class="string">&#x27;2012-05-08&#x27;</span>, <span class="string">&#x27;2012-05-09&#x27;</span>, <span class="string">&#x27;2012-05-10&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-11&#x27;</span>, <span class="string">&#x27;2012-05-12&#x27;</span>, <span class="string">&#x27;2012-05-13&#x27;</span>, <span class="string">&#x27;2012-05-14&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-15&#x27;</span>, <span class="string">&#x27;2012-05-16&#x27;</span>, <span class="string">&#x27;2012-05-17&#x27;</span>, <span class="string">&#x27;2012-05-18&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-19&#x27;</span>, <span class="string">&#x27;2012-05-20&#x27;</span>, <span class="string">&#x27;2012-05-21&#x27;</span>, <span class="string">&#x27;2012-05-22&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-23&#x27;</span>, <span class="string">&#x27;2012-05-24&#x27;</span>, <span class="string">&#x27;2012-05-25&#x27;</span>, <span class="string">&#x27;2012-05-26&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-27&#x27;</span>, <span class="string">&#x27;2012-05-28&#x27;</span>, <span class="string">&#x27;2012-05-29&#x27;</span>, <span class="string">&#x27;2012-05-30&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-31&#x27;</span>, <span class="string">&#x27;2012-06-01&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>默认情况下，date_range会产生按天计算的时间点。如果只传入起始或结束日期，那就还得传入一个表示一段时间的数字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: pd.date_range(start=<span class="string">&#x27;2012-04-01&#x27;</span>, periods=<span class="number">20</span>)</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-04-01&#x27;</span>, <span class="string">&#x27;2012-04-02&#x27;</span>, <span class="string">&#x27;2012-04-03&#x27;</span>, <span class="string">&#x27;2012-04-04&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-05&#x27;</span>, <span class="string">&#x27;2012-04-06&#x27;</span>, <span class="string">&#x27;2012-04-07&#x27;</span>, <span class="string">&#x27;2012-04-08&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-09&#x27;</span>, <span class="string">&#x27;2012-04-10&#x27;</span>, <span class="string">&#x27;2012-04-11&#x27;</span>, <span class="string">&#x27;2012-04-12&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-13&#x27;</span>, <span class="string">&#x27;2012-04-14&#x27;</span>, <span class="string">&#x27;2012-04-15&#x27;</span>, <span class="string">&#x27;2012-04-16&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-04-17&#x27;</span>, <span class="string">&#x27;2012-04-18&#x27;</span>, <span class="string">&#x27;2012-04-19&#x27;</span>, <span class="string">&#x27;2012-04-20&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: pd.date_range(end=<span class="string">&#x27;2012-06-01&#x27;</span>, periods=<span class="number">20</span>)</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-05-13&#x27;</span>, <span class="string">&#x27;2012-05-14&#x27;</span>, <span class="string">&#x27;2012-05-15&#x27;</span>, <span class="string">&#x27;2012-05-16&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-17&#x27;</span>, <span class="string">&#x27;2012-05-18&#x27;</span>, <span class="string">&#x27;2012-05-19&#x27;</span>, <span class="string">&#x27;2012-05-20&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-21&#x27;</span>, <span class="string">&#x27;2012-05-22&#x27;</span>, <span class="string">&#x27;2012-05-23&#x27;</span>, <span class="string">&#x27;2012-05-24&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-25&#x27;</span>, <span class="string">&#x27;2012-05-26&#x27;</span>, <span class="string">&#x27;2012-05-27&#x27;</span>,<span class="string">&#x27;2012-05-28&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-29&#x27;</span>, <span class="string">&#x27;2012-05-30&#x27;</span>, <span class="string">&#x27;2012-05-31&#x27;</span>, <span class="string">&#x27;2012-06-01&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>起始和结束日期定义了日期索引的严格边界。例如，如果你想要生成一个由每月最后一个工作日组成的日期索引，可以传入"BM"频率（表示business end of month，表11-4是频率列表），这样就只会包含时间间隔内（或刚好在边界上的）符合频率要求的日期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, <span class="string">&#x27;2000-12-01&#x27;</span>, freq=<span class="string">&#x27;BM&#x27;</span>)</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2000-01-31&#x27;</span>, <span class="string">&#x27;2000-02-29&#x27;</span>, <span class="string">&#x27;2000-03-31&#x27;</span>, <span class="string">&#x27;2000-04-28&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-05-31&#x27;</span>, <span class="string">&#x27;2000-06-30&#x27;</span>, <span class="string">&#x27;2000-07-31&#x27;</span>, <span class="string">&#x27;2000-08-31&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-09-29&#x27;</span>, <span class="string">&#x27;2000-10-31&#x27;</span>, <span class="string">&#x27;2000-11-30&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;BM&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>表11-4 基本的时间序列频率（不完整）</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-c8614ddbd10793ca.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-8da46ba96544b071.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-3ca410609195edc4.png" class="">
<p>date_range默认会保留起始和结束时间戳的时间信息（如果有的话）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: pd.date_range(<span class="string">&#x27;2012-05-02 12:56:31&#x27;</span>, periods=<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-05-02 12:56:31&#x27;</span>, <span class="string">&#x27;2012-05-03 12:56:31&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-04 12:56:31&#x27;</span>, <span class="string">&#x27;2012-05-05 12:56:31&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-06 12:56:31&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>有时，虽然起始和结束日期带有时间信息，但你希望产生一组被规范化（normalize）到午夜的时间戳。normalize选项即可实现该功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">80</span>]: pd.date_range(<span class="string">&#x27;2012-05-02 12:56:31&#x27;</span>, periods=<span class="number">5</span>, normalize=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-05-02&#x27;</span>, <span class="string">&#x27;2012-05-03&#x27;</span>, <span class="string">&#x27;2012-05-04&#x27;</span>, <span class="string">&#x27;2012-05-05&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-05-06&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="频率和日期偏移量">11.3.2 频率和日期偏移量</h3>
<p>pandas中的频率是由一个基础频率（base frequency）和一个乘数组成的。基础频率通常以一个字符串别名表示，比如"M"表示每月，"H"表示每小时。对于每个基础频率，都有一个被称为日期偏移量（date offset）的对象与之对应。例如，按小时计算的频率可以用Hour类表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: <span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour, Minute</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: hour = Hour()</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: hour</span><br><span class="line">Out[<span class="number">83</span>]: &lt;Hour&gt;</span><br></pre></td></tr></table></figure>
<p>传入一个整数即可定义偏移量的倍数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">84</span>]: four_hours = Hour(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: four_hours</span><br><span class="line">Out[<span class="number">85</span>]: &lt;<span class="number">4</span> * Hours&gt;</span><br></pre></td></tr></table></figure>
<p>一般来说，无需明确创建这样的对象，只需使用诸如"H"或"4H"这样的字符串别名即可。在基础频率前面放上一个整数即可创建倍数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">86</span>]: pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, <span class="string">&#x27;2000-01-03 23:59&#x27;</span>, freq=<span class="string">&#x27;4h&#x27;</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2000-01-01 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 04:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 08:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 12:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 16:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 20:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-02 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-02 04:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-02 08:00:00&#x27;</span>, <span class="string">&#x27;2000-01-02 12:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-02 16:00:00&#x27;</span>, <span class="string">&#x27;2000-01-02 20:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-03 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-03 04:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-03 08:00:00&#x27;</span>, <span class="string">&#x27;2000-01-03 12:00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-03 16:00:00&#x27;</span>, <span class="string">&#x27;2000-01-03 20:00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;4H&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>大部分偏移量对象都可通过加法进行连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: Hour(<span class="number">2</span>) + Minute(<span class="number">30</span>)</span><br><span class="line">Out[<span class="number">87</span>]: &lt;<span class="number">150</span> * Minutes&gt;</span><br></pre></td></tr></table></figure>
<p>同理，你也可以传入频率字符串（如"2h30min"），这种字符串可以被高效地解析为等效的表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">88</span>]: pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">10</span>, freq=<span class="string">&#x27;1h30min&#x27;</span>)</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2000-01-01 00:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 01:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 03:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 04:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 06:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 07:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 09:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 10:30:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2000-01-01 12:00:00&#x27;</span>, <span class="string">&#x27;2000-01-01 13:30:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;90T&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>有些频率所描述的时间点并不是均匀分隔的。例如，"M"（日历月末）和"BM"（每月最后一个工作日）就取决于每月的天数，对于后者，还要考虑月末是不是周末。由于没有更好的术语，我将这些称为锚点偏移量（anchored offset）。</p>
<p>表11-4列出了pandas中的频率代码和日期偏移量类。</p>
<blockquote>
<p>笔记：用户可以根据实际需求自定义一些频率类以便提供pandas所没有的日期逻辑，但具体的细节超出了本书的范围。</p>
</blockquote>
<p>表11-4 时间序列的基础频率</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-ff139312cd972204.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-adfa57a998c0296e.png" class="">
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-d09e577a10d0e6eb.png" class="">
<h3 id="wom日期">11.3.3 WOM日期</h3>
<p>WOM（Week Of Month）是一种非常实用的频率类，它以WOM开头。它使你能获得诸如“每月第3个星期五”之类的日期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: rng = pd.date_range(<span class="string">&#x27;2012-01-01&#x27;</span>, <span class="string">&#x27;2012-09-01&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: <span class="built_in">list</span>(rng)</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">[Timestamp(<span class="string">&#x27;2012-01-20 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-02-17 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-03-16 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-04-20 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-05-18 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-06-15 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-07-20 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>),</span><br><span class="line"> Timestamp(<span class="string">&#x27;2012-08-17 00:00:00&#x27;</span>, freq=<span class="string">&#x27;WOM-3FRI&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="移动超前和滞后数据">11.3.4 移动（超前和滞后）数据</h3>
<p>移动（shifting）指的是沿着时间轴将数据前移或后移。Series和DataFrame都有一个shift方法用于执行单纯的前移或后移操作，保持索引不变：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: ts = pd.Series(np.random.randn(<span class="number">4</span>),</span><br><span class="line">   ....:                index=pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">4</span>, freq=<span class="string">&#x27;M&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: ts</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>   -<span class="number">0.517795</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: ts.shift(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>         NaN</span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>         NaN</span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>    <span class="number">0.838639</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: ts.shift(-<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>   -<span class="number">0.517795</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>         NaN</span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>         NaN</span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<p>当我们这样进行移动时，就会在时间序列的前面或后面产生缺失数据。</p>
<p>shift通常用于计算一个时间序列或多个时间序列（如DataFrame的列）中的百分比变化。可以这样表达：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts / ts.shift(<span class="number">1</span>) - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>由于单纯的移位操作不会修改索引，所以部分数据会被丢弃。因此，如果频率已知，则可以将其传给shift以便实现对时间戳进行位移而不是对数据进行简单位移：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: ts.shift(<span class="number">2</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-05-<span class="number">31</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-06-<span class="number">30</span>   -<span class="number">0.517795</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<p>这里还可以使用其他频率，于是你就能非常灵活地对数据进行超前和滞后处理了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: ts.shift(<span class="number">3</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">Out[<span class="number">96</span>]: </span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-03-03    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-04-03   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-05-03   -<span class="number">0.517795</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: ts.shift(<span class="number">1</span>, freq=<span class="string">&#x27;90T&#x27;</span>)</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span> 01:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.066748</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span> 01:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.838639</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span> 01:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.117388</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span> 01:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.517795</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="通过偏移量对日期进行位移">11.3.5 通过偏移量对日期进行位移</h3>
<p>pandas的日期偏移量还可以用在datetime或Timestamp对象上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: <span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Day, MonthEnd</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: now = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: now + <span class="number">3</span> * Day()</span><br><span class="line">Out[<span class="number">100</span>]: Timestamp(<span class="string">&#x27;2011-11-20 00:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果加的是锚点偏移量（比如MonthEnd），第一次增量会将原日期向前滚动到符合频率规则的下一个日期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: now + MonthEnd()</span><br><span class="line">Out[<span class="number">101</span>]: Timestamp(<span class="string">&#x27;2011-11-30 00:00:00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: now + MonthEnd(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">102</span>]: Timestamp(<span class="string">&#x27;2011-12-31 00:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>通过锚点偏移量的rollforward和rollback方法，可明确地将日期向前或向后“滚动”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">103</span>]: offset = MonthEnd()</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: offset.rollforward(now)</span><br><span class="line">Out[<span class="number">104</span>]: Timestamp(<span class="string">&#x27;2011-11-30 00:00:00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: offset.rollback(now)</span><br><span class="line">Out[<span class="number">105</span>]: Timestamp(<span class="string">&#x27;2011-10-31 00:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>日期偏移量还有一个巧妙的用法，即结合groupby使用这两个“滚动”方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: ts = pd.Series(np.random.randn(<span class="number">20</span>),</span><br><span class="line">   .....:                index=pd.date_range(<span class="string">&#x27;1/15/2000&#x27;</span>, periods=<span class="number">20</span>, freq=<span class="string">&#x27;4d&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: ts</span><br><span class="line">Out[<span class="number">107</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">15</span>   -<span class="number">0.116696</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">19</span>    <span class="number">2.389645</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">23</span>   -<span class="number">0.932454</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">27</span>   -<span class="number">0.229331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">1.140330</span></span><br><span class="line"><span class="number">2000</span>-02-04    <span class="number">0.439920</span></span><br><span class="line"><span class="number">2000</span>-02-08   -<span class="number">0.823758</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">12</span>   -<span class="number">0.520930</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">16</span>    <span class="number">0.350282</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">20</span>    <span class="number">0.204395</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">24</span>    <span class="number">0.133445</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">28</span>    <span class="number">0.327905</span></span><br><span class="line"><span class="number">2000</span>-03-03    <span class="number">0.072153</span></span><br><span class="line"><span class="number">2000</span>-03-07    <span class="number">0.131678</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">11</span>   -<span class="number">1.297459</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">15</span>    <span class="number">0.997747</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">19</span>    <span class="number">0.870955</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">23</span>   -<span class="number">0.991253</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">27</span>    <span class="number">0.151699</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">1.266151</span></span><br><span class="line">Freq: 4D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: ts.groupby(offset.rollforward).mean()</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.005833</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.015894</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">0.150209</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>当然，更简单、更快速地实现该功能的办法是使用resample（11.6小节将对此进行详细介绍）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: ts.resample(<span class="string">&#x27;M&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.005833</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.015894</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">0.150209</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<h2 id="时区处理">11.4 时区处理</h2>
<p>时间序列处理工作中最让人不爽的就是对时区的处理。许多人都选择以协调世界时（UTC，它是格林尼治标准时间（Greenwich Mean Time）的接替者，目前已经是国际标准了）来处理时间序列。时区是以UTC偏移量的形式表示的。例如，夏令时期间，纽约比UTC慢4小时，而在全年其他时间则比UTC慢5小时。</p>
<p>在Python中，时区信息来自第三方库pytz，它使Python可以使用Olson数据库（汇编了世界时区信息）。这对历史数据非常重要，这是因为由于各地政府的各种突发奇想，夏令时转变日期（甚至UTC偏移量）已经发生过多次改变了。就拿美国来说，DST转变时间自1900年以来就改变过多次！</p>
<p>有关pytz库的更多信息，请查阅其文档。就本书而言，由于pandas包装了pytz的功能，因此你可以不用记忆其API，只要记得时区的名称即可。时区名可以在shell中看到，也可以通过文档查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: <span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: pytz.common_timezones[-<span class="number">5</span>:]</span><br><span class="line">Out[<span class="number">111</span>]: [<span class="string">&#x27;US/Eastern&#x27;</span>, <span class="string">&#x27;US/Hawaii&#x27;</span>, <span class="string">&#x27;US/Mountain&#x27;</span>, <span class="string">&#x27;US/Pacific&#x27;</span>, <span class="string">&#x27;UTC&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>要从pytz中获取时区对象，使用pytz.timezone即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">112</span>]: tz = pytz.timezone(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: tz</span><br><span class="line">Out[<span class="number">113</span>]: &lt;DstTzInfo <span class="string">&#x27;America/New_York&#x27;</span> LMT-<span class="number">1</span> day, <span class="number">19</span>:04:<span class="number">00</span> STD&gt;</span><br></pre></td></tr></table></figure>
<p>pandas中的方法既可以接受时区名也可以接受这些对象。</p>
<h3 id="时区本地化和转换">11.4.1 时区本地化和转换</h3>
<p>默认情况下，pandas中的时间序列是单纯（naive）的时区。看看下面这个时间序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">114</span>]: rng = pd.date_range(<span class="string">&#x27;3/9/2012 9:30&#x27;</span>, periods=<span class="number">6</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: ts</span><br><span class="line">Out[<span class="number">116</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure>
<p>其索引的tz字段为None：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">117</span>]: <span class="built_in">print</span>(ts.index.tz)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>可以用时区集生成日期范围：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">118</span>]: pd.date_range(<span class="string">&#x27;3/9/2012 9:30&#x27;</span>, periods=<span class="number">10</span>, freq=<span class="string">&#x27;D&#x27;</span>, tz=<span class="string">&#x27;UTC&#x27;</span>)</span><br><span class="line">Out[<span class="number">118</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-09 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-10 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-11 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-15 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-16 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-17 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-18 09:30:00+00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, UTC]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>从单纯到本地化的转换是通过tz_localize方法处理的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">119</span>]: ts</span><br><span class="line">Out[<span class="number">119</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: ts_utc = ts.tz_localize(<span class="string">&#x27;UTC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: ts_utc</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: ts_utc.index</span><br><span class="line">Out[<span class="number">122</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-09 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-10 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-11 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, UTC]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>一旦时间序列被本地化到某个特定时区，就可以用tz_convert将其转换到别的时区了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">123</span>]: ts_utc.tz_convert(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line">Out[<span class="number">123</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 04:<span class="number">30</span>:<span class="number">00</span>-05:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> 04:<span class="number">30</span>:<span class="number">00</span>-05:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 05:<span class="number">30</span>:<span class="number">00</span>-04:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure>
<p>对于上面这种时间序列（它跨越了美国东部时区的夏令时转变期），我们可以将其本地化到EST，然后转换为UTC或柏林时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">124</span>]: ts_eastern = ts.tz_localize(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: ts_eastern.tz_convert(<span class="string">&#x27;UTC&#x27;</span>)</span><br><span class="line">Out[<span class="number">125</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> <span class="number">13</span>:<span class="number">30</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: ts_eastern.tz_convert(<span class="string">&#x27;Europe/Berlin&#x27;</span>)</span><br><span class="line">Out[<span class="number">126</span>]: </span><br><span class="line"><span class="number">2012</span>-03-09 <span class="number">15</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>   -<span class="number">0.202469</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">10</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.050718</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">11</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.639869</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.597594</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>   -<span class="number">0.797246</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">00</span>+01:<span class="number">00</span>    <span class="number">0.472879</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure>
<p>tz_localize和tz_convert也是DatetimeIndex的实例方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">127</span>]: ts.index.tz_localize(<span class="string">&#x27;Asia/Shanghai&#x27;</span>)</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-09 09:30:00+08:00&#x27;</span>, <span class="string">&#x27;2012-03-10 09:30:00+08:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-11 09:30:00+08:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+08:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+08:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+08:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, Asia/Shanghai]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：对单纯时间戳的本地化操作还会检查夏令时转变期附近容易混淆或不存在的时间。</p>
</blockquote>
<h3 id="操作时区意识型timestamp对象">11.4.2 操作时区意识型Timestamp对象</h3>
<p>跟时间序列和日期范围差不多，独立的Timestamp对象也能被从单纯型（naive）本地化为时区意识型（time zone-aware），并从一个时区转换到另一个时区：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: stamp = pd.Timestamp(<span class="string">&#x27;2011-03-12 04:00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: stamp_utc = stamp.tz_localize(<span class="string">&#x27;utc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: stamp_utc.tz_convert(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br><span class="line">Out[<span class="number">130</span>]: Timestamp(<span class="string">&#x27;2011-03-11 23:00:00-0500&#x27;</span>, tz=<span class="string">&#x27;America/New_York&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在创建Timestamp时，还可以传入一个时区信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">131</span>]: stamp_moscow = pd.Timestamp(<span class="string">&#x27;2011-03-12 04:00&#x27;</span>, tz=<span class="string">&#x27;Europe/Moscow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: stamp_moscow</span><br><span class="line">Out[<span class="number">132</span>]: Timestamp(<span class="string">&#x27;2011-03-12 04:00:00+0300&#x27;</span>, tz=<span class="string">&#x27;Europe/Moscow&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>时区意识型Timestamp对象在内部保存了一个UTC时间戳值（自UNIX纪元（1970年1月1日）算起的纳秒数）。这个UTC值在时区转换过程中是不会发生变化的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">133</span>]: stamp_utc.value</span><br><span class="line">Out[<span class="number">133</span>]: <span class="number">1299902400000000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: stamp_utc.tz_convert(<span class="string">&#x27;America/New_York&#x27;</span>).value</span><br><span class="line">Out[<span class="number">134</span>]: <span class="number">1299902400000000000</span></span><br></pre></td></tr></table></figure>
<p>当使用pandas的DateOffset对象执行时间算术运算时，运算过程会自动关注是否存在夏令时转变期。这里，我们创建了在DST转变之前的时间戳。首先，来看夏令时转变前的30分钟：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">135</span>]: <span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: stamp = pd.Timestamp(<span class="string">&#x27;2012-03-12 01:30&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: stamp</span><br><span class="line">Out[<span class="number">137</span>]: Timestamp(<span class="string">&#x27;2012-03-12 01:30:00-0400&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">138</span>]: stamp + Hour()</span><br><span class="line">Out[<span class="number">138</span>]: Timestamp(<span class="string">&#x27;2012-03-12 02:30:00-0400&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>然后，夏令时转变前90分钟：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">139</span>]: stamp = pd.Timestamp(<span class="string">&#x27;2012-11-04 00:30&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: stamp</span><br><span class="line">Out[<span class="number">140</span>]: Timestamp(<span class="string">&#x27;2012-11-04 00:30:00-0400&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">141</span>]: stamp + <span class="number">2</span> * Hour()</span><br><span class="line">Out[<span class="number">141</span>]: Timestamp(<span class="string">&#x27;2012-11-04 01:30:00-0500&#x27;</span>, tz=<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="不同时区之间的运算">11.4.3 不同时区之间的运算</h3>
<p>如果两个时间序列的时区不同，在将它们合并到一起时，最终结果就会是UTC。由于时间戳其实是以UTC存储的，所以这是一个很简单的运算，并不需要发生任何转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">142</span>]: rng = pd.date_range(<span class="string">&#x27;3/7/2012 9:30&#x27;</span>, periods=<span class="number">10</span>, freq=<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: ts</span><br><span class="line">Out[<span class="number">144</span>]: </span><br><span class="line"><span class="number">2012</span>-03-07 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.522356</span></span><br><span class="line"><span class="number">2012</span>-03-08 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.546348</span></span><br><span class="line"><span class="number">2012</span>-03-09 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.733537</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">12</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">1.302736</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">13</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.022199</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">14</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.364287</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">15</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.922839</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">16</span> 09:<span class="number">30</span>:<span class="number">00</span>    <span class="number">0.312656</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">19</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">1.128497</span></span><br><span class="line"><span class="number">2012</span>-03-<span class="number">20</span> 09:<span class="number">30</span>:<span class="number">00</span>   -<span class="number">0.333488</span></span><br><span class="line">Freq: B, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: ts1 = ts[:<span class="number">7</span>].tz_localize(<span class="string">&#x27;Europe/London&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: ts2 = ts1[<span class="number">2</span>:].tz_convert(<span class="string">&#x27;Europe/Moscow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">147</span>]: result = ts1 + ts2</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: result.index</span><br><span class="line">Out[<span class="number">148</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2012-03-07 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-08 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-09 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-12 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-13 09:30:00+00:00&#x27;</span>, <span class="string">&#x27;2012-03-14 09:30:00+00:00&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;2012-03-15 09:30:00+00:00&#x27;</span>],</span><br><span class="line">              dtype=<span class="string">&#x27;datetime64[ns, UTC]&#x27;</span>, freq=<span class="string">&#x27;B&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="时期及其算术运算">11.5 时期及其算术运算</h2>
<p>时期（period）表示的是时间区间，比如数日、数月、数季、数年等。Period类所表示的就是这种数据类型，其构造函数需要用到一个字符串或整数，以及表11-4中的频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">149</span>]: p = pd.Period(<span class="number">2007</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: p</span><br><span class="line">Out[<span class="number">150</span>]: Period(<span class="string">&#x27;2007&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里，这个Period对象表示的是从2007年1月1日到2007年12月31日之间的整段时间。只需对Period对象加上或减去一个整数即可达到根据其频率进行位移的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">151</span>]: p + <span class="number">5</span></span><br><span class="line">Out[<span class="number">151</span>]: Period(<span class="string">&#x27;2012&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: p - <span class="number">2</span></span><br><span class="line">Out[<span class="number">152</span>]: Period(<span class="string">&#x27;2005&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果两个Period对象拥有相同的频率，则它们的差就是它们之间的单位数量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">153</span>]: pd.Period(<span class="string">&#x27;2014&#x27;</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>) - p</span><br><span class="line">Out[<span class="number">153</span>]: <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>period_range函数可用于创建规则的时期范围：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: rng = pd.period_range(<span class="string">&#x27;2000-01-01&#x27;</span>, <span class="string">&#x27;2000-06-30&#x27;</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: rng</span><br><span class="line">Out[<span class="number">155</span>]: PeriodIndex([<span class="string">&#x27;2000-01&#x27;</span>, <span class="string">&#x27;2000-02&#x27;</span>, <span class="string">&#x27;2000-03&#x27;</span>, <span class="string">&#x27;2000-04&#x27;</span>, <span class="string">&#x27;2000-05&#x27;</span>, <span class="string">&#x27;20</span></span><br><span class="line"><span class="string">00-06&#x27;</span>], dtype=<span class="string">&#x27;period[M]&#x27;</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>PeriodIndex类保存了一组Period，它可以在任何pandas数据结构中被用作轴索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">156</span>]: pd.Series(np.random.randn(<span class="number">6</span>), index=rng)</span><br><span class="line">Out[<span class="number">156</span>]: </span><br><span class="line"><span class="number">2000</span>-01   -<span class="number">0.514551</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.559782</span></span><br><span class="line"><span class="number">2000</span>-03   -<span class="number">0.783408</span></span><br><span class="line"><span class="number">2000</span>-04   -<span class="number">1.797685</span></span><br><span class="line"><span class="number">2000</span>-05   -<span class="number">0.172670</span></span><br><span class="line"><span class="number">2000</span>-06    <span class="number">0.680215</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<p>如果你有一个字符串数组，你也可以使用PeriodIndex类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">157</span>]: values = [<span class="string">&#x27;2001Q3&#x27;</span>, <span class="string">&#x27;2002Q2&#x27;</span>, <span class="string">&#x27;2003Q1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: index = pd.PeriodIndex(values, freq=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: index</span><br><span class="line">Out[<span class="number">159</span>]: PeriodIndex([<span class="string">&#x27;2001Q3&#x27;</span>, <span class="string">&#x27;2002Q2&#x27;</span>, <span class="string">&#x27;2003Q1&#x27;</span>], dtype=<span class="string">&#x27;period[Q-DEC]&#x27;</span>, freq</span><br><span class="line">=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="时期的频率转换">11.5.1 时期的频率转换</h3>
<p>Period和PeriodIndex对象都可以通过其asfreq方法被转换成别的频率。假设我们有一个年度时期，希望将其转换为当年年初或年末的一个月度时期。该任务非常简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">160</span>]: p = pd.Period(<span class="string">&#x27;2007&#x27;</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: p</span><br><span class="line">Out[<span class="number">161</span>]: Period(<span class="string">&#x27;2007&#x27;</span>, <span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, how=<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">162</span>]: Period(<span class="string">&#x27;2007-01&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, how=<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">163</span>]: Period(<span class="string">&#x27;2007-12&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>你可以将Period('2007','A-DEC')看做一个被划分为多个月度时期的时间段中的游标。图11-1对此进行了说明。对于一个不以12月结束的财政年度，月度子时期的归属情况就不一样了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">164</span>]: p = pd.Period(<span class="string">&#x27;2007&#x27;</span>, freq=<span class="string">&#x27;A-JUN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">165</span>]: p</span><br><span class="line">Out[<span class="number">165</span>]: Period(<span class="string">&#x27;2007&#x27;</span>, <span class="string">&#x27;A-JUN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">166</span>]: Period(<span class="string">&#x27;2006-07&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: p.asfreq(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">167</span>]: Period(<span class="string">&#x27;2007-06&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-d201200d0e65676f.png" class="" title="图11-1 Period频率转换示例">
<p>在将高频率转换为低频率时，超时期（superperiod）是由子时期（subperiod）所属的位置决定的。例如，在A-JUN频率中，月份“2007年8月”实际上是属于周期“2008年”的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">168</span>]: p = pd.Period(<span class="string">&#x27;Aug-2007&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: p.asfreq(<span class="string">&#x27;A-JUN&#x27;</span>)</span><br><span class="line">Out[<span class="number">169</span>]: Period(<span class="string">&#x27;2008&#x27;</span>, <span class="string">&#x27;A-JUN&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>完整的PeriodIndex或TimeSeries的频率转换方式也是如此：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">170</span>]: rng = pd.period_range(<span class="string">&#x27;2006&#x27;</span>, <span class="string">&#x27;2009&#x27;</span>, freq=<span class="string">&#x27;A-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">171</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">172</span>]: ts</span><br><span class="line">Out[<span class="number">172</span>]: </span><br><span class="line"><span class="number">2006</span>    <span class="number">1.607578</span></span><br><span class="line"><span class="number">2007</span>    <span class="number">0.200381</span></span><br><span class="line"><span class="number">2008</span>   -<span class="number">0.834068</span></span><br><span class="line"><span class="number">2009</span>   -<span class="number">0.302988</span></span><br><span class="line">Freq: A-DEC, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: ts.asfreq(<span class="string">&#x27;M&#x27;</span>, how=<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">173</span>]: </span><br><span class="line"><span class="number">2006</span>-01    <span class="number">1.607578</span></span><br><span class="line"><span class="number">2007</span>-01    <span class="number">0.200381</span></span><br><span class="line"><span class="number">2008</span>-01   -<span class="number">0.834068</span></span><br><span class="line"><span class="number">2009</span>-01   -<span class="number">0.302988</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<p>这里，根据年度时期的第一个月，每年的时期被取代为每月的时期。如果我们想要每年的最后一个工作日，我们可以使用“B”频率，并指明想要该时期的末尾：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">174</span>]: ts.asfreq(<span class="string">&#x27;B&#x27;</span>, how=<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line"><span class="number">2006</span>-<span class="number">12</span>-<span class="number">29</span>    <span class="number">1.607578</span></span><br><span class="line"><span class="number">2007</span>-<span class="number">12</span>-<span class="number">31</span>    <span class="number">0.200381</span></span><br><span class="line"><span class="number">2008</span>-<span class="number">12</span>-<span class="number">31</span>   -<span class="number">0.834068</span></span><br><span class="line"><span class="number">2009</span>-<span class="number">12</span>-<span class="number">31</span>   -<span class="number">0.302988</span></span><br><span class="line">Freq: B, dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="按季度计算的时期频率">11.5.2 按季度计算的时期频率</h3>
<p>季度型数据在会计、金融等领域中很常见。许多季度型数据都会涉及“财年末”的概念，通常是一年12个月中某月的最后一个日历日或工作日。就这一点来说，时期"2012Q4"根据财年末的不同会有不同的含义。pandas支持12种可能的季度型频率，即Q-JAN到Q-DEC：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">175</span>]: p = pd.Period(<span class="string">&#x27;2012Q4&#x27;</span>, freq=<span class="string">&#x27;Q-JAN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">176</span>]: p</span><br><span class="line">Out[<span class="number">176</span>]: Period(<span class="string">&#x27;2012Q4&#x27;</span>, <span class="string">&#x27;Q-JAN&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在以1月结束的财年中，2012Q4是从11月到1月（将其转换为日型频率就明白了）。图11-2对此进行了说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">177</span>]: p.asfreq(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">Out[<span class="number">177</span>]: Period(<span class="string">&#x27;2011-11-01&#x27;</span>, <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: p.asfreq(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">178</span>]: Period(<span class="string">&#x27;2012-01-31&#x27;</span>, <span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-e2e1d52c9766f6ff.png" class="" title="图11.2 不同季度型频率之间的转换">
<p>因此，Period之间的算术运算会非常简单。例如，要获取该季度倒数第二个工作日下午4点的时间戳，你可以这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">179</span>]: p4pm = (p.asfreq(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;e&#x27;</span>) - <span class="number">1</span>).asfreq(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;s&#x27;</span>) + <span class="number">16</span> * <span class="number">60</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: p4pm</span><br><span class="line">Out[<span class="number">180</span>]: Period(<span class="string">&#x27;2012-01-30 16:00&#x27;</span>, <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: p4pm.to_timestamp()</span><br><span class="line">Out[<span class="number">181</span>]: Timestamp(<span class="string">&#x27;2012-01-30 16:00:00&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>period_range可用于生成季度型范围。季度型范围的算术运算也跟上面是一样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">182</span>]: rng = pd.period_range(<span class="string">&#x27;2011Q3&#x27;</span>, <span class="string">&#x27;2012Q4&#x27;</span>, freq=<span class="string">&#x27;Q-JAN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: ts = pd.Series(np.arange(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">184</span>]: ts</span><br><span class="line">Out[<span class="number">184</span>]: </span><br><span class="line">2011Q3    <span class="number">0</span></span><br><span class="line">2011Q4    <span class="number">1</span></span><br><span class="line">2012Q1    <span class="number">2</span></span><br><span class="line">2012Q2    <span class="number">3</span></span><br><span class="line">2012Q3    <span class="number">4</span></span><br><span class="line">2012Q4    <span class="number">5</span></span><br><span class="line">Freq: Q-JAN, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: new_rng = (rng.asfreq(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;e&#x27;</span>) - <span class="number">1</span>).asfreq(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;s&#x27;</span>) + <span class="number">16</span> * <span class="number">60</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">186</span>]: ts.index = new_rng.to_timestamp()</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: ts</span><br><span class="line">Out[<span class="number">187</span>]:</span><br><span class="line"><span class="number">2010</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">0</span></span><br><span class="line"><span class="number">2011</span>-01-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2011</span>-04-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2011</span>-07-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2012</span>-01-<span class="number">30</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">5</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="将timestamp转换为period及其反向过程">11.5.3 将Timestamp转换为Period（及其反向过程）</h3>
<p>通过使用to_period方法，可以将由时间戳索引的Series和DataFrame对象转换为以时期索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">188</span>]: rng = pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">3</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: ts = pd.Series(np.random.randn(<span class="number">3</span>), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">190</span>]: ts</span><br><span class="line">Out[<span class="number">190</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>    <span class="number">1.663261</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>   -<span class="number">0.996206</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">1.521760</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: pts = ts.to_period()</span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: pts</span><br><span class="line">Out[<span class="number">192</span>]: </span><br><span class="line"><span class="number">2000</span>-01    <span class="number">1.663261</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.996206</span></span><br><span class="line"><span class="number">2000</span>-03    <span class="number">1.521760</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<p>由于时期指的是非重叠时间区间，因此对于给定的频率，一个时间戳只能属于一个时期。新PeriodIndex的频率默认是从时间戳推断而来的，你也可以指定任何别的频率。结果中允许存在重复时期：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">193</span>]: rng = pd.date_range(<span class="string">&#x27;1/29/2000&#x27;</span>, periods=<span class="number">6</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: ts2 = pd.Series(np.random.randn(<span class="number">6</span>), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">195</span>]: ts2</span><br><span class="line">Out[<span class="number">195</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">29</span>    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">30</span>    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02-01    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.167933</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">196</span>]: ts2.to_period(<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">Out[<span class="number">196</span>]: </span><br><span class="line"><span class="number">2000</span>-01    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02   -<span class="number">0.167933</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<p>要转换回时间戳，使用to_timestamp即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">197</span>]: pts = ts2.to_period()</span><br><span class="line"></span><br><span class="line">In [<span class="number">198</span>]: pts</span><br><span class="line">Out[<span class="number">198</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">29</span>    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">30</span>    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02-01    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.167933</span></span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">199</span>]: pts.to_timestamp(how=<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">Out[<span class="number">199</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">29</span>    <span class="number">0.244175</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">30</span>    <span class="number">0.423331</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.654040</span></span><br><span class="line"><span class="number">2000</span>-02-01    <span class="number">2.089154</span></span><br><span class="line"><span class="number">2000</span>-02-02   -<span class="number">0.060220</span></span><br><span class="line"><span class="number">2000</span>-02-03   -<span class="number">0.167933</span></span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="通过数组创建periodindex">11.5.4 通过数组创建PeriodIndex</h3>
<p>固定频率的数据集通常会将时间信息分开存放在多个列中。例如，在下面这个宏观经济数据集中，年度和季度就分别存放在不同的列中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">200</span>]: data = pd.read_csv(<span class="string">&#x27;examples/macrodata.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">201</span>]: data.head(<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">201</span>]: </span><br><span class="line">     year  quarter   realgdp  realcons  realinv  realgovt  realdpi    cpi  \</span><br><span class="line"><span class="number">0</span>  <span class="number">1959.0</span>      <span class="number">1.0</span>  <span class="number">2710.349</span>    <span class="number">1707.4</span>  <span class="number">286.898</span>   <span class="number">470.045</span>   <span class="number">1886.9</span>  <span class="number">28.98</span>   </span><br><span class="line"><span class="number">1</span>  <span class="number">1959.0</span>      <span class="number">2.0</span>  <span class="number">2778.801</span>    <span class="number">1733.7</span>  <span class="number">310.859</span>   <span class="number">481.301</span>   <span class="number">1919.7</span>  <span class="number">29.15</span>   </span><br><span class="line"><span class="number">2</span>  <span class="number">1959.0</span>      <span class="number">3.0</span>  <span class="number">2775.488</span>    <span class="number">1751.8</span>  <span class="number">289.226</span>   <span class="number">491.260</span>   <span class="number">1916.4</span>  <span class="number">29.35</span>   </span><br><span class="line"><span class="number">3</span>  <span class="number">1959.0</span>      <span class="number">4.0</span>  <span class="number">2785.204</span>    <span class="number">1753.7</span>  <span class="number">299.356</span>   <span class="number">484.052</span>   <span class="number">1931.3</span>  <span class="number">29.37</span>   </span><br><span class="line"><span class="number">4</span>  <span class="number">1960.0</span>      <span class="number">1.0</span>  <span class="number">2847.699</span>    <span class="number">1770.5</span>  <span class="number">331.722</span>   <span class="number">462.199</span>   <span class="number">1955.5</span>  <span class="number">29.54</span>   </span><br><span class="line">      m1  tbilrate  unemp      pop  infl  realint  </span><br><span class="line"><span class="number">0</span>  <span class="number">139.7</span>      <span class="number">2.82</span>    <span class="number">5.8</span>  <span class="number">177.146</span>  <span class="number">0.00</span>     <span class="number">0.00</span>  </span><br><span class="line"><span class="number">1</span>  <span class="number">141.7</span>      <span class="number">3.08</span>    <span class="number">5.1</span>  <span class="number">177.830</span>  <span class="number">2.34</span>     <span class="number">0.74</span>  </span><br><span class="line"><span class="number">2</span>  <span class="number">140.5</span>      <span class="number">3.82</span>    <span class="number">5.3</span>  <span class="number">178.657</span>  <span class="number">2.74</span>     <span class="number">1.09</span>  </span><br><span class="line"><span class="number">3</span>  <span class="number">140.0</span>      <span class="number">4.33</span>    <span class="number">5.6</span>  <span class="number">179.386</span>  <span class="number">0.27</span>     <span class="number">4.06</span>  </span><br><span class="line"><span class="number">4</span>  <span class="number">139.6</span>      <span class="number">3.50</span>    <span class="number">5.2</span>  <span class="number">180.007</span>  <span class="number">2.31</span>     <span class="number">1.19</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: data.year</span><br><span class="line">Out[<span class="number">202</span>]: </span><br><span class="line"><span class="number">0</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">1959.0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">6</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">7</span>      <span class="number">1960.0</span></span><br><span class="line"><span class="number">8</span>      <span class="number">1961.0</span></span><br><span class="line"><span class="number">9</span>      <span class="number">1961.0</span></span><br><span class="line">        ...  </span><br><span class="line"><span class="number">193</span>    <span class="number">2007.0</span></span><br><span class="line"><span class="number">194</span>    <span class="number">2007.0</span></span><br><span class="line"><span class="number">195</span>    <span class="number">2007.0</span></span><br><span class="line"><span class="number">196</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">197</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">198</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">199</span>    <span class="number">2008.0</span></span><br><span class="line"><span class="number">200</span>    <span class="number">2009.0</span></span><br><span class="line"><span class="number">201</span>    <span class="number">2009.0</span></span><br><span class="line"><span class="number">202</span>    <span class="number">2009.0</span></span><br><span class="line">Name: year, Length: <span class="number">203</span>, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">203</span>]: data.quarter</span><br><span class="line">Out[<span class="number">203</span>]: </span><br><span class="line"><span class="number">0</span>      <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">3.0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">1.0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>      <span class="number">3.0</span></span><br><span class="line"><span class="number">7</span>      <span class="number">4.0</span></span><br><span class="line"><span class="number">8</span>      <span class="number">1.0</span></span><br><span class="line"><span class="number">9</span>      <span class="number">2.0</span></span><br><span class="line">      ... </span><br><span class="line"><span class="number">193</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">194</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">195</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">196</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">197</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">198</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">199</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">200</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">201</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">202</span>    <span class="number">3.0</span></span><br><span class="line">Name: quarter, Length: <span class="number">203</span>, dtype: float64</span><br></pre></td></tr></table></figure>
<p>通过将这些数组以及一个频率传入PeriodIndex，就可以将它们合并成DataFrame的一个索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">204</span>]: index = pd.PeriodIndex(year=data.year, quarter=data.quarter,</span><br><span class="line">   .....:                        freq=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">205</span>]: index</span><br><span class="line">Out[<span class="number">205</span>]: </span><br><span class="line">PeriodIndex([<span class="string">&#x27;1959Q1&#x27;</span>, <span class="string">&#x27;1959Q2&#x27;</span>, <span class="string">&#x27;1959Q3&#x27;</span>, <span class="string">&#x27;1959Q4&#x27;</span>, <span class="string">&#x27;1960Q1&#x27;</span>, <span class="string">&#x27;1960Q2&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;1960Q3&#x27;</span>, <span class="string">&#x27;1960Q4&#x27;</span>, <span class="string">&#x27;1961Q1&#x27;</span>, <span class="string">&#x27;1961Q2&#x27;</span>,</span><br><span class="line">             ...</span><br><span class="line">             <span class="string">&#x27;2007Q2&#x27;</span>, <span class="string">&#x27;2007Q3&#x27;</span>, <span class="string">&#x27;2007Q4&#x27;</span>, <span class="string">&#x27;2008Q1&#x27;</span>, <span class="string">&#x27;2008Q2&#x27;</span>, <span class="string">&#x27;2008Q3&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;2008Q4&#x27;</span>, <span class="string">&#x27;2009Q1&#x27;</span>, <span class="string">&#x27;2009Q2&#x27;</span>, <span class="string">&#x27;2009Q3&#x27;</span>],</span><br><span class="line">            dtype=<span class="string">&#x27;period[Q-DEC]&#x27;</span>, length=<span class="number">203</span>, freq=<span class="string">&#x27;Q-DEC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">206</span>]: data.index = index</span><br><span class="line"></span><br><span class="line">In [<span class="number">207</span>]: data.infl</span><br><span class="line">Out[<span class="number">207</span>]: </span><br><span class="line">1959Q1    <span class="number">0.00</span></span><br><span class="line">1959Q2    <span class="number">2.34</span></span><br><span class="line">1959Q3    <span class="number">2.74</span></span><br><span class="line">1959Q4    <span class="number">0.27</span></span><br><span class="line">1960Q1    <span class="number">2.31</span></span><br><span class="line">1960Q2    <span class="number">0.14</span></span><br><span class="line">1960Q3    <span class="number">2.70</span></span><br><span class="line">1960Q4    <span class="number">1.21</span></span><br><span class="line">1961Q1   -<span class="number">0.40</span></span><br><span class="line">1961Q2    <span class="number">1.47</span></span><br><span class="line">          ... </span><br><span class="line">2007Q2    <span class="number">2.75</span></span><br><span class="line">2007Q3    <span class="number">3.45</span></span><br><span class="line">2007Q4    <span class="number">6.38</span></span><br><span class="line">2008Q1    <span class="number">2.82</span></span><br><span class="line">2008Q2    <span class="number">8.53</span></span><br><span class="line">2008Q3   -<span class="number">3.16</span></span><br><span class="line">2008Q4   -<span class="number">8.79</span></span><br><span class="line">2009Q1    <span class="number">0.94</span></span><br><span class="line">2009Q2    <span class="number">3.37</span></span><br><span class="line">2009Q3    <span class="number">3.56</span></span><br><span class="line">Freq: Q-DEC, Name: infl, Length: <span class="number">203</span>, dtype: float64</span><br></pre></td></tr></table></figure>
<h2 id="重采样及频率转换">11.6 重采样及频率转换</h2>
<p>重采样（resampling）指的是将时间序列从一个频率转换到另一个频率的处理过程。将高频率数据聚合到低频率称为降采样（downsampling），而将低频率数据转换到高频率则称为升采样（upsampling）。并不是所有的重采样都能被划分到这两个大类中。例如，将W-WED（每周三）转换为W-FRI既不是降采样也不是升采样。</p>
<p>pandas对象都带有一个resample方法，它是各种频率转换工作的主力函数。resample有一个类似于groupby的API，调用resample可以分组数据，然后会调用一个聚合函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">208</span>]: rng = pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">100</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">209</span>]: ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">210</span>]: ts</span><br><span class="line">Out[<span class="number">210</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01    <span class="number">0.631634</span></span><br><span class="line"><span class="number">2000</span>-01-02   -<span class="number">1.594313</span></span><br><span class="line"><span class="number">2000</span>-01-03   -<span class="number">1.519937</span></span><br><span class="line"><span class="number">2000</span>-01-04    <span class="number">1.108752</span></span><br><span class="line"><span class="number">2000</span>-01-05    <span class="number">1.255853</span></span><br><span class="line"><span class="number">2000</span>-01-06   -<span class="number">0.024330</span></span><br><span class="line"><span class="number">2000</span>-01-07   -<span class="number">2.047939</span></span><br><span class="line"><span class="number">2000</span>-01-08   -<span class="number">0.272657</span></span><br><span class="line"><span class="number">2000</span>-01-09   -<span class="number">1.692615</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>    <span class="number">1.423830</span></span><br><span class="line">                ...   </span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>   -<span class="number">0.007852</span></span><br><span class="line"><span class="number">2000</span>-04-01   -<span class="number">1.638806</span></span><br><span class="line"><span class="number">2000</span>-04-02    <span class="number">1.401227</span></span><br><span class="line"><span class="number">2000</span>-04-03    <span class="number">1.758539</span></span><br><span class="line"><span class="number">2000</span>-04-04    <span class="number">0.628932</span></span><br><span class="line"><span class="number">2000</span>-04-05   -<span class="number">0.423776</span></span><br><span class="line"><span class="number">2000</span>-04-06    <span class="number">0.789740</span></span><br><span class="line"><span class="number">2000</span>-04-07    <span class="number">0.937568</span></span><br><span class="line"><span class="number">2000</span>-04-08   -<span class="number">2.253294</span></span><br><span class="line"><span class="number">2000</span>-04-09   -<span class="number">1.772919</span></span><br><span class="line">Freq: D, Length: <span class="number">100</span>, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">211</span>]: ts.resample(<span class="string">&#x27;M&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">211</span>]: </span><br><span class="line"><span class="number">2000</span>-01-<span class="number">31</span>   -<span class="number">0.165893</span></span><br><span class="line"><span class="number">2000</span>-02-<span class="number">29</span>    <span class="number">0.078606</span></span><br><span class="line"><span class="number">2000</span>-03-<span class="number">31</span>    <span class="number">0.223811</span></span><br><span class="line"><span class="number">2000</span>-04-<span class="number">30</span>   -<span class="number">0.063643</span></span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: ts.resample(<span class="string">&#x27;M&#x27;</span>, kind=<span class="string">&#x27;period&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line"><span class="number">2000</span>-01   -<span class="number">0.165893</span></span><br><span class="line"><span class="number">2000</span>-02    <span class="number">0.078606</span></span><br><span class="line"><span class="number">2000</span>-03    <span class="number">0.223811</span></span><br><span class="line"><span class="number">2000</span>-04   -<span class="number">0.063643</span></span><br><span class="line">Freq: M, dtype: float64</span><br></pre></td></tr></table></figure>
<p>resample是一个灵活高效的方法，可用于处理非常大的时间序列。我将通过一系列的示例说明其用法。表11-5总结它的一些选项。</p>
<p>表11-5 resample方法的参数 <img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-b40a57086c904e83.png" class=""></p>
<h3 id="降采样">11.6.1 降采样</h3>
<p>将数据聚合到规律的低频率是一件非常普通的时间序列处理任务。待聚合的数据不必拥有固定的频率，期望的频率会自动定义聚合的面元边界，这些面元用于将时间序列拆分为多个片段。例如，要转换到月度频率（'M'或'BM'），数据需要被划分到多个单月时间段中。各时间段都是半开放的。一个数据点只能属于一个时间段，所有时间段的并集必须能组成整个时间帧。在用resample对数据进行降采样时，需要考虑两样东西：</p>
<ul>
<li>各区间哪边是闭合的。</li>
<li>如何标记各个聚合面元，用区间的开头还是末尾。</li>
</ul>
<p>为了说明，我们来看一些“1分钟”数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">213</span>]: rng = pd.date_range(<span class="string">&#x27;2000-01-01&#x27;</span>, periods=<span class="number">12</span>, freq=<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: ts = pd.Series(np.arange(<span class="number">12</span>), index=rng)</span><br><span class="line"></span><br><span class="line">In [<span class="number">215</span>]: ts</span><br><span class="line">Out[<span class="number">215</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:01:<span class="number">00</span>     <span class="number">1</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:02:<span class="number">00</span>     <span class="number">2</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:03:<span class="number">00</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:04:<span class="number">00</span>     <span class="number">4</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>     <span class="number">5</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:06:<span class="number">00</span>     <span class="number">6</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:07:<span class="number">00</span>     <span class="number">7</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:08:<span class="number">00</span>     <span class="number">8</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:09:<span class="number">00</span>     <span class="number">9</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">10</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">11</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: T, dtype: int64</span><br></pre></td></tr></table></figure>
<p>假设你想要通过求和的方式将这些数据聚合到“5分钟”块中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">216</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">216</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">15</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>    <span class="number">40</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: 5T, dtype: int64</span><br></pre></td></tr></table></figure>
<p>传入的频率将会以“5分钟”的增量定义面元边界。默认情况下，面元的右边界是包含的，因此00:00到00:05的区间中是包含00:05的。传入closed='left'会让区间以左边界闭合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">217</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">217</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">15</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>    <span class="number">40</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: 5T, dtype: int64</span><br></pre></td></tr></table></figure>
<p>如你所见，最终的时间序列是以各面元右边界的时间戳进行标记的。传入label='right'即可用面元的邮编界对其进行标记：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">218</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>, label=<span class="string">&#x27;right&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">218</span>]: </span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>    <span class="number">15</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">40</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">15</span>:<span class="number">00</span>    <span class="number">11</span></span><br><span class="line">Freq: 5T, dtype: int64</span><br></pre></td></tr></table></figure>
<p>图11-3说明了“1分钟”数据被转换为“5分钟”数据的处理过程。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-7a77f47844f2ee8c.png" class="" title="图11-3 各种closed、label约定的“5分钟”重采样演示">
<p>最后，你可能希望对结果索引做一些位移，比如从右边界减去一秒以便更容易明白该时间戳到底表示的是哪个区间。只需通过loffset设置一个字符串或日期偏移量即可实现这个目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">219</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">   .....:             label=<span class="string">&#x27;right&#x27;</span>, loffset=<span class="string">&#x27;-1s&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">219</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:04:<span class="number">59</span>    <span class="number">15</span></span><br><span class="line">In [<span class="number">219</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>, closed=<span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">   .....:             label=<span class="string">&#x27;right&#x27;</span>, loffset=<span class="string">&#x27;-1s&#x27;</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">219</span>]: </span><br><span class="line"><span class="number">1999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:04:<span class="number">59</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>此外，也可以通过调用结果对象的shift方法来实现该目的，这样就不需要设置loffset了。</p>
<p>###OHLC重采样</p>
<p>金融领域中有一种无所不在的时间序列聚合方式，即计算各面元的四个值：第一个值（open，开盘）、最后一个值（close，收盘）、最大值（high，最高）以及最小值（low，最低）。传入how='ohlc'即可得到一个含有这四种聚合值的DataFrame。整个过程很高效，只需一次扫描即可计算出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">220</span>]: ts.resample(<span class="string">&#x27;5min&#x27;</span>).ohlc()</span><br><span class="line">Out[<span class="number">220</span>]: </span><br><span class="line">                     <span class="built_in">open</span>  high  low  close</span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>     <span class="number">0</span>     <span class="number">4</span>    <span class="number">0</span>      <span class="number">4</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:05:<span class="number">00</span>     <span class="number">5</span>     <span class="number">9</span>    <span class="number">5</span>      <span class="number">9</span></span><br><span class="line"><span class="number">2000</span>-01-01 <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>    <span class="number">10</span>    <span class="number">11</span>   <span class="number">10</span>     <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>###升采样和插值</p>
<p>在将数据从低频率转换到高频率时，就不需要聚合了。我们来看一个带有一些周型数据的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">221</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">   .....:                      index=pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">2</span>,</span><br><span class="line">   .....:                                          freq=<span class="string">&#x27;W-WED&#x27;</span>),</span><br><span class="line">   .....:                      columns=[<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">222</span>]: frame</span><br><span class="line">Out[<span class="number">222</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br></pre></td></tr></table></figure>
<p>当你对这个数据进行聚合，每组只有一个值，这样就会引入缺失值。我们使用asfreq方法转换成高频，不经过聚合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">223</span>]: df_daily = frame.resample(<span class="string">&#x27;D&#x27;</span>).asfreq()</span><br><span class="line"></span><br><span class="line">In [<span class="number">224</span>]: df_daily</span><br><span class="line">Out[<span class="number">224</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-06       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-07       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-08       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-09       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">11</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br></pre></td></tr></table></figure>
<p>假设你想要用前面的周型值填充“非星期三”。resampling的填充和插值方式跟fillna和reindex的一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">225</span>]: frame.resample(<span class="string">&#x27;D&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-06 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-07 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-08 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-09 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span> -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">11</span> -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br></pre></td></tr></table></figure>
<p>同样，这里也可以只填充指定的时期数（目的是限制前面的观测值的持续使用距离）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">226</span>]: frame.resample(<span class="string">&#x27;D&#x27;</span>).ffill(limit=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">226</span>]:</span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-05 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-06 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-07 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-08       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-09       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">10</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">11</span>       NaN       NaN       NaN       NaN</span><br><span class="line"><span class="number">2000</span>-01-<span class="number">12</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br></pre></td></tr></table></figure>
<p>注意，新的日期索引完全没必要跟旧的重叠：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">227</span>]: frame.resample(<span class="string">&#x27;W-THU&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">227</span>]: </span><br><span class="line">            Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01-06 -<span class="number">0.896431</span>  <span class="number">0.677263</span>  <span class="number">0.036503</span>  <span class="number">0.087102</span></span><br><span class="line"><span class="number">2000</span>-01-<span class="number">13</span> -<span class="number">0.046662</span>  <span class="number">0.927238</span>  <span class="number">0.482284</span> -<span class="number">0.867130</span></span><br></pre></td></tr></table></figure>
<h3 id="通过时期进行重采样">11.6.2 通过时期进行重采样</h3>
<p>对那些使用时期索引的数据进行重采样与时间戳很像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">228</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">24</span>, <span class="number">4</span>),</span><br><span class="line">   .....:                      index=pd.period_range(<span class="string">&#x27;1-2000&#x27;</span>, <span class="string">&#x27;12-2001&#x27;</span>,</span><br><span class="line">   .....:                                            freq=<span class="string">&#x27;M&#x27;</span>),</span><br><span class="line">   .....:                      columns=[<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">229</span>]: frame[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">229</span>]: </span><br><span class="line">         Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>-01  <span class="number">0.493841</span> -<span class="number">0.155434</span>  <span class="number">1.397286</span>  <span class="number">1.507055</span></span><br><span class="line"><span class="number">2000</span>-02 -<span class="number">1.179442</span>  <span class="number">0.443171</span>  <span class="number">1.395676</span> -<span class="number">0.529658</span></span><br><span class="line"><span class="number">2000</span>-03  <span class="number">0.787358</span>  <span class="number">0.248845</span>  <span class="number">0.743239</span>  <span class="number">1.267746</span></span><br><span class="line"><span class="number">2000</span>-04  <span class="number">1.302395</span> -<span class="number">0.272154</span> -<span class="number">0.051532</span> -<span class="number">0.467740</span></span><br><span class="line"><span class="number">2000</span>-05 -<span class="number">1.040816</span>  <span class="number">0.426419</span>  <span class="number">0.312945</span> -<span class="number">1.115689</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">230</span>]: annual_frame = frame.resample(<span class="string">&#x27;A-DEC&#x27;</span>).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">231</span>]: annual_frame</span><br><span class="line">Out[<span class="number">231</span>]: </span><br><span class="line">      Colorado     Texas  New York      Ohio</span><br><span class="line"><span class="number">2000</span>  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line"><span class="number">2001</span>  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br></pre></td></tr></table></figure>
<p>升采样要稍微麻烦一些，因为你必须决定在新频率中各区间的哪端用于放置原来的值，就像asfreq方法那样。convention参数默认为'start'，也可设置为'end'：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Q-DEC: Quarterly, year ending in December</span></span><br><span class="line">In [<span class="number">232</span>]: annual_frame.resample(<span class="string">&#x27;Q-DEC&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">232</span>]: </span><br><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q1  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2000Q2  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2000Q3  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2000Q4  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q1  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2001Q2  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2001Q3  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2001Q4  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">233</span>]: annual_frame.resample(<span class="string">&#x27;Q-DEC&#x27;</span>, convention=<span class="string">&#x27;end&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">233</span>]: </span><br><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q4  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q1  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q2  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q3  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q4  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br></pre></td></tr></table></figure>
<p>由于时期指的是时间区间，所以升采样和降采样的规则就比较严格：</p>
<ul>
<li>在降采样中，目标频率必须是源频率的子时期（subperiod）。</li>
<li>在升采样中，目标频率必须是源频率的超时期（superperiod）。</li>
</ul>
<p>如果不满足这些条件，就会引发异常。这主要影响的是按季、年、周计算的频率。例如，由Q-MAR定义的时间区间只能升采样为A-MAR、A-JUN、A-SEP、A-DEC等：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">234</span>]: annual_frame.resample(<span class="string">&#x27;Q-MAR&#x27;</span>).ffill()</span><br><span class="line">Out[<span class="number">234</span>]: </span><br><span class="line">        Colorado     Texas  New York      Ohio</span><br><span class="line">2000Q4  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q1  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q2  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q3  <span class="number">0.556703</span>  <span class="number">0.016631</span>  <span class="number">0.111873</span> -<span class="number">0.027445</span></span><br><span class="line">2001Q4  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2002Q1  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2002Q2  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br><span class="line">2002Q3  <span class="number">0.046303</span>  <span class="number">0.163344</span>  <span class="number">0.251503</span> -<span class="number">0.157276</span></span><br></pre></td></tr></table></figure>
<h2 id="移动窗口函数">11.7 移动窗口函数</h2>
<p>在移动窗口（可以带有指数衰减权数）上计算的各种统计函数也是一类常见于时间序列的数组变换。这样可以圆滑噪音数据或断裂数据。我将它们称为移动窗口函数（moving window function），其中还包括那些窗口不定长的函数（如指数加权移动平均）。跟其他统计函数一样，移动窗口函数也会自动排除缺失值。</p>
<p>开始之前，我们加载一些时间序列数据，将其重采样为工作日频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">235</span>]: close_px_all = pd.read_csv(<span class="string">&#x27;examples/stock_px_2.csv&#x27;</span>,</span><br><span class="line">   .....:                            parse_dates=<span class="literal">True</span>, index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">236</span>]: close_px = close_px_all[[<span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;MSFT&#x27;</span>, <span class="string">&#x27;XOM&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">237</span>]: close_px = close_px.resample(<span class="string">&#x27;B&#x27;</span>).ffill()</span><br></pre></td></tr></table></figure>
<p>现在引入rolling运算符，它与resample和groupby很像。可以在TimeSeries或DataFrame以及一个window（表示期数，见图11-4）上调用它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">238</span>]: close_px.AAPL.plot()</span><br><span class="line">Out[<span class="number">238</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7f2f2570cf98</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">239</span>]: close_px.AAPL.rolling(<span class="number">250</span>).mean().plot()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-3327483eab730b09.png" class="" title="图11-4 苹果公司股价的250日均线">
<p>表达式rolling(250)与groupby很像，但不是对其进行分组，而是创建一个按照250天分组的滑动窗口对象。然后，我们就得到了苹果公司股价的250天的移动窗口。</p>
<p>默认情况下，rolling函数需要窗口中所有的值为非NA值。可以修改该行为以解决缺失数据的问题。其实，在时间序列开始处尚不足窗口期的那些数据就是个特例（见图11-5）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">241</span>]: appl_std250 = close_px.AAPL.rolling(<span class="number">250</span>, min_periods=<span class="number">10</span>).std()</span><br><span class="line"></span><br><span class="line">In [<span class="number">242</span>]: appl_std250[<span class="number">5</span>:<span class="number">12</span>]</span><br><span class="line">Out[<span class="number">242</span>]: </span><br><span class="line"><span class="number">2003</span>-01-09         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">10</span>         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">13</span>         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">14</span>         NaN</span><br><span class="line"><span class="number">2003</span>-01-<span class="number">15</span>    <span class="number">0.077496</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">16</span>    <span class="number">0.074760</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">17</span>    <span class="number">0.112368</span></span><br><span class="line">Freq: B, Name: AAPL, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">243</span>]: appl_std250.plot()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-15f565bed1ccad09.png" class="" title="图11-5 苹果公司250日每日回报标准差">
<p>要计算扩展窗口平均（expanding window mean），可以使用expanding而不是rolling。“扩展”意味着，从时间序列的起始处开始窗口，增加窗口直到它超过所有的序列。apple_std250时间序列的扩展窗口平均如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">244</span>]: expanding_mean = appl_std250.expanding().mean()</span><br></pre></td></tr></table></figure>
<p>对DataFrame调用rolling_mean（以及与之类似的函数）会将转换应用到所有的列上（见图11-6）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">246</span>]: close_px.rolling(<span class="number">60</span>).mean().plot(logy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-979f748052b2279f.png" class="" title="图11-6 各股价60日均线（对数Y轴）">
<p>rolling函数也可以接受一个指定固定大小时间补偿字符串，而不是一组时期。这样可以方便处理不规律的时间序列。这些字符串也可以传递给resample。例如，我们可以计算20天的滚动均值，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">247</span>]: close_px.rolling(<span class="string">&#x27;20D&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">247</span>]:</span><br><span class="line">                  AAPL       MSFT        XOM</span><br><span class="line"><span class="number">2003</span>-01-02    <span class="number">7.400000</span>  <span class="number">21.110000</span>  <span class="number">29.220000</span></span><br><span class="line"><span class="number">2003</span>-01-03    <span class="number">7.425000</span>  <span class="number">21.125000</span>  <span class="number">29.230000</span></span><br><span class="line"><span class="number">2003</span>-01-06    <span class="number">7.433333</span>  <span class="number">21.256667</span>  <span class="number">29.473333</span></span><br><span class="line"><span class="number">2003</span>-01-07    <span class="number">7.432500</span>  <span class="number">21.425000</span>  <span class="number">29.342500</span></span><br><span class="line"><span class="number">2003</span>-01-08    <span class="number">7.402000</span>  <span class="number">21.402000</span>  <span class="number">29.240000</span></span><br><span class="line"><span class="number">2003</span>-01-09    <span class="number">7.391667</span>  <span class="number">21.490000</span>  <span class="number">29.273333</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">10</span>    <span class="number">7.387143</span>  <span class="number">21.558571</span>  <span class="number">29.238571</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">13</span>    <span class="number">7.378750</span>  <span class="number">21.633750</span>  <span class="number">29.197500</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">14</span>    <span class="number">7.370000</span>  <span class="number">21.717778</span>  <span class="number">29.194444</span></span><br><span class="line"><span class="number">2003</span>-01-<span class="number">15</span>    <span class="number">7.355000</span>  <span class="number">21.757000</span>  <span class="number">29.152000</span></span><br><span class="line"><span class="meta">... </span>               ...        ...        ...</span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-03  <span class="number">398.002143</span>  <span class="number">25.890714</span>  <span class="number">72.413571</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-04  <span class="number">396.802143</span>  <span class="number">25.807857</span>  <span class="number">72.427143</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-05  <span class="number">395.751429</span>  <span class="number">25.729286</span>  <span class="number">72.422857</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-06  <span class="number">394.099286</span>  <span class="number">25.673571</span>  <span class="number">72.375714</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-07  <span class="number">392.479333</span>  <span class="number">25.712000</span>  <span class="number">72.454667</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">10</span>  <span class="number">389.351429</span>  <span class="number">25.602143</span>  <span class="number">72.527857</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">11</span>  <span class="number">388.505000</span>  <span class="number">25.674286</span>  <span class="number">72.835000</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">12</span>  <span class="number">388.531429</span>  <span class="number">25.810000</span>  <span class="number">73.400714</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">13</span>  <span class="number">388.826429</span>  <span class="number">25.961429</span>  <span class="number">73.905000</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">14</span>  <span class="number">391.038000</span>  <span class="number">26.048667</span>  <span class="number">74.185333</span></span><br><span class="line">[<span class="number">2292</span> rows x <span class="number">3</span> columns]</span><br></pre></td></tr></table></figure>
<h3 id="指数加权函数">11.7.1 指数加权函数</h3>
<p>另一种使用固定大小窗口及相等权数观测值的办法是，定义一个衰减因子（decay factor）常量，以便使近期的观测值拥有更大的权数。衰减因子的定义方式有很多，比较流行的是使用时间间隔（span），它可以使结果兼容于窗口大小等于时间间隔的简单移动窗口（simple moving window）函数。</p>
<p>由于指数加权统计会赋予近期的观测值更大的权数，因此相对于等权统计，它能“适应”更快的变化。</p>
<p>除了rolling和expanding，pandas还有ewm运算符。下面这个例子对比了苹果公司股价的30日移动平均和span=30的指数加权移动平均（如图11-7所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">249</span>]: aapl_px = close_px.AAPL[<span class="string">&#x27;2006&#x27;</span>:<span class="string">&#x27;2007&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">250</span>]: ma60 = aapl_px.rolling(<span class="number">30</span>, min_periods=<span class="number">20</span>).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">251</span>]: ewma60 = aapl_px.ewm(span=<span class="number">30</span>).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">252</span>]: ma60.plot(style=<span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;Simple MA&#x27;</span>)</span><br><span class="line">Out[<span class="number">252</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7f2f252161d0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">253</span>]: ewma60.plot(style=<span class="string">&#x27;k-&#x27;</span>, label=<span class="string">&#x27;EW MA&#x27;</span>)</span><br><span class="line">Out[<span class="number">253</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x7f2f252161d0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">254</span>]: plt.legend()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-dae48defe3749fad.png" class="" title="图11-7 简单移动平均与指数加权移动平均">
<h3 id="二元移动窗口函数">11.7.2 二元移动窗口函数</h3>
<p>有些统计运算（如相关系数和协方差）需要在两个时间序列上执行。例如，金融分析师常常对某只股票对某个参考指数（如标准普尔500指数）的相关系数感兴趣。要进行说明，我们先计算我们感兴趣的时间序列的百分数变化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">256</span>]: spx_px = close_px_all[<span class="string">&#x27;SPX&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">257</span>]: spx_rets = spx_px.pct_change()</span><br><span class="line"></span><br><span class="line">In [<span class="number">258</span>]: returns = close_px.pct_change()</span><br></pre></td></tr></table></figure>
<p>调用rolling之后，corr聚合函数开始计算与spx_rets滚动相关系数（结果见图11-8）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">259</span>]: corr = returns.AAPL.rolling(<span class="number">125</span>, min_periods=<span class="number">100</span>).corr(spx_rets)</span><br><span class="line"></span><br><span class="line">In [<span class="number">260</span>]: corr.plot()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-e81e0f602b4db0ed.png" class="" title="图11-8 AAPL 6个月的回报与标准普尔500指数的相关系数">
<p>假设你想要一次性计算多只股票与标准普尔500指数的相关系数。虽然编写一个循环并新建一个DataFrame不是什么难事，但比较啰嗦。其实，只需传入一个TimeSeries和一个DataFrame，rolling_corr就会自动计算TimeSeries（本例中就是spx_rets）与DataFrame各列的相关系数。结果如图11-9所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">262</span>]: corr = returns.rolling(<span class="number">125</span>, min_periods=<span class="number">100</span>).corr(spx_rets)</span><br><span class="line"></span><br><span class="line">In [<span class="number">263</span>]: corr.plot()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-0a54a028a62b9b50.png" class="" title="图11-9 3只股票6个月的回报与标准普尔500指数的相关系数">
<h3 id="用户定义的移动窗口函数">11.7.3 用户定义的移动窗口函数</h3>
<p>rolling_apply函数使你能够在移动窗口上应用自己设计的数组函数。唯一要求的就是：该函数要能从数组的各个片段中产生单个值（即约简）。比如说，当我们用rolling(...).quantile(q)计算样本分位数时，可能对样本中特定值的百分等级感兴趣。scipy.stats.percentileofscore函数就能达到这个目的（结果见图11-10）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">265</span>]: <span class="keyword">from</span> scipy.stats <span class="keyword">import</span> percentileofscore</span><br><span class="line"></span><br><span class="line">In [<span class="number">266</span>]: score_at_2percent = <span class="keyword">lambda</span> x: percentileofscore(x, <span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">267</span>]: result = returns.AAPL.rolling(<span class="number">250</span>).apply(score_at_2percent)</span><br><span class="line"></span><br><span class="line">In [<span class="number">268</span>]: result.plot()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap11/7178691-af49e84a90c23c1e.png" class="" title="图11-10 AAPL 2%回报率的百分等级（一年窗口期）">
<p>如果你没安装SciPy，可以使用conda或pip安装。</p>
<h2 id="总结">11.8 总结</h2>
<p>与前面章节接触的数据相比，时间序列数据要求不同类型的分析和数据转换工具。</p>
<p>在接下来的章节中，我们将学习一些高级的pandas方法和如何开始使用建模库statsmodels和scikit-learn。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第12章_pandas高级应用</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap12/</url>
    <content><![CDATA[<h1 id="第12章-pandas高级应用">第12章 pandas高级应用</h1>
<p>前面的章节关注于不同类型的数据规整流程和NumPy、pandas与其它库的特点。随着时间的发展，pandas发展出了更多适合高级用户的功能。本章就要深入学习pandas的高级功能。</p>
<span id="more"></span>
<h2 id="分类数据">12.1 分类数据</h2>
<p>这一节介绍的是pandas的分类类型。我会向你展示通过使用它，提高性能和内存的使用率。我还会介绍一些在统计和机器学习中使用分类数据的工具。</p>
<h3 id="背景和目的">12.1.1 背景和目的</h3>
<p>表中的一列通常会有重复的包含不同值的小集合的情况。我们已经学过了unique和value_counts，它们可以从数组提取出不同的值，并分别计算频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np; <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: values = pd.Series([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">   ....:                     <span class="string">&#x27;apple&#x27;</span>] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: values</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">2</span>     apple</span><br><span class="line"><span class="number">3</span>     apple</span><br><span class="line"><span class="number">4</span>     apple</span><br><span class="line"><span class="number">5</span>    orange</span><br><span class="line"><span class="number">6</span>     apple</span><br><span class="line"><span class="number">7</span>     apple</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: pd.unique(values)</span><br><span class="line">Out[<span class="number">13</span>]: array([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: pd.value_counts(values)</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">apple     <span class="number">6</span></span><br><span class="line">orange    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>许多数据系统（数据仓库、统计计算或其它应用）都发展出了特定的表征重复值的方法，以进行高效的存储和计算。在数据仓库中，最好的方法是使用所谓的包含不同值的维表(Dimension Table)，将主要的参数存储为引用维表整数键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: values = pd.Series([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: dim = pd.Series([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: values</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">1</span></span><br><span class="line"><span class="number">6</span>    <span class="number">0</span></span><br><span class="line"><span class="number">7</span>    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: dim</span><br><span class="line">Out[<span class="number">18</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>可以使用take方法存储原始的字符串Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">19</span>]: dim.take(values)</span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>这种用整数表示的方法称为分类或字典编码表示法。不同值得数组称为分类、字典或数据级。本书中，我们使用分类的说法。表示分类的整数值称为分类编码或简单地称为编码。</p>
<p>分类表示可以在进行分析时大大的提高性能。你也可以在保持编码不变的情况下，对分类进行转换。一些相对简单的转变例子包括：</p>
<ul>
<li>重命名分类。</li>
<li>加入一个新的分类，不改变已经存在的分类的顺序或位置。</li>
</ul>
<h3 id="pandas的分类类型">12.1.2 pandas的分类类型</h3>
<p>pandas有一个特殊的分类类型，用于保存使用整数分类表示法的数据。看一个之前的Series例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>] * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: N = <span class="built_in">len</span>(fruits)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;fruit&#x27;</span>: fruits,</span><br><span class="line">   ....:                    <span class="string">&#x27;basket_id&#x27;</span>: np.arange(N),</span><br><span class="line">   ....:                    <span class="string">&#x27;count&#x27;</span>: np.random.randint(<span class="number">3</span>, <span class="number">15</span>, size=N),</span><br><span class="line">   ....:                    <span class="string">&#x27;weight&#x27;</span>: np.random.uniform(<span class="number">0</span>, <span class="number">4</span>, size=N)&#125;,</span><br><span class="line">   ....:                   columns=[<span class="string">&#x27;basket_id&#x27;</span>, <span class="string">&#x27;fruit&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: df</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">   basket_id   fruit  count    weight</span><br><span class="line"><span class="number">0</span>          <span class="number">0</span>   apple      <span class="number">5</span>  <span class="number">3.858058</span></span><br><span class="line"><span class="number">1</span>          <span class="number">1</span>  orange      <span class="number">8</span>  <span class="number">2.612708</span></span><br><span class="line"><span class="number">2</span>          <span class="number">2</span>   apple      <span class="number">4</span>  <span class="number">2.995627</span></span><br><span class="line"><span class="number">3</span>          <span class="number">3</span>   apple      <span class="number">7</span>  <span class="number">2.614279</span></span><br><span class="line"><span class="number">4</span>          <span class="number">4</span>   apple     <span class="number">12</span>  <span class="number">2.990859</span></span><br><span class="line"><span class="number">5</span>          <span class="number">5</span>  orange      <span class="number">8</span>  <span class="number">3.845227</span></span><br><span class="line"><span class="number">6</span>          <span class="number">6</span>   apple      <span class="number">5</span>  <span class="number">0.033553</span></span><br><span class="line"><span class="number">7</span>          <span class="number">7</span>   apple      <span class="number">4</span>  <span class="number">0.425778</span></span><br></pre></td></tr></table></figure>
<p>这里，df['fruit']是一个Python字符串对象的数组。我们可以通过调用它，将它转变为分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: fruit_cat = df[<span class="string">&#x27;fruit&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: fruit_cat</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">2</span>     apple</span><br><span class="line"><span class="number">3</span>     apple</span><br><span class="line"><span class="number">4</span>     apple</span><br><span class="line"><span class="number">5</span>    orange</span><br><span class="line"><span class="number">6</span>     apple</span><br><span class="line"><span class="number">7</span>     apple</span><br><span class="line">Name: fruit, dtype: category</span><br><span class="line">Categories (<span class="number">2</span>, <span class="built_in">object</span>): [apple, orange]</span><br></pre></td></tr></table></figure>
<p>fruit_cat的值不是NumPy数组，而是一个pandas.Categorical实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: c = fruit_cat.values</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: <span class="built_in">type</span>(c)</span><br><span class="line">Out[<span class="number">27</span>]: pandas.core.categorical.Categorical</span><br></pre></td></tr></table></figure>
<p>分类对象有categories和codes属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">28</span>]: c.categories</span><br><span class="line">Out[<span class="number">28</span>]: Index([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: c.codes</span><br><span class="line">Out[<span class="number">29</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], dtype=int8)</span><br></pre></td></tr></table></figure>
<p>你可将DataFrame的列通过分配转换结果，转换为分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: df[<span class="string">&#x27;fruit&#x27;</span>] = df[<span class="string">&#x27;fruit&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: df.fruit</span><br><span class="line">Out[<span class="number">31</span>]:</span><br><span class="line"><span class="number">0</span>     apple</span><br><span class="line"><span class="number">1</span>    orange</span><br><span class="line"><span class="number">2</span>     apple</span><br><span class="line"><span class="number">3</span>     apple</span><br><span class="line"><span class="number">4</span>     apple</span><br><span class="line"><span class="number">5</span>    orange</span><br><span class="line"><span class="number">6</span>     apple</span><br><span class="line"><span class="number">7</span>     apple</span><br><span class="line">Name: fruit, dtype: category</span><br><span class="line">Categories (<span class="number">2</span>, <span class="built_in">object</span>): [apple, orange]</span><br></pre></td></tr></table></figure>
<p>你还可以从其它Python序列直接创建pandas.Categorical：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: my_categories = pd.Categorical([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: my_categories</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">[foo, bar, baz, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [bar, baz, foo]</span><br></pre></td></tr></table></figure>
<p>如果你已经从其它源获得了分类编码，你还可以使用from_codes构造器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: categories = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: codes = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: my_cats_2 = pd.Categorical.from_codes(codes, categories)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: my_cats_2</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">[foo, bar, baz, foo, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [foo, bar, baz]</span><br></pre></td></tr></table></figure>
<p>与显示指定不同，分类变换不认定指定的分类顺序。因此取决于输入数据的顺序，categories数组的顺序会不同。当使用from_codes或其它的构造器时，你可以指定分类一个有意义的顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: ordered_cat = pd.Categorical.from_codes(codes, categories,</span><br><span class="line">   ....:                                         ordered=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: ordered_cat</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">[foo, bar, baz, foo, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [foo &lt; bar &lt; baz]</span><br></pre></td></tr></table></figure>
<p>输出[foo &lt; bar &lt; baz]指明‘foo’位于‘bar’的前面，以此类推。无序的分类实例可以通过as_ordered排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: my_cats_2.as_ordered()</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">[foo, bar, baz, foo, foo, bar]</span><br><span class="line">Categories (<span class="number">3</span>, <span class="built_in">object</span>): [foo &lt; bar &lt; baz]</span><br></pre></td></tr></table></figure>
<p>最后要注意，分类数据不需要字符串，尽管我仅仅展示了字符串的例子。分类数组可以包括任意不可变类型。</p>
<h3 id="用分类进行计算">12.1.3 用分类进行计算</h3>
<p>与非编码版本（比如字符串数组）相比，使用pandas的Categorical有些类似。某些pandas组件，比如groupby函数，更适合进行分类。还有一些函数可以使用有序标志位。</p>
<p>来看一些随机的数值数据，使用pandas.qcut面元函数。它会返回pandas.Categorical，我们之前使用过pandas.cut，但没解释分类是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: np.random.seed(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: draws = np.random.randn(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: draws[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">43</span>]: array([-<span class="number">0.2047</span>,  <span class="number">0.4789</span>, -<span class="number">0.5194</span>, -<span class="number">0.5557</span>,  <span class="number">1.9658</span>])</span><br></pre></td></tr></table></figure>
<p>计算这个数据的分位面元，提取一些统计信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: bins = pd.qcut(draws, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: bins</span><br><span class="line">Out[<span class="number">45</span>]: </span><br><span class="line">[(-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (-<span class="number">0.0101</span>, <span class="number">0.63</span>], (-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (<span class="number">0.63</span>,</span><br><span class="line"> <span class="number">3.928</span>], ..., (-<span class="number">0.0101</span>, <span class="number">0.63</span>], (-<span class="number">0.684</span>, -<span class="number">0.0101</span>], (-<span class="number">2.95</span>, -<span class="number">0.684</span>], (-<span class="number">0.0101</span>, <span class="number">0.63</span></span><br><span class="line">], (<span class="number">0.63</span>, <span class="number">3.928</span>]]</span><br><span class="line">Length: <span class="number">1000</span></span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(-<span class="number">2.95</span>, -<span class="number">0.684</span>] &lt; (-<span class="number">0.684</span>, -<span class="number">0.0101</span>] &lt; (-<span class="number">0.010</span></span><br><span class="line"><span class="number">1</span>, <span class="number">0.63</span>] &lt;</span><br><span class="line">                                    (<span class="number">0.63</span>, <span class="number">3.928</span>]]</span><br></pre></td></tr></table></figure>
<p>虽然有用，确切的样本分位数与分位的名称相比，不利于生成汇总。我们可以使用labels参数qcut，实现目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: bins = pd.qcut(draws, <span class="number">4</span>, labels=[<span class="string">&#x27;Q1&#x27;</span>, <span class="string">&#x27;Q2&#x27;</span>, <span class="string">&#x27;Q3&#x27;</span>, <span class="string">&#x27;Q4&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: bins</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line">[Q2, Q3, Q2, Q2, Q4, ..., Q3, Q2, Q1, Q3, Q4]</span><br><span class="line">Length: <span class="number">1000</span></span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [Q1 &lt; Q2 &lt; Q3 &lt; Q4]</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: bins.codes[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">48</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>], dtype=int8)</span><br></pre></td></tr></table></figure>
<p>加上标签的面元分类不包含数据面元边界的信息，因此可以使用groupby提取一些汇总信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: bins = pd.Series(bins, name=<span class="string">&#x27;quartile&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: results = (pd.Series(draws)</span><br><span class="line">   ....:            .groupby(bins)</span><br><span class="line">   ....:            .agg([<span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>])</span><br><span class="line">   ....:            .reset_index())</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: results</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">  quartile  count       <span class="built_in">min</span>       <span class="built_in">max</span></span><br><span class="line"><span class="number">0</span>       Q1    <span class="number">250</span> -<span class="number">2.949343</span> -<span class="number">0.685484</span></span><br><span class="line"><span class="number">1</span>       Q2    <span class="number">250</span> -<span class="number">0.683066</span> -<span class="number">0.010115</span></span><br><span class="line"><span class="number">2</span>       Q3    <span class="number">250</span> -<span class="number">0.010032</span>  <span class="number">0.628894</span></span><br><span class="line"><span class="number">3</span>       Q4    <span class="number">250</span>  <span class="number">0.634238</span>  <span class="number">3.927528</span></span><br></pre></td></tr></table></figure>
<p>分位数列保存了原始的面元分类信息，包括排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">52</span>]: results[<span class="string">&#x27;quartile&#x27;</span>]</span><br><span class="line">Out[<span class="number">52</span>]:</span><br><span class="line"><span class="number">0</span>    Q1</span><br><span class="line"><span class="number">1</span>    Q2</span><br><span class="line"><span class="number">2</span>    Q3</span><br><span class="line"><span class="number">3</span>    Q4</span><br><span class="line">Name: quartile, dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [Q1 &lt; Q2 &lt; Q3 &lt; Q4]</span><br></pre></td></tr></table></figure>
<h3 id="用分类提高性能">12.1.4 用分类提高性能</h3>
<p>如果你是在一个特定数据集上做大量分析，将其转换为分类可以极大地提高效率。DataFrame列的分类使用的内存通常少的多。来看一些包含一千万元素的Series，和一些不同的分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">53</span>]: N = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: draws = pd.Series(np.random.randn(N))</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: labels = pd.Series([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>] * (N // <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>现在，将标签转换为分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: categories = labels.astype(<span class="string">&#x27;category&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这时，可以看到标签使用的内存远比分类多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: labels.memory_usage()</span><br><span class="line">Out[<span class="number">57</span>]: <span class="number">80000080</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: categories.memory_usage()</span><br><span class="line">Out[<span class="number">58</span>]: <span class="number">10000272</span></span><br></pre></td></tr></table></figure>
<p>转换为分类不是没有代价的，但这是一次性的代价：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">59</span>]: %time _ = labels.astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line">CPU times: user <span class="number">490</span> ms, sys: <span class="number">240</span> ms, total: <span class="number">730</span> ms</span><br><span class="line">Wall time: <span class="number">726</span> ms</span><br></pre></td></tr></table></figure>
<p>GroupBy使用分类操作明显更快，是因为底层的算法使用整数编码数组，而不是字符串数组。</p>
<h3 id="分类方法">12.1.5 分类方法</h3>
<p>包含分类数据的Series有一些特殊的方法，类似于Series.str字符串方法。它还提供了方便的分类和编码的使用方法。看下面的Series：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: s = pd.Series([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: cat_s = s.astype(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: cat_s</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">2</span>    c</span><br><span class="line"><span class="number">3</span>    d</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    c</span><br><span class="line"><span class="number">7</span>    d</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [a, b, c, d]</span><br></pre></td></tr></table></figure>
<p>特别的cat属性提供了分类方法的入口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: cat_s.cat.codes</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">1</span></span><br><span class="line"><span class="number">6</span>    <span class="number">2</span></span><br><span class="line"><span class="number">7</span>    <span class="number">3</span></span><br><span class="line">dtype: int8</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: cat_s.cat.categories</span><br><span class="line">Out[<span class="number">64</span>]: Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>假设我们知道这个数据的实际分类集，超出了数据中的四个值。我们可以使用set_categories方法改变它们：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: actual_categories = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: cat_s2 = cat_s.cat.set_categories(actual_categories)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: cat_s2</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">2</span>    c</span><br><span class="line"><span class="number">3</span>    d</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    c</span><br><span class="line"><span class="number">7</span>    d</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">5</span>, <span class="built_in">object</span>): [a, b, c, d, e]</span><br></pre></td></tr></table></figure>
<p>虽然数据看起来没变，新的分类将反映在它们的操作中。例如，如果有的话，value_counts表示分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: cat_s.value_counts()</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">d    <span class="number">2</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">a    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: cat_s2.value_counts()</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">d    <span class="number">2</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">a    <span class="number">2</span></span><br><span class="line">e    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>在大数据集中，分类经常作为节省内存和高性能的便捷工具。过滤完大DataFrame或Series之后，许多分类可能不会出现在数据中。我们可以使用remove_unused_categories方法删除没看到的分类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">70</span>]: cat_s3 = cat_s[cat_s.isin([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])]</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: cat_s3</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, <span class="built_in">object</span>): [a, b, c, d]</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: cat_s3.cat.remove_unused_categories()</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line"><span class="number">0</span>    a</span><br><span class="line"><span class="number">1</span>    b</span><br><span class="line"><span class="number">4</span>    a</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line">dtype: category</span><br><span class="line">Categories (<span class="number">2</span>, <span class="built_in">object</span>): [a, b]</span><br></pre></td></tr></table></figure>
<p>表12-1列出了可用的分类方法。</p>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap12/7178691-6c602152c2bba658.png" class="" title="表12-1 pandas的Series的分类方法">
<h3 id="为建模创建虚拟变量">12.1.6 为建模创建虚拟变量</h3>
<p>当你使用统计或机器学习工具时，通常会将分类数据转换为虚拟变量，也称为one-hot编码。这包括创建一个不同类别的列的DataFrame；这些列包含给定分类的1s，其它为0。</p>
<p>看前面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: cat_s = pd.Series([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>] * <span class="number">2</span>, dtype=<span class="string">&#x27;category&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>前面的第7章提到过，pandas.get_dummies函数可以转换这个分类数据为包含虚拟变量的DataFrame：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: pd.get_dummies(cat_s)</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">   a  b  c  d</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">6</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">7</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="groupby高级应用">12.2 GroupBy高级应用</h2>
<p>尽管我们在第10章已经深度学习了Series和DataFrame的Groupby方法，还有一些方法也是很有用的。</p>
<h3 id="分组转换和解封groupby">12.2.1 分组转换和“解封”GroupBy</h3>
<p>在第10章，我们在分组操作中学习了apply方法，进行转换。还有另一个transform方法，它与apply很像，但是对使用的函数有一定限制：</p>
<ul>
<li>它可以产生向分组形状广播标量值</li>
<li>它可以产生一个和输入组形状相同的对象</li>
<li>它不能修改输入</li>
</ul>
<p>来看一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] * <span class="number">4</span>,</span><br><span class="line">   ....:                    <span class="string">&#x27;value&#x27;</span>: np.arange(<span class="number">12.</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: df</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">   key  value</span><br><span class="line"><span class="number">0</span>    a    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>    b    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    c    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    a    <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>    b    <span class="number">4.0</span></span><br><span class="line"><span class="number">5</span>    c    <span class="number">5.0</span></span><br><span class="line"><span class="number">6</span>    a    <span class="number">6.0</span></span><br><span class="line"><span class="number">7</span>    b    <span class="number">7.0</span></span><br><span class="line"><span class="number">8</span>    c    <span class="number">8.0</span></span><br><span class="line"><span class="number">9</span>    a    <span class="number">9.0</span></span><br><span class="line"><span class="number">10</span>   b   <span class="number">10.0</span></span><br><span class="line"><span class="number">11</span>   c   <span class="number">11.0</span></span><br></pre></td></tr></table></figure>
<p>按键进行分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: g = df.groupby(<span class="string">&#x27;key&#x27;</span>).value</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: g.mean()</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">key</span><br><span class="line">a    <span class="number">4.5</span></span><br><span class="line">b    <span class="number">5.5</span></span><br><span class="line">c    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure>
<p>假设我们想产生一个和df['value']形状相同的Series，但值替换为按键分组的平均值。我们可以传递函数lambda x: x.mean()进行转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: g.transform(<span class="keyword">lambda</span> x: x.mean())</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">1</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">2</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">5</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">6</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">7</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">8</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">9</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">10</span>    <span class="number">5.5</span></span><br><span class="line"><span class="number">11</span>    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure>
<p>对于内置的聚合函数，我们可以传递一个字符串假名作为GroupBy的agg方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">80</span>]: g.transform(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">1</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">2</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">5</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">6</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">7</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">8</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">9</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">10</span>    <span class="number">5.5</span></span><br><span class="line"><span class="number">11</span>    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure>
<p>与apply类似，transform的函数会返回Series，但是结果必须与输入大小相同。举个例子，我们可以用lambda函数将每个分组乘以2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: g.transform(<span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line"><span class="number">0</span>      <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">8.0</span></span><br><span class="line"><span class="number">5</span>     <span class="number">10.0</span></span><br><span class="line"><span class="number">6</span>     <span class="number">12.0</span></span><br><span class="line"><span class="number">7</span>     <span class="number">14.0</span></span><br><span class="line"><span class="number">8</span>     <span class="number">16.0</span></span><br><span class="line"><span class="number">9</span>     <span class="number">18.0</span></span><br><span class="line"><span class="number">10</span>    <span class="number">20.0</span></span><br><span class="line"><span class="number">11</span>    <span class="number">22.0</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure>
<p>再举一个复杂的例子，我们可以计算每个分组的降序排名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: g.transform(<span class="keyword">lambda</span> x: x.rank(ascending=<span class="literal">False</span>))</span><br><span class="line">Out[<span class="number">82</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>     <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>     <span class="number">3.0</span></span><br><span class="line"><span class="number">6</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">7</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">8</span>     <span class="number">2.0</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.0</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.0</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure>
<p>看一个由简单聚合构造的的分组转换函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> (x - x.mean()) / x.std()</span><br></pre></td></tr></table></figure>
<p>我们用transform或apply可以获得等价的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">84</span>]: g.transform(normalize)</span><br><span class="line">Out[<span class="number">84</span>]: </span><br><span class="line"><span class="number">0</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">2</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">4</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">5</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">6</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">7</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">8</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.161895</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.161895</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.161895</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: g.apply(normalize)</span><br><span class="line">Out[<span class="number">85</span>]: </span><br><span class="line"><span class="number">0</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">2</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">4</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">5</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">6</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">7</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">8</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.161895</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.161895</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.161895</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure>
<p>内置的聚合函数，比如mean或sum，通常比apply函数快，也比transform快。这允许我们进行一个所谓的解封（unwrapped）分组操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">86</span>]: g.transform(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">1</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">2</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">5</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">6</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">7</span>     <span class="number">5.5</span></span><br><span class="line"><span class="number">8</span>     <span class="number">6.5</span></span><br><span class="line"><span class="number">9</span>     <span class="number">4.5</span></span><br><span class="line"><span class="number">10</span>    <span class="number">5.5</span></span><br><span class="line"><span class="number">11</span>    <span class="number">6.5</span></span><br><span class="line">Name: value, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: normalized = (df[<span class="string">&#x27;value&#x27;</span>] - g.transform(<span class="string">&#x27;mean&#x27;</span>)) / g.transform(<span class="string">&#x27;std&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: normalized</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line"><span class="number">0</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">2</span>    -<span class="number">1.161895</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">4</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">5</span>    -<span class="number">0.387298</span></span><br><span class="line"><span class="number">6</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">7</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">8</span>     <span class="number">0.387298</span></span><br><span class="line"><span class="number">9</span>     <span class="number">1.161895</span></span><br><span class="line"><span class="number">10</span>    <span class="number">1.161895</span></span><br><span class="line"><span class="number">11</span>    <span class="number">1.161895</span></span><br><span class="line">Name: value, dtype: float64</span><br></pre></td></tr></table></figure>
<p>解封分组操作可能包括多个分组聚合，但是矢量化操作还是会带来收益。</p>
<h3 id="分组的时间重采样">12.2.2 分组的时间重采样</h3>
<p>对于时间序列数据，resample方法从语义上是一个基于内在时间的分组操作。下面是一个示例表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: N = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: times = pd.date_range(<span class="string">&#x27;2017-05-20 00:00&#x27;</span>, freq=<span class="string">&#x27;1min&#x27;</span>, periods=N)</span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;time&#x27;</span>: times,</span><br><span class="line">   ....:                    <span class="string">&#x27;value&#x27;</span>: np.arange(N)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: df</span><br><span class="line">Out[<span class="number">92</span>]: </span><br><span class="line">                  time  value</span><br><span class="line"><span class="number">0</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:02:<span class="number">00</span>      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:03:<span class="number">00</span>      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:04:<span class="number">00</span>      <span class="number">4</span></span><br><span class="line"><span class="number">5</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>      <span class="number">5</span></span><br><span class="line"><span class="number">6</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:06:<span class="number">00</span>      <span class="number">6</span></span><br><span class="line"><span class="number">7</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:07:<span class="number">00</span>      <span class="number">7</span></span><br><span class="line"><span class="number">8</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:08:<span class="number">00</span>      <span class="number">8</span></span><br><span class="line"><span class="number">9</span>  <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:09:<span class="number">00</span>      <span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>     <span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">11</span>:<span class="number">00</span>     <span class="number">11</span></span><br><span class="line"><span class="number">12</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">12</span>:<span class="number">00</span>     <span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">13</span>:<span class="number">00</span>     <span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">14</span>:<span class="number">00</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>这里，我们可以用time作为索引，然后重采样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: df.set_index(<span class="string">&#x27;time&#x27;</span>).resample(<span class="string">&#x27;5min&#x27;</span>).count()</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line">                     value</span><br><span class="line">time                      </span><br><span class="line"><span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>      <span class="number">5</span></span><br><span class="line"><span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>      <span class="number">5</span></span><br><span class="line"><span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>      <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>假设DataFrame包含多个时间序列，用一个额外的分组键的列进行标记：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;time&#x27;</span>: times.repeat(<span class="number">3</span>),</span><br><span class="line">   ....:                     <span class="string">&#x27;key&#x27;</span>: np.tile([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], N),</span><br><span class="line">   ....:                     <span class="string">&#x27;value&#x27;</span>: np.arange(N * <span class="number">3.</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: df2[:<span class="number">7</span>]</span><br><span class="line">Out[<span class="number">95</span>]: </span><br><span class="line">  key                time  value</span><br><span class="line"><span class="number">0</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">5</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:01:<span class="number">00</span>    <span class="number">5.0</span></span><br><span class="line"><span class="number">6</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:02:<span class="number">00</span>    <span class="number">6.0</span></span><br></pre></td></tr></table></figure>
<p>要对每个key值进行相同的重采样，我们引入pandas.TimeGrouper对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: time_key = pd.TimeGrouper(<span class="string">&#x27;5min&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>我们然后设定时间索引，用key和time_key分组，然后聚合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">97</span>]: resampled = (df2.set_index(<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line">   ....:              .groupby([<span class="string">&#x27;key&#x27;</span>, time_key])</span><br><span class="line">   ....:              .<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: resampled</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">                         value</span><br><span class="line">key time                      </span><br><span class="line">a   <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">30.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">105.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">180.0</span></span><br><span class="line">b   <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">35.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">110.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">185.0</span></span><br><span class="line">c   <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">40.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">115.0</span></span><br><span class="line">    <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">190.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: resampled.reset_index()</span><br><span class="line">Out[<span class="number">99</span>]:</span><br><span class="line">key                time  value</span><br><span class="line"><span class="number">0</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">30.0</span></span><br><span class="line"><span class="number">1</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">105.0</span></span><br><span class="line"><span class="number">2</span>   a <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">180.0</span></span><br><span class="line"><span class="number">3</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">35.0</span></span><br><span class="line"><span class="number">4</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">110.0</span></span><br><span class="line"><span class="number">5</span>   b <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">185.0</span></span><br><span class="line"><span class="number">6</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>   <span class="number">40.0</span></span><br><span class="line"><span class="number">7</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:05:<span class="number">00</span>  <span class="number">115.0</span></span><br><span class="line"><span class="number">8</span>   c <span class="number">2017</span>-05-<span class="number">20</span> <span class="number">00</span>:<span class="number">10</span>:<span class="number">00</span>  <span class="number">190.0</span></span><br></pre></td></tr></table></figure>
<p>使用TimeGrouper的限制是时间必须是Series或DataFrame的索引。</p>
<h2 id="链式编程技术">12.3 链式编程技术</h2>
<p>当对数据集进行一系列变换时，你可能发现创建的多个临时变量其实并没有在分析中用到。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = load_data()</span><br><span class="line">df2 = df[df[<span class="string">&#x27;col2&#x27;</span>] &lt; <span class="number">0</span>]</span><br><span class="line">df2[<span class="string">&#x27;col1_demeaned&#x27;</span>] = df2[<span class="string">&#x27;col1&#x27;</span>] - df2[<span class="string">&#x27;col1&#x27;</span>].mean()</span><br><span class="line">result = df2.groupby(<span class="string">&#x27;key&#x27;</span>).col1_demeaned.std()</span><br></pre></td></tr></table></figure>
<p>虽然这里没有使用真实的数据，这个例子却指出了一些新方法。首先，DataFrame.assign方法是一个df[k] = v形式的函数式的列分配方法。它不是就地修改对象，而是返回新的修改过的DataFrame。因此，下面的语句是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Usual non-functional way</span></span><br><span class="line">df2 = df.copy()</span><br><span class="line">df2[<span class="string">&#x27;k&#x27;</span>] = v</span><br><span class="line"></span><br><span class="line"><span class="comment">## Functional assign way</span></span><br><span class="line">df2 = df.assign(k=v)</span><br></pre></td></tr></table></figure>
<p>就地分配可能会比assign快，但是assign可以方便地进行链式编程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = (df2.assign(col1_demeaned=df2.col1 - df2.col2.mean())</span><br><span class="line">          .groupby(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">          .col1_demeaned.std())</span><br></pre></td></tr></table></figure>
<p>我使用外括号，这样便于添加换行符。</p>
<p>使用链式编程时要注意，你可能会需要涉及临时对象。在前面的例子中，我们不能使用load_data的结果，直到它被赋值给临时变量df。为了这么做，assign和许多其它pandas函数可以接收类似函数的参数，即可调用对象（callable）。为了展示可调用对象，看一个前面例子的片段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = load_data()</span><br><span class="line">df2 = df[df[<span class="string">&#x27;col2&#x27;</span>] &lt; <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>它可以重写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = (load_data()</span><br><span class="line">      [<span class="keyword">lambda</span> x: x[<span class="string">&#x27;col2&#x27;</span>] &lt; <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>这里，load_data的结果没有赋值给某个变量，因此传递到[ ]的函数在这一步被绑定到了对象。</p>
<p>我们可以把整个过程写为一个单链表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = (load_data()</span><br><span class="line">          [<span class="keyword">lambda</span> x: x.col2 &lt; <span class="number">0</span>]</span><br><span class="line">          .assign(col1_demeaned=<span class="keyword">lambda</span> x: x.col1 - x.col1.mean())</span><br><span class="line">          .groupby(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">          .col1_demeaned.std())</span><br></pre></td></tr></table></figure>
<p>是否将代码写成这种形式只是习惯而已，将它分开成若干步可以提高可读性。</p>
<h3 id="管道方法">12.3.1 管道方法</h3>
<p>你可以用Python内置的pandas函数和方法，用带有可调用对象的链式编程做许多工作。但是，有时你需要使用自己的函数，或是第三方库的函数。这时就要用到管道方法。</p>
<p>看下面的函数调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = f(df, arg1=v1)</span><br><span class="line">b = g(a, v2, arg3=v3)</span><br><span class="line">c = h(b, arg4=v4)</span><br></pre></td></tr></table></figure>
<p>当使用接收、返回Series或DataFrame对象的函数式，你可以调用pipe将其重写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = (df.pipe(f, arg1=v1)</span><br><span class="line">          .pipe(g, v2, arg3=v3)</span><br><span class="line">          .pipe(h, arg4=v4))</span><br></pre></td></tr></table></figure>
<p>f(df)和df.pipe(f)是等价的，但是pipe使得链式声明更容易。</p>
<p>pipe的另一个有用的地方是提炼操作为可复用的函数。看一个从列减去分组方法的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;col1&#x27;</span>] = df[<span class="string">&#x27;col1&#x27;</span>] - g.transform(<span class="string">&#x27;mean&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>假设你想转换多列，并修改分组的键。另外，你想用链式编程做这个转换。下面就是一个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">group_demean</span>(<span class="params">df, by, cols</span>):</span><br><span class="line">    result = df.copy()</span><br><span class="line">    g = df.groupby(by)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cols:</span><br><span class="line">        result[c] = df[c] - g[c].transform(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>然后可以写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = (df[df.col1 &lt; <span class="number">0</span>]</span><br><span class="line">          .pipe(group_demean, [<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], [<span class="string">&#x27;col1&#x27;</span>]))</span><br></pre></td></tr></table></figure>
<h2 id="总结">12.4 总结</h2>
<p>和其它许多开源项目一样，pandas仍然在不断的变化和进步中。和本书中其它地方一样，这里的重点是放在接下来几年不会发生什么改变且稳定的功能。</p>
<p>为了深入学习pandas的知识，我建议你学习官方文档，并阅读开发团队发布的文档更新。我们还邀请你加入pandas的开发工作：修改bug、创建新功能、完善文档。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第13章_Python建模库介绍</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap13/</url>
    <content><![CDATA[<h1 id="第13章-python建模库介绍">第13章 Python建模库介绍</h1>
<p>本书中，我已经介绍了Python数据分析的编程基础。因为数据分析师和科学家总是在数据规整和准备上花费大量时间，这本书的重点在于掌握这些功能。</p>
<span id="more"></span>
<p>开发模型选用什么库取决于应用本身。许多统计问题可以用简单方法解决，比如普通的最小二乘回归，其它问题可能需要复杂的机器学习方法。幸运的是，Python已经成为了运用这些分析方法的语言之一，因此读完此书，你可以探索许多工具。</p>
<p>本章中，我会回顾一些pandas的特点，在你胶着于pandas数据规整和模型拟合和评分时，它们可能派上用场。然后我会简短介绍两个流行的建模工具，statsmodels和scikit-learn。这二者每个都值得再写一本书，我就不做全面的介绍，而是建议你学习两个项目的线上文档和其它基于Python的数据科学、统计和机器学习的书籍。</p>
<h2 id="pandas与模型代码的接口">13.1 pandas与模型代码的接口</h2>
<p>模型开发的通常工作流是使用pandas进行数据加载和清洗，然后切换到建模库进行建模。开发模型的重要一环是机器学习中的“特征工程”。它可以描述从原始数据集中提取信息的任何数据转换或分析，这些数据集可能在建模中有用。本书中学习的数据聚合和GroupBy工具常用于特征工程中。</p>
<p>优秀的特征工程超出了本书的范围，我会尽量直白地介绍一些用于数据操作和建模切换的方法。</p>
<p>pandas与其它分析库通常是靠NumPy的数组联系起来的。将DataFrame转换为NumPy数组，可以使用.values属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: data = pd.DataFrame(&#123;</span><br><span class="line">   ....:     <span class="string">&#x27;x0&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;x1&#x27;</span>: [<span class="number">0.01</span>, -<span class="number">0.01</span>, <span class="number">0.25</span>, -<span class="number">4.1</span>, <span class="number">0.</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;y&#x27;</span>: [-<span class="number">1.5</span>, <span class="number">0.</span>, <span class="number">3.6</span>, <span class="number">1.3</span>, -<span class="number">2.</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: data</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">   x0    x1    y</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span></span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: data.columns</span><br><span class="line">Out[<span class="number">14</span>]: Index([<span class="string">&#x27;x0&#x27;</span>, <span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;y&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: data.values</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>  ,  <span class="number">0.01</span>, -<span class="number">1.5</span> ],</span><br><span class="line">       [ <span class="number">2.</span>  , -<span class="number">0.01</span>,  <span class="number">0.</span>  ],</span><br><span class="line">       [ <span class="number">3.</span>  ,  <span class="number">0.25</span>,  <span class="number">3.6</span> ],</span><br><span class="line">       [ <span class="number">4.</span>  , -<span class="number">4.1</span> ,  <span class="number">1.3</span> ],</span><br><span class="line">       [ <span class="number">5.</span>  ,  <span class="number">0.</span>  , -<span class="number">2.</span>  ]])</span><br></pre></td></tr></table></figure>
<p>要转换回DataFrame，可以传递一个二维ndarray，可带有列名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: df2 = pd.DataFrame(data.values, columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: df2</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">   one   two  three</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">0.01</span>   -<span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2.0</span> -<span class="number">0.01</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3.0</span>  <span class="number">0.25</span>    <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4.0</span> -<span class="number">4.10</span>    <span class="number">1.3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">5.0</span>  <span class="number">0.00</span>   -<span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>笔记：最好当数据是均匀的时候使用.values属性。例如，全是数值类型。如果数据是不均匀的，结果会是Python对象的ndarray： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;In [<span class="number">18</span>]: df3 = data.copy()</span><br><span class="line"></span><br><span class="line">&gt;In [<span class="number">19</span>]: df3[<span class="string">&#x27;strings&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"></span><br><span class="line">&gt;In [<span class="number">20</span>]: df3</span><br><span class="line">&gt;Out[<span class="number">20</span>]: </span><br><span class="line">  x0    x1    y strings</span><br><span class="line">&gt;<span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span>       a</span><br><span class="line">&gt;<span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span>       b</span><br><span class="line">&gt;<span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span>       c</span><br><span class="line">&gt;<span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span>       d</span><br><span class="line">&gt;<span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span>       e</span><br><span class="line"></span><br><span class="line">&gt;In [<span class="number">21</span>]: df3.values</span><br><span class="line">&gt;Out[<span class="number">21</span>]: </span><br><span class="line">&gt;array([[<span class="number">1</span>, <span class="number">0.01</span>, -<span class="number">1.5</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">      [<span class="number">2</span>, -<span class="number">0.01</span>, <span class="number">0.0</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">      [<span class="number">3</span>, <span class="number">0.25</span>, <span class="number">3.6</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">      [<span class="number">4</span>, -<span class="number">4.1</span>, <span class="number">1.3</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">      [<span class="number">5</span>, <span class="number">0.0</span>, -<span class="number">2.0</span>, <span class="string">&#x27;e&#x27;</span>]], dtype=<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>对于一些模型，你可能只想使用列的子集。我建议你使用loc，用values作索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: model_cols = [<span class="string">&#x27;x0&#x27;</span>, <span class="string">&#x27;x1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: data.loc[:, model_cols].values</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>  ,  <span class="number">0.01</span>],</span><br><span class="line">       [ <span class="number">2.</span>  , -<span class="number">0.01</span>],</span><br><span class="line">       [ <span class="number">3.</span>  ,  <span class="number">0.25</span>],</span><br><span class="line">       [ <span class="number">4.</span>  , -<span class="number">4.1</span> ],</span><br><span class="line">       [ <span class="number">5.</span>  ,  <span class="number">0.</span>  ]])</span><br></pre></td></tr></table></figure>
<p>一些库原生支持pandas，会自动完成工作：从DataFrame转换到NumPy，将模型的参数名添加到输出表的列或Series。其它情况，你可以手工进行“元数据管理”。</p>
<p>在第12章，我们学习了pandas的Categorical类型和pandas.get_dummies函数。假设数据集中有一个非数值列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: data[<span class="string">&#x27;category&#x27;</span>] = pd.Categorical([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:                                   categories=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: data</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">   x0    x1    y category</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span>        a</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span>        b</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span>        a</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span>        a</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span>        b</span><br></pre></td></tr></table></figure>
<p>如果我们想替换category列为虚变量，我们可以创建虚变量，删除category列，然后添加到结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: dummies = pd.get_dummies(data.category, prefix=<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: data_with_dummies = data.drop(<span class="string">&#x27;category&#x27;</span>, axis=<span class="number">1</span>).join(dummies)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: data_with_dummies</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">   x0    x1    y  category_a  category_b</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span>           <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span>           <span class="number">0</span>           <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span>           <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span>           <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span>           <span class="number">0</span>           <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>用虚变量拟合某些统计模型会有一些细微差别。当你不只有数字列时，使用Patsy（下一节的主题）可能更简单，更不容易出错。</p>
<h2 id="用patsy创建模型描述">13.2 用Patsy创建模型描述</h2>
<p>Patsy是Python的一个库，使用简短的字符串“公式语法”描述统计模型（尤其是线性模型），可能是受到了R和S统计编程语言的公式语法的启发。</p>
<p>Patsy适合描述statsmodels的线性模型，因此我会关注于它的主要特点，让你尽快掌握。Patsy的公式是一个特殊的字符串语法，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y ~ x0 + x1</span><br></pre></td></tr></table></figure>
<p>a+b不是将a与b相加的意思，而是为模型创建的设计矩阵。patsy.dmatrices函数接收一个公式字符串和一个数据集（可以是DataFrame或数组的字典），为线性模型创建设计矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: data = pd.DataFrame(&#123;</span><br><span class="line">   ....:     <span class="string">&#x27;x0&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;x1&#x27;</span>: [<span class="number">0.01</span>, -<span class="number">0.01</span>, <span class="number">0.25</span>, -<span class="number">4.1</span>, <span class="number">0.</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;y&#x27;</span>: [-<span class="number">1.5</span>, <span class="number">0.</span>, <span class="number">3.6</span>, <span class="number">1.3</span>, -<span class="number">2.</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: data</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">   x0    x1    y</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span></span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: <span class="keyword">import</span> patsy</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;y ~ x0 + x1&#x27;</span>, data)</span><br></pre></td></tr></table></figure>
<p>现在有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: y</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">     y</span><br><span class="line">  -<span class="number">1.5</span></span><br><span class="line">   <span class="number">0.0</span></span><br><span class="line">   <span class="number">3.6</span></span><br><span class="line">   <span class="number">1.3</span></span><br><span class="line">  -<span class="number">2.0</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: X</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  Intercept  x0     x1</span><br><span class="line">          <span class="number">1</span>   <span class="number">1</span>   <span class="number">0.01</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">2</span>  -<span class="number">0.01</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">3</span>   <span class="number">0.25</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">4</span>  -<span class="number">4.10</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">5</span>   <span class="number">0.00</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;x0&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">    <span class="string">&#x27;x1&#x27;</span> (column <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这些Patsy的DesignMatrix实例是NumPy的ndarray，带有附加元数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: np.asarray(y)</span><br><span class="line">Out[<span class="number">35</span>]: </span><br><span class="line">array([[-<span class="number">1.5</span>],</span><br><span class="line">       [ <span class="number">0.</span> ],</span><br><span class="line">       [ <span class="number">3.6</span>],</span><br><span class="line">       [ <span class="number">1.3</span>],</span><br><span class="line">       [-<span class="number">2.</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: np.asarray(X)</span><br><span class="line">Out[<span class="number">36</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>  ,  <span class="number">1.</span>  ,  <span class="number">0.01</span>],</span><br><span class="line">       [ <span class="number">1.</span>  ,  <span class="number">2.</span>  , -<span class="number">0.01</span>],</span><br><span class="line">       [ <span class="number">1.</span>  ,  <span class="number">3.</span>  ,  <span class="number">0.25</span>],</span><br><span class="line">       [ <span class="number">1.</span>  ,  <span class="number">4.</span>  , -<span class="number">4.1</span> ],</span><br><span class="line">       [ <span class="number">1.</span>  ,  <span class="number">5.</span>  ,  <span class="number">0.</span>  ]])</span><br></pre></td></tr></table></figure>
<p>你可能想Intercept是哪里来的。这是线性模型（比如普通最小二乘回归）的惯例用法。添加 +0 到模型可以不显示intercept：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: patsy.dmatrices(<span class="string">&#x27;y ~ x0 + x1 + 0&#x27;</span>, data)[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">  x0     x1</span><br><span class="line">   <span class="number">1</span>   <span class="number">0.01</span></span><br><span class="line">   <span class="number">2</span>  -<span class="number">0.01</span></span><br><span class="line">   <span class="number">3</span>   <span class="number">0.25</span></span><br><span class="line">   <span class="number">4</span>  -<span class="number">4.10</span></span><br><span class="line">   <span class="number">5</span>   <span class="number">0.00</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;x0&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;x1&#x27;</span> (column <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>Patsy对象可以直接传递到算法（比如numpy.linalg.lstsq）中，它执行普通最小二乘回归：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: coef, resid, _, _ = np.linalg.lstsq(X, y)</span><br></pre></td></tr></table></figure>
<p>模型的元数据保留在design_info属性中，因此你可以重新附加列名到拟合系数，以获得一个Series，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: coef</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">array([[ <span class="number">0.3129</span>],</span><br><span class="line">       [-<span class="number">0.0791</span>],</span><br><span class="line">       [-<span class="number">0.2655</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: coef = pd.Series(coef.squeeze(), index=X.design_info.column_names)</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: coef</span><br><span class="line">Out[<span class="number">41</span>]: </span><br><span class="line">Intercept    <span class="number">0.312910</span></span><br><span class="line">x0          -<span class="number">0.079106</span></span><br><span class="line">x1          -<span class="number">0.265464</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="用patsy公式进行数据转换">13.2.1 用Patsy公式进行数据转换</h3>
<p>你可以将Python代码与patsy公式结合。在评估公式时，库将尝试查找在封闭作用域内使用的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">42</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;y ~ x0 + np.log(np.abs(x1) + 1)&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: X</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  Intercept  x0  np.log(np.<span class="built_in">abs</span>(x1) + <span class="number">1</span>)</span><br><span class="line">          <span class="number">1</span>   <span class="number">1</span>                 <span class="number">0.00995</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">2</span>                 <span class="number">0.00995</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">3</span>                 <span class="number">0.22314</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">4</span>                 <span class="number">1.62924</span></span><br><span class="line">          <span class="number">1</span>   <span class="number">5</span>                 <span class="number">0.00000</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;x0&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">    <span class="string">&#x27;np.log(np.abs(x1) + 1)&#x27;</span> (column <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>常见的变量转换包括标准化（平均值为0，方差为1）和中心化（减去平均值）。Patsy有内置的函数进行这样的工作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;y ~ standardize(x0) + center(x1)&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: X</span><br><span class="line">Out[<span class="number">45</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  Intercept  standardize(x0)  center(x1)</span><br><span class="line">          <span class="number">1</span>         -<span class="number">1.41421</span>        <span class="number">0.78</span></span><br><span class="line">          <span class="number">1</span>         -<span class="number">0.70711</span>        <span class="number">0.76</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0.00000</span>        <span class="number">1.02</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0.70711</span>       -<span class="number">3.33</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1.41421</span>        <span class="number">0.77</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;standardize(x0)&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">    <span class="string">&#x27;center(x1)&#x27;</span> (column <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>作为建模的一步，你可能拟合模型到一个数据集，然后用另一个数据集评估模型。另一个数据集可能是剩余的部分或是新数据。当执行中心化和标准化转变，用新数据进行预测要格外小心。因为你必须使用平均值或标准差转换新数据集，这也称作状态转换。</p>
<p>patsy.build_design_matrices函数可以使用原始样本数据集的保存信息，来转换新数据，：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: new_data = pd.DataFrame(&#123;</span><br><span class="line">   ....:     <span class="string">&#x27;x0&#x27;</span>: [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;x1&#x27;</span>: [<span class="number">3.1</span>, -<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">2.3</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;y&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: new_X = patsy.build_design_matrices([X.design_info], new_data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: new_X</span><br><span class="line">Out[<span class="number">48</span>]: </span><br><span class="line">[DesignMatrix <span class="keyword">with</span> shape (<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">   Intercept  standardize(x0)  center(x1)</span><br><span class="line">           <span class="number">1</span>          <span class="number">2.12132</span>        <span class="number">3.87</span></span><br><span class="line">           <span class="number">1</span>          <span class="number">2.82843</span>        <span class="number">0.27</span></span><br><span class="line">           <span class="number">1</span>          <span class="number">3.53553</span>        <span class="number">0.77</span></span><br><span class="line">           <span class="number">1</span>          <span class="number">4.24264</span>        <span class="number">3.07</span></span><br><span class="line">   Terms:</span><br><span class="line">     <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">     <span class="string">&#x27;standardize(x0)&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">     <span class="string">&#x27;center(x1)&#x27;</span> (column <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<p>因为Patsy中的加号不是加法的意义，当你按照名称将数据集的列相加时，你必须用特殊I函数将它们封装起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;y ~ I(x0 + x1)&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: X</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">  Intercept  I(x0 + x1)</span><br><span class="line">          <span class="number">1</span>        <span class="number">1.01</span></span><br><span class="line">          <span class="number">1</span>        <span class="number">1.99</span></span><br><span class="line">          <span class="number">1</span>        <span class="number">3.25</span></span><br><span class="line">          <span class="number">1</span>       -<span class="number">0.10</span></span><br><span class="line">          <span class="number">1</span>        <span class="number">5.00</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;I(x0 + x1)&#x27;</span> (column <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>Patsy的patsy.builtins模块还有一些其它的内置转换。请查看线上文档。</p>
<p>分类数据有一个特殊的转换类，下面进行讲解。</p>
<h3 id="分类数据和patsy">13.2.2 分类数据和Patsy</h3>
<p>非数值数据可以用多种方式转换为模型设计矩阵。完整的讲解超出了本书范围，最好和统计课一起学习。</p>
<p>当你在Patsy公式中使用非数值数据，它们会默认转换为虚变量。如果有截距，会去掉一个，避免共线性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: data = pd.DataFrame(&#123;</span><br><span class="line">   ....:     <span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;key2&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;v1&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">   ....:     <span class="string">&#x27;v2&#x27;</span>: [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">2.5</span>, -<span class="number">0.5</span>, <span class="number">4.0</span>, -<span class="number">1.2</span>, <span class="number">0.2</span>, -<span class="number">1.7</span>]</span><br><span class="line">   ....: &#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;v2 ~ key1&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: X</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">  Intercept  key1[T.b]</span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span> (column <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>如果你从模型中忽略截距，每个分类值的列都会包括在设计矩阵的模型中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;v2 ~ key1 + 0&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: X</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">  key1[a]  key1[b]</span><br><span class="line">        <span class="number">1</span>        <span class="number">0</span></span><br><span class="line">        <span class="number">1</span>        <span class="number">0</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">1</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">1</span></span><br><span class="line">        <span class="number">1</span>        <span class="number">0</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">1</span></span><br><span class="line">        <span class="number">1</span>        <span class="number">0</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">1</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span> (columns <span class="number">0</span>:<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>使用C函数，数值列可以截取为分类量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;v2 ~ C(key2)&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: X</span><br><span class="line">Out[<span class="number">57</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">  Intercept  C(key2)[T<span class="number">.1</span>]</span><br><span class="line">          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;C(key2)&#x27;</span> (column <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>当你在模型中使用多个分类名，事情就会变复杂，因为会包括key1:key2形式的相交部分，它可以用在方差（ANOVA）模型分析中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: data[<span class="string">&#x27;key2&#x27;</span>] = data[<span class="string">&#x27;key2&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="number">0</span>: <span class="string">&#x27;zero&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;one&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: data</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line">  key1  key2  v1   v2</span><br><span class="line"><span class="number">0</span>    a  zero   <span class="number">1</span> -<span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    a   one   <span class="number">2</span>  <span class="number">0.0</span></span><br><span class="line"><span class="number">2</span>    b  zero   <span class="number">3</span>  <span class="number">2.5</span></span><br><span class="line"><span class="number">3</span>    b   one   <span class="number">4</span> -<span class="number">0.5</span></span><br><span class="line"><span class="number">4</span>    a  zero   <span class="number">5</span>  <span class="number">4.0</span></span><br><span class="line"><span class="number">5</span>    b   one   <span class="number">6</span> -<span class="number">1.2</span></span><br><span class="line"><span class="number">6</span>    a  zero   <span class="number">7</span>  <span class="number">0.2</span></span><br><span class="line"><span class="number">7</span>    b  zero   <span class="number">8</span> -<span class="number">1.7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;v2 ~ key1 + key2&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: X</span><br><span class="line">Out[<span class="number">61</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">8</span>, <span class="number">3</span>)</span><br><span class="line">  Intercept  key1[T.b]  key2[T.zero]</span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">    <span class="string">&#x27;key2&#x27;</span> (column <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: y, X = patsy.dmatrices(<span class="string">&#x27;v2 ~ key1 + key2 + key1:key2&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: X</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line">DesignMatrix <span class="keyword">with</span> shape (<span class="number">8</span>, <span class="number">4</span>)</span><br><span class="line">  Intercept  key1[T.b]  key2[T.zero]</span><br><span class="line">key1[T.b]:key2[T.zero]</span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">0</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">1</span>                       <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">0</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">0</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">0</span>             <span class="number">1</span>                       <span class="number">0</span></span><br><span class="line">          <span class="number">1</span>          <span class="number">1</span>             <span class="number">1</span>                       <span class="number">1</span></span><br><span class="line">  Terms:</span><br><span class="line">    <span class="string">&#x27;Intercept&#x27;</span> (column <span class="number">0</span>)</span><br><span class="line">    <span class="string">&#x27;key1&#x27;</span> (column <span class="number">1</span>)</span><br><span class="line">    <span class="string">&#x27;key2&#x27;</span> (column <span class="number">2</span>)</span><br><span class="line">    <span class="string">&#x27;key1:key2&#x27;</span> (column <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>Patsy提供转换分类数据的其它方法，包括以特定顺序转换。请参阅线上文档。</p>
<h2 id="statsmodels介绍">13.3 statsmodels介绍</h2>
<p>statsmodels是Python进行拟合多种统计模型、进行统计试验和数据探索可视化的库。Statsmodels包含许多经典的统计方法，但没有贝叶斯方法和机器学习模型。</p>
<p>statsmodels包含的模型有：</p>
<ul>
<li>线性模型，广义线性模型和健壮线性模型</li>
<li>线性混合效应模型</li>
<li>方差（ANOVA）方法分析</li>
<li>时间序列过程和状态空间模型</li>
<li>广义矩估计</li>
</ul>
<p>下面，我会使用一些基本的statsmodels工具，探索Patsy公式和pandasDataFrame对象如何使用模型接口。</p>
<h3 id="估计线性模型">13.3.1 估计线性模型</h3>
<p>statsmodels有多种线性回归模型，包括从基本（比如普通最小二乘）到复杂（比如迭代加权最小二乘法）的。</p>
<p>statsmodels的线性模型有两种不同的接口：基于数组和基于公式。它们可以通过API模块引入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> statsmodels.formula.api <span class="keyword">as</span> smf</span><br></pre></td></tr></table></figure>
<p>为了展示它们的使用方法，我们从一些随机数据生成一个线性模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dnorm</span>(<span class="params">mean, variance, size=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(size, <span class="built_in">int</span>):</span><br><span class="line">        size = size,</span><br><span class="line">    <span class="keyword">return</span> mean + np.sqrt(variance) * np.random.randn(*size)</span><br><span class="line"></span><br><span class="line"><span class="comment">## For reproducibility</span></span><br><span class="line">np.random.seed(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">100</span></span><br><span class="line">X = np.c_[dnorm(<span class="number">0</span>, <span class="number">0.4</span>, size=N),</span><br><span class="line">          dnorm(<span class="number">0</span>, <span class="number">0.6</span>, size=N),</span><br><span class="line">          dnorm(<span class="number">0</span>, <span class="number">0.2</span>, size=N)]</span><br><span class="line">eps = dnorm(<span class="number">0</span>, <span class="number">0.1</span>, size=N)</span><br><span class="line">beta = [<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.5</span>]</span><br><span class="line"></span><br><span class="line">y = np.dot(X, beta) + eps</span><br></pre></td></tr></table></figure>
<p>这里，我使用了“真实”模型和可知参数beta。此时，dnorm可用来生成正态分布数据，带有特定均值和方差。现在有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: X[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">66</span>]: </span><br><span class="line">array([[-<span class="number">0.1295</span>, -<span class="number">1.2128</span>,  <span class="number">0.5042</span>],</span><br><span class="line">       [ <span class="number">0.3029</span>, -<span class="number">0.4357</span>, -<span class="number">0.2542</span>],</span><br><span class="line">       [-<span class="number">0.3285</span>, -<span class="number">0.0253</span>,  <span class="number">0.1384</span>],</span><br><span class="line">       [-<span class="number">0.3515</span>, -<span class="number">0.7196</span>, -<span class="number">0.2582</span>],</span><br><span class="line">       [ <span class="number">1.2433</span>, -<span class="number">0.3738</span>, -<span class="number">0.5226</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: y[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">67</span>]: array([ <span class="number">0.4279</span>, -<span class="number">0.6735</span>, -<span class="number">0.0909</span>, -<span class="number">0.4895</span>,-<span class="number">0.1289</span>])</span><br></pre></td></tr></table></figure>
<p>像之前Patsy看到的，线性模型通常要拟合一个截距。sm.add_constant函数可以添加一个截距的列到现存的矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: X_model = sm.add_constant(X)</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: X_model[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">array([[ <span class="number">1.</span>    , -<span class="number">0.1295</span>, -<span class="number">1.2128</span>,  <span class="number">0.5042</span>],</span><br><span class="line">       [ <span class="number">1.</span>    ,  <span class="number">0.3029</span>, -<span class="number">0.4357</span>, -<span class="number">0.2542</span>],</span><br><span class="line">       [ <span class="number">1.</span>    , -<span class="number">0.3285</span>, -<span class="number">0.0253</span>,  <span class="number">0.1384</span>],</span><br><span class="line">       [ <span class="number">1.</span>    , -<span class="number">0.3515</span>, -<span class="number">0.7196</span>, -<span class="number">0.2582</span>],</span><br><span class="line">       [ <span class="number">1.</span>    ,  <span class="number">1.2433</span>, -<span class="number">0.3738</span>, -<span class="number">0.5226</span>]])</span><br></pre></td></tr></table></figure>
<p>sm.OLS类可以拟合一个普通最小二乘回归：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">70</span>]: model = sm.OLS(y, X)</span><br></pre></td></tr></table></figure>
<p>这个模型的fit方法返回了一个回归结果对象，它包含估计的模型参数和其它内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: results = model.fit()</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: results.params</span><br><span class="line">Out[<span class="number">72</span>]: array([ <span class="number">0.1783</span>,  <span class="number">0.223</span> ,  <span class="number">0.501</span> ])</span><br></pre></td></tr></table></figure>
<p>对结果使用summary方法可以打印模型的详细诊断结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: <span class="built_in">print</span>(results.summary())</span><br><span class="line">OLS Regression Results                            </span><br><span class="line">==============================================================================</span><br><span class="line">Dep. Variable:                      y   R-squared:                       <span class="number">0.430</span></span><br><span class="line">Model:                            OLS   Adj. R-squared:                  <span class="number">0.413</span></span><br><span class="line">Method:                 Least Squares   F-statistic:                     <span class="number">24.42</span></span><br><span class="line">Date:                Mon, <span class="number">25</span> Sep <span class="number">2017</span>   Prob (F-statistic):           <span class="number">7.44e-12</span></span><br><span class="line">Time:                        <span class="number">14</span>:06:<span class="number">15</span>   Log-Likelihood:                -<span class="number">34.305</span></span><br><span class="line">No. Observations:                 <span class="number">100</span>   AIC:                             <span class="number">74.61</span></span><br><span class="line">Df Residuals:                      <span class="number">97</span>   BIC:                             <span class="number">82.42</span></span><br><span class="line">Df Model:                           <span class="number">3</span>                                         </span><br><span class="line">Covariance <span class="type">Type</span>:            nonrobust                                         </span><br><span class="line">==============================================================================</span><br><span class="line">                 coef    std err          t      P&gt;|t|      [<span class="number">0.025</span>      <span class="number">0.975</span>]</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">x1             <span class="number">0.1783</span>      <span class="number">0.053</span>      <span class="number">3.364</span>      <span class="number">0.001</span>       <span class="number">0.073</span>       <span class="number">0.283</span></span><br><span class="line">x2             <span class="number">0.2230</span>      <span class="number">0.046</span>      <span class="number">4.818</span>      <span class="number">0.000</span>       <span class="number">0.131</span>       <span class="number">0.315</span></span><br><span class="line">x3             <span class="number">0.5010</span>      <span class="number">0.080</span>      <span class="number">6.237</span>      <span class="number">0.000</span>       <span class="number">0.342</span>       <span class="number">0.660</span></span><br><span class="line">==============================================================================</span><br><span class="line">Omnibus:                        <span class="number">4.662</span>   Durbin-Watson:                   <span class="number">2.201</span></span><br><span class="line">Prob(Omnibus):                  <span class="number">0.097</span>   Jarque-Bera (JB):                <span class="number">4.098</span></span><br><span class="line">Skew:                           <span class="number">0.481</span>   Prob(JB):                        <span class="number">0.129</span></span><br><span class="line">Kurtosis:                       <span class="number">3.243</span>   Cond. No.</span><br><span class="line"><span class="number">1.74</span></span><br><span class="line">==============================================================================</span><br><span class="line">Warnings:</span><br><span class="line">[<span class="number">1</span>] Standard Errors assume that the covariance matrix of the errors <span class="keyword">is</span> correctly </span><br><span class="line">specified.</span><br></pre></td></tr></table></figure>
<p>这里的参数名为通用名x1, x2等等。假设所有的模型参数都在一个DataFrame中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: data = pd.DataFrame(X, columns=[<span class="string">&#x27;col0&#x27;</span>, <span class="string">&#x27;col1&#x27;</span>, <span class="string">&#x27;col2&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: data[<span class="string">&#x27;y&#x27;</span>] = y</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: data[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">       col0      col1      col2         y</span><br><span class="line"><span class="number">0</span> -<span class="number">0.129468</span> -<span class="number">1.212753</span>  <span class="number">0.504225</span>  <span class="number">0.427863</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.302910</span> -<span class="number">0.435742</span> -<span class="number">0.254180</span> -<span class="number">0.673480</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.328522</span> -<span class="number">0.025302</span>  <span class="number">0.138351</span> -<span class="number">0.090878</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.351475</span> -<span class="number">0.719605</span> -<span class="number">0.258215</span> -<span class="number">0.489494</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.243269</span> -<span class="number">0.373799</span> -<span class="number">0.522629</span> -<span class="number">0.128941</span></span><br></pre></td></tr></table></figure>
<p>现在，我们使用statsmodels的公式API和Patsy的公式字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: results = smf.ols(<span class="string">&#x27;y ~ col0 + col1 + col2&#x27;</span>, data=data).fit()</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: results.params</span><br><span class="line">Out[<span class="number">78</span>]: </span><br><span class="line">Intercept    <span class="number">0.033559</span></span><br><span class="line">col0         <span class="number">0.176149</span></span><br><span class="line">col1         <span class="number">0.224826</span></span><br><span class="line">col2         <span class="number">0.514808</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: results.tvalues</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">Intercept    <span class="number">0.952188</span></span><br><span class="line">col0         <span class="number">3.319754</span></span><br><span class="line">col1         <span class="number">4.850730</span></span><br><span class="line">col2         <span class="number">6.303971</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>观察下statsmodels是如何返回Series结果的，附带有DataFrame的列名。当使用公式和pandas对象时，我们不需要使用add_constant。</p>
<p>给出一个样本外数据，你可以根据估计的模型参数计算预测值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">80</span>]: results.predict(data[:<span class="number">5</span>])</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line"><span class="number">0</span>   -<span class="number">0.002327</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">0.141904</span></span><br><span class="line"><span class="number">2</span>    <span class="number">0.041226</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.323070</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">0.100535</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>statsmodels的线性模型结果还有其它的分析、诊断和可视化工具。除了普通最小二乘模型，还有其它的线性模型。</p>
<h3 id="估计时间序列过程">13.3.2 估计时间序列过程</h3>
<p>statsmodels的另一模型类是进行时间序列分析，包括自回归过程、卡尔曼滤波和其它态空间模型，和多元自回归模型。</p>
<p>用自回归结构和噪声来模拟一些时间序列数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init_x = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">values = [init_x, init_x]</span><br><span class="line">N = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">b0 = <span class="number">0.8</span></span><br><span class="line">b1 = -<span class="number">0.4</span></span><br><span class="line">noise = dnorm(<span class="number">0</span>, <span class="number">0.1</span>, N)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    new_x = values[-<span class="number">1</span>] * b0 + values[-<span class="number">2</span>] * b1 + noise[i]</span><br><span class="line">    values.append(new_x)</span><br></pre></td></tr></table></figure>
<p>这个数据有AR(2)结构（两个延迟），参数是0.8和-0.4。拟合AR模型时，你可能不知道滞后项的个数，因此可以用较多的滞后量来拟合这个模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">82</span>]: MAXLAGS = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: model = sm.tsa.AR(values)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: results = model.fit(MAXLAGS)</span><br></pre></td></tr></table></figure>
<p>结果中的估计参数首先是截距，其次是前两个参数的估计值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: results.params</span><br><span class="line">Out[<span class="number">85</span>]: array([-<span class="number">0.0062</span>,  <span class="number">0.7845</span>, -<span class="number">0.4085</span>, -<span class="number">0.0136</span>,  <span class="number">0.015</span> ,  <span class="number">0.0143</span>])</span><br></pre></td></tr></table></figure>
<p>更多的细节以及如何解释结果超出了本书的范围，可以通过statsmodels文档学习更多。</p>
<h2 id="scikit-learn介绍">13.4 scikit-learn介绍</h2>
<p>scikit-learn是一个广泛使用、用途多样的Python机器学习库。它包含多种标准监督和非监督机器学习方法和模型选择和评估、数据转换、数据加载和模型持久化工具。这些模型可以用于分类、聚合、预测和其它任务。</p>
<p>机器学习方面的学习和应用scikit-learn和TensorFlow解决实际问题的线上和纸质资料很多。本节中，我会简要介绍scikit-learn API的风格。</p>
<p>写作此书的时候，scikit-learn并没有和pandas深度结合，但是有些第三方包在开发中。尽管如此，pandas非常适合在模型拟合前处理数据集。</p>
<p>举个例子，我用一个Kaggle竞赛的经典数据集，关于泰坦尼克号乘客的生还率。我们用pandas加载测试和训练数据集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">86</span>]: train = pd.read_csv(<span class="string">&#x27;datasets/titanic/train.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: test = pd.read_csv(<span class="string">&#x27;datasets/titanic/test.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: train[:<span class="number">4</span>]</span><br><span class="line">Out[<span class="number">88</span>]: </span><br><span class="line">   PassengerId  Survived  Pclass  \</span><br><span class="line"><span class="number">0</span>            <span class="number">1</span>         <span class="number">0</span>       <span class="number">3</span>   </span><br><span class="line"><span class="number">1</span>            <span class="number">2</span>         <span class="number">1</span>       <span class="number">1</span>   </span><br><span class="line"><span class="number">2</span>            <span class="number">3</span>         <span class="number">1</span>       <span class="number">3</span>   </span><br><span class="line"><span class="number">3</span>            <span class="number">4</span>         <span class="number">1</span>       <span class="number">1</span>   </span><br><span class="line">                                                Name     Sex   Age  SibSp  \</span><br><span class="line"><span class="number">0</span>                            Braund, Mr. Owen Harris    male  <span class="number">22.0</span>      <span class="number">1</span>   </span><br><span class="line"><span class="number">1</span>  Cumings, Mrs. John Bradley (Florence Briggs Th...  female  <span class="number">38.0</span>      <span class="number">1</span>   </span><br><span class="line"><span class="number">2</span>                             Heikkinen, Miss. Laina  female  <span class="number">26.0</span>      <span class="number">0</span>   </span><br><span class="line"><span class="number">3</span>       Futrelle, Mrs. Jacques Heath (Lily May Peel)  female  <span class="number">35.0</span>      <span class="number">1</span>   </span><br><span class="line">   Parch            Ticket     Fare Cabin Embarked  </span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>         A/<span class="number">5</span> <span class="number">21171</span>   <span class="number">7.2500</span>   NaN        S  </span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>          PC <span class="number">17599</span>  <span class="number">71.2833</span>   C85        C  </span><br><span class="line"><span class="number">2</span>      <span class="number">0</span>  STON/O2. <span class="number">3101282</span>   <span class="number">7.9250</span>   NaN        S  </span><br><span class="line"><span class="number">3</span>      <span class="number">0</span>            <span class="number">113803</span>  <span class="number">53.1000</span>  C123        S</span><br></pre></td></tr></table></figure>
<p>statsmodels和scikit-learn通常不能接收缺失数据，因此我们要查看列是否包含缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: train.isnull().<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">89</span>]: </span><br><span class="line">PassengerId      <span class="number">0</span></span><br><span class="line">Survived         <span class="number">0</span></span><br><span class="line">Pclass           <span class="number">0</span></span><br><span class="line">Name             <span class="number">0</span></span><br><span class="line">Sex              <span class="number">0</span></span><br><span class="line">Age            <span class="number">177</span></span><br><span class="line">SibSp            <span class="number">0</span></span><br><span class="line">Parch            <span class="number">0</span></span><br><span class="line">Ticket           <span class="number">0</span></span><br><span class="line">Fare             <span class="number">0</span></span><br><span class="line">Cabin          <span class="number">687</span></span><br><span class="line">Embarked         <span class="number">2</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: test.isnull().<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">PassengerId      <span class="number">0</span></span><br><span class="line">Pclass           <span class="number">0</span></span><br><span class="line">Name             <span class="number">0</span></span><br><span class="line">Sex              <span class="number">0</span></span><br><span class="line">Age             <span class="number">86</span></span><br><span class="line">SibSp            <span class="number">0</span></span><br><span class="line">Parch            <span class="number">0</span></span><br><span class="line">Ticket           <span class="number">0</span></span><br><span class="line">Fare             <span class="number">1</span></span><br><span class="line">Cabin          <span class="number">327</span></span><br><span class="line">Embarked         <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>在统计和机器学习的例子中，根据数据中的特征，一个典型的任务是预测乘客能否生还。模型现在训练数据集中拟合，然后用样本外测试数据集评估。</p>
<p>我想用年龄作为预测值，但是它包含缺失值。缺失数据补全的方法有多种，我用的是一种简单方法，用训练数据集的中位数补全两个表的空值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: impute_value = train[<span class="string">&#x27;Age&#x27;</span>].median()</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: train[<span class="string">&#x27;Age&#x27;</span>] = train[<span class="string">&#x27;Age&#x27;</span>].fillna(impute_value)</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: test[<span class="string">&#x27;Age&#x27;</span>] = test[<span class="string">&#x27;Age&#x27;</span>].fillna(impute_value)</span><br></pre></td></tr></table></figure>
<p>现在我们需要指定模型。我增加了一个列IsFemale，作为“Sex”列的编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: train[<span class="string">&#x27;IsFemale&#x27;</span>] = (train[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;female&#x27;</span>).astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: test[<span class="string">&#x27;IsFemale&#x27;</span>] = (test[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;female&#x27;</span>).astype(<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>
<p>然后，我们确定一些模型变量，并创建NumPy数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">96</span>]: predictors = [<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;IsFemale&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: X_train = train[predictors].values</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: X_test = test[predictors].values</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: y_train = train[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: X_train[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">array([[  <span class="number">3.</span>,   <span class="number">0.</span>,  <span class="number">22.</span>],</span><br><span class="line">       [  <span class="number">1.</span>,   <span class="number">1.</span>,  <span class="number">38.</span>],</span><br><span class="line">       [  <span class="number">3.</span>,   <span class="number">1.</span>,  <span class="number">26.</span>],</span><br><span class="line">       [  <span class="number">1.</span>,   <span class="number">1.</span>,  <span class="number">35.</span>],</span><br><span class="line">       [  <span class="number">3.</span>,   <span class="number">0.</span>,  <span class="number">35.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: y_train[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">101</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>我不能保证这是一个好模型，但它的特征都符合。我们用scikit-learn的LogisticRegression模型，创建一个模型实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: <span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: model = LogisticRegression()</span><br></pre></td></tr></table></figure>
<p>与statsmodels类似，我们可以用模型的fit方法，将它拟合到训练数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">104</span>]: model.fit(X_train, y_train)</span><br><span class="line">Out[<span class="number">104</span>]: </span><br><span class="line">LogisticRegression(C=<span class="number">1.0</span>, class_weight=<span class="literal">None</span>, dual=<span class="literal">False</span>, fit_intercept=<span class="literal">True</span>,</span><br><span class="line">          intercept_scaling=<span class="number">1</span>, max_iter=<span class="number">100</span>, multi_class=<span class="string">&#x27;ovr&#x27;</span>, n_jobs=<span class="number">1</span>,</span><br><span class="line">          penalty=<span class="string">&#x27;l2&#x27;</span>, random_state=<span class="literal">None</span>, solver=<span class="string">&#x27;liblinear&#x27;</span>, tol=<span class="number">0.0001</span>,</span><br><span class="line">          verbose=<span class="number">0</span>, warm_start=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>现在，我们可以用model.predict，对测试数据进行预测：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: y_predict = model.predict(X_test)</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: y_predict[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">106</span>]: array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>如果你有测试数据集的真是值，你可以计算准确率或其它错误度量值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(y_true == y_predict).mean()</span><br></pre></td></tr></table></figure>
<p>在实际中，模型训练经常有许多额外的复杂因素。许多模型有可以调节的参数，有些方法（比如交叉验证）可以用来进行参数调节，避免对训练数据过拟合。这通常可以提高预测性或对新数据的健壮性。</p>
<p>交叉验证通过分割训练数据来模拟样本外预测。基于模型的精度得分（比如均方差），可以对模型参数进行网格搜索。有些模型，如logistic回归，有内置的交叉验证的估计类。例如，logisticregressioncv类可以用一个参数指定网格搜索对模型的正则化参数C的粒度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: <span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegressionCV</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: model_cv = LogisticRegressionCV(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: model_cv.fit(X_train, y_train)</span><br><span class="line">Out[<span class="number">109</span>]: </span><br><span class="line">LogisticRegressionCV(Cs=<span class="number">10</span>, class_weight=<span class="literal">None</span>, cv=<span class="literal">None</span>, dual=<span class="literal">False</span>,</span><br><span class="line">           fit_intercept=<span class="literal">True</span>, intercept_scaling=<span class="number">1.0</span>, max_iter=<span class="number">100</span>,</span><br><span class="line">           multi_class=<span class="string">&#x27;ovr&#x27;</span>, n_jobs=<span class="number">1</span>, penalty=<span class="string">&#x27;l2&#x27;</span>, random_state=<span class="literal">None</span>,</span><br><span class="line">           refit=<span class="literal">True</span>, scoring=<span class="literal">None</span>, solver=<span class="string">&#x27;lbfgs&#x27;</span>, tol=<span class="number">0.0001</span>, verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>要手动进行交叉验证，你可以使用cross_val_score帮助函数，它可以处理数据分割。例如，要交叉验证我们的带有四个不重叠训练数据的模型，可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: <span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: model = LogisticRegression(C=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: scores = cross_val_score(model, X_train, y_train, cv=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: scores</span><br><span class="line">Out[<span class="number">113</span>]: array([ <span class="number">0.7723</span>,  <span class="number">0.8027</span>,  <span class="number">0.7703</span>,  <span class="number">0.7883</span>])</span><br></pre></td></tr></table></figure>
<p>默认的评分指标取决于模型本身，但是可以明确指定一个评分。交叉验证过的模型需要更长时间来训练，但会有更高的模型性能。</p>
<h2 id="继续学习">13.5 继续学习</h2>
<p>我只是介绍了一些Python建模库的表面内容，现在有越来越多的框架用于各种统计和机器学习，它们都是用Python或Python用户界面实现的。</p>
<p>这本书的重点是数据规整，有其它的书是关注建模和数据科学工具的。其中优秀的有：</p>
<ul>
<li>Andreas Mueller and Sarah Guido (O’Reilly)的 《Introduction to Machine Learning with Python》</li>
<li>Jake VanderPlas (O’Reilly)的 《Python Data Science Handbook》</li>
<li>Joel Grus (O’Reilly) 的 《Data Science from Scratch: First Principles》</li>
<li>Sebastian Raschka (Packt Publishing) 的《Python Machine Learning》</li>
<li>Aurélien Géron (O’Reilly) 的《Hands-On Machine Learning with Scikit-Learn and TensorFlow》</li>
</ul>
<p>虽然书是学习的好资源，但是随着底层开源软件的发展，书的内容会过时。最好是不断熟悉各种统计和机器学习框架的文档，学习最新的功能和API。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析_第14章_数据分析案例</title>
    <url>/2018/08/02/python_for_data_analysis/pfda_chap14/</url>
    <content><![CDATA[<h1 id="第14章-数据分析案例">第14章 数据分析案例</h1>
<p>本书正文的最后一章，我们来看一些真实世界的数据集。对于每个数据集，我们会用之前介绍的方法，从原始数据中提取有意义的内容。展示的方法适用于其它数据集，也包括你的。本章包含了一些各种各样的案例数据集，可以用来练习。</p>
<p>案例数据集可以在Github仓库找到，见第一章。</p>
<span id="more"></span>
<h2 id="来自bitly的usa.gov数据">14.1 来自Bitly的USA.gov数据</h2>
<p>2011年，URL缩短服务Bitly跟美国政府网站USA.gov合作，提供了一份从生成.gov或.mil短链接的用户那里收集来的匿名数据。在2011年，除实时数据之外，还可以下载文本文件形式的每小时快照。写作此书时（2017年），这项服务已经关闭，但我们保存一份数据用于本书的案例。</p>
<p>以每小时快照为例，文件中各行的格式为JSON（即JavaScript Object Notation，这是一种常用的Web数据格式）。例如，如果我们只读取某个文件中的第一行，那么所看到的结果应该是下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: path = <span class="string">&#x27;datasets/bitly_usagov/example.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="built_in">open</span>(path).readline()</span><br><span class="line">Out[<span class="number">6</span>]: <span class="string">&#x27;&#123; &quot;a&quot;: &quot;Mozilla\\/5.0 (Windows NT 6.1; WOW64) AppleWebKit\\/535.11</span></span><br><span class="line"><span class="string">(KHTML, like Gecko) Chrome\\/17.0.963.78 Safari\\/535.11&quot;, &quot;c&quot;: &quot;US&quot;, &quot;nk&quot;: 1,</span></span><br><span class="line"><span class="string">&quot;tz&quot;: &quot;America\\/New_York&quot;, &quot;gr&quot;: &quot;MA&quot;, &quot;g&quot;: &quot;A6qOVH&quot;, &quot;h&quot;: &quot;wfLQtf&quot;, &quot;l&quot;:</span></span><br><span class="line"><span class="string">&quot;orofrog&quot;, &quot;al&quot;: &quot;en-US,en;q=0.8&quot;, &quot;hh&quot;: &quot;1.usa.gov&quot;, &quot;r&quot;:</span></span><br><span class="line"><span class="string">&quot;http:\\/\\/www.facebook.com\\/l\\/7AQEFzjSi\\/1.usa.gov\\/wfLQtf&quot;, &quot;u&quot;:</span></span><br><span class="line"><span class="string">&quot;http:\\/\\/www.ncbi.nlm.nih.gov\\/pubmed\\/22415991&quot;, &quot;t&quot;: 1331923247, &quot;hc&quot;:</span></span><br><span class="line"><span class="string">1331822918, &quot;cy&quot;: &quot;Danvers&quot;, &quot;ll&quot;: [ 42.576698, -70.954903 ] &#125;\n&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Python有内置或第三方模块可以将JSON字符串转换成Python字典对象。这里，我将使用json模块及其loads函数逐行加载已经下载好的数据文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">path = <span class="string">&#x27;datasets/bitly_usagov/example.txt&#x27;</span></span><br><span class="line">records = [json.loads(line) <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(path)]</span><br></pre></td></tr></table></figure>
<p>现在，records对象就成为一组Python字典了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: records[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">18</span>]:</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko)</span></span><br><span class="line"><span class="string">Chrome/17.0.963.78 Safari/535.11&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;al&#x27;</span>: <span class="string">&#x27;en-US,en;q=0.8&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;US&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;cy&#x27;</span>: <span class="string">&#x27;Danvers&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;g&#x27;</span>: <span class="string">&#x27;A6qOVH&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;gr&#x27;</span>: <span class="string">&#x27;MA&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;h&#x27;</span>: <span class="string">&#x27;wfLQtf&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;hc&#x27;</span>: <span class="number">1331822918</span>,</span><br><span class="line"> <span class="string">&#x27;hh&#x27;</span>: <span class="string">&#x27;1.usa.gov&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;l&#x27;</span>: <span class="string">&#x27;orofrog&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ll&#x27;</span>: [<span class="number">42.576698</span>, -<span class="number">70.954903</span>],</span><br><span class="line"> <span class="string">&#x27;nk&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">&#x27;r&#x27;</span>: <span class="string">&#x27;http://www.facebook.com/l/7AQEFzjSi/1.usa.gov/wfLQtf&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;t&#x27;</span>: <span class="number">1331923247</span>,</span><br><span class="line"> <span class="string">&#x27;tz&#x27;</span>: <span class="string">&#x27;America/New_York&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;u&#x27;</span>: <span class="string">&#x27;http://www.ncbi.nlm.nih.gov/pubmed/22415991&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用纯python代码对时区进行计数">14.1.1 用纯Python代码对时区进行计数</h3>
<p>假设我们想要知道该数据集中最常出现的是哪个时区（即tz字段），得到答案的办法有很多。首先，我们用列表推导式取出一组时区：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: time_zones = [rec[<span class="string">&#x27;tz&#x27;</span>] <span class="keyword">for</span> rec <span class="keyword">in</span> records]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">KeyError                                  Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">12</span>-db4fbd348da9&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; <span class="number">1</span> time_zones = [rec[<span class="string">&#x27;tz&#x27;</span>] <span class="keyword">for</span> rec <span class="keyword">in</span> records]</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">12</span>-db4fbd348da9&gt; <span class="keyword">in</span> &lt;listcomp&gt;(<span class="number">.0</span>)</span><br><span class="line">----&gt; <span class="number">1</span> time_zones = [rec[<span class="string">&#x27;tz&#x27;</span>] <span class="keyword">for</span> rec <span class="keyword">in</span> records]</span><br><span class="line">KeyError: <span class="string">&#x27;tz&#x27;</span></span><br></pre></td></tr></table></figure>
<p>晕！原来并不是所有记录都有时区字段。这个好办，只需在列表推导式末尾加上一个<code>if 'tz'in rec</code>判断即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: time_zones = [rec[<span class="string">&#x27;tz&#x27;</span>] <span class="keyword">for</span> rec <span class="keyword">in</span> records <span class="keyword">if</span> <span class="string">&#x27;tz&#x27;</span> <span class="keyword">in</span> rec]</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: time_zones[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">[<span class="string">&#x27;America/New_York&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;America/Denver&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;America/New_York&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;America/Sao_Paulo&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;America/New_York&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;America/New_York&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Europe/Warsaw&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>只看前10个时区，我们发现有些是未知的（即空的）。虽然可以将它们过滤掉，但现在暂时先留着。接下来，为了对时区进行计数，这里介绍两个办法：一个较难（只使用标准Python库），另一个较简单（使用pandas）。计数的办法之一是在遍历时区的过程中将计数值保存在字典中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_counts</span>(<span class="params">sequence</span>):</span><br><span class="line">    counts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> sequence:</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> counts:</span><br><span class="line">            counts[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            counts[x] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counts</span><br></pre></td></tr></table></figure>
<p>如果使用Python标准库的更高级工具，那么你可能会将代码写得更简洁一些：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_counts2</span>(<span class="params">sequence</span>):</span><br><span class="line">    counts = defaultdict(<span class="built_in">int</span>) <span class="comment"># values will initialize to 0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> sequence:</span><br><span class="line">        counts[x] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counts</span><br></pre></td></tr></table></figure>
<p>我将逻辑写到函数中是为了获得更高的复用性。要用它对时区进行处理，只需将<code>time_zones</code>传入即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: counts = get_counts(time_zones)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: counts[<span class="string">&#x27;America/New_York&#x27;</span>]</span><br><span class="line">Out[<span class="number">18</span>]: <span class="number">1251</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: <span class="built_in">len</span>(time_zones)</span><br><span class="line">Out[<span class="number">19</span>]: <span class="number">3440</span></span><br></pre></td></tr></table></figure>
<p>如果想要得到前10位的时区及其计数值，我们需要用到一些有关字典的处理技巧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">top_counts</span>(<span class="params">count_dict, n=<span class="number">10</span></span>):</span><br><span class="line">    value_key_pairs = [(count, tz) <span class="keyword">for</span> tz, count <span class="keyword">in</span> count_dict.items()]</span><br><span class="line">    value_key_pairs.sort()</span><br><span class="line">    <span class="keyword">return</span> value_key_pairs[-n:]</span><br></pre></td></tr></table></figure>
<p>然后有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: top_counts(counts)</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">[(<span class="number">33</span>, <span class="string">&#x27;America/Sao_Paulo&#x27;</span>),</span><br><span class="line"> (<span class="number">35</span>, <span class="string">&#x27;Europe/Madrid&#x27;</span>),</span><br><span class="line">(<span class="number">36</span>, <span class="string">&#x27;Pacific/Honolulu&#x27;</span>),</span><br><span class="line"> (<span class="number">37</span>, <span class="string">&#x27;Asia/Tokyo&#x27;</span>),</span><br><span class="line"> (<span class="number">74</span>, <span class="string">&#x27;Europe/London&#x27;</span>),</span><br><span class="line"> (<span class="number">191</span>, <span class="string">&#x27;America/Denver&#x27;</span>),</span><br><span class="line"> (<span class="number">382</span>, <span class="string">&#x27;America/Los_Angeles&#x27;</span>),</span><br><span class="line"> (<span class="number">400</span>, <span class="string">&#x27;America/Chicago&#x27;</span>),</span><br><span class="line"> (<span class="number">521</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line"> (<span class="number">1251</span>, <span class="string">&#x27;America/New_York&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>如果搜索Python的标准库，能找到collections.Counter类，它可以使这项工作更简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: counts = Counter(time_zones)</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: counts.most_common(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">[(<span class="string">&#x27;America/New_York&#x27;</span>, <span class="number">1251</span>),</span><br><span class="line"> (<span class="string">&#x27;&#x27;</span>, <span class="number">521</span>),</span><br><span class="line"> (<span class="string">&#x27;America/Chicago&#x27;</span>, <span class="number">400</span>),</span><br><span class="line"> (<span class="string">&#x27;America/Los_Angeles&#x27;</span>, <span class="number">382</span>),</span><br><span class="line"> (<span class="string">&#x27;America/Denver&#x27;</span>, <span class="number">191</span>),</span><br><span class="line"> (<span class="string">&#x27;Europe/London&#x27;</span>, <span class="number">74</span>),</span><br><span class="line"> (<span class="string">&#x27;Asia/Tokyo&#x27;</span>, <span class="number">37</span>),</span><br><span class="line"> (<span class="string">&#x27;Pacific/Honolulu&#x27;</span>, <span class="number">36</span>),</span><br><span class="line"> (<span class="string">&#x27;Europe/Madrid&#x27;</span>, <span class="number">35</span>),</span><br><span class="line"> (<span class="string">&#x27;America/Sao_Paulo&#x27;</span>, <span class="number">33</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="用pandas对时区进行计数">14.1.2 用pandas对时区进行计数</h3>
<p>从原始记录的集合创建DateFrame，与将记录列表传递到pandas.DataFrame一样简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: frame = pd.DataFrame(records)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: frame.info()</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;</span><br><span class="line">RangeIndex: <span class="number">3560</span> entries, <span class="number">0</span> to <span class="number">3559</span></span><br><span class="line">Data columns (total <span class="number">18</span> columns):</span><br><span class="line">_heartbeat_    <span class="number">120</span> non-null float64</span><br><span class="line">a              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">al             <span class="number">3094</span> non-null <span class="built_in">object</span></span><br><span class="line">c              <span class="number">2919</span> non-null <span class="built_in">object</span></span><br><span class="line">cy             <span class="number">2919</span> non-null <span class="built_in">object</span></span><br><span class="line">g              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">gr             <span class="number">2919</span> non-null <span class="built_in">object</span></span><br><span class="line">h              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">hc             <span class="number">3440</span> non-null float64</span><br><span class="line">hh             <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">kw             <span class="number">93</span> non-null <span class="built_in">object</span></span><br><span class="line">l              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">ll             <span class="number">2919</span> non-null <span class="built_in">object</span></span><br><span class="line">nk             <span class="number">3440</span> non-null float64</span><br><span class="line">r              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">t              <span class="number">3440</span> non-null float64</span><br><span class="line">tz             <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">u              <span class="number">3440</span> non-null <span class="built_in">object</span></span><br><span class="line">dtypes: float64(<span class="number">4</span>), <span class="built_in">object</span>(<span class="number">14</span>)</span><br><span class="line">memory usage: <span class="number">500.7</span>+ KB</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: frame[<span class="string">&#x27;tz&#x27;</span>][:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line"><span class="number">0</span>     America/New_York</span><br><span class="line"><span class="number">1</span>       America/Denver</span><br><span class="line"><span class="number">2</span>     America/New_York</span><br><span class="line"><span class="number">3</span>    America/Sao_Paulo</span><br><span class="line"><span class="number">4</span>     America/New_York</span><br><span class="line"><span class="number">5</span>     America/New_York</span><br><span class="line"><span class="number">6</span>        Europe/Warsaw</span><br><span class="line"><span class="number">7</span>                     </span><br><span class="line"><span class="number">8</span>                     </span><br><span class="line"><span class="number">9</span>                     </span><br><span class="line">Name: tz, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>这里frame的输出形式是摘要视图（summary view），主要用于较大的<code>DataFrame</code>对象。我们然后可以对<code>Series</code>使用<code>value_counts</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: tz_counts = frame[<span class="string">&#x27;tz&#x27;</span>].value_counts()</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: tz_counts[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">America/New_York       <span class="number">1251</span></span><br><span class="line">                        <span class="number">521</span></span><br><span class="line">America/Chicago         <span class="number">400</span></span><br><span class="line">America/Los_Angeles     <span class="number">382</span></span><br><span class="line">America/Denver          <span class="number">191</span></span><br><span class="line">Europe/London            <span class="number">74</span></span><br><span class="line">Asia/Tokyo               <span class="number">37</span></span><br><span class="line">Pacific/Honolulu         <span class="number">36</span></span><br><span class="line">Europe/Madrid            <span class="number">35</span></span><br><span class="line">America/Sao_Paulo        <span class="number">33</span></span><br><span class="line">Name: tz, dtype: int64</span><br></pre></td></tr></table></figure>
<p>我们可以用<code>matplotlib</code>可视化这个数据。为此，我们先给记录中未知或缺失的时区填上一个替代值。<code>fillna</code>函数可以替换缺失值（NA），而未知值（空字符串）则可以通过布尔型数组索引加以替换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: clean_tz = frame[<span class="string">&#x27;tz&#x27;</span>].fillna(<span class="string">&#x27;Missing&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: clean_tz[clean_tz == <span class="string">&#x27;&#x27;</span>] = <span class="string">&#x27;Unknown&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: tz_counts = clean_tz.value_counts()</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: tz_counts[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">America/New_York       <span class="number">1251</span></span><br><span class="line">Unknown                 <span class="number">521</span></span><br><span class="line">America/Chicago         <span class="number">400</span></span><br><span class="line">America/Los_Angeles     <span class="number">382</span></span><br><span class="line">America/Denver          <span class="number">191</span></span><br><span class="line">Missing                 <span class="number">120</span></span><br><span class="line">Europe/London            <span class="number">74</span></span><br><span class="line">Asia/Tokyo               <span class="number">37</span></span><br><span class="line">Pacific/Honolulu         <span class="number">36</span></span><br><span class="line">Europe/Madrid            <span class="number">35</span></span><br><span class="line">Name: tz, dtype: int64</span><br></pre></td></tr></table></figure>
<p>此时，我们可以用<code>seaborn</code>包创建水平柱状图（结果见图14-1）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">36</span>]: <span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: subset = tz_counts[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: sns.barplot(y=subset.index, x=subset.values)</span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line">&#123;% asset_img <span class="number">7178691</span>-aa267c1d399a78f0.png 图<span class="number">14</span>-<span class="number">1</span> usa.gov示例数据中最常出现的时区 %&#125;</span><br><span class="line"></span><br><span class="line">a字段含有执行URL短缩操作的浏览器、设备、应用程序的相关信息：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">In [<span class="number">39</span>]: frame[<span class="string">&#x27;a&#x27;</span>][<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">39</span>]: <span class="string">&#x27;GoogleMaps/RochesterNY&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: frame[<span class="string">&#x27;a&#x27;</span>][<span class="number">50</span>]</span><br><span class="line">Out[<span class="number">40</span>]: <span class="string">&#x27;Mozilla/5.0 (Windows NT 5.1; rv:10.0.2)</span></span><br><span class="line"><span class="string">Gecko/20100101 Firefox/10.0.2&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: frame[<span class="string">&#x27;a&#x27;</span>][<span class="number">51</span>][:<span class="number">50</span>]  <span class="comment"># long line</span></span><br><span class="line">Out[<span class="number">41</span>]: <span class="string">&#x27;Mozilla/5.0 (Linux; U; Android 2.2.2; en-us; LG-P9&#x27;</span></span><br></pre></td></tr></table></figure>
<p>将这些"agent"字符串中的所有信息都解析出来是一件挺郁闷的工作。一种策略是将这种字符串的第一节（与浏览器大致对应）分离出来并得到另外一份用户行为摘要：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">42</span>]: results = pd.Series([x.split()[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> frame.a.dropna()])</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: results[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line"><span class="number">0</span>               Mozilla/<span class="number">5.0</span></span><br><span class="line"><span class="number">1</span>    GoogleMaps/RochesterNY</span><br><span class="line"><span class="number">2</span>               Mozilla/<span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>               Mozilla/<span class="number">5.0</span></span><br><span class="line"><span class="number">4</span>               Mozilla/<span class="number">5.0</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: results.value_counts()[:<span class="number">8</span>]</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">Mozilla/<span class="number">5.0</span>                 <span class="number">2594</span></span><br><span class="line">Mozilla/<span class="number">4.0</span>                  <span class="number">601</span></span><br><span class="line">GoogleMaps/RochesterNY       <span class="number">121</span></span><br><span class="line">Opera/<span class="number">9.80</span>                    <span class="number">34</span></span><br><span class="line">TEST_INTERNET_AGENT           <span class="number">24</span></span><br><span class="line">GoogleProducer                <span class="number">21</span></span><br><span class="line">Mozilla/<span class="number">6.0</span>                    <span class="number">5</span></span><br><span class="line">BlackBerry8520/<span class="number">5.0</span><span class="number">.0</span><span class="number">.681</span>       <span class="number">4</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>现在，假设你想按Windows和非Windows用户对时区统计信息进行分解。为了简单起见，我们假定只要agent字符串中含有"Windows"就认为该用户为Windows用户。由于有的agent缺失，所以首先将它们从数据中移除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: cframe = frame[frame.a.notnull()]</span><br></pre></td></tr></table></figure>
<p>然后计算出各行是否含有Windows的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: cframe[<span class="string">&#x27;os&#x27;</span>] = np.where(cframe[<span class="string">&#x27;a&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;Windows&#x27;</span>),</span><br><span class="line">   ....:                         <span class="string">&#x27;Windows&#x27;</span>, <span class="string">&#x27;Not Windows&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: cframe[<span class="string">&#x27;os&#x27;</span>][:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">48</span>]: </span><br><span class="line"><span class="number">0</span>        Windows</span><br><span class="line"><span class="number">1</span>    Not Windows</span><br><span class="line"><span class="number">2</span>        Windows</span><br><span class="line"><span class="number">3</span>    Not Windows</span><br><span class="line"><span class="number">4</span>        Windows</span><br><span class="line">Name: os, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>接下来就可以根据时区和新得到的操作系统列表对数据进行分组了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: by_tz_os = cframe.groupby([<span class="string">&#x27;tz&#x27;</span>, <span class="string">&#x27;os&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>分组计数，类似于<code>value_counts</code>函数，可以用<code>size</code>来计算。并利用<code>unstack</code>对计数结果进行重塑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: agg_counts = by_tz_os.size().unstack().fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: agg_counts[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">os                              Not Windows  Windows</span><br><span class="line">tz                                                  </span><br><span class="line">                                      <span class="number">245.0</span>    <span class="number">276.0</span></span><br><span class="line">Africa/Cairo                            <span class="number">0.0</span>      <span class="number">3.0</span></span><br><span class="line">Africa/Casablanca                       <span class="number">0.0</span>      <span class="number">1.0</span></span><br><span class="line">Africa/Ceuta                            <span class="number">0.0</span>      <span class="number">2.0</span></span><br><span class="line">Africa/Johannesburg                     <span class="number">0.0</span>      <span class="number">1.0</span></span><br><span class="line">Africa/Lusaka                           <span class="number">0.0</span>      <span class="number">1.0</span></span><br><span class="line">America/Anchorage                       <span class="number">4.0</span>      <span class="number">1.0</span></span><br><span class="line">America/Argentina/Buenos_Aires          <span class="number">1.0</span>      <span class="number">0.0</span></span><br><span class="line">America/Argentina/Cordoba               <span class="number">0.0</span>      <span class="number">1.0</span></span><br><span class="line">America/Argentina/Mendoza               <span class="number">0.0</span>      <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>最后，我们来选取最常出现的时区。为了达到这个目的，我根据agg_counts中的行数构造了一个间接索引数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use to sort in ascending order</span></span><br><span class="line">In [<span class="number">52</span>]: indexer = agg_counts.<span class="built_in">sum</span>(<span class="number">1</span>).argsort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: indexer[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">tz</span><br><span class="line">                                  <span class="number">24</span></span><br><span class="line">Africa/Cairo                      <span class="number">20</span></span><br><span class="line">Africa/Casablanca                 <span class="number">21</span></span><br><span class="line">Africa/Ceuta                      <span class="number">92</span></span><br><span class="line">Africa/Johannesburg               <span class="number">87</span></span><br><span class="line">Africa/Lusaka                     <span class="number">53</span></span><br><span class="line">America/Anchorage                 <span class="number">54</span></span><br><span class="line">America/Argentina/Buenos_Aires    <span class="number">57</span></span><br><span class="line">America/Argentina/Cordoba         <span class="number">26</span></span><br><span class="line">America/Argentina/Mendoza         <span class="number">55</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>然后通过<code>take</code>函数按照这个顺序截取了最后10行最大值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: count_subset = agg_counts.take(indexer[-<span class="number">10</span>:])</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: count_subset</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">os                   Not Windows  Windows</span><br><span class="line">tz                                       </span><br><span class="line">America/Sao_Paulo           <span class="number">13.0</span>     <span class="number">20.0</span></span><br><span class="line">Europe/Madrid               <span class="number">16.0</span>     <span class="number">19.0</span></span><br><span class="line">Pacific/Honolulu             <span class="number">0.0</span>     <span class="number">36.0</span></span><br><span class="line">Asia/Tokyo                   <span class="number">2.0</span>     <span class="number">35.0</span></span><br><span class="line">Europe/London               <span class="number">43.0</span>     <span class="number">31.0</span></span><br><span class="line">America/Denver             <span class="number">132.0</span>     <span class="number">59.0</span></span><br><span class="line">America/Los_Angeles        <span class="number">130.0</span>    <span class="number">252.0</span></span><br><span class="line">America/Chicago            <span class="number">115.0</span>    <span class="number">285.0</span></span><br><span class="line">                           <span class="number">245.0</span>    <span class="number">276.0</span></span><br><span class="line">America/New_York           <span class="number">339.0</span>    <span class="number">912.0</span></span><br></pre></td></tr></table></figure>
<p><code>pandas</code>有一个简便方法<code>nlargest</code>，可以做同样的工作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: agg_counts.<span class="built_in">sum</span>(<span class="number">1</span>).nlargest(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line">tz</span><br><span class="line">America/New_York       <span class="number">1251.0</span></span><br><span class="line">                        <span class="number">521.0</span></span><br><span class="line">America/Chicago         <span class="number">400.0</span></span><br><span class="line">America/Los_Angeles     <span class="number">382.0</span></span><br><span class="line">America/Denver          <span class="number">191.0</span></span><br><span class="line">Europe/London            <span class="number">74.0</span></span><br><span class="line">Asia/Tokyo               <span class="number">37.0</span></span><br><span class="line">Pacific/Honolulu         <span class="number">36.0</span></span><br><span class="line">Europe/Madrid            <span class="number">35.0</span></span><br><span class="line">America/Sao_Paulo        <span class="number">33.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>然后，如这段代码所示，可以用柱状图表示。我传递一个额外参数到<code>seaborn</code>的<code>barpolt</code>函数，来画一个堆积条形图（见图14-2）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Rearrange the data for plotting</span></span><br><span class="line">In [<span class="number">58</span>]: count_subset = count_subset.stack()</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: count_subset.name = <span class="string">&#x27;total&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: count_subset = count_subset.reset_index()</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: count_subset[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">61</span>]: </span><br><span class="line">                  tz           os  total</span><br><span class="line"><span class="number">0</span>  America/Sao_Paulo  Not Windows   <span class="number">13.0</span></span><br><span class="line"><span class="number">1</span>  America/Sao_Paulo      Windows   <span class="number">20.0</span></span><br><span class="line"><span class="number">2</span>      Europe/Madrid  Not Windows   <span class="number">16.0</span></span><br><span class="line"><span class="number">3</span>      Europe/Madrid      Windows   <span class="number">19.0</span></span><br><span class="line"><span class="number">4</span>   Pacific/Honolulu  Not Windows    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>   Pacific/Honolulu      Windows   <span class="number">36.0</span></span><br><span class="line"><span class="number">6</span>         Asia/Tokyo  Not Windows    <span class="number">2.0</span></span><br><span class="line"><span class="number">7</span>         Asia/Tokyo      Windows   <span class="number">35.0</span></span><br><span class="line"><span class="number">8</span>      Europe/London  Not Windows   <span class="number">43.0</span></span><br><span class="line"><span class="number">9</span>      Europe/London      Windows   <span class="number">31.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: sns.barplot(x=<span class="string">&#x27;total&#x27;</span>, y=<span class="string">&#x27;tz&#x27;</span>, hue=<span class="string">&#x27;os&#x27;</span>,  data=count_subset)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-053612a5655b68d9.png" class="" title="图14-2 最常出现时区的Windows和非Windows用户">
<p>这张图不容易看出Windows用户在小分组中的相对比例，因此标准化分组百分比之和为1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">norm_total</span>(<span class="params">group</span>):</span><br><span class="line">    group[<span class="string">&#x27;normed_total&#x27;</span>] = group.total / group.total.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> group</span><br><span class="line"></span><br><span class="line">results = count_subset.groupby(<span class="string">&#x27;tz&#x27;</span>).apply(norm_total)</span><br></pre></td></tr></table></figure>
<p>再次画图，见图14-3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: sns.barplot(x=<span class="string">&#x27;normed_total&#x27;</span>, y=<span class="string">&#x27;tz&#x27;</span>, hue=<span class="string">&#x27;os&#x27;</span>,  data=results)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-60ee355801daf412.png" class="" title="图14-3 最常出现时区的Windows和非Windows用户的百分比">
<p>我们还可以用groupby的transform方法，更高效的计算标准化的和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">66</span>]: g = count_subset.groupby(<span class="string">&#x27;tz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: results2 = count_subset.total / g.total.transform(<span class="string">&#x27;sum&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="movielens-1m数据集">14.2 MovieLens 1M数据集</h2>
<p>GroupLens Research（http://www.grouplens.org/node/73 ）采集了一组从20世纪90年末到21世纪初由MovieLens用户提供的电影评分数据。这些数据中包括电影评分、电影元数据（风格类型和年代）以及关于用户的人口统计学数据（年龄、邮编、性别和职业等）。基于机器学习算法的推荐系统一般都会对此类数据感兴趣。虽然我不会在本书中详细介绍机器学习技术，但我会告诉你如何对这种数据进行切片切块以满足实际需求。</p>
<p>MovieLens 1M数据集含有来自6000名用户对4000部电影的100万条评分数据。它分为三个表：评分、用户信息和电影信息。将该数据从zip文件中解压出来之后，可以通过<code>pandas.read_table</code>将各个表分别读到一个<code>pandas DataFrame</code>对象中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make display smaller</span></span><br><span class="line">pd.options.display.max_rows = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">unames = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;occupation&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>]</span><br><span class="line">users = pd.read_table(<span class="string">&#x27;datasets/movielens/users.dat&#x27;</span>, sep=<span class="string">&#x27;::&#x27;</span>,</span><br><span class="line">                      header=<span class="literal">None</span>, names=unames)</span><br><span class="line"></span><br><span class="line">rnames = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;movie_id&#x27;</span>, <span class="string">&#x27;rating&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>]</span><br><span class="line">ratings = pd.read_table(<span class="string">&#x27;datasets/movielens/ratings.dat&#x27;</span>, sep=<span class="string">&#x27;::&#x27;</span>,</span><br><span class="line">                        header=<span class="literal">None</span>, names=rnames)</span><br><span class="line">mnames = [<span class="string">&#x27;movie_id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;genres&#x27;</span>]</span><br><span class="line">movies = pd.read_table(<span class="string">&#x27;datasets/movielens/movies.dat&#x27;</span>, sep=<span class="string">&#x27;::&#x27;</span>,</span><br><span class="line">                       header=<span class="literal">None</span>, names=mnames)</span><br></pre></td></tr></table></figure>
<p>利用Python的切片语法，通过查看每个<code>DataFrame</code>的前几行即可验证数据加载工作是否一切顺利：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: users[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">69</span>]: </span><br><span class="line">   user_id gender  age  occupation    <span class="built_in">zip</span></span><br><span class="line"><span class="number">0</span>        <span class="number">1</span>      F    <span class="number">1</span>          <span class="number">10</span>  <span class="number">48067</span></span><br><span class="line"><span class="number">1</span>        <span class="number">2</span>      M   <span class="number">56</span>          <span class="number">16</span>  <span class="number">70072</span></span><br><span class="line"><span class="number">2</span>        <span class="number">3</span>      M   <span class="number">25</span>          <span class="number">15</span>  <span class="number">55117</span></span><br><span class="line"><span class="number">3</span>        <span class="number">4</span>      M   <span class="number">45</span>           <span class="number">7</span>  02460</span><br><span class="line"><span class="number">4</span>        <span class="number">5</span>      M   <span class="number">25</span>          <span class="number">20</span>  <span class="number">55455</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: ratings[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">   user_id  movie_id  rating  timestamp</span><br><span class="line"><span class="number">0</span>        <span class="number">1</span>      <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978300760</span></span><br><span class="line"><span class="number">1</span>        <span class="number">1</span>       <span class="number">661</span>       <span class="number">3</span>  <span class="number">978302109</span></span><br><span class="line"><span class="number">2</span>        <span class="number">1</span>       <span class="number">914</span>       <span class="number">3</span>  <span class="number">978301968</span></span><br><span class="line"><span class="number">3</span>        <span class="number">1</span>      <span class="number">3408</span>       <span class="number">4</span>  <span class="number">978300275</span></span><br><span class="line"><span class="number">4</span>        <span class="number">1</span>      <span class="number">2355</span>       <span class="number">5</span>  <span class="number">978824291</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: movies[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">   movie_id                               title                        genres</span><br><span class="line"><span class="number">0</span>         <span class="number">1</span>                    Toy Story (<span class="number">1995</span>)   Animation|Children<span class="string">&#x27;s|Comedy</span></span><br><span class="line"><span class="string">1         2                      Jumanji (1995)  Adventure|Children&#x27;</span>s|Fantasy</span><br><span class="line"><span class="number">2</span>         <span class="number">3</span>             Grumpier Old Men (<span class="number">1995</span>)                Comedy|Romance</span><br><span class="line"><span class="number">3</span>         <span class="number">4</span>            Waiting to Exhale (<span class="number">1995</span>)                  Comedy|Drama</span><br><span class="line"><span class="number">4</span>         <span class="number">5</span>  Father of the Bride Part II (<span class="number">1995</span>)                        Comedy</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: ratings</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line">         user_id  movie_id  rating  timestamp</span><br><span class="line"><span class="number">0</span>              <span class="number">1</span>      <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978300760</span></span><br><span class="line"><span class="number">1</span>              <span class="number">1</span>       <span class="number">661</span>       <span class="number">3</span>  <span class="number">978302109</span></span><br><span class="line"><span class="number">2</span>              <span class="number">1</span>       <span class="number">914</span>       <span class="number">3</span>  <span class="number">978301968</span></span><br><span class="line"><span class="number">3</span>              <span class="number">1</span>      <span class="number">3408</span>       <span class="number">4</span>  <span class="number">978300275</span></span><br><span class="line"><span class="number">4</span>              <span class="number">1</span>      <span class="number">2355</span>       <span class="number">5</span>  <span class="number">978824291</span></span><br><span class="line"><span class="meta">... </span>         ...       ...     ...        ...</span><br><span class="line"><span class="number">1000204</span>     <span class="number">6040</span>      <span class="number">1091</span>       <span class="number">1</span>  <span class="number">956716541</span></span><br><span class="line"><span class="number">1000205</span>     <span class="number">6040</span>      <span class="number">1094</span>       <span class="number">5</span>  <span class="number">956704887</span></span><br><span class="line"><span class="number">1000206</span>     <span class="number">6040</span>       <span class="number">562</span>       <span class="number">5</span>  <span class="number">956704746</span></span><br><span class="line"><span class="number">1000207</span>     <span class="number">6040</span>      <span class="number">1096</span>       <span class="number">4</span>  <span class="number">956715648</span></span><br><span class="line"><span class="number">1000208</span>     <span class="number">6040</span>      <span class="number">1097</span>       <span class="number">4</span>  <span class="number">956715569</span></span><br><span class="line">[<span class="number">1000209</span> rows x <span class="number">4</span> columns]</span><br></pre></td></tr></table></figure>
<p>注意，其中的年龄和职业是以编码形式给出的，它们的具体含义请参考该数据集的README文件。分析散布在三个表中的数据可不是一件轻松的事情。假设我们想要根据性别和年龄计算某部电影的平均得分，如果将所有数据都合并到一个表中的话问题就简单多了。我们先用<code>pandas</code>的<code>merge</code>函数将<code>ratings</code>跟<code>users</code>合并到一起，然后再将<code>movies</code>也合并进去。<code>pandas</code>会根据列名的重叠情况推断出哪些列是合并（或连接）键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: data = pd.merge(pd.merge(ratings, users), movies)</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: data</span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line">         user_id  movie_id  rating  timestamp gender  age  occupation    <span class="built_in">zip</span>  \</span><br><span class="line"><span class="number">0</span>              <span class="number">1</span>      <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978300760</span>      F    <span class="number">1</span>          <span class="number">10</span>  <span class="number">48067</span>   </span><br><span class="line"><span class="number">1</span>              <span class="number">2</span>      <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978298413</span>      M   <span class="number">56</span>          <span class="number">16</span>  <span class="number">70072</span>   </span><br><span class="line"><span class="number">2</span>             <span class="number">12</span>      <span class="number">1193</span>       <span class="number">4</span>  <span class="number">978220179</span>      M   <span class="number">25</span>          <span class="number">12</span>  <span class="number">32793</span>   </span><br><span class="line"><span class="number">3</span>             <span class="number">15</span>      <span class="number">1193</span>       <span class="number">4</span>  <span class="number">978199279</span>      M   <span class="number">25</span>           <span class="number">7</span>  <span class="number">22903</span>   </span><br><span class="line"><span class="number">4</span>             <span class="number">17</span>      <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978158471</span>      M   <span class="number">50</span>           <span class="number">1</span>  <span class="number">95350</span>   </span><br><span class="line"><span class="meta">... </span>         ...       ...     ...        ...    ...  ...         ...    ...   </span><br><span class="line"><span class="number">1000204</span>     <span class="number">5949</span>      <span class="number">2198</span>       <span class="number">5</span>  <span class="number">958846401</span>      M   <span class="number">18</span>          <span class="number">17</span>  <span class="number">47901</span></span><br><span class="line"><span class="number">1000205</span>     <span class="number">5675</span>      <span class="number">2703</span>       <span class="number">3</span>  <span class="number">976029116</span>      M   <span class="number">35</span>          <span class="number">14</span>  <span class="number">30030</span>   </span><br><span class="line"><span class="number">1000206</span>     <span class="number">5780</span>      <span class="number">2845</span>       <span class="number">1</span>  <span class="number">958153068</span>      M   <span class="number">18</span>          <span class="number">17</span>  <span class="number">92886</span>   </span><br><span class="line"><span class="number">1000207</span>     <span class="number">5851</span>      <span class="number">3607</span>       <span class="number">5</span>  <span class="number">957756608</span>      F   <span class="number">18</span>          <span class="number">20</span>  <span class="number">55410</span>   </span><br><span class="line"><span class="number">1000208</span>     <span class="number">5938</span>      <span class="number">2909</span>       <span class="number">4</span>  <span class="number">957273353</span>      M   <span class="number">25</span>           <span class="number">1</span>  <span class="number">35401</span>   </span><br><span class="line">                                               title                genres  </span><br><span class="line"><span class="number">0</span>             One Flew Over the Cuckoo<span class="string">&#x27;s Nest (1975)                 Drama  </span></span><br><span class="line"><span class="string">1             One Flew Over the Cuckoo&#x27;</span>s Nest (<span class="number">1975</span>)                 Drama  </span><br><span class="line"><span class="number">2</span>             One Flew Over the Cuckoo<span class="string">&#x27;s Nest (1975)                 Drama  </span></span><br><span class="line"><span class="string">3             One Flew Over the Cuckoo&#x27;</span>s Nest (<span class="number">1975</span>)                 Drama  </span><br><span class="line"><span class="number">4</span>             One Flew Over the Cuckoo<span class="string">&#x27;s Nest (1975)                 Drama  </span></span><br><span class="line"><span class="string">...                                              ...                   ...  </span></span><br><span class="line"><span class="string">1000204                           Modulations (1998)           Documentary  </span></span><br><span class="line"><span class="string">1000205                        Broken Vessels (1998)                 Drama  </span></span><br><span class="line"><span class="string">1000206                            White Boys (1999)                 Drama  </span></span><br><span class="line"><span class="string">1000207                     One Little Indian (1973)  Comedy|Drama|Western  </span></span><br><span class="line"><span class="string">1000208  Five Wives, Three Secretaries and Me (1998)           Documentary  </span></span><br><span class="line"><span class="string">[1000209 rows x 10 columns]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [75]: data.iloc[0]</span></span><br><span class="line"><span class="string">Out[75]: </span></span><br><span class="line"><span class="string">user_id                                            1</span></span><br><span class="line"><span class="string">movie_id                                        1193</span></span><br><span class="line"><span class="string">rating                                             5</span></span><br><span class="line"><span class="string">timestamp                                  978300760</span></span><br><span class="line"><span class="string">gender                                             F</span></span><br><span class="line"><span class="string">age                                                1</span></span><br><span class="line"><span class="string">occupation                                        10</span></span><br><span class="line"><span class="string">zip                                            48067</span></span><br><span class="line"><span class="string">title         One Flew Over the Cuckoo&#x27;</span>s Nest (<span class="number">1975</span>)</span><br><span class="line">genres                                         Drama</span><br><span class="line">Name: <span class="number">0</span>, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>为了按性别计算每部电影的平均得分，我们可以使用<code>pivot_table</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: mean_ratings = data.pivot_table(<span class="string">&#x27;rating&#x27;</span>, index=<span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">   ....:                                 columns=<span class="string">&#x27;gender&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: mean_ratings[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">gender                                F         M</span><br><span class="line">title                                            </span><br><span class="line">$<span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span> Duck (<span class="number">1971</span>)         <span class="number">3.375000</span>  <span class="number">2.761905</span></span><br><span class="line"><span class="string">&#x27;Night Mother (1986)           3.388889  3.352941</span></span><br><span class="line"><span class="string">&#x27;</span>Til There Was You (<span class="number">1997</span>)      <span class="number">2.675676</span>  <span class="number">2.733333</span></span><br><span class="line"><span class="string">&#x27;burbs, The (1989)             2.793478  2.962085</span></span><br><span class="line"><span class="string">...And Justice for All (1979)  3.828571  3.689024</span></span><br></pre></td></tr></table></figure>
<p>该操作产生了另一个<code>DataFrame</code>，其内容为电影平均得分，行标为电影名称（索引），列标为性别。现在，我打算过滤掉评分数据不够250条的电影（随便选的一个数字）。为了达到这个目的，我先对<code>title</code>进行分组，然后利用<code>size()</code>得到一个含有各电影分组大小的<code>Series</code>对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: ratings_by_title = data.groupby(<span class="string">&#x27;title&#x27;</span>).size()</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: ratings_by_title[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">title</span><br><span class="line">$<span class="number">1</span>,<span class="number">000</span>,<span class="number">000</span> Duck (<span class="number">1971</span>)                <span class="number">37</span></span><br><span class="line"><span class="string">&#x27;Night Mother (1986)                  70</span></span><br><span class="line"><span class="string">&#x27;</span>Til There Was You (<span class="number">1997</span>)             <span class="number">52</span></span><br><span class="line"><span class="string">&#x27;burbs, The (1989)                   303</span></span><br><span class="line"><span class="string">...And Justice for All (1979)        199</span></span><br><span class="line"><span class="string">1-900 (1994)                           2</span></span><br><span class="line"><span class="string">10 Things I Hate About You (1999)    700</span></span><br><span class="line"><span class="string">101 Dalmatians (1961)                565</span></span><br><span class="line"><span class="string">101 Dalmatians (1996)                364</span></span><br><span class="line"><span class="string">12 Angry Men (1957)                  616</span></span><br><span class="line"><span class="string">dtype: int64</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [80]: active_titles = ratings_by_title.index[ratings_by_title &gt;= 250]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [81]: active_titles</span></span><br><span class="line"><span class="string">Out[81]: </span></span><br><span class="line"><span class="string">Index([&#x27;</span><span class="string">&#x27;burbs, The (1989)&#x27;</span>, <span class="string">&#x27;10 Things I Hate About You (1999)&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;101 Dalmatians (1961)&#x27;</span>, <span class="string">&#x27;101 Dalmatians (1996)&#x27;</span>, <span class="string">&#x27;12 Angry Men (1957)&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;13th Warrior, The (1999)&#x27;</span>, <span class="string">&#x27;2 Days in the Valley (1996)&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;20,000 Leagues Under the Sea (1954)&#x27;</span>, <span class="string">&#x27;2001: A Space Odyssey (1968)&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;2010 (1984)&#x27;</span>,</span><br><span class="line">       ...</span><br><span class="line"><span class="string">&#x27;X-Men (2000)&#x27;</span>, <span class="string">&#x27;Year of Living Dangerously (1982)&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Yellow Submarine (1968)&#x27;</span>, <span class="string">&#x27;You&#x27;</span>ve Got Mail (<span class="number">1998</span>)<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">       &#x27;</span>Young Frankenstein (<span class="number">1974</span>)<span class="string">&#x27;, &#x27;</span>Young Guns (<span class="number">1988</span>)<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">       &#x27;</span>Young Guns II (<span class="number">1990</span>)<span class="string">&#x27;, &#x27;</span>Young Sherlock Holmes (<span class="number">1985</span>)<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">       &#x27;</span>Zero Effect (<span class="number">1998</span>)<span class="string">&#x27;, &#x27;</span>eXistenZ (<span class="number">1999</span>)<span class="string">&#x27;],</span></span><br><span class="line"><span class="string">      dtype=&#x27;</span><span class="built_in">object</span><span class="string">&#x27;, name=&#x27;</span>title<span class="string">&#x27;, length=1216)</span></span><br></pre></td></tr></table></figure>
<p>标题索引中含有评分数据大于250条的电影名称，然后我们就可以据此从前面的<code>mean_ratings</code>中选取所需的行了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Select rows on the index</span></span><br><span class="line">In [<span class="number">82</span>]: mean_ratings = mean_ratings.loc[active_titles]</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: mean_ratings</span><br><span class="line">Out[<span class="number">83</span>]: </span><br><span class="line">gender                                    F         M</span><br><span class="line">title                                                </span><br><span class="line"><span class="string">&#x27;burbs, The (1989)                 2.793478  2.962085</span></span><br><span class="line"><span class="string">10 Things I Hate About You (1999)  3.646552  3.311966</span></span><br><span class="line"><span class="string">101 Dalmatians (1961)              3.791444  3.500000</span></span><br><span class="line"><span class="string">101 Dalmatians (1996)              3.240000  2.911215</span></span><br><span class="line"><span class="string">12 Angry Men (1957)                4.184397  4.328421</span></span><br><span class="line"><span class="string">...                                     ...       ...</span></span><br><span class="line"><span class="string">Young Guns (1988)                  3.371795  3.425620</span></span><br><span class="line"><span class="string">Young Guns II (1990)               2.934783  2.904025</span></span><br><span class="line"><span class="string">Young Sherlock Holmes (1985)       3.514706  3.363344</span></span><br><span class="line"><span class="string">Zero Effect (1998)                 3.864407  3.723140</span></span><br><span class="line"><span class="string">eXistenZ (1999)                    3.098592  3.289086</span></span><br><span class="line"><span class="string">[1216 rows x 2 columns]</span></span><br></pre></td></tr></table></figure>
<p>为了了解女性观众最喜欢的电影，我们可以对F列降序排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: top_female_ratings = mean_ratings.sort_values(by=<span class="string">&#x27;F&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: top_female_ratings[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">gender                                                     F         M</span><br><span class="line">title                                                                 </span><br><span class="line">Close Shave, A (<span class="number">1995</span>)                               <span class="number">4.644444</span>  <span class="number">4.473795</span></span><br><span class="line">Wrong Trousers, The (<span class="number">1993</span>)                          <span class="number">4.588235</span>  <span class="number">4.478261</span></span><br><span class="line">Sunset Blvd. (a.k.a. Sunset Boulevard) (<span class="number">1950</span>)       <span class="number">4.572650</span>  <span class="number">4.464589</span></span><br><span class="line">Wallace &amp; Gromit: The Best of Aardman Animation...  <span class="number">4.563107</span>  <span class="number">4.385075</span></span><br><span class="line">Schindle<span class="string">r&#x27;s List (1993)                             4.562602  4.491415</span></span><br><span class="line"><span class="string">Shawshank Redemption, The (1994)                    4.539075  4.560625</span></span><br><span class="line"><span class="string">Grand Day Out, A (1992)                             4.537879  4.293255</span></span><br><span class="line"><span class="string">To Kill a Mockingbird (1962)                        4.536667  4.372611</span></span><br><span class="line"><span class="string">Creature Comforts (1990)                            4.513889  4.272277</span></span><br><span class="line"><span class="string">Usual Suspects, The (1995)                          4.513317  4.518248</span></span><br></pre></td></tr></table></figure>
<h3 id="计算评分分歧">14.2.1 计算评分分歧</h3>
<p>假设我们想要找出男性和女性观众分歧最大的电影。一个办法是给<code>mean_ratings</code>加上一个用于存放平均得分之差的列，并对其进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: mean_ratings[<span class="string">&#x27;diff&#x27;</span>] = mean_ratings[<span class="string">&#x27;M&#x27;</span>] - mean_ratings[<span class="string">&#x27;F&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>按"diff"排序即可得到分歧最大且女性观众更喜欢的电影：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">88</span>]: sorted_by_diff = mean_ratings.sort_values(by=<span class="string">&#x27;diff&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: sorted_by_diff[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">89</span>]: </span><br><span class="line">gender                                        F         M      diff</span><br><span class="line">title                                                              </span><br><span class="line">Dirty Dancing (<span class="number">1987</span>)                   <span class="number">3.790378</span>  <span class="number">2.959596</span> -<span class="number">0.830782</span></span><br><span class="line">Jumpin<span class="string">&#x27; Jack Flash (1986)              3.254717  2.578358 -0.676359</span></span><br><span class="line"><span class="string">Grease (1978)                          3.975265  3.367041 -0.608224</span></span><br><span class="line"><span class="string">Little Women (1994)                    3.870588  3.321739 -0.548849</span></span><br><span class="line"><span class="string">Steel Magnolias (1989)                 3.901734  3.365957 -0.535777</span></span><br><span class="line"><span class="string">Anastasia (1997)                       3.800000  3.281609 -0.518391</span></span><br><span class="line"><span class="string">Rocky Horror Picture Show, The (1975)  3.673016  3.160131 -0.512885</span></span><br><span class="line"><span class="string">Color Purple, The (1985)               4.158192  3.659341 -0.498851</span></span><br><span class="line"><span class="string">Age of Innocence, The (1993)           3.827068  3.339506 -0.487561</span></span><br><span class="line"><span class="string">Free Willy (1993)                      2.921348  2.438776 -0.482573</span></span><br></pre></td></tr></table></figure>
<p>对排序结果反序并取出前10行，得到的则是男性观众更喜欢的电影：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reverse order of rows, take first 10 rows</span></span><br><span class="line">In [<span class="number">90</span>]: sorted_by_diff[::-<span class="number">1</span>][:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">gender                                         F         M      diff</span><br><span class="line">title                                                               </span><br><span class="line">Good, The Bad <span class="keyword">and</span> The Ugly, The (<span class="number">1966</span>)  <span class="number">3.494949</span>  <span class="number">4.221300</span>  <span class="number">0.726351</span></span><br><span class="line">Kentucky Fried Movie, The (<span class="number">1977</span>)        <span class="number">2.878788</span>  <span class="number">3.555147</span>  <span class="number">0.676359</span></span><br><span class="line">Dumb &amp; Dumber (<span class="number">1994</span>)                    <span class="number">2.697987</span>  <span class="number">3.336595</span>  <span class="number">0.638608</span></span><br><span class="line">Longest Day, The (<span class="number">1962</span>)                 <span class="number">3.411765</span>  <span class="number">4.031447</span>  <span class="number">0.619682</span></span><br><span class="line">Cable Guy, The (<span class="number">1996</span>)                   <span class="number">2.250000</span>  <span class="number">2.863787</span>  <span class="number">0.613787</span></span><br><span class="line">Evil Dead II (Dead By Dawn) (<span class="number">1987</span>)      <span class="number">3.297297</span>  <span class="number">3.909283</span>  <span class="number">0.611985</span></span><br><span class="line">Hidden, The (<span class="number">1987</span>)                      <span class="number">3.137931</span>  <span class="number">3.745098</span>  <span class="number">0.607167</span></span><br><span class="line">Rocky III (<span class="number">1982</span>)                        <span class="number">2.361702</span>  <span class="number">2.943503</span>  <span class="number">0.581801</span></span><br><span class="line">Caddyshack (<span class="number">1980</span>)                       <span class="number">3.396135</span>  <span class="number">3.969737</span>  <span class="number">0.573602</span></span><br><span class="line">For a Few Dollars More (<span class="number">1965</span>)           <span class="number">3.409091</span>  <span class="number">3.953795</span>  <span class="number">0.544704</span></span><br></pre></td></tr></table></figure>
<p>如果只是想要找出分歧最大的电影（不考虑性别因素），则可以计算得分数据的方差或标准差：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Standard deviation of rating grouped by title</span></span><br><span class="line">In [<span class="number">91</span>]: rating_std_by_title = data.groupby(<span class="string">&#x27;title&#x27;</span>)[<span class="string">&#x27;rating&#x27;</span>].std()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Filter down to active_titles</span></span><br><span class="line">In [<span class="number">92</span>]: rating_std_by_title = rating_std_by_title.loc[active_titles]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Order Series by value in descending order</span></span><br><span class="line">In [<span class="number">93</span>]: rating_std_by_title.sort_values(ascending=<span class="literal">False</span>)[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line">title</span><br><span class="line">Dumb &amp; Dumber (<span class="number">1994</span>)                     <span class="number">1.321333</span></span><br><span class="line">Blair Witch Project, The (<span class="number">1999</span>)          <span class="number">1.316368</span></span><br><span class="line">Natural Born Killers (<span class="number">1994</span>)              <span class="number">1.307198</span></span><br><span class="line">Tank Girl (<span class="number">1995</span>)                         <span class="number">1.277695</span></span><br><span class="line">Rocky Horror Picture Show, The (<span class="number">1975</span>)    <span class="number">1.260177</span></span><br><span class="line">Eyes Wide Shut (<span class="number">1999</span>)                    <span class="number">1.259624</span></span><br><span class="line">Evita (<span class="number">1996</span>)                             <span class="number">1.253631</span></span><br><span class="line">Billy Madison (<span class="number">1995</span>)                     <span class="number">1.249970</span></span><br><span class="line">Fear <span class="keyword">and</span> Loathing <span class="keyword">in</span> Las Vegas (<span class="number">1998</span>)    <span class="number">1.246408</span></span><br><span class="line">Bicentennial Man (<span class="number">1999</span>)                  <span class="number">1.245533</span></span><br><span class="line">Name: rating, dtype: float64</span><br></pre></td></tr></table></figure>
<p>可能你已经注意到了，电影分类是以竖线（|）分隔的字符串形式给出的。如果想对电影分类进行分析的话，就需要先将其转换成更有用的形式才行。</p>
<h2 id="年间全美婴儿姓名">14.3 1880-2010年间全美婴儿姓名</h2>
<p>美国社会保障总署（SSA）提供了一份从1880年到现在的婴儿名字频率数据。Hadley Wickham（许多流行R包的作者）经常用这份数据来演示R的数据处理功能。</p>
<p>我们要做一些数据规整才能加载这个数据集，这么做就会产生一个如下的<code>DataFrame</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: names.head(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">4</span>]:</span><br><span class="line">        name sex  births  year</span><br><span class="line"><span class="number">0</span>       Mary   F    <span class="number">7065</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">1</span>       Anna   F    <span class="number">2604</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">2</span>       Emma   F    <span class="number">2003</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">3</span>  Elizabeth   F    <span class="number">1939</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">4</span>     Minnie   F    <span class="number">1746</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">5</span>   Margaret   F    <span class="number">1578</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">6</span>        Ida   F    <span class="number">1472</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">7</span>      Alice   F    <span class="number">1414</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">8</span>     Bertha   F    <span class="number">1320</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">9</span>      Sarah   F    <span class="number">1288</span>  <span class="number">1880</span></span><br></pre></td></tr></table></figure>
<p>可以用这个数据集做很多事，例如：</p>
<ul>
<li>计算指定名字（可以是你自己的，也可以是别人的）的年度比例。</li>
<li>计算某个名字的相对排名。</li>
<li>计算各年度最流行的名字，以及增长或减少最快的名字。</li>
<li>分析名字趋势：元音、辅音、长度、总体多样性、拼写变化、首尾字母等。</li>
<li>分析外源性趋势：圣经中的名字、名人、人口结构变化等。</li>
</ul>
<p>利用前面介绍过的那些工具，这些分析工作都能很轻松地完成，我会讲解其中的一些。</p>
<p>到编写本书时为止，美国社会保障总署将该数据库按年度制成了多个数据文件，其中给出了每个性别/名字组合的出生总数。这些文件的原始档案可以在这里获取：http://www.ssa.gov/oact/babynames/limits.html。</p>
<p>如果在阅读本书的时候这个页面无法访问，可以用搜索引擎找找。</p>
<p>下载"National data"文件names.zip，解压后的目录中含有一组文件（如yob1880.txt）。利用UNIX的head命令查看了其中一个文件的前10行（在Windows上，可以用more命令，或直接在文本编辑器中打开）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: !head -n <span class="number">10</span> datasets/babynames/yob1880.txt</span><br><span class="line">Mary,F,<span class="number">7065</span></span><br><span class="line">Anna,F,<span class="number">2604</span></span><br><span class="line">Emma,F,<span class="number">2003</span></span><br><span class="line">Elizabeth,F,<span class="number">1939</span></span><br><span class="line">Minnie,F,<span class="number">1746</span></span><br><span class="line">Margaret,F,<span class="number">1578</span></span><br><span class="line">Ida,F,<span class="number">1472</span></span><br><span class="line">Alice,F,<span class="number">1414</span></span><br><span class="line">Bertha,F,<span class="number">1320</span></span><br><span class="line">Sarah,F,<span class="number">1288</span></span><br></pre></td></tr></table></figure>
<p>由于这是一个非常标准的以逗号隔开的格式，所以可以用<code>pandas.read_csv</code>将其加载到<code>DataFrame</code>中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: names1880 =</span><br><span class="line">pd.read_csv(<span class="string">&#x27;datasets/babynames/yob1880.txt&#x27;</span>,</span><br><span class="line">   ....:                         names=[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;births&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: names1880</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line">           name sex  births</span><br><span class="line"><span class="number">0</span>          Mary   F    <span class="number">7065</span></span><br><span class="line"><span class="number">1</span>          Anna   F    <span class="number">2604</span></span><br><span class="line"><span class="number">2</span>          Emma   F    <span class="number">2003</span></span><br><span class="line"><span class="number">3</span>     Elizabeth   F    <span class="number">1939</span></span><br><span class="line"><span class="number">4</span>        Minnie   F    <span class="number">1746</span></span><br><span class="line"><span class="meta">... </span>        ...  ..     ...</span><br><span class="line"><span class="number">1995</span>     Woodie   M       <span class="number">5</span></span><br><span class="line"><span class="number">1996</span>     Worthy   M       <span class="number">5</span></span><br><span class="line"><span class="number">1997</span>     Wright   M       <span class="number">5</span></span><br><span class="line"><span class="number">1998</span>       York   M       <span class="number">5</span></span><br><span class="line"><span class="number">1999</span>  Zachariah   M       <span class="number">5</span></span><br><span class="line">[<span class="number">2000</span> rows x <span class="number">3</span> columns]</span><br></pre></td></tr></table></figure>
<p>这些文件中仅含有当年出现超过5次的名字。为了简单起见，我们可以用<code>births</code>列的<code>sex</code>分组小计表示该年度的<code>births</code>总计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">98</span>]: names1880.groupby(<span class="string">&#x27;sex&#x27;</span>).births.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">sex</span><br><span class="line">F     <span class="number">90993</span></span><br><span class="line">M    <span class="number">110493</span></span><br><span class="line">Name: births, dtype: int64</span><br></pre></td></tr></table></figure>
<p>由于该数据集按年度被分隔成了多个文件，所以第一件事情就是要将所有数据都组装到一个<code>DataFrame</code>里面，并加上一个<code>year</code>字段。使用<code>pandas.concat</code>即可达到这个目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">years = <span class="built_in">range</span>(<span class="number">1880</span>, <span class="number">2011</span>)</span><br><span class="line"></span><br><span class="line">pieces = []</span><br><span class="line">columns = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;births&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> years:</span><br><span class="line">    path = <span class="string">&#x27;datasets/babynames/yob%d.txt&#x27;</span> % year</span><br><span class="line">    frame = pd.read_csv(path, names=columns)</span><br><span class="line"></span><br><span class="line">    frame[<span class="string">&#x27;year&#x27;</span>] = year</span><br><span class="line">    pieces.append(frame)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Concatenate everything into a single DataFrame</span></span><br><span class="line">names = pd.concat(pieces, ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这里需要注意几件事情。第一，<code>concat</code>默认是按行将多个<code>DataFrame</code>组合到一起的；第二，必须指定<code>ignore_index=True</code>，因为我们不希望保留<code>read_csv</code>所返回的原始行号。现在我们得到了一个非常大的<code>DataFrame</code>，它含有全部的名字数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">100</span>]: names</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">              name sex  births  year</span><br><span class="line"><span class="number">0</span>             Mary   F    <span class="number">7065</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">1</span>             Anna   F    <span class="number">2604</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">2</span>             Emma   F    <span class="number">2003</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">3</span>        Elizabeth   F    <span class="number">1939</span>  <span class="number">1880</span></span><br><span class="line"><span class="number">4</span>           Minnie   F    <span class="number">1746</span>  <span class="number">1880</span></span><br><span class="line"><span class="meta">... </span>           ...  ..     ...   ...</span><br><span class="line"><span class="number">1690779</span>    Zymaire   M       <span class="number">5</span>  <span class="number">2010</span></span><br><span class="line"><span class="number">1690780</span>     Zyonne   M       <span class="number">5</span>  <span class="number">2010</span></span><br><span class="line"><span class="number">1690781</span>  Zyquarius   M       <span class="number">5</span>  <span class="number">2010</span></span><br><span class="line"><span class="number">1690782</span>      Zyran   M       <span class="number">5</span>  <span class="number">2010</span></span><br><span class="line"><span class="number">1690783</span>      Zzyzx   M       <span class="number">5</span>  <span class="number">2010</span></span><br><span class="line">[<span class="number">1690784</span> rows x <span class="number">4</span> columns]</span><br></pre></td></tr></table></figure>
<p>有了这些数据之后，我们就可以利用<code>groupby</code>或<code>pivot_table</code>在<code>year</code>和<code>sex</code>级别上对其进行聚合了，如图14-4所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: total_births = names.pivot_table(<span class="string">&#x27;births&#x27;</span>, index=<span class="string">&#x27;year&#x27;</span>,</span><br><span class="line">   .....:                                  columns=<span class="string">&#x27;sex&#x27;</span>, aggfunc=<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: total_births.tail()</span><br><span class="line">Out[<span class="number">102</span>]: </span><br><span class="line">sex         F        M</span><br><span class="line">year                  </span><br><span class="line"><span class="number">2006</span>  <span class="number">1896468</span>  <span class="number">2050234</span></span><br><span class="line"><span class="number">2007</span>  <span class="number">1916888</span>  <span class="number">2069242</span></span><br><span class="line"><span class="number">2008</span>  <span class="number">1883645</span>  <span class="number">2032310</span></span><br><span class="line"><span class="number">2009</span>  <span class="number">1827643</span>  <span class="number">1973359</span></span><br><span class="line"><span class="number">2010</span>  <span class="number">1759010</span>  <span class="number">1898382</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: total_births.plot(title=<span class="string">&#x27;Total births by sex and year&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-7643b150d88aae11.png" class="" title="图14-4 按性别和年度统计的总出生数">
<p>下面我们来插入一个<code>prop</code>列，用于存放指定名字的婴儿数相对于总出生数的比例。<code>prop</code>值为0.02表示每100名婴儿中有2名取了当前这个名字。因此，我们先按<code>year</code>和<code>sex</code>分组，然后再将新列加到各个分组上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_prop</span>(<span class="params">group</span>):</span><br><span class="line">    group[<span class="string">&#x27;prop&#x27;</span>] = group.births / group.births.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> group</span><br><span class="line">names = names.groupby([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]).apply(add_prop)</span><br></pre></td></tr></table></figure>
<p>现在，完整的数据集就有了下面这些列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: names</span><br><span class="line">Out[<span class="number">105</span>]: </span><br><span class="line">              name sex  births  year      prop</span><br><span class="line"><span class="number">0</span>             Mary   F    <span class="number">7065</span>  <span class="number">1880</span>  <span class="number">0.077643</span></span><br><span class="line"><span class="number">1</span>             Anna   F    <span class="number">2604</span>  <span class="number">1880</span>  <span class="number">0.028618</span></span><br><span class="line"><span class="number">2</span>             Emma   F    <span class="number">2003</span>  <span class="number">1880</span>  <span class="number">0.022013</span></span><br><span class="line"><span class="number">3</span>        Elizabeth   F    <span class="number">1939</span>  <span class="number">1880</span>  <span class="number">0.021309</span></span><br><span class="line"><span class="number">4</span>           Minnie   F    <span class="number">1746</span>  <span class="number">1880</span>  <span class="number">0.019188</span></span><br><span class="line"><span class="meta">... </span>           ...  ..     ...   ...       ...</span><br><span class="line"><span class="number">1690779</span>    Zymaire   M       <span class="number">5</span>  <span class="number">2010</span>  <span class="number">0.000003</span></span><br><span class="line"><span class="number">1690780</span>     Zyonne   M       <span class="number">5</span>  <span class="number">2010</span>  <span class="number">0.000003</span></span><br><span class="line"><span class="number">1690781</span>  Zyquarius   M       <span class="number">5</span>  <span class="number">2010</span>  <span class="number">0.000003</span></span><br><span class="line"><span class="number">1690782</span>      Zyran   M       <span class="number">5</span>  <span class="number">2010</span>  <span class="number">0.000003</span></span><br><span class="line"><span class="number">1690783</span>      Zzyzx   M       <span class="number">5</span>  <span class="number">2010</span>  <span class="number">0.000003</span></span><br><span class="line">[<span class="number">1690784</span> rows x <span class="number">5</span> columns]</span><br></pre></td></tr></table></figure>
<p>在执行这样的分组处理时，一般都应该做一些有效性检查，比如验证所有分组的<code>prop</code>的总和是否为1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: names.groupby([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]).prop.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">year  sex</span><br><span class="line"><span class="number">1880</span>  F      <span class="number">1.0</span></span><br><span class="line">      M      <span class="number">1.0</span></span><br><span class="line"><span class="number">1881</span>  F      <span class="number">1.0</span></span><br><span class="line">      M      <span class="number">1.0</span></span><br><span class="line"><span class="number">1882</span>  F      <span class="number">1.0</span></span><br><span class="line">            ... </span><br><span class="line"><span class="number">2008</span>  M      <span class="number">1.0</span></span><br><span class="line"><span class="number">2009</span>  F      <span class="number">1.0</span></span><br><span class="line">      M      <span class="number">1.0</span></span><br><span class="line"><span class="number">2010</span>  F      <span class="number">1.0</span></span><br><span class="line">      M      <span class="number">1.0</span></span><br><span class="line">Name: prop, Length: <span class="number">262</span>, dtype: float64</span><br></pre></td></tr></table></figure>
<p>工作完成。为了便于实现更进一步的分析，我需要取出该数据的一个子集：每对<code>sex/year</code>组合的前1000个名字。这又是一个分组操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_top1000</span>(<span class="params">group</span>):</span><br><span class="line">    <span class="keyword">return</span> group.sort_values(by=<span class="string">&#x27;births&#x27;</span>, ascending=<span class="literal">False</span>)[:<span class="number">1000</span>]</span><br><span class="line">grouped = names.groupby([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>])</span><br><span class="line">top1000 = grouped.apply(get_top1000)</span><br><span class="line"><span class="comment"># Drop the group index, not needed</span></span><br><span class="line">top1000.reset_index(inplace=<span class="literal">True</span>, drop=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>如果你喜欢DIY的话，也可以这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pieces = []</span><br><span class="line"><span class="keyword">for</span> year, group <span class="keyword">in</span> names.groupby([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]):</span><br><span class="line">    pieces.append(group.sort_values(by=<span class="string">&#x27;births&#x27;</span>, ascending=<span class="literal">False</span>)[:<span class="number">1000</span>])</span><br><span class="line">top1000 = pd.concat(pieces, ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>现在的结果数据集就小多了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: top1000</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line">             name sex  births  year      prop</span><br><span class="line"><span class="number">0</span>            Mary   F    <span class="number">7065</span>  <span class="number">1880</span>  <span class="number">0.077643</span></span><br><span class="line"><span class="number">1</span>            Anna   F    <span class="number">2604</span>  <span class="number">1880</span>  <span class="number">0.028618</span></span><br><span class="line"><span class="number">2</span>            Emma   F    <span class="number">2003</span>  <span class="number">1880</span>  <span class="number">0.022013</span></span><br><span class="line"><span class="number">3</span>       Elizabeth   F    <span class="number">1939</span>  <span class="number">1880</span>  <span class="number">0.021309</span></span><br><span class="line"><span class="number">4</span>          Minnie   F    <span class="number">1746</span>  <span class="number">1880</span>  <span class="number">0.019188</span></span><br><span class="line"><span class="meta">... </span>          ...  ..     ...   ...       ...</span><br><span class="line"><span class="number">261872</span>     Camilo   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261873</span>     Destin   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261874</span>     Jaquan   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261875</span>     Jaydan   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261876</span>     Maxton   M     <span class="number">193</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line">[<span class="number">261877</span> rows x <span class="number">5</span> columns]</span><br></pre></td></tr></table></figure>
<p>接下来的数据分析工作就针对这个top1000数据集了。</p>
<h3 id="分析命名趋势">14.3.1 分析命名趋势</h3>
<p>有了完整的数据集和刚才生成的top1000数据集，我们就可以开始分析各种命名趋势了。首先将前1000个名字分为男女两个部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: boys = top1000[top1000.sex == <span class="string">&#x27;M&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: girls = top1000[top1000.sex == <span class="string">&#x27;F&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>这是两个简单的时间序列，只需稍作整理即可绘制出相应的图表（比如每年叫做John和Mary的婴儿数）。我们先生成一张按<code>year</code>和<code>name</code>统计的总出生数透视表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">111</span>]: total_births = top1000.pivot_table(<span class="string">&#x27;births&#x27;</span>, index=<span class="string">&#x27;year&#x27;</span>,</span><br><span class="line">   .....:                                    columns=<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">   .....:                                    aggfunc=<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>
<p>现在，我们用DataFrame的plot方法绘制几个名字的曲线图（见图14-5）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">112</span>]: total_births.info()</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;</span><br><span class="line">Int64Index: <span class="number">131</span> entries, <span class="number">1880</span> to <span class="number">2010</span></span><br><span class="line">Columns: <span class="number">6868</span> entries, Aaden to Zuri</span><br><span class="line">dtypes: float64(<span class="number">6868</span>)</span><br><span class="line">memory usage: <span class="number">6.9</span> MB</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: subset = total_births[[<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Harry&#x27;</span>, <span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;Marilyn&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: subset.plot(subplots=<span class="literal">True</span>, figsize=(<span class="number">12</span>, <span class="number">10</span>), grid=<span class="literal">False</span>,</span><br><span class="line">   .....:             title=<span class="string">&quot;Number of births per year&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-33f0f97656367a53.png" class="" title="图14-5 几个男孩和女孩名字随时间变化的使用数量">
<p>从图中可以看出，这几个名字在美国人民的心目中已经风光不再了。但事实并非如此简单，我们在下一节中就能知道是怎么一回事了。</p>
<h3 id="评估命名多样性的增长">14.3.2 评估命名多样性的增长</h3>
<p>一种解释是父母愿意给小孩起常见的名字越来越少。这个假设可以从数据中得到验证。一个办法是计算最流行的1000个名字所占的比例，按<code>year</code>和<code>sex</code>进行聚合并绘图（见图14-6）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">116</span>]: table = top1000.pivot_table(<span class="string">&#x27;prop&#x27;</span>, index=<span class="string">&#x27;year&#x27;</span>,</span><br><span class="line">   .....:                             columns=<span class="string">&#x27;sex&#x27;</span>, aggfunc=<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: table.plot(title=<span class="string">&#x27;Sum of table1000.prop by year and sex&#x27;</span>,</span><br><span class="line">   .....:            yticks=np.linspace(<span class="number">0</span>, <span class="number">1.2</span>, <span class="number">13</span>), xticks=<span class="built_in">range</span>(<span class="number">1880</span>, <span class="number">2020</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-63e1ddc326a033b9.png" class="" title="图14-6 分性别统计的前1000个名字在总出生人数中的比例">
<p>从图中可以看出，名字的多样性确实出现了增长（前1000项的比例降低）。另一个办法是计算占总出生人数前50%的不同名字的数量，这个数字不太好计算。我们只考虑2010年男孩的名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">118</span>]: df = boys[boys.year == <span class="number">2010</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">119</span>]: df</span><br><span class="line">Out[<span class="number">119</span>]: </span><br><span class="line">           name sex  births  year      prop</span><br><span class="line"><span class="number">260877</span>    Jacob   M   <span class="number">21875</span>  <span class="number">2010</span>  <span class="number">0.011523</span></span><br><span class="line"><span class="number">260878</span>    Ethan   M   <span class="number">17866</span>  <span class="number">2010</span>  <span class="number">0.009411</span></span><br><span class="line"><span class="number">260879</span>  Michael   M   <span class="number">17133</span>  <span class="number">2010</span>  <span class="number">0.009025</span></span><br><span class="line"><span class="number">260880</span>   Jayden   M   <span class="number">17030</span>  <span class="number">2010</span>  <span class="number">0.008971</span></span><br><span class="line"><span class="number">260881</span>  William   M   <span class="number">16870</span>  <span class="number">2010</span>  <span class="number">0.008887</span></span><br><span class="line"><span class="meta">... </span>        ...  ..     ...   ...       ...</span><br><span class="line"><span class="number">261872</span>   Camilo   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261873</span>   Destin   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261874</span>   Jaquan   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261875</span>   Jaydan   M     <span class="number">194</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line"><span class="number">261876</span>   Maxton   M     <span class="number">193</span>  <span class="number">2010</span>  <span class="number">0.000102</span></span><br><span class="line">[<span class="number">1000</span> rows x <span class="number">5</span> columns]</span><br></pre></td></tr></table></figure>
<p>在对<code>prop</code>降序排列之后，我们想知道前面多少个名字的人数加起来才够50%。虽然编写一个for循环确实也能达到目的，但<code>NumPy</code>有一种更聪明的矢量方式。先计算<code>prop</code>的累计和<code>cumsum</code>，然后再通过<code>searchsorted</code>方法找出0.5应该被插入在哪个位置才能保证不破坏顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">120</span>]: prop_cumsum = df.sort_values(by=<span class="string">&#x27;prop&#x27;</span>, ascending=<span class="literal">False</span>).prop.cumsum()</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: prop_cumsum[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line"><span class="number">260877</span>    <span class="number">0.011523</span></span><br><span class="line"><span class="number">260878</span>    <span class="number">0.020934</span></span><br><span class="line"><span class="number">260879</span>    <span class="number">0.029959</span></span><br><span class="line"><span class="number">260880</span>    <span class="number">0.038930</span></span><br><span class="line"><span class="number">260881</span>    <span class="number">0.047817</span></span><br><span class="line"><span class="number">260882</span>    <span class="number">0.056579</span></span><br><span class="line"><span class="number">260883</span>    <span class="number">0.065155</span></span><br><span class="line"><span class="number">260884</span>    <span class="number">0.073414</span></span><br><span class="line"><span class="number">260885</span>    <span class="number">0.081528</span></span><br><span class="line"><span class="number">260886</span>    <span class="number">0.089621</span></span><br><span class="line">Name: prop, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: prop_cumsum.values.searchsorted(<span class="number">0.5</span>)</span><br><span class="line">Out[<span class="number">122</span>]: <span class="number">116</span></span><br></pre></td></tr></table></figure>
<p>由于数组索引是从0开始的，因此我们要给这个结果加1，即最终结果为117。拿1900年的数据来做个比较，这个数字要小得多：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">123</span>]: df = boys[boys.year == <span class="number">1900</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: in1900 = df.sort_values(by=<span class="string">&#x27;prop&#x27;</span>, ascending=<span class="literal">False</span>).prop.cumsum()</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: in1900.values.searchsorted(<span class="number">0.5</span>) + <span class="number">1</span></span><br><span class="line">Out[<span class="number">125</span>]: <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>现在就可以对所有<code>year/sex</code>组合执行这个计算了。按这两个字段进行<code>groupby</code>处理，然后用一个函数计算各分组的这个值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_quantile_count</span>(<span class="params">group, q=<span class="number">0.5</span></span>):</span><br><span class="line">    group = group.sort_values(by=<span class="string">&#x27;prop&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> group.prop.cumsum().values.searchsorted(q) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">diversity = top1000.groupby([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]).apply(get_quantile_count)</span><br><span class="line">diversity = diversity.unstack(<span class="string">&#x27;sex&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>现在，<code>diversity</code>这个<code>DataFrame</code>拥有两个时间序列（每个性别各一个，按年度索引）。通过<code>IPython</code>，你可以查看其内容，还可以像之前那样绘制图表（如图14-7所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: diversity.head()</span><br><span class="line">Out[<span class="number">128</span>]: </span><br><span class="line">sex    F   M</span><br><span class="line">year        </span><br><span class="line"><span class="number">1880</span>  <span class="number">38</span>  <span class="number">14</span></span><br><span class="line"><span class="number">1881</span>  <span class="number">38</span>  <span class="number">14</span></span><br><span class="line"><span class="number">1882</span>  <span class="number">38</span>  <span class="number">15</span></span><br><span class="line"><span class="number">1883</span>  <span class="number">39</span>  <span class="number">15</span></span><br><span class="line"><span class="number">1884</span>  <span class="number">39</span>  <span class="number">16</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: diversity.plot(title=<span class="string">&quot;Number of popular names in top 50%&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-574b53a383cad681.png" class="" title="图14-7 按年度统计的密度表">
<p>从图中可以看出，女孩名字的多样性总是比男孩的高，而且还在变得越来越高。读者们可以自己分析一下具体是什么在驱动这个多样性（比如拼写形式的变化）。</p>
<h3 id="最后一个字母的变革">14.3.3 “最后一个字母”的变革</h3>
<p>2007年，一名婴儿姓名研究人员Laura Wattenberg在她自己的网站上指出（ http://www.babynamewizard.com ）：近百年来，男孩名字在最后一个字母上的分布发生了显著的变化。为了了解具体的情况，我首先将全部出生数据在年度、性别以及末字母上进行了聚合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># extract last letter from name column</span></span><br><span class="line">get_last_letter = <span class="keyword">lambda</span> x: x[-<span class="number">1</span>]</span><br><span class="line">last_letters = names.name.<span class="built_in">map</span>(get_last_letter)</span><br><span class="line">last_letters.name = <span class="string">&#x27;last_letter&#x27;</span></span><br><span class="line"></span><br><span class="line">table = names.pivot_table(<span class="string">&#x27;births&#x27;</span>, index=last_letters,</span><br><span class="line">                          columns=[<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;year&#x27;</span>], aggfunc=<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>
<p>然后，我选出具有一定代表性的三年，并输出前面几行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">131</span>]: subtable = table.reindex(columns=[<span class="number">1910</span>, <span class="number">1960</span>, <span class="number">2010</span>], level=<span class="string">&#x27;year&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: subtable.head()</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">sex                 F                            M                    </span><br><span class="line">year             <span class="number">1910</span>      <span class="number">1960</span>      <span class="number">2010</span>     <span class="number">1910</span>      <span class="number">1960</span>      <span class="number">2010</span></span><br><span class="line">last_letter                                                           </span><br><span class="line">a            <span class="number">108376.0</span>  <span class="number">691247.0</span>  <span class="number">670605.0</span>    <span class="number">977.0</span>    <span class="number">5204.0</span>   <span class="number">28438.0</span></span><br><span class="line">b                 NaN     <span class="number">694.0</span>     <span class="number">450.0</span>    <span class="number">411.0</span>    <span class="number">3912.0</span>   <span class="number">38859.0</span></span><br><span class="line">c                 <span class="number">5.0</span>      <span class="number">49.0</span>     <span class="number">946.0</span>    <span class="number">482.0</span>   <span class="number">15476.0</span>   <span class="number">23125.0</span></span><br><span class="line">d              <span class="number">6750.0</span>    <span class="number">3729.0</span>    <span class="number">2607.0</span>  <span class="number">22111.0</span>  <span class="number">262112.0</span>   <span class="number">44398.0</span></span><br><span class="line">e            <span class="number">133569.0</span>  <span class="number">435013.0</span>  <span class="number">313833.0</span>  <span class="number">28655.0</span>  <span class="number">178823.0</span>  <span class="number">129012.0</span></span><br></pre></td></tr></table></figure>
<p>接下来我们需要按总出生数对该表进行规范化处理，以便计算出各性别各末字母占总出生人数的比例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">133</span>]: subtable.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">sex  year</span><br><span class="line">F    <span class="number">1910</span>     <span class="number">396416.0</span></span><br><span class="line">     <span class="number">1960</span>    <span class="number">2022062.0</span></span><br><span class="line">     <span class="number">2010</span>    <span class="number">1759010.0</span></span><br><span class="line">M    <span class="number">1910</span>     <span class="number">194198.0</span></span><br><span class="line">     <span class="number">1960</span>    <span class="number">2132588.0</span></span><br><span class="line"><span class="number">2010</span>    <span class="number">1898382.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: letter_prop = subtable / subtable.<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: letter_prop</span><br><span class="line">Out[<span class="number">135</span>]: </span><br><span class="line">sex                 F                             M                    </span><br><span class="line">year             <span class="number">1910</span>      <span class="number">1960</span>      <span class="number">2010</span>      <span class="number">1910</span>      <span class="number">1960</span>      <span class="number">2010</span></span><br><span class="line">last_letter                                                            </span><br><span class="line">a            <span class="number">0.273390</span>  <span class="number">0.341853</span>  <span class="number">0.381240</span>  <span class="number">0.005031</span>  <span class="number">0.002440</span>  <span class="number">0.014980</span></span><br><span class="line">b                 NaN  <span class="number">0.000343</span>  <span class="number">0.000256</span>  <span class="number">0.002116</span>  <span class="number">0.001834</span>  <span class="number">0.020470</span></span><br><span class="line">c            <span class="number">0.000013</span>  <span class="number">0.000024</span>  <span class="number">0.000538</span>  <span class="number">0.002482</span>  <span class="number">0.007257</span>  <span class="number">0.012181</span></span><br><span class="line">d            <span class="number">0.017028</span>  <span class="number">0.001844</span>  <span class="number">0.001482</span>  <span class="number">0.113858</span>  <span class="number">0.122908</span>  <span class="number">0.023387</span></span><br><span class="line">e            <span class="number">0.336941</span>  <span class="number">0.215133</span>  <span class="number">0.178415</span>  <span class="number">0.147556</span>  <span class="number">0.083853</span>  <span class="number">0.067959</span></span><br><span class="line"><span class="meta">... </span>              ...       ...       ...       ...       ...       ...</span><br><span class="line">v                 NaN  <span class="number">0.000060</span>  <span class="number">0.000117</span>  <span class="number">0.000113</span></span><br><span class="line"><span class="number">0.000037</span>  <span class="number">0.001434</span></span><br><span class="line">w            <span class="number">0.000020</span>  <span class="number">0.000031</span>  <span class="number">0.001182</span>  <span class="number">0.006329</span>  <span class="number">0.007711</span>  <span class="number">0.016148</span></span><br><span class="line">x            <span class="number">0.000015</span>  <span class="number">0.000037</span>  <span class="number">0.000727</span>  <span class="number">0.003965</span>  <span class="number">0.001851</span>  <span class="number">0.008614</span></span><br><span class="line">y            <span class="number">0.110972</span>  <span class="number">0.152569</span>  <span class="number">0.116828</span>  <span class="number">0.077349</span>  <span class="number">0.160987</span>  <span class="number">0.058168</span></span><br><span class="line">z            <span class="number">0.002439</span>  <span class="number">0.000659</span>  <span class="number">0.000704</span>  <span class="number">0.000170</span>  <span class="number">0.000184</span>  <span class="number">0.001831</span></span><br><span class="line">[<span class="number">26</span> rows x <span class="number">6</span> columns]</span><br></pre></td></tr></table></figure>
<p>有了这个字母比例数据之后，就可以生成一张各年度各性别的条形图了，如图14-8所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">1</span>, figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">letter_prop[<span class="string">&#x27;M&#x27;</span>].plot(kind=<span class="string">&#x27;bar&#x27;</span>, rot=<span class="number">0</span>, ax=axes[<span class="number">0</span>], title=<span class="string">&#x27;Male&#x27;</span>)</span><br><span class="line">letter_prop[<span class="string">&#x27;F&#x27;</span>].plot(kind=<span class="string">&#x27;bar&#x27;</span>, rot=<span class="number">0</span>, ax=axes[<span class="number">1</span>], title=<span class="string">&#x27;Female&#x27;</span>,</span><br><span class="line">                      legend=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-67686f38e66ef5f1.png" class="" title="图14-8 男孩女孩名字中各个末字母的比例">
<p>可以看出，从20世纪60年代开始，以字母"n"结尾的男孩名字出现了显著的增长。回到之前创建的那个完整表，按年度和性别对其进行规范化处理，并在男孩名字中选取几个字母，最后进行转置以便将各个列做成一个时间序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">138</span>]: letter_prop = table / table.<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: dny_ts = letter_prop.loc[[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;y&#x27;</span>], <span class="string">&#x27;M&#x27;</span>].T</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: dny_ts.head()</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">last_letter         d         n         y</span><br><span class="line">year                                     </span><br><span class="line"><span class="number">1880</span>         <span class="number">0.083055</span>  <span class="number">0.153213</span>  <span class="number">0.075760</span></span><br><span class="line"><span class="number">1881</span>         <span class="number">0.083247</span>  <span class="number">0.153214</span>  <span class="number">0.077451</span></span><br><span class="line"><span class="number">1882</span>         <span class="number">0.085340</span>  <span class="number">0.149560</span>  <span class="number">0.077537</span></span><br><span class="line"><span class="number">1883</span>         <span class="number">0.084066</span>  <span class="number">0.151646</span>  <span class="number">0.079144</span></span><br><span class="line"><span class="number">1884</span>         <span class="number">0.086120</span>  <span class="number">0.149915</span>  <span class="number">0.080405</span></span><br></pre></td></tr></table></figure>
<p>有了这个时间序列的DataFrame之后，就可以通过其plot方法绘制出一张趋势图了（如图14-9所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">143</span>]: dny_ts.plot()</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-51c431b2490424c2.png" class="" title="图14-9 各年出生的男孩中名字以d&#x2F;n&#x2F;y结尾的人数比例">
<h3 id="变成女孩名字的男孩名字以及相反的情况">14.3.4 变成女孩名字的男孩名字（以及相反的情况）</h3>
<p>另一个有趣的趋势是，早年流行于男孩的名字近年来“变性了”，例如Lesley或Leslie。回到top1000数据集，找出其中以"lesl"开头的一组名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">144</span>]: all_names = pd.Series(top1000.name.unique())</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: lesley_like = all_names[all_names.<span class="built_in">str</span>.lower().<span class="built_in">str</span>.contains(<span class="string">&#x27;lesl&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: lesley_like</span><br><span class="line">Out[<span class="number">146</span>]: </span><br><span class="line"><span class="number">632</span>     Leslie</span><br><span class="line"><span class="number">2294</span>    Lesley</span><br><span class="line"><span class="number">4262</span>    Leslee</span><br><span class="line"><span class="number">4728</span>     Lesli</span><br><span class="line"><span class="number">6103</span>     Lesly</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>然后利用这个结果过滤其他的名字，并按名字分组计算出生数以查看相对频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">147</span>]: filtered = top1000[top1000.name.isin(lesley_like)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: filtered.groupby(<span class="string">&#x27;name&#x27;</span>).births.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">148</span>]: </span><br><span class="line">name</span><br><span class="line">Leslee      <span class="number">1082</span></span><br><span class="line">Lesley     <span class="number">35022</span></span><br><span class="line">Lesli        <span class="number">929</span></span><br><span class="line">Leslie    <span class="number">370429</span></span><br><span class="line">Lesly      <span class="number">10067</span></span><br><span class="line">Name: births, dtype: int64</span><br></pre></td></tr></table></figure>
<p>接下来，我们按性别和年度进行聚合，并按年度进行规范化处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">149</span>]: table = filtered.pivot_table(<span class="string">&#x27;births&#x27;</span>, index=<span class="string">&#x27;year&#x27;</span>,</span><br><span class="line">   .....:                              columns=<span class="string">&#x27;sex&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">150</span>]: table = table.div(table.<span class="built_in">sum</span>(<span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: table.tail()</span><br><span class="line">Out[<span class="number">151</span>]: </span><br><span class="line">sex     F   M</span><br><span class="line">year         </span><br><span class="line"><span class="number">2006</span>  <span class="number">1.0</span> NaN</span><br><span class="line"><span class="number">2007</span>  <span class="number">1.0</span> NaN</span><br><span class="line"><span class="number">2008</span>  <span class="number">1.0</span> NaN</span><br><span class="line"><span class="number">2009</span>  <span class="number">1.0</span> NaN</span><br><span class="line"><span class="number">2010</span>  <span class="number">1.0</span> NaN</span><br></pre></td></tr></table></figure>
<p>最后，就可以轻松绘制一张分性别的年度曲线图了（如图2-10所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">153</span>]: table.plot(style=&#123;<span class="string">&#x27;M&#x27;</span>: <span class="string">&#x27;k-&#x27;</span>, <span class="string">&#x27;F&#x27;</span>: <span class="string">&#x27;k--&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-b99d98f8bb5fc695.png" class="" title="图14-10 各年度使用“Lesley型”名字的男女比例">
<h2 id="usda食品数据库">14.4 USDA食品数据库</h2>
<p>美国农业部（USDA）制作了一份有关食物营养信息的数据库。Ashley Williams制作了该数据的JSON版（http://ashleyw.co.uk/project/food-nutrient-database）。其中的记录如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">21441</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;KENTUCKY FRIED CHICKEN, Fried Chicken, EXTRA CRISPY,</span></span><br><span class="line"><span class="string">Wing, meat and skin with breading&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;KFC&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;manufacturer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Kentucky Fried Chicken&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Fast Foods&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;portions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;amount&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;unit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wing, with skin&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;grams&quot;</span><span class="punctuation">:</span> <span class="number">68.0</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;nutrients&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">20.8</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;units&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Protein&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Composition&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>每种食物都带有若干标识性属性以及两个有关营养成分和分量的列表。这种形式的数据不是很适合分析工作，因此我们需要做一些规整化以使其具有更好用的形式。</p>
<p>从上面列举的那个网址下载并解压数据之后，你可以用任何喜欢的JSON库将其加载到Python中。我用的是Python内置的json模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: db = json.load(<span class="built_in">open</span>(<span class="string">&#x27;datasets/usda_food/database.json&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: <span class="built_in">len</span>(db)</span><br><span class="line">Out[<span class="number">156</span>]: <span class="number">6636</span></span><br></pre></td></tr></table></figure>
<p>db中的每个条目都是一个含有某种食物全部数据的字典。nutrients字段是一个字典列表，其中的每个字典对应一种营养成分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">157</span>]: db[<span class="number">0</span>].keys()</span><br><span class="line">Out[<span class="number">157</span>]: dict_keys([<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;tags&#x27;</span>, <span class="string">&#x27;manufacturer&#x27;</span>, <span class="string">&#x27;group&#x27;</span>, <span class="string">&#x27;porti</span></span><br><span class="line"><span class="string">ons&#x27;</span>, <span class="string">&#x27;nutrients&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: db[<span class="number">0</span>][<span class="string">&#x27;nutrients&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">&#123;<span class="string">&#x27;description&#x27;</span>: <span class="string">&#x27;Protein&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;group&#x27;</span>: <span class="string">&#x27;Composition&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;units&#x27;</span>: <span class="string">&#x27;g&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;value&#x27;</span>: <span class="number">25.18</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: nutrients = pd.DataFrame(db[<span class="number">0</span>][<span class="string">&#x27;nutrients&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">160</span>]: nutrients[:<span class="number">7</span>]</span><br><span class="line">Out[<span class="number">160</span>]: </span><br><span class="line">                   description        group units    value</span><br><span class="line"><span class="number">0</span>                      Protein  Composition     g    <span class="number">25.18</span></span><br><span class="line"><span class="number">1</span>            Total lipid (fat)  Composition     g    <span class="number">29.20</span></span><br><span class="line"><span class="number">2</span>  Carbohydrate, by difference  Composition     g     <span class="number">3.06</span></span><br><span class="line"><span class="number">3</span>                          Ash        Other     g     <span class="number">3.28</span></span><br><span class="line"><span class="number">4</span>                       Energy       Energy  kcal   <span class="number">376.00</span></span><br><span class="line"><span class="number">5</span>                        Water  Composition     g    <span class="number">39.28</span></span><br><span class="line"><span class="number">6</span>                       Energy       Energy    kJ  <span class="number">1573.00</span></span><br></pre></td></tr></table></figure>
<p>在将字典列表转换为DataFrame时，可以只抽取其中的一部分字段。这里，我们将取出食物的名称、分类、编号以及制造商等信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">161</span>]: info_keys = [<span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;group&#x27;</span>, <span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;manufacturer&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: info = pd.DataFrame(db, columns=info_keys)</span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: info[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">163</span>]: </span><br><span class="line">                          description                   group    <span class="built_in">id</span>  \</span><br><span class="line"><span class="number">0</span>                     Cheese, caraway  Dairy <span class="keyword">and</span> Egg Products  <span class="number">1008</span>   </span><br><span class="line"><span class="number">1</span>                     Cheese, cheddar  Dairy <span class="keyword">and</span> Egg Products  <span class="number">1009</span></span><br><span class="line"><span class="number">2</span>                        Cheese, edam  Dairy <span class="keyword">and</span> Egg Products  <span class="number">1018</span>   </span><br><span class="line"><span class="number">3</span>                        Cheese, feta  Dairy <span class="keyword">and</span> Egg Products  <span class="number">1019</span>   </span><br><span class="line"><span class="number">4</span>  Cheese, mozzarella, part skim milk  Dairy <span class="keyword">and</span> Egg Products  <span class="number">1028</span>   </span><br><span class="line">  manufacturer  </span><br><span class="line"><span class="number">0</span>               </span><br><span class="line"><span class="number">1</span>               </span><br><span class="line"><span class="number">2</span>               </span><br><span class="line"><span class="number">3</span>               </span><br><span class="line"><span class="number">4</span>               </span><br><span class="line"></span><br><span class="line">In [<span class="number">164</span>]: info.info()</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;</span><br><span class="line">RangeIndex: <span class="number">6636</span> entries, <span class="number">0</span> to <span class="number">6635</span></span><br><span class="line">Data columns (total <span class="number">4</span> columns):</span><br><span class="line">description     <span class="number">6636</span> non-null <span class="built_in">object</span></span><br><span class="line">group           <span class="number">6636</span> non-null <span class="built_in">object</span></span><br><span class="line"><span class="built_in">id</span>              <span class="number">6636</span> non-null int64</span><br><span class="line">manufacturer    <span class="number">5195</span> non-null <span class="built_in">object</span></span><br><span class="line">dtypes: int64(<span class="number">1</span>), <span class="built_in">object</span>(<span class="number">3</span>)</span><br><span class="line">memory usage: <span class="number">207.5</span>+ KB</span><br></pre></td></tr></table></figure>
<p>通过<code>value_counts</code>，你可以查看食物类别的分布情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: pd.value_counts(info.group)[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">165</span>]: </span><br><span class="line">Vegetables <span class="keyword">and</span> Vegetable Products    <span class="number">812</span></span><br><span class="line">Beef Products                        <span class="number">618</span></span><br><span class="line">Baked Products                       <span class="number">496</span></span><br><span class="line">Breakfast Cereals                    <span class="number">403</span></span><br><span class="line">Fast Foods                           <span class="number">365</span></span><br><span class="line">Legumes <span class="keyword">and</span> Legume Products          <span class="number">365</span></span><br><span class="line">Lamb, Veal, <span class="keyword">and</span> Game Products        <span class="number">345</span></span><br><span class="line">Sweets                               <span class="number">341</span></span><br><span class="line">Pork Products                        <span class="number">328</span></span><br><span class="line">Fruits <span class="keyword">and</span> Fruit Juices              <span class="number">328</span></span><br><span class="line">Name: group, dtype: int64</span><br></pre></td></tr></table></figure>
<p>现在，为了对全部营养数据做一些分析，最简单的办法是将所有食物的营养成分整合到一个大表中。我们分几个步骤来实现该目的。首先，将各食物的营养成分列表转换为一个<code>DataFrame</code>，并添加一个表示编号的列，然后将该<code>DataFrame</code>添加到一个列表中。最后通过<code>concat</code>将这些东西连接起来就可以了：</p>
<p>顺利的话，nutrients的结果是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">167</span>]: nutrients</span><br><span class="line">Out[<span class="number">167</span>]: </span><br><span class="line">                               description        group units    value     <span class="built_in">id</span></span><br><span class="line"><span class="number">0</span>                                  Protein  Composition     g   <span class="number">25.180</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">1</span>                        Total lipid (fat)  Composition     g   <span class="number">29.200</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">2</span>              Carbohydrate, by difference  Composition     g    <span class="number">3.060</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">3</span>                                      Ash        Other     g    <span class="number">3.280</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">4</span>                                   Energy       Energy  kcal  <span class="number">376.000</span>   <span class="number">1008</span></span><br><span class="line"><span class="meta">... </span>                                   ...          ...</span><br><span class="line"><span class="meta">... </span>     ...    ...</span><br><span class="line"><span class="number">389350</span>                 Vitamin B-<span class="number">12</span>, added     Vitamins   mcg    <span class="number">0.000</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389351</span>                         Cholesterol        Other    mg    <span class="number">0.000</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389352</span>        Fatty acids, total saturated        Other     g    <span class="number">0.072</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389353</span>  Fatty acids, total monounsaturated        Other     g    <span class="number">0.028</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389354</span>  Fatty acids, total polyunsaturated        Other     g    <span class="number">0.041</span>  <span class="number">43546</span></span><br><span class="line">[<span class="number">389355</span> rows x <span class="number">5</span> columns]</span><br></pre></td></tr></table></figure>
<p>我发现这个DataFrame中无论如何都会有一些重复项，所以直接丢弃就可以了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">168</span>]: nutrients.duplicated().<span class="built_in">sum</span>()  <span class="comment"># number of duplicates</span></span><br><span class="line">Out[<span class="number">168</span>]: <span class="number">14179</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: nutrients = nutrients.drop_duplicates()</span><br></pre></td></tr></table></figure>
<p>由于两个<code>DataFrame</code>对象中都有"<code>group</code>"和"<code>description</code>"，所以为了明确到底谁是谁，我们需要对它们进行重命名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">170</span>]: col_mapping = &#123;<span class="string">&#x27;description&#x27;</span> : <span class="string">&#x27;food&#x27;</span>,</span><br><span class="line">   .....:                <span class="string">&#x27;group&#x27;</span>       : <span class="string">&#x27;fgroup&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">171</span>]: info = info.rename(columns=col_mapping, copy=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">172</span>]: info.info()</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;</span><br><span class="line">RangeIndex: <span class="number">6636</span> entries, <span class="number">0</span> to <span class="number">6635</span></span><br><span class="line">Data columns (total <span class="number">4</span> columns):</span><br><span class="line">food            <span class="number">6636</span> non-null <span class="built_in">object</span></span><br><span class="line">fgroup          <span class="number">6636</span> non-null <span class="built_in">object</span></span><br><span class="line"><span class="built_in">id</span>              <span class="number">6636</span> non-null int64</span><br><span class="line">manufacturer    <span class="number">5195</span> non-null <span class="built_in">object</span></span><br><span class="line">dtypes: int64(<span class="number">1</span>), <span class="built_in">object</span>(<span class="number">3</span>)</span><br><span class="line">memory usage: <span class="number">207.5</span>+ KB</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: col_mapping = &#123;<span class="string">&#x27;description&#x27;</span> : <span class="string">&#x27;nutrient&#x27;</span>,</span><br><span class="line">   .....:                <span class="string">&#x27;group&#x27;</span> : <span class="string">&#x27;nutgroup&#x27;</span>&#125;</span><br><span class="line">In [<span class="number">174</span>]: nutrients = nutrients.rename(columns=col_mapping, copy=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">175</span>]: nutrients</span><br><span class="line">Out[<span class="number">175</span>]: </span><br><span class="line">                                  nutrient     nutgroup units    value     <span class="built_in">id</span></span><br><span class="line"><span class="number">0</span>                                  Protein  Composition     g   <span class="number">25.180</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">1</span>                        Total lipid (fat)  Composition     g   <span class="number">29.200</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">2</span>              Carbohydrate, by difference  Composition     g    <span class="number">3.060</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">3</span>                                      Ash        Other     g    <span class="number">3.280</span>   <span class="number">1008</span></span><br><span class="line"><span class="number">4</span>                                   Energy       Energy  kcal  <span class="number">376.000</span>   <span class="number">1008</span></span><br><span class="line"><span class="meta">... </span>                                   ...          ...   ...      ...    ...</span><br><span class="line"><span class="number">389350</span>                 Vitamin B-<span class="number">12</span>, added     Vitamins   mcg    <span class="number">0.000</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389351</span>                         Cholesterol        Other    mg    <span class="number">0.000</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389352</span>        Fatty acids, total saturated        Other     g    <span class="number">0.072</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389353</span>  Fatty acids, total monounsaturated        Other     g    <span class="number">0.028</span>  <span class="number">43546</span></span><br><span class="line"><span class="number">389354</span>  Fatty acids, total polyunsaturated        Other     g    <span class="number">0.041</span>  <span class="number">43546</span></span><br><span class="line">[<span class="number">375176</span> rows x <span class="number">5</span> columns]</span><br></pre></td></tr></table></figure>
<p>做完这些，就可以将<code>info</code>跟nutrients合并起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">176</span>]: ndata = pd.merge(nutrients, info, on=<span class="string">&#x27;id&#x27;</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: ndata.info()</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;</span><br><span class="line">Int64Index: <span class="number">375176</span> entries, <span class="number">0</span> to <span class="number">375175</span></span><br><span class="line">Data columns (total <span class="number">8</span> columns):</span><br><span class="line">nutrient        <span class="number">375176</span> non-null <span class="built_in">object</span></span><br><span class="line">nutgroup        <span class="number">375176</span> non-null <span class="built_in">object</span></span><br><span class="line">units           <span class="number">375176</span> non-null <span class="built_in">object</span></span><br><span class="line">value           <span class="number">375176</span> non-null float64</span><br><span class="line"><span class="built_in">id</span>              <span class="number">375176</span> non-null int64</span><br><span class="line">food            <span class="number">375176</span> non-null <span class="built_in">object</span></span><br><span class="line">fgroup          <span class="number">375176</span> non-null <span class="built_in">object</span></span><br><span class="line">manufacturer    <span class="number">293054</span> non-null <span class="built_in">object</span></span><br><span class="line">dtypes: float64(<span class="number">1</span>), int64(<span class="number">1</span>), <span class="built_in">object</span>(<span class="number">6</span>)</span><br><span class="line">memory usage: <span class="number">25.8</span>+ MB</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: ndata.iloc[<span class="number">30000</span>]</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">nutrient                                       Glycine</span><br><span class="line">nutgroup                                   Amino Acids</span><br><span class="line">units                                                g</span><br><span class="line">value                                             <span class="number">0.04</span></span><br><span class="line"><span class="built_in">id</span>                                                <span class="number">6158</span></span><br><span class="line">food            Soup, tomato bisque, canned, condensed</span><br><span class="line">fgroup                      Soups, Sauces, <span class="keyword">and</span> Gravies</span><br><span class="line">manufacturer                                          </span><br><span class="line">Name: <span class="number">30000</span>, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>我们现在可以根据食物分类和营养类型画出一张中位值图（如图14-11所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">180</span>]: result = ndata.groupby([<span class="string">&#x27;nutrient&#x27;</span>, <span class="string">&#x27;fgroup&#x27;</span>])[<span class="string">&#x27;value&#x27;</span>].quantile(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: result[<span class="string">&#x27;Zinc, Zn&#x27;</span>].sort_values().plot(kind=<span class="string">&#x27;barh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-99b176d022a444c0.png" class="" title="图14-11 根据营养分类得出的锌中位值">
<p>只要稍微动一动脑子，就可以发现各营养成分最为丰富的食物是什么了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">by_nutrient = ndata.groupby([<span class="string">&#x27;nutgroup&#x27;</span>, <span class="string">&#x27;nutrient&#x27;</span>])</span><br><span class="line"></span><br><span class="line">get_maximum = <span class="keyword">lambda</span> x: x.loc[x.value.idxmax()]</span><br><span class="line">get_minimum = <span class="keyword">lambda</span> x: x.loc[x.value.idxmin()]</span><br><span class="line"></span><br><span class="line">max_foods = by_nutrient.apply(get_maximum)[[<span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;food&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># make the food a little smaller</span></span><br><span class="line">max_foods.food = max_foods.food.<span class="built_in">str</span>[:<span class="number">50</span>]</span><br></pre></td></tr></table></figure>
<p>由于得到的DataFrame很大，所以不方便在书里面全部打印出来。这里只给出"Amino Acids"营养分组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">183</span>]: max_foods.loc[<span class="string">&#x27;Amino Acids&#x27;</span>][<span class="string">&#x27;food&#x27;</span>]</span><br><span class="line">Out[<span class="number">183</span>]: </span><br><span class="line">nutrient</span><br><span class="line">Alanine                          Gelatins, dry powder, unsweetened</span><br><span class="line">Arginine                              Seeds, sesame flour, low-fat</span><br><span class="line">Aspartic acid                                  Soy protein isolate</span><br><span class="line">Cystine               Seeds, cottonseed flour, low fat (glandless)</span><br><span class="line">Glutamic acid                                  Soy protein isolate</span><br><span class="line">                                       ...                        </span><br><span class="line">Serine           Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span><br><span class="line">Threonine        Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span><br><span class="line">Tryptophan        Sea lion, Steller, meat <span class="keyword">with</span> fat (Alaska Native)</span><br><span class="line">Tyrosine         Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span><br><span class="line">Valine           Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span><br><span class="line">Name: food, Length: <span class="number">19</span>, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<h2 id="联邦选举委员会数据库">14.5 2012联邦选举委员会数据库</h2>
<p>美国联邦选举委员会发布了有关政治竞选赞助方面的数据。其中包括赞助者的姓名、职业、雇主、地址以及出资额等信息。我们对2012年美国总统大选的数据集比较感兴趣（http://www.fec.gov/disclosurep/PDownload.do ）。我在2012年6月下载的数据集是一个150MB的CSV文件（P00000001-ALL.csv），我们先用pandas.read_csv将其加载进来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">184</span>]: fec = pd.read_csv(<span class="string">&#x27;datasets/fec/P00000001-ALL.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: fec.info()</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;</span><br><span class="line">RangeIndex: <span class="number">1001731</span> entries, <span class="number">0</span> to <span class="number">1001730</span></span><br><span class="line">Data columns (total <span class="number">16</span> columns):</span><br><span class="line">cmte_id              <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">cand_id              <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">cand_nm              <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_nm            <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_city          <span class="number">1001712</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_st            <span class="number">1001727</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_zip           <span class="number">1001620</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_employer      <span class="number">988002</span> non-null <span class="built_in">object</span></span><br><span class="line">contbr_occupation    <span class="number">993301</span> non-null <span class="built_in">object</span></span><br><span class="line">contb_receipt_amt    <span class="number">1001731</span> non-null float64</span><br><span class="line">contb_receipt_dt     <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">receipt_desc         <span class="number">14166</span> non-null <span class="built_in">object</span></span><br><span class="line">memo_cd              <span class="number">92482</span> non-null <span class="built_in">object</span></span><br><span class="line">memo_text            <span class="number">97770</span> non-null <span class="built_in">object</span></span><br><span class="line">form_tp              <span class="number">1001731</span> non-null <span class="built_in">object</span></span><br><span class="line">file_num             <span class="number">1001731</span> non-null int64</span><br><span class="line">dtypes: float64(<span class="number">1</span>), int64(<span class="number">1</span>), <span class="built_in">object</span>(<span class="number">14</span>)</span><br><span class="line">memory usage: <span class="number">122.3</span>+ MB</span><br></pre></td></tr></table></figure>
<p>该DataFrame中的记录如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">186</span>]: fec.iloc[<span class="number">123456</span>]</span><br><span class="line">Out[<span class="number">186</span>]: </span><br><span class="line">cmte_id             C00431445</span><br><span class="line">cand_id             P80003338</span><br><span class="line">cand_nm         Obama, Barack</span><br><span class="line">contbr_nm         ELLMAN, IRA</span><br><span class="line">contbr_city             TEMPE</span><br><span class="line">                    ...      </span><br><span class="line">receipt_desc              NaN</span><br><span class="line">memo_cd                   NaN</span><br><span class="line">memo_text                 NaN</span><br><span class="line">form_tp                 SA17A</span><br><span class="line">file_num               <span class="number">772372</span></span><br><span class="line">Name: <span class="number">123456</span>, Length: <span class="number">16</span>, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>你可能已经想出了许多办法从这些竞选赞助数据中抽取有关赞助人和赞助模式的统计信息。我将在接下来的内容中介绍几种不同的分析工作（运用到目前为止已经学到的方法）。</p>
<p>不难看出，该数据中没有党派信息，因此最好把它加进去。通过unique，你可以获取全部的候选人名单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">187</span>]: unique_cands = fec.cand_nm.unique()</span><br><span class="line"></span><br><span class="line">In [<span class="number">188</span>]: unique_cands</span><br><span class="line">Out[<span class="number">188</span>]: </span><br><span class="line">array([<span class="string">&#x27;Bachmann, Michelle&#x27;</span>, <span class="string">&#x27;Romney, Mitt&#x27;</span>, <span class="string">&#x27;Obama, Barack&#x27;</span>,</span><br><span class="line">       <span class="string">&quot;Roemer, Charles E. &#x27;Buddy&#x27; III&quot;</span>, <span class="string">&#x27;Pawlenty, Timothy&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Johnson, Gary Earl&#x27;</span>, <span class="string">&#x27;Paul, Ron&#x27;</span>, <span class="string">&#x27;Santorum, Rick&#x27;</span>, <span class="string">&#x27;Cain, Herman&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Gingrich, Newt&#x27;</span>, <span class="string">&#x27;McCotter, Thaddeus G&#x27;</span>, <span class="string">&#x27;Huntsman, Jon&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Perry, Rick&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: unique_cands[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">189</span>]: <span class="string">&#x27;Obama, Barack&#x27;</span></span><br></pre></td></tr></table></figure>
<p>指明党派信息的方法之一是使用字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parties = &#123;<span class="string">&#x27;Bachmann, Michelle&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Cain, Herman&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Gingrich, Newt&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Huntsman, Jon&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Johnson, Gary Earl&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;McCotter, Thaddeus G&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Obama, Barack&#x27;</span>: <span class="string">&#x27;Democrat&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Paul, Ron&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Pawlenty, Timothy&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Perry, Rick&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&quot;Roemer, Charles E. &#x27;Buddy&#x27; III&quot;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Romney, Mitt&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Santorum, Rick&#x27;</span>: <span class="string">&#x27;Republican&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>现在，通过这个映射以及Series对象的map方法，你可以根据候选人姓名得到一组党派信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">191</span>]: fec.cand_nm[<span class="number">123456</span>:<span class="number">123461</span>]</span><br><span class="line">Out[<span class="number">191</span>]: </span><br><span class="line"><span class="number">123456</span>    Obama, Barack</span><br><span class="line"><span class="number">123457</span>    Obama, Barack</span><br><span class="line"><span class="number">123458</span>    Obama, Barack</span><br><span class="line"><span class="number">123459</span>    Obama, Barack</span><br><span class="line"><span class="number">123460</span>    Obama, Barack</span><br><span class="line">Name: cand_nm, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: fec.cand_nm[<span class="number">123456</span>:<span class="number">123461</span>].<span class="built_in">map</span>(parties)</span><br><span class="line">Out[<span class="number">192</span>]: </span><br><span class="line"><span class="number">123456</span>    Democrat</span><br><span class="line"><span class="number">123457</span>    Democrat</span><br><span class="line"><span class="number">123458</span>    Democrat</span><br><span class="line"><span class="number">123459</span>    Democrat</span><br><span class="line"><span class="number">123460</span>    Democrat</span><br><span class="line">Name: cand_nm, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add it as a column</span></span><br><span class="line">In [<span class="number">193</span>]: fec[<span class="string">&#x27;party&#x27;</span>] = fec.cand_nm.<span class="built_in">map</span>(parties)</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: fec[<span class="string">&#x27;party&#x27;</span>].value_counts()</span><br><span class="line">Out[<span class="number">194</span>]: </span><br><span class="line">Democrat      <span class="number">593746</span></span><br><span class="line">Republican    <span class="number">407985</span></span><br><span class="line">Name: party, dtype: int64</span><br></pre></td></tr></table></figure>
<p>这里有两个需要注意的地方。第一，该数据既包括赞助也包括退款（负的出资额）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">195</span>]: (fec.contb_receipt_amt &gt; <span class="number">0</span>).value_counts()</span><br><span class="line">Out[<span class="number">195</span>]: </span><br><span class="line"><span class="literal">True</span>     <span class="number">991475</span></span><br><span class="line"><span class="literal">False</span>     <span class="number">10256</span></span><br><span class="line">Name: contb_receipt_amt, dtype: int64</span><br></pre></td></tr></table></figure>
<p>为了简化分析过程，我限定该数据集只能有正的出资额：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">196</span>]: fec = fec[fec.contb_receipt_amt &gt; <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>由于Barack Obama和Mitt Romney是最主要的两名候选人，所以我还专门准备了一个子集，只包含针对他们两人的竞选活动的赞助信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">197</span>]: fec_mrbo = fec[fec.cand_nm.isin([<span class="string">&#x27;Obama, Barack&#x27;</span>,<span class="string">&#x27;Romney, Mitt&#x27;</span>])]</span><br></pre></td></tr></table></figure>
<p>根据职业和雇主统计赞助信息 基于职业的赞助信息统计是另一种经常被研究的统计任务。例如，律师们更倾向于资助民主党，而企业主则更倾向于资助共和党。你可以不相信我，自己看那些数据就知道了。首先，根据职业计算出资总额，这很简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">198</span>]: fec.contbr_occupation.value_counts()[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">198</span>]: </span><br><span class="line">RETIRED                                   <span class="number">233990</span></span><br><span class="line">INFORMATION REQUESTED                      <span class="number">35107</span></span><br><span class="line">ATTORNEY                                   <span class="number">34286</span></span><br><span class="line">HOMEMAKER                                  <span class="number">29931</span></span><br><span class="line">PHYSICIAN                                  <span class="number">23432</span></span><br><span class="line">INFORMATION REQUESTED PER BEST EFFORTS     <span class="number">21138</span></span><br><span class="line">ENGINEER                                   <span class="number">14334</span></span><br><span class="line">TEACHER                                    <span class="number">13990</span></span><br><span class="line">CONSULTANT                                 <span class="number">13273</span></span><br><span class="line">PROFESSOR                                  <span class="number">12555</span></span><br><span class="line">Name: contbr_occupation, dtype: int64</span><br></pre></td></tr></table></figure>
<p>不难看出，许多职业都涉及相同的基本工作类型，或者同一样东西有多种变体。下面的代码片段可以清理一些这样的数据（将一个职业信息映射到另一个）。注意，这里巧妙地利用了<code>dict.get</code>，它允许没有映射关系的职业也能“通过”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">occ_mapping = &#123;</span><br><span class="line">   <span class="string">&#x27;INFORMATION REQUESTED PER BEST EFFORTS&#x27;</span> : <span class="string">&#x27;NOT PROVIDED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;INFORMATION REQUESTED&#x27;</span> : <span class="string">&#x27;NOT PROVIDED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;INFORMATION REQUESTED (BEST EFFORTS)&#x27;</span> : <span class="string">&#x27;NOT PROVIDED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;C.E.O.&#x27;</span>: <span class="string">&#x27;CEO&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># If no mapping provided, return x</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: occ_mapping.get(x, x)</span><br><span class="line">fec.contbr_occupation = fec.contbr_occupation.<span class="built_in">map</span>(f)</span><br></pre></td></tr></table></figure>
<p>我对雇主信息也进行了同样的处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emp_mapping = &#123;</span><br><span class="line">   <span class="string">&#x27;INFORMATION REQUESTED PER BEST EFFORTS&#x27;</span> : <span class="string">&#x27;NOT PROVIDED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;INFORMATION REQUESTED&#x27;</span> : <span class="string">&#x27;NOT PROVIDED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;SELF&#x27;</span> : <span class="string">&#x27;SELF-EMPLOYED&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;SELF EMPLOYED&#x27;</span> : <span class="string">&#x27;SELF-EMPLOYED&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># If no mapping provided, return x</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: emp_mapping.get(x, x)</span><br><span class="line">fec.contbr_employer = fec.contbr_employer.<span class="built_in">map</span>(f)</span><br></pre></td></tr></table></figure>
<p>现在，你可以通过pivot_table根据党派和职业对数据进行聚合，然后过滤掉总出资额不足200万美元的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">201</span>]: by_occupation = fec.pivot_table(<span class="string">&#x27;contb_receipt_amt&#x27;</span>,</span><br><span class="line">   .....:                                 index=<span class="string">&#x27;contbr_occupation&#x27;</span>,</span><br><span class="line">   .....:                                 columns=<span class="string">&#x27;party&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">202</span>]: over_2mm = by_occupation[by_occupation.<span class="built_in">sum</span>(<span class="number">1</span>) &gt; <span class="number">2000000</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">203</span>]: over_2mm</span><br><span class="line">Out[<span class="number">203</span>]: </span><br><span class="line">party                 Democrat    Republican</span><br><span class="line">contbr_occupation                           </span><br><span class="line">ATTORNEY           <span class="number">11141982.97</span>  <span class="number">7.477194e+06</span></span><br><span class="line">CEO                 <span class="number">2074974.79</span>  <span class="number">4.211041e+06</span></span><br><span class="line">CONSULTANT          <span class="number">2459912.71</span>  <span class="number">2.544725e+06</span></span><br><span class="line">ENGINEER             <span class="number">951525.55</span>  <span class="number">1.818374e+06</span></span><br><span class="line">EXECUTIVE           <span class="number">1355161.05</span>  <span class="number">4.138850e+06</span></span><br><span class="line"><span class="meta">... </span>                       ...           ...</span><br><span class="line">PRESIDENT           <span class="number">1878509.95</span>  <span class="number">4.720924e+06</span></span><br><span class="line">PROFESSOR           <span class="number">2165071.08</span>  <span class="number">2.967027e+05</span></span><br><span class="line">REAL ESTATE          <span class="number">528902.09</span>  <span class="number">1.625902e+06</span></span><br><span class="line">RETIRED            <span class="number">25305116.38</span>  <span class="number">2.356124e+07</span></span><br><span class="line">SELF-EMPLOYED        <span class="number">672393.40</span>  <span class="number">1.640253e+06</span></span><br><span class="line">[<span class="number">17</span> rows x <span class="number">2</span> columns]</span><br></pre></td></tr></table></figure>
<p>把这些数据做成柱状图看起来会更加清楚（'<code>barh</code>'表示水平柱状图，如图14-12所示）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">205</span>]: over_2mm.plot(kind=<span class="string">&#x27;barh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-d2254e547c6ce537.png" class="" title="图14-12 对各党派总出资额最高的职业">
<p>你可能还想了解一下对Obama和Romney总出资额最高的职业和企业。为此，我们先对候选人进行分组，然后使用本章前面介绍的类似top的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_top_amounts</span>(<span class="params">group, key, n=<span class="number">5</span></span>):</span><br><span class="line">    totals = group.groupby(key)[<span class="string">&#x27;contb_receipt_amt&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> totals.nlargest(n)</span><br></pre></td></tr></table></figure>
<p>然后根据职业和雇主进行聚合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">207</span>]: grouped = fec_mrbo.groupby(<span class="string">&#x27;cand_nm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: grouped.apply(get_top_amounts, <span class="string">&#x27;contbr_occupation&#x27;</span>, n=<span class="number">7</span>)</span><br><span class="line">Out[<span class="number">208</span>]: </span><br><span class="line">cand_nm        contbr_occupation    </span><br><span class="line">Obama, Barack  RETIRED                  <span class="number">25305116.38</span></span><br><span class="line">               ATTORNEY                 <span class="number">11141982.97</span></span><br><span class="line">               INFORMATION REQUESTED     <span class="number">4866973.96</span></span><br><span class="line">               HOMEMAKER                 <span class="number">4248875.80</span></span><br><span class="line">               PHYSICIAN                 <span class="number">3735124.94</span></span><br><span class="line">                                           ...     </span><br><span class="line">Romney, Mitt   HOMEMAKER                 <span class="number">8147446.22</span></span><br><span class="line">               ATTORNEY                  <span class="number">5364718.82</span></span><br><span class="line">               PRESIDENT                 <span class="number">2491244.89</span></span><br><span class="line">               EXECUTIVE                 <span class="number">2300947.03</span></span><br><span class="line">               C.E.O.                    <span class="number">1968386.11</span></span><br><span class="line">Name: contb_receipt_amt, Length: <span class="number">14</span>, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">209</span>]: grouped.apply(get_top_amounts, <span class="string">&#x27;contbr_employer&#x27;</span>, n=<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">209</span>]: </span><br><span class="line">cand_nm        contbr_employer      </span><br><span class="line">Obama, Barack  RETIRED                  <span class="number">22694358.85</span></span><br><span class="line">               SELF-EMPLOYED            <span class="number">17080985.96</span></span><br><span class="line">               NOT EMPLOYED              <span class="number">8586308.70</span></span><br><span class="line">               INFORMATION REQUESTED     <span class="number">5053480.37</span></span><br><span class="line">               HOMEMAKER                 <span class="number">2605408.54</span></span><br><span class="line">                                           ...     </span><br><span class="line">Romney, Mitt   CREDIT SUISSE              <span class="number">281150.00</span></span><br><span class="line">               MORGAN STANLEY             <span class="number">267266.00</span></span><br><span class="line">               GOLDMAN SACH &amp; CO.         <span class="number">238250.00</span></span><br><span class="line">               BARCLAYS CAPITAL           <span class="number">162750.00</span></span><br><span class="line">               H.I.G. CAPITAL             <span class="number">139500.00</span></span><br><span class="line">Name: contb_receipt_amt, Length: <span class="number">20</span>, dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="对出资额分组">14.5.1 对出资额分组</h3>
<p>还可以对该数据做另一种非常实用的分析：利用<code>cut</code>函数根据出资额的大小将数据离散化到多个面元中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">210</span>]: bins = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>,</span><br><span class="line">   .....:                  <span class="number">100000</span>, <span class="number">1000000</span>, <span class="number">10000000</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">211</span>]: labels = pd.cut(fec_mrbo.contb_receipt_amt, bins)</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: labels</span><br><span class="line">Out[<span class="number">212</span>]: </span><br><span class="line"><span class="number">411</span>         (<span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line"><span class="number">412</span>       (<span class="number">100</span>, <span class="number">1000</span>]</span><br><span class="line"><span class="number">413</span>       (<span class="number">100</span>, <span class="number">1000</span>]</span><br><span class="line"><span class="number">414</span>         (<span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line"><span class="number">415</span>         (<span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line">             ...     </span><br><span class="line"><span class="number">701381</span>      (<span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line"><span class="number">701382</span>    (<span class="number">100</span>, <span class="number">1000</span>]</span><br><span class="line"><span class="number">701383</span>        (<span class="number">1</span>, <span class="number">10</span>]</span><br><span class="line"><span class="number">701384</span>      (<span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line"><span class="number">701385</span>    (<span class="number">100</span>, <span class="number">1000</span>]</span><br><span class="line">Name: contb_receipt_amt, Length: <span class="number">694282</span>, dtype: category</span><br><span class="line">Categories (<span class="number">8</span>, interval[int64]): [(<span class="number">0</span>, <span class="number">1</span>] &lt; (<span class="number">1</span>, <span class="number">10</span>] &lt; (<span class="number">10</span>, <span class="number">100</span>] &lt; (<span class="number">100</span>, <span class="number">1000</span>] &lt; (<span class="number">1</span></span><br><span class="line"><span class="number">000</span>, <span class="number">10000</span>] &lt;</span><br><span class="line">                                  (<span class="number">10000</span>, <span class="number">100000</span>] &lt; (<span class="number">100000</span>, <span class="number">1000000</span>] &lt; (<span class="number">1000000</span>,</span><br><span class="line"> <span class="number">10000000</span>]]</span><br></pre></td></tr></table></figure>
<p>现在可以根据候选人姓名以及面元标签对奥巴马和罗姆尼数据进行分组，以得到一个柱状图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">213</span>]: grouped = fec_mrbo.groupby([<span class="string">&#x27;cand_nm&#x27;</span>, labels])</span><br><span class="line"></span><br><span class="line">In [<span class="number">214</span>]: grouped.size().unstack(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">214</span>]: </span><br><span class="line">cand_nm              Obama, Barack  Romney, Mitt</span><br><span class="line">contb_receipt_amt                               </span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>]                       <span class="number">493.0</span>          <span class="number">77.0</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>]                    <span class="number">40070.0</span>        <span class="number">3681.0</span></span><br><span class="line">(<span class="number">10</span>, <span class="number">100</span>]                 <span class="number">372280.0</span>       <span class="number">31853.0</span></span><br><span class="line">(<span class="number">100</span>, <span class="number">1000</span>]               <span class="number">153991.0</span>       <span class="number">43357.0</span></span><br><span class="line">(<span class="number">1000</span>, <span class="number">10000</span>]              <span class="number">22284.0</span>       <span class="number">26186.0</span></span><br><span class="line">(<span class="number">10000</span>, <span class="number">100000</span>]                <span class="number">2.0</span>           <span class="number">1.0</span></span><br><span class="line">(<span class="number">100000</span>, <span class="number">1000000</span>]              <span class="number">3.0</span>           NaN</span><br><span class="line">(<span class="number">1000000</span>, <span class="number">10000000</span>]            <span class="number">4.0</span>           NaN</span><br></pre></td></tr></table></figure>
<p>从这个数据中可以看出，在小额赞助方面，Obama获得的数量比Romney多得多。你还可以对出资额求和并在面元内规格化，以便图形化显示两位候选人各种赞助额度的比例（见图14-13）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">216</span>]: bucket_sums = grouped.contb_receipt_amt.<span class="built_in">sum</span>().unstack(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">217</span>]: normed_sums = bucket_sums.div(bucket_sums.<span class="built_in">sum</span>(axis=<span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">218</span>]: normed_sums</span><br><span class="line">Out[<span class="number">218</span>]: </span><br><span class="line">cand_nm              Obama, Barack  Romney, Mitt</span><br><span class="line">contb_receipt_amt                               </span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>]                    <span class="number">0.805182</span>      <span class="number">0.194818</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>]                   <span class="number">0.918767</span>      <span class="number">0.081233</span></span><br><span class="line">(<span class="number">10</span>, <span class="number">100</span>]                 <span class="number">0.910769</span>      <span class="number">0.089231</span></span><br><span class="line">(<span class="number">100</span>, <span class="number">1000</span>]               <span class="number">0.710176</span>      <span class="number">0.289824</span></span><br><span class="line">(<span class="number">1000</span>, <span class="number">10000</span>]             <span class="number">0.447326</span>      <span class="number">0.552674</span></span><br><span class="line">(<span class="number">10000</span>, <span class="number">100000</span>]           <span class="number">0.823120</span>      <span class="number">0.176880</span></span><br><span class="line">(<span class="number">100000</span>, <span class="number">1000000</span>]         <span class="number">1.000000</span>           NaN</span><br><span class="line">(<span class="number">1000000</span>, <span class="number">10000000</span>]       <span class="number">1.000000</span>           NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">219</span>]: normed_sums[:-<span class="number">2</span>].plot(kind=<span class="string">&#x27;barh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2018/08/02/python_for_data_analysis/pfda_chap14/7178691-77e8c8d3c784692b.png" class="" title="图14-13 两位候选人收到的各种捐赠额度的总额比例">
<p>我排除了两个最大的面元，因为这些不是由个人捐赠的。</p>
<p>还可以对该分析过程做许多的提炼和改进。比如说，可以根据赞助人的姓名和邮编对数据进行聚合，以便找出哪些人进行了多次小额捐款，哪些人又进行了一次或多次大额捐款。我强烈建议你下载这些数据并自己摸索一下。</p>
<h3 id="根据州统计赞助信息">14.5.2 根据州统计赞助信息</h3>
<p>根据候选人和州对数据进行聚合是常规操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">220</span>]: grouped = fec_mrbo.groupby([<span class="string">&#x27;cand_nm&#x27;</span>, <span class="string">&#x27;contbr_st&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">221</span>]: totals = grouped.contb_receipt_amt.<span class="built_in">sum</span>().unstack(<span class="number">0</span>).fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">222</span>]: totals = totals[totals.<span class="built_in">sum</span>(<span class="number">1</span>) &gt; <span class="number">100000</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">223</span>]: totals[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">223</span>]: </span><br><span class="line">cand_nm    Obama, Barack  Romney, Mitt</span><br><span class="line">contbr_st                             </span><br><span class="line">AK             <span class="number">281840.15</span>      <span class="number">86204.24</span></span><br><span class="line">AL             <span class="number">543123.48</span>     <span class="number">527303.51</span></span><br><span class="line">AR             <span class="number">359247.28</span>     <span class="number">105556.00</span></span><br><span class="line">AZ            <span class="number">1506476.98</span>    <span class="number">1888436.23</span></span><br><span class="line">CA           <span class="number">23824984.24</span>   <span class="number">11237636.60</span></span><br><span class="line">CO            <span class="number">2132429.49</span>    <span class="number">1506714.12</span></span><br><span class="line">CT            <span class="number">2068291.26</span>    <span class="number">3499475.45</span></span><br><span class="line">DC            <span class="number">4373538.80</span>    <span class="number">1025137.50</span></span><br><span class="line">DE             <span class="number">336669.14</span>      <span class="number">82712.00</span></span><br><span class="line">FL            <span class="number">7318178.58</span>    <span class="number">8338458.81</span></span><br></pre></td></tr></table></figure>
<p>如果对各行除以总赞助额，就会得到各候选人在各州的总赞助额比例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">224</span>]: percent = totals.div(totals.<span class="built_in">sum</span>(<span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">225</span>]: percent[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">225</span>]: </span><br><span class="line">cand_nm    Obama, Barack  Romney, Mitt</span><br><span class="line">contbr_st                             </span><br><span class="line">AK              <span class="number">0.765778</span>      <span class="number">0.234222</span></span><br><span class="line">AL              <span class="number">0.507390</span>      <span class="number">0.492610</span></span><br><span class="line">AR              <span class="number">0.772902</span>      <span class="number">0.227098</span></span><br><span class="line">AZ              <span class="number">0.443745</span>      <span class="number">0.556255</span></span><br><span class="line">CA              <span class="number">0.679498</span>      <span class="number">0.320502</span></span><br><span class="line">CO              <span class="number">0.585970</span>      <span class="number">0.414030</span></span><br><span class="line">CT              <span class="number">0.371476</span>      <span class="number">0.628524</span></span><br><span class="line">DC              <span class="number">0.810113</span>      <span class="number">0.189887</span></span><br><span class="line">DE              <span class="number">0.802776</span>      <span class="number">0.197224</span></span><br><span class="line">FL              <span class="number">0.467417</span>      <span class="number">0.532583</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">14.6 总结</h2>
<p>我们已经完成了正文的最后一章。附录中有一些额外的内容，可能对你有用。</p>
<p>本书第一版出版已经有5年了，Python已经成为了一个流行的、广泛使用的数据分析语言。你从本书中学到的方法，在相当长的一段时间都是可用的。我希望本书介绍的工具和库对你的工作有用。</p>
]]></content>
      <categories>
        <category>编程开发</category>
        <category>python</category>
        <category>利用Python进行数据分析·第2版</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>book</tag>
      </tags>
  </entry>
</search>
