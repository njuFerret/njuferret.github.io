<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.20/fancybox/fancybox.css" integrity="sha256-RvRHGSuWAxZpXKV9lLDt2e+rZ+btzn48Wp4ueS3NZKs=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"njuferret.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文较为全面的介绍了C++各个版本的新特性，作者 [401@简书]，原文在这里。  原文如下：  本文按照 cppreference 列出的特性列表依次介绍。  C++11 新特性 01 auto 与 decltype auto: 对于变量，指定要从其初始化器⾃动推导出其类型。⽰例： 1234auto a &#x3D; 10;    &#x2F;&#x2F; 自动推导 a 为 intauto b &#x3D; 10">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11&#x2F;14&#x2F;17&#x2F;20 特性介绍 转">
<meta property="og:url" content="https://njuferret.github.io/2023/09/10/cpp_11_14_17_20/index.html">
<meta property="og:site_name" content="有点博客">
<meta property="og:description" content="本文较为全面的介绍了C++各个版本的新特性，作者 [401@简书]，原文在这里。  原文如下：  本文按照 cppreference 列出的特性列表依次介绍。  C++11 新特性 01 auto 与 decltype auto: 对于变量，指定要从其初始化器⾃动推导出其类型。⽰例： 1234auto a &#x3D; 10;    &#x2F;&#x2F; 自动推导 a 为 intauto b &#x3D; 10">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://njuferret.github.io/2023/09/10/cpp_11_14_17_20/value_type.png">
<meta property="og:image" content="https://njuferret.github.io/2023/09/10/cpp_11_14_17_20/move_constructor.png">
<meta property="og:image" content="https://njuferret.github.io/2023/09/10/cpp_11_14_17_20/pointer1.png">
<meta property="og:image" content="https://njuferret.github.io/2023/09/10/cpp_11_14_17_20/pointer2.png">
<meta property="article:published_time" content="2023-09-10T13:28:32.000Z">
<meta property="article:modified_time" content="2023-09-10T14:03:43.417Z">
<meta property="article:author" content="Ferret@NJTech">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="基础语法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://njuferret.github.io/2023/09/10/cpp_11_14_17_20/value_type.png">


<link rel="canonical" href="https://njuferret.github.io/2023/09/10/cpp_11_14_17_20/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://njuferret.github.io/2023/09/10/cpp_11_14_17_20/","path":"2023/09/10/cpp_11_14_17_20/","title":"C++11/14/17/20 特性介绍 转"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++11/14/17/20 特性介绍 转 | 有点博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">有点博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#c11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">C++11 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-%E4%B8%8E-decltype"><span class="nav-text">01 auto 与 decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defaulted-%E4%B8%8E-deleted-%E5%87%BD%E6%95%B0"><span class="nav-text">02 defaulted 与 deleted 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-%E4%B8%8E-override"><span class="nav-text">03 final 与 override</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-text">04 尾置返回类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95"><span class="nav-text">05 右值引⽤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E4%B8%BA%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC"><span class="nav-text">何为左值与右值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E4%B8%BA%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">何为左值引用与右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">右值引用的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-text">右值引⽤带来的移动语义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-text">右值引⽤带来的完美转发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">06 移动构造函数与移动赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E4%BD%9C%E5%9F%9F%E6%9E%9A%E4%B8%BE"><span class="nav-text">07 有作⽤域枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr-%E4%B8%8E%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="nav-text">08 constexpr 与字⾯类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8---%E6%89%A9%E5%B1%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E9%80%82%E8%8C%83%E5%9B%B4"><span class="nav-text">09 初始化列表 - 扩展「初始化列表」的适⽤范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">10 委托与继承的构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%B1%E6%8B%AC%E5%8F%B7%E6%88%96%E7%AD%89%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="nav-text">11 花括号或等号初始化器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nullptr"><span class="nav-text">12 nullptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#long-long"><span class="nav-text">13 long long</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#char16_t-%E4%B8%8E-char32_t"><span class="nav-text">14 char16_t 与 char32_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-text">15 类型别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-text">16 变长参数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E7%9A%84%E5%B9%B3%E5%87%A1%E8%81%94%E5%90%88%E4%BD%93"><span class="nav-text">17 推⼴的（⾮平凡）联合体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E7%9A%84-pod-%E5%B9%B3%E5%87%A1%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%A0%87%E5%87%86%E5%B8%83%E5%B1%80%E7%B1%BB%E5%9E%8B"><span class="nav-text">18 推⼴的 POD （平凡类型与标准布局类型）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unicode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%87%8F"><span class="nav-text">19 Unicode 字符串字⾯量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%B7%E5%AE%9A%E4%B9%89%E5%AD%97%E9%87%8F"><span class="nav-text">20 ⽤户定义字⾯量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-text">21 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">22 Lambda 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noexcept-%E8%AF%B4%E6%98%8E%E7%AC%A6%E4%B8%8E-noexcept-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">23 noexcept 说明符与 noexcept 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alignof-%E4%B8%8E-alignas"><span class="nav-text">24 alignof 与 alignas</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">25 多线程内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="nav-text">26 线程局部存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gc-%E6%8E%A5%E5%8F%A3"><span class="nav-text">27 GC 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4-for"><span class="nav-text">28 范围 for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static_assert"><span class="nav-text">29 static_assert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">30 智能指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c14-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">C++14 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF"><span class="nav-text">01 变量模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B-lambda"><span class="nav-text">02 泛型 lambda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8D%95%E8%8E%B7"><span class="nav-text">03 lambda 初始化捕获</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newdelete-elision"><span class="nav-text">04 new&#x2F;delete elision</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr-%E5%87%BD%E6%95%B0%E4%B8%8A%E6%94%BE%E6%9D%BE%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-text">05 constexpr 函数上放松的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%88%B6%E5%AD%97%E9%87%8F"><span class="nav-text">06 ⼆进制字⾯量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%88%86%E9%9A%94%E7%AC%A6"><span class="nav-text">07 数字分隔符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-text">08 函数的返回类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E7%9A%84%E8%81%9A%E5%90%88%E7%B1%BB"><span class="nav-text">09 带默认成员初始化器的聚合类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltypeauto"><span class="nav-text">10 decltype(auto)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c17-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">C++17 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">01 折叠表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E5%AF%BC"><span class="nav-text">02 类模板实参推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-%E5%8D%A0%E4%BD%8D%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%8F%82"><span class="nav-text">03 auto 占位的⾮类型模板形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E7%9A%84-constexpr-if-%E8%AF%AD%E5%8F%A5"><span class="nav-text">04 编译期的 constexpr if 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%8F%98%E9%87%8Finline-%E5%8F%98%E9%87%8F"><span class="nav-text">05 内联变量（inline 变量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="nav-text">06 结构化绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ifswitch-%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">07 if&#x2F;switch 语句的变量初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u8-char"><span class="nav-text">08 u8-char</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E7%9A%84%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-text">09 简化的嵌套命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-%E5%A3%B0%E6%98%8E%E8%AF%AD%E5%8F%A5%E5%8F%AF%E4%BB%A5%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E5%90%8D%E7%A7%B0"><span class="nav-text">10 using 声明语句可以声明多个名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86-noexcept-%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86"><span class="nav-text">11 将 noexcept 作为类型系统的一部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F%E8%A7%84%E5%88%99"><span class="nav-text">12 新的求值顺序规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E6%B6%88%E9%99%A4guaranteed-copy-elision"><span class="nav-text">13 强制的复制消除（guaranteed copy elision）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8D%95%E8%8E%B7-this"><span class="nav-text">14 lambda 表达式捕获 *this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr-%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">15 constexpr 的 lambda 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8D%E5%BF%85%E9%87%8D%E5%A4%8D"><span class="nav-text">16 属性命名空间不必重复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%B1%9E%E6%80%A7-fallthrough-nodiscard-%E5%92%8C-maybe_unused"><span class="nav-text">17 新属性 [[fallthrough]] [[nodiscard]] 和 [[maybe_unused]]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#has_include"><span class="nav-text">18 __has_include</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c20-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">C++20 新特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E5%AE%8F"><span class="nav-text">01 特性测试宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">02 三路比较运算符 &lt;&#x3D;&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4-for-%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="nav-text">04 范围 for 中的初始化语句和初始化器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#char8_t"><span class="nav-text">05 char8_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#no_unique_address"><span class="nav-text">06 [[no_unique_address]]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#likely"><span class="nav-text">07 [[likely]]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unlikely"><span class="nav-text">08 [[unlikely]]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8D%95%E8%8E%B7%E4%B8%AD%E7%9A%84%E5%8C%85%E5%B1%95%E5%BC%80"><span class="nav-text">09 lambda 初始化捕获中的包展开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E4%BA%86%E5%9C%A8%E5%A4%9A%E7%A7%8D%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AF%AD%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-typename-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E6%B6%88%E9%99%A4%E7%B1%BB%E5%9E%8B%E6%AD%A7%E4%B9%89%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-text">10 移除了在多种上下文语境中，使用 typename 关键字以消除类型歧义的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constevalconstinit"><span class="nav-text">11 consteval、constinit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E4%B8%BA%E5%AE%BD%E6%9D%BE%E7%9A%84-constexpr-%E8%A6%81%E6%B1%82"><span class="nav-text">12 更为宽松的 constexpr 要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%84%E5%AE%9A%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E4%BB%A5%E8%A1%A5%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">13 规定有符号整数以补码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%86%E6%8B%AC%E5%8F%B7%E7%9A%84%E8%81%9A%E5%90%88%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">14 使用圆括号的聚合初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-text">15 协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-text">16 模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%AE%9A%E4%B8%8E%E6%A6%82%E5%BF%B5concepts"><span class="nav-text">17 限定与概念(concepts)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%A9%E7%95%A5%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-text">18 缩略函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E6%8E%A8%E5%AF%BC"><span class="nav-text">19 数组长度推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="nav-text">相关代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%AA"><span class="nav-text">汪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-text">原理</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ferret@NJTech"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Ferret@NJTech</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://njuferret.github.io/2023/09/10/cpp_11_14_17_20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Ferret@NJTech">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="有点博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++11/14/17/20 特性介绍 转 | 有点博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++11/14/17/20 特性介绍 转
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-10 21:28:32 / 修改时间：22:03:43" itemprop="dateCreated datePublished" datetime="2023-09-10T21:28:32+08:00">2023-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">编程开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>本文较为全面的介绍了C++各个版本的新特性，作者 [401@简书]，原文在<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8c4952e9edec">这里</a>。</p>
</blockquote>
<p>原文如下：</p>
<blockquote>
<p>本文按照 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.cppreference.com%2Fw%2F">cppreference</a> 列出的特性列表依次介绍。</p>
</blockquote>
<h2 id="c11-新特性">C++11 新特性</h2>
<h3 id="auto-与-decltype">01 auto 与 decltype</h3>
<p><strong>auto</strong>: 对于变量，指定要从其初始化器⾃动推导出其类型。⽰例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>;    <span class="comment">// 自动推导 a 为 int</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">10.2</span>;  <span class="comment">// 自动推导 b 为 double</span></span><br><span class="line"><span class="keyword">auto</span> c = &amp;a;    <span class="comment">// 自动推导 c 为 int*</span></span><br><span class="line"><span class="keyword">auto</span> d = <span class="string">&quot;xxx&quot;</span>; <span class="comment">// 自动推导 d 为 const char*</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><strong>decltype</strong>: 推导实体的声明类型，或表达式的类型。为了解决 auto 关键字只能对变量进⾏类型推导的缺陷⽽出现。⽰例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>;        <span class="comment">// b 被推导为 int 类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) c = <span class="number">5.5</span>;   <span class="comment">// c 被推导为 double 类型</span></span><br><span class="line"><span class="keyword">decltype</span>(c + <span class="number">100</span>) d;      <span class="comment">// d 被推导为 double</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123; <span class="type">double</span> x; &#125; aa;</span><br><span class="line"><span class="keyword">decltype</span>(aa.x) y;         <span class="comment">// y 被推导为 double 类型</span></span><br><span class="line"><span class="keyword">decltype</span>(aa) bb;          <span class="comment">// 推断匿名结构体类型</span></span><br></pre></td></tr></table></figure>
<p>C++11 中 auto 和 decltype 结合再借助「尾置返回类型」还可推导函数的返回类型。⽰例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利⽤ auto 关键字将返回类型后置</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add1</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <strong>C++14</strong> 开始⽀持仅⽤ auto 并实现返回类型推导，见下⽂ C++14 章节。</p>
<h3 id="defaulted-与-deleted-函数">02 defaulted 与 deleted 函数</h3>
<p>在 C++ 中，如果程序员没有⾃定义，那么编译器会<strong>默认</strong>为程序员⽣成 「<strong>构造函数</strong>」、「<strong>拷贝构造函数</strong>」、「<strong>拷贝赋值函数</strong>」 等。</p>
<p>但如果程序员⾃定义了上述函数，编译器则不会⾃动⽣成这些函数。</p>
<p>⽽在实际开发过程中，我们有时需要<strong>在保留⼀些默认函数的同时禁⽌⼀些默认函数</strong>。</p>
<p>例如创建 「<strong>不允许拷贝的类</strong>」 时，在传统 C++ 中，我们经常有如下的惯例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除非特别熟悉编译器自动生成特殊成员函数的所有规则，否则意图是不明确的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noncopyable</span>   &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 由于下⽅有⾃定义的构造函数（拷⻉构造函数）</span></span><br><span class="line">  <span class="comment">// 编译器不再⽣成默认构造函数，所以这⾥需要⼿动定义构造函数</span></span><br><span class="line">  <span class="comment">// 但这种⼿动声明的构造函数没有编译器⾃动⽣成的默认构造函数执⾏效率⾼</span></span><br><span class="line">  <span class="built_in">noncopyable</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="comment">// 将拷⻉构造函数和拷⻉赋值函数设置为 private</span></span><br><span class="line">  <span class="comment">// 但却⽆法阻⽌友元函数以及类成员函数的调⽤</span></span><br><span class="line">  <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;);</span><br><span class="line">  noncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> noncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>传统 C++ 的惯例处理⽅式存在如下缺陷：</p>
<ol type="1">
<li>由于⾃定义了「拷贝构造函数」，编译器不再⽣成「默认构造函数」，需要⼿动的显式定义「无参构造函数」</li>
<li>⼿动显式定义的「无参构造函数」效率低于「默认构造函数」</li>
<li>虽然「拷贝构造函数」和「拷贝赋值函数」是私有的，对外部隐藏。但⽆法阻⽌友元函数和类成员函数的调⽤</li>
<li>除⾮特别熟悉编译器⾃动⽣成特殊成员函数的所有规则，否则意图是不明确的</li>
</ol>
<p>为此，C++11 引⼊了 <strong>default</strong> 和 <strong>delete</strong> 关键字，来显式保留或禁止特殊成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">noncopyable</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">noncopyable</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">noncopyable</span>(<span class="type">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  noncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> noncopyable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>
<h3 id="final-与-override">03 final 与 override</h3>
<p>在传统 C++ 中，按照如下⽅式覆盖⽗类虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass</span>: Base &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>
<p>上述代码存在⼀定的隐患：</p>
<ul>
<li>程序员并⾮想覆盖⽗类虚函数，⽽是 <strong>定义了⼀个重名的成员函数</strong>。由于没有编译器的检查导致了意外覆盖且难以发现</li>
<li>⽗类的虚函数被删除后，编译器不会进⾏检查和警告，这可能引发严重的错误</li>
</ul>
<p>为此，C++11 引⼊ <strong>override</strong> 显式的声明<strong>要覆盖基类的虚函数</strong>，如果不存在这样的虚函数，将不会通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchTv</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : Parent &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchTv</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;    <span class="comment">// 合法</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchTv</span><span class="params">(<span class="type">double</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法，父类没有此虚函数</span></span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>
<p>⽽ <strong>final</strong> 则终⽌虚类被继承或虚函数被覆盖：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span> <span class="keyword">final</span> : Parent2 &#123;&#125;;  <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span> : Child2 &#123;&#125;;       <span class="comment">// 非法，Child2 已经 Final，不可被继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child3</span> : Parent2 &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 非法，foo 已 final</span></span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>
<h3 id="尾置返回类型">04 尾置返回类型</h3>
<p>看一个比较复杂的函数定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func1(int arr[][3], int n) 为函数名和参数</span></span><br><span class="line"><span class="comment">// (* func1(int arr[][3], int n)) 表示对返回值进⾏解引⽤操作</span></span><br><span class="line"><span class="comment">// (* func1(int arr[][3], int n))[3] 表示返回值解引⽤后为⼀个⻓度为 3 的数组</span></span><br><span class="line"><span class="comment">// int (* func1(int arr[][3], int n))[3] 表示返回值解引⽤后为⼀个⻓度为 3 的 int 数组</span></span><br><span class="line"><span class="built_in">int</span> (* <span class="built_in">func1</span>(<span class="type">int</span> arr[][<span class="number">3</span>], <span class="type">int</span> n))[<span class="number">3</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;arr[n];</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>C++11 引⼊「尾置返回类型」，将「函数返回类型」通过 <strong>-&gt; 符号</strong>连接到函数后面，配合 auto 简化上述复杂函数的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指向数组的指针</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> arr[][<span class="number">3</span>], <span class="type">int</span> n)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[3] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;arr[n];</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>尾置返回类型经常在 「<strong>lambda 表达式</strong>」、「<strong>模板函数返回</strong>」中使⽤：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使⽤尾置返回类型来声明 lambda 表达式的返回类型</span></span><br><span class="line">[capture list] (params list) <span class="keyword">mutable</span> exception-&gt;return_type &#123; function body &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在模板函数返回中结合 auto\decltype 声明模板函数返回值类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h3 id="右值引">05 右值引⽤</h3>
<h4 id="何为左值与右值">何为左值与右值</h4>
<ul>
<li><strong>左值</strong>：内存中有确定存储地址的对象的表达式的值</li>
<li><strong>右值</strong>：所有不是左值的表达式的值。右值可分为「<strong>传统纯右值</strong>」和「<strong>将亡值</strong>」</li>
</ul>
<p>上述的「传统纯右值」和「将亡值」又是什么？</p>
<ul>
<li><p><strong>纯右值</strong>：即 C++11 之前的右值。包括：</p>
<ol type="1">
<li>常见的字面量如 0、"123"、或表达式为字面量</li>
<li>不具名的临时对象，如函数返回临时对象</li>
</ol></li>
<li><p><strong>将亡值</strong>：随着 C++11 引入的右值引用而来的概念。包括：</p>
<ol type="1">
<li>「返回右值引用的函数」的返回值。如返回类型为 T&amp;&amp; 的函数的返回值</li>
<li>「转换为右值引用的转换函数」的返回值，如 std::move() 函数的返回值</li>
</ol></li>
</ul>
<p>同时，左值 + 将亡值又被称为「泛左值」。这几个概念对于刚接触的同学可能会比较混乱，我们梳理一下，如下图所示：</p>
<img src="/2023/09/10/cpp_11_14_17_20/value_type.png" class="" title="value_type">
<p>左值还是右值可以通过<strong>取地址运算符 &amp;</strong> 来进⾏判断，能够通过 &amp; 正确取得地址的为左值，反之为右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p_i = &amp;i;            <span class="comment">// 可通过 &amp; 取出地址，固 i 为左值</span></span><br><span class="line">cout &lt;&lt; p_i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p_i_plus = &amp;(i + <span class="number">1</span>); <span class="comment">// 非法，i + 1 为右值</span></span><br><span class="line"><span class="type">int</span>* p_i_const = &amp;(<span class="number">0</span>);    <span class="comment">// 非法，0 为右值    </span></span><br></pre></td></tr></table></figure>
<h4 id="何为左值引用与右值引用">何为左值引用与右值引用</h4>
<p>C++11 之前，我们就经常使⽤对左值的引⽤，即左值引⽤，使用 <code>&amp;</code> 符号声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref_j = j;           <span class="comment">// ref_j 为左值引⽤</span></span><br><span class="line"><span class="type">int</span>&amp; ref_ret = <span class="built_in">getVal</span>();  <span class="comment">// ref_ret 为左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp; ref_j_plus = j + <span class="number">1</span>;  <span class="comment">// ⾮法，左值引⽤不能作⽤于右值</span></span><br><span class="line"><span class="type">int</span>&amp; ref_const = <span class="number">0</span>;       <span class="comment">// 非法，左值引用不能作用于右值    </span></span><br></pre></td></tr></table></figure>
<p>如上例代码所示，<strong>ref_j_plus</strong> 和 <strong>ref_const</strong> 为传统 C++ 中经常使用的左值引用，无法作用于 <strong>j+1</strong> 或 <strong>0</strong> 这样的右值。</p>
<p>C++11 引⼊了针对右值的引⽤，即右值引⽤，使用 &amp;&amp; 符号声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; ref_k_plus = (i + <span class="number">1</span>); <span class="comment">// ref_k_plus 为右值引用，它绑定了右值 i + 1</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; ref_k = <span class="number">0</span>;            <span class="comment">// ref_k 为右值引用，它绑定了右值 0     </span></span><br></pre></td></tr></table></figure>
<h4 id="右值引用的特点">右值引用的特点</h4>
<p>以下述代码为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里存在两个值：</span></span><br><span class="line">  <span class="comment">//    1. val(左值)</span></span><br><span class="line">  <span class="comment">//    2. getVal() 返回的临时变量（右值）</span></span><br><span class="line">  <span class="comment">// 其中 getVal() 返回的临时变量赋值给 val 后会被销毁</span></span><br><span class="line">  <span class="type">int</span> val = <span class="built_in">getVal</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>上述代码中，getVal 函数产⽣的 <strong>「临时变量」</strong> 需要先复制给左值 val，然后再被销毁。</p>
<p>但是如果使⽤右值引⽤：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 &amp;&amp; 来表明 val 的类型为右值引用</span></span><br><span class="line"><span class="comment">// 这样 getVal() 返回的临时对象（右值） 将被「续命」</span></span><br><span class="line"><span class="comment">// 拥有与 val 一样长的生命周期</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; val = <span class="built_in">getVal</span>();    </span><br></pre></td></tr></table></figure>
<p>上述代码体现了右值引⽤的<strong>第⼀个特点</strong>：</p>
<blockquote>
<p>通过右值引⽤的声明，右值可「重⽣」，⽣命周期与右值引⽤类型的变量⽣命周期⼀样长。</p>
</blockquote>
<p>再看如下例⼦：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);      <span class="comment">// t 为右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x);       <span class="comment">// t 为左值    </span></span><br></pre></td></tr></table></figure>
<p>上述例⼦体现了右值引⽤的<strong>第⼆个特点</strong>：</p>
<blockquote>
<p>在 <strong>⾃动类型推断（如模板函数等）的场景下</strong>，T&amp;&amp; t 是<strong>未定的引⽤类型</strong>，即 t 并⾮⼀定为右值。如果它被左值初始化，那么 t 就为左值。如果它被右值初始化，则它为右值。</p>
</blockquote>
<p>正是由于上述特点，C++11 引入右值引⽤可以实现如下⽬的：</p>
<ul>
<li><strong>实现移动语义</strong>。解决临时对象的低效率拷贝问题</li>
<li><strong>实现完美转发</strong>。解决函数转发右值特征丢失的问题</li>
</ul>
<h5 id="右值引带来的移动语义">右值引⽤带来的移动语义</h5>
<p>在 C++11 之前，临时对象的赋值采⽤的是低效的拷贝。</p>
<p>举例来讲，整个过程如同将⼀个冰箱⾥的⼤象搬到另⼀个冰箱，传统 C++ 的做法是第⼆个冰箱⾥复制⼀个⼀摸⼀样的⼤象，再把第⼀个冰箱的⼤象销毁，这显然不是⼀个⾃然的操作⽅式。</p>
<p>看如下例⼦：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtrMem1</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">HasPtrMem1</span>() : <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">HasPtrMem1</span>() &#123; <span class="keyword">delete</span> d; &#125;</span><br><span class="line">  <span class="type">int</span>* d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HasPtrMem1 a1;</span><br><span class="line">  <span class="function">HasPtrMem1 <span class="title">b1</span><span class="params">(a1)</span></span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; *a1.d &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; *b1.d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>上述代码中 <code>HasPtrMem1 b(a)</code> 将调⽤编译器默认⽣成的「拷贝构造函数」进⾏拷贝，且进⾏的是按位拷贝（浅拷贝），这将导致<strong>悬挂指针问题[1]</strong>。</p>
<blockquote>
<p><strong>悬挂指针问题[1]</strong>: 上述代码在执⾏ main 函数后，将销毁 a、b 对象，于是调⽤对应的析构函数执⾏ delete d 操作。但由 于 a、b 对象中的成员 d 指针同⼀块内存，于是在其中⼀个对象被析构后，另⼀个对象中的指针 d 不再指向有效内存，这个对象的 d 就变成了悬挂指针。</p>
</blockquote>
<p>在悬挂指针上释放内存将导致严重的错误。所以针对上述场景必须进⾏深拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtrMem2</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">HasPtrMem2</span>() : <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;&#125;</span><br><span class="line">  <span class="built_in">HasPtrMem2</span>(<span class="type">const</span> HasPtrMem2&amp; h) :</span><br><span class="line">      <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*h.d)) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">HasPtrMem2</span>() &#123; <span class="keyword">delete</span> d; &#125;</span><br><span class="line">  <span class="type">int</span>* d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HasPtrMem2 a2;</span><br><span class="line">  <span class="function">HasPtrMem2 <span class="title">b2</span><span class="params">(a2)</span></span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; *a2.d &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; *b2.d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们⾃定义了拷贝构造函数的实现，我们通过 <code>new</code> 分配新的内存实现了深度拷贝，避免了「悬挂指针」的问题，但也引出了新的问题。</p>
<p>拷贝构造函数为指针成员分配新的内存并进⾏拷贝的做法是传统 C++ 编程中是⼗分常见的。但有些时候我们并不需要这样的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HasPtrMem2 <span class="title">GetTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">HasPtrMem2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HasPtrMem2 a = <span class="built_in">GetTemp</span>();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>GetTemp</code> 返回的临时对象进⾏深度拷贝操作，然后再被销毁。如下图所⽰：</p>

<p>如果 <code>HasPtrMem2</code> 中的指针成员是复杂和庞⼤的数据类型，那么就会导致⼤量的性能消耗。</p>
<p>再回到⼤象移动的类⽐，其实更⾼效的做法是将⼤象直接从第⼀个冰箱拿出，然后放⼊第⼆个冰箱。同样的，我们在将临时对象赋值给某个变量时是否可以不⽤拷贝构造函数？答案是肯定的，如下图所⽰：</p>
<img src="/2023/09/10/cpp_11_14_17_20/move_constructor.png" class="" title="移动构造">
<p>在 C++11 中，像这样「偷⾛」资源的构造函数，称为 「<strong>移动构造函数</strong>」，这种「偷」的⾏为，称为 「<strong>移动语义</strong>」，可理解为「移为⼰⽤」。</p>
<p>当然实现时需要在代码中定义对应的「移动构造函数」：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtrMem3</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtrMem3</span>() : <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;&#125;</span><br><span class="line">    <span class="built_in">HasPtrMem3</span>(<span class="type">const</span> HasPtrMem3&amp; h) : </span><br><span class="line">        <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*h.d)) &#123;&#125;</span><br><span class="line">    <span class="built_in">HasPtrMem3</span>(HasPtrMem3&amp;&amp; h) : <span class="built_in">d</span>(h.d) &#123;</span><br><span class="line">      h.d = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">HasPtrMem3</span>() &#123; <span class="keyword">delete</span> d; &#125;</span><br><span class="line">    <span class="type">int</span>* d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意「移动构造函数」依然会存在悬挂指针问题，所以在通过移动构造函数「偷」完资源后，要把临时对象的 h.d 指针置为空，避免两个指针指向同⼀个内存，在析构时被析构两次。</p>
<p>「移动构造函数」中的参数为 <code>HasPtrMem3&amp;&amp; h</code> 为<strong>右值类型[2]</strong>，⽽返回值的临时对象就是右值类型，这也是为什么返回值临时对象能够匹配到「移动构造函数」的原因。</p>
<blockquote>
<p><strong>右值类型[2]</strong>: 注意和上⾯提到的右值引⽤第⼆个特点做区分，这⾥不是类型推导的场景，<code>HasPtrMem3</code> 是确定的类型，所以 <code>HasPtrMem3&amp;&amp; h</code> 就是确定的右值类型。</p>
</blockquote>
<p>上述的移动语义是通过右值引⽤来匹配临时值的，那么左值是否可以借助移动语义来优化性能呢？C++11 为我们 提供了 <strong>std::move</strong> 函数来实现这⼀⽬标：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  std::list&lt;std::string&gt; tokens;              <span class="comment">// tokens 为左值</span></span><br><span class="line">  <span class="comment">// 省略初始化...</span></span><br><span class="line">  std::list&lt;std::string&gt; t = tokens;          <span class="comment">// 这里存在拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::list&lt;std::string&gt; tokens;</span><br><span class="line">std::list&lt;std::string&gt; t = std::<span class="built_in">move</span>(tokens); <span class="comment">// 这里不存在拷贝    </span></span><br></pre></td></tr></table></figure>
<p>std::move 函数实际没有移动任何资源，它唯⼀做的就是<strong>将⼀个左值强制转换成右值引⽤</strong>，从而匹配到「移动构造函数」或「移动赋值运算符」，应⽤移动语义实现资源移动。⽽ C++11 中所有的容器都实现了移动语义，所以使用了 list 容器的上述代码能够避免拷贝，提⾼性能。</p>
<h5 id="右值引带来的完美转发">右值引⽤带来的完美转发</h5>
<p>传统 C++ 中右值参数后被转换成左值，即不能按照参数原先的类型进⾏转发，如下所⽰：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwardValue1</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 右值参数变为左值</span></span><br><span class="line">  <span class="built_in">processValue</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwardValue1</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">processValue</span>(val); <span class="comment">// 参数都变成常量左值引用了</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>如何保持参数的左值、右值特征，C++11 引⼊了 std::forward，它将按照参数的实际类型进⾏转发：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processValue</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;lvalue&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processValue</span><span class="params">(<span class="type">int</span>&amp;&amp; a)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;rvalue&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwardValue2</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 照参数本来的类型进⾏转发</span></span><br><span class="line">  <span class="built_in">processValue</span>(std::forward&lt;T&gt;(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  forwardValue2(i); <span class="comment">// 传入左值，函数执行输出 lvalue</span></span><br><span class="line">  forwardValue2(<span class="number">0</span>); <span class="comment">// 传入右值，函数执行输出 rvalue</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h3 id="移动构造函数与移动赋值运算符">06 移动构造函数与移动赋值运算符</h3>
<p>在规则 <a href="#05">#05</a> 已经提及，不再赘述。</p>
<h3 id="有作域枚举">07 有作⽤域枚举</h3>
<p>传统 C++ 的枚举类型存在如下问题：</p>
<ul>
<li>每⼀个枚举值在其作⽤域内都是可见，容易引起命名冲突</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Color 下的 BLUE 和 Feeling 下的 BLUE 命名冲突</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, BLUE &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Feeling</span> &#123; EXCITED, BLUE &#125;;    </span><br></pre></td></tr></table></figure>
<ul>
<li>会被隐式转换成 int，这在那些不该转换成 int 的场景下可能导致错误</li>
<li>不可指定枚举的数据类型，导致代码不易理解、不可进⾏前向声明等</li>
</ul>
<p>在传统 C++ 中也有⼀些间接⽅案可以适当解决或缓解上述问题，例如使⽤<strong>命名空间</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Color &#123; <span class="keyword">enum</span> <span class="title class_">Type</span> &#123; RED, YELLOW, BLUE &#125;; &#125;;    </span><br></pre></td></tr></table></figure>
<p>或使⽤类、结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span> &#123; <span class="keyword">enum</span> <span class="title class_">Type</span> &#123; RED, YELLOW, BLUE &#125;; &#125;;    </span><br></pre></td></tr></table></figure>
<p>但上述⽅案通常值解决了<strong>作⽤域问题</strong>，隐式转换以及数据类型的问题⽆法解决。</p>
<p>C++11 引⼊了枚举类解决上述问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举值为 char 类型的枚举类</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>:<span class="type">char</span> &#123; RED, BLACK &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使⽤</span></span><br><span class="line">Color c = Color::RED;    </span><br></pre></td></tr></table></figure>
<h3 id="constexpr-与字类型">08 <code>constexpr</code> 与字⾯类型</h3>
<p><strong>constexpr</strong>: 在编译期将表达式或函数编译为常量结果</p>
<p>constexpr 修饰变量、函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰变量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">char</span> arr[a]; <span class="comment">// 合法，a 是编译期常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修饰函数，使函数在编译期会成为常量表达式（如果可以）</span></span><br><span class="line"><span class="comment">// 如果 constexpr 函数返回的值不能在编译器确定，则 constexpr 函数就会退化为运行期函数（这样做的初衷是避免在为编译期和运行期写两份相同代码）</span></span><br><span class="line"><span class="comment">// constexpr 函数的设计其实不够严谨，所以 C++20 引入了 consteval （详见下文 C++20 部分）</span></span><br><span class="line"><span class="comment">// C++11 中，constexpr 修饰的函数只能包含 using 指令、typedef 语句以及 static_assert </span></span><br><span class="line"><span class="comment">// C++14 实现了对其他语句的支持</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">len_foo_constexpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h3 id="初始化列表---扩展初始化列表的适范围">09 初始化列表 - 扩展「初始化列表」的适⽤范围</h3>
<p>在 C++98/03 中，普通数组或 <strong>POD 类型</strong> 可以通过初始化列表的⽅式进⾏初始化，例如：</p>
<blockquote>
<p>POD 类型见下文的 #18 条</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> arr2[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; </span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;    </span><br></pre></td></tr></table></figure>
<p>C++11 扩展了「初始化列表」的适⽤范围，使之可以适⽤于所有类型对象的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dog</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dog dog1 = &#123;<span class="string">&quot;cat1&quot;</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Dog dog2 &#123;<span class="string">&quot;cat2&quot;</span>, <span class="number">2</span>&#125;;    </span><br></pre></td></tr></table></figure>
<p>还可以通过 <strong>std::initializer_list</strong> 来实现更强⼤的「初始化列表」，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dog</span>(initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">   <span class="keyword">for</span> (initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">          it != list.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">      cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dog dog3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;    </span><br></pre></td></tr></table></figure>
<p>同时，初始化列表还可以⽤作普通函数的<strong>形参</strong>或<strong>返回值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">watch</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;watch&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">watch</span>(&#123;<span class="string">&quot;watch_dog&quot;</span>, <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 作为返回值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getDefaultDog</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="string">&quot;default&quot;</span>, <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getDefaultDog</span>();    </span><br></pre></td></tr></table></figure>
<h3 id="委托与继承的构造函数">10 委托与继承的构造函数</h3>
<p><strong>委托构造</strong>：在⼀个构造函数中调⽤同⼀个类的另⼀个构造函数<br />
<strong>继承构造</strong>：在 C++11 之前的 C++ 中，⼦类需要依次声明⽗类拥有的构造函数，并传递相应的初始化参数。C++11 利⽤关键字 using 引⼊了继承构造函数，使⽤⼀⾏语句让编译器⾃动完成上述⼯作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Parent</span>() &#123;</span><br><span class="line">    value1 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Parent</span>(<span class="type">int</span> value) : <span class="built_in">Parent</span>() &#123; <span class="comment">// 委托 Parent() 构造函数</span></span><br><span class="line">    value2 = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent &#123;</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">using</span> Parent::Parent;         <span class="comment">// 继承构造</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h3 id="花括号或等号初始化器">11 花括号或等号初始化器</h3>
<p>上⽂已提及，不再赘述</p>
<h3 id="nullptr">12 <code>nullptr</code></h3>
<p>传统 C++ 中 NULL 的定义存在很多缺陷，编译器在实现时常常将其定义为 0，这会导致重载混乱。考虑如下代码；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;    </span><br></pre></td></tr></table></figure>
<p>当调⽤ <code>foo(NULL)</code> 时将匹配到 <code>foo(int)</code> 函数，这显然会让⼈感到迷惑。</p>
<p>C++11 引⼊了 <strong>nullptr</strong> （类型为 <code>nullptr_t</code>）关键字，以便区分空指针与 0，且 <code>nullptr</code> 能够隐式的转换为任何指针或成员指针的类型。</p>
<h3 id="long-long">13 long long</h3>
<p><strong>long</strong>: ⽬标类型将有⾄少 <strong>32 位</strong>的宽度<br />
<strong>long long</strong>: ⽬标类型将有⾄少 <strong>64 位</strong>的宽度</p>
<blockquote>
<p>如同 long 类型后缀需要 「l」 或 「L」，long long 类型后缀需要加上「ll」或「LL」。</p>
</blockquote>
<h3 id="char16_t-与-char32_t">14 char16_t 与 char32_t</h3>
<p>C++98 中为了表达 Unicode 字符串，引⼊了 wchar_t 类型，以解决 1 字节的 char 只能 256 个字符的问题。</p>
<p>但是由于 wchar_t 类型在不同平台上实现的长度不同，在代码移植⽅⾯有⼀定的影响。于是 C++11 引⼊ <strong>char16_t</strong> 和 <strong>char32_t</strong>，他们拥有的固定的长度，分别为 <strong>2 个字节</strong>和 <strong>4 个字节</strong>。</p>
<p><strong>char16_t</strong>: UTF-16 字符表⽰的类型，要求⼤到⾜以表⽰任何 UTF-16 编码单元（ 16 位）。它与 <code>std::uint_least16_t</code> 具有相同的⼤⼩、符号性和对齐，但它是独⽴的类型。</p>
<p><strong>char32_t</strong>: - UTF-32 字符表⽰的类型，要求⼤到⾜以表⽰任何 UTF-32 编码单元（ 32 位）。它与 <code>std::uint_least32_t</code> 具有相同的⼤⼩、符号性和对齐，但它是独⽴的类型。</p>
<p>同时 C++11 还定义了 3 个常量字符串前缀：</p>
<ul>
<li>u8 代表 UTF-8 编码</li>
<li>u 代表 UTF-16 编码</li>
<li>U 代表 UTF-32 编码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char16_t</span> UTF16[] = <span class="string">u&quot;中国&quot;</span>; <span class="comment">// 使用 UTF-16 编码存储</span></span><br><span class="line"></span><br><span class="line"><span class="type">char32_t</span> UTF16[] = <span class="string">U&quot;中国&quot;</span>; <span class="comment">// 使用 UTF-32 编码存储    </span></span><br></pre></td></tr></table></figure>
<h3 id="类型别名">15 类型别名</h3>
<p>传统 C++ 中使⽤ typedef 来为类型定义⼀个新的名称，C++11 中我们可以使⽤ using 达到同样的效果，如下所⽰：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::ios_base::fmtflags flags;</span><br><span class="line"><span class="keyword">using</span> flags = std::ios_base::fmtflags;    </span><br></pre></td></tr></table></figure>
<p>既然有了 typedef 为什么还引⼊ using？当然是因为 using ⽐起 typedef 还能做更多。</p>
<p>typedef 是只能为「类型」定义新名称，⽽模板则是 「<strong>⽤来产⽣类型</strong>」的，所以以下代码是⾮法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogTemplate</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    T attr1;</span><br><span class="line">    U aatr2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> DogTemplate&lt;std::vector&lt;T&gt;, std::string&gt; DogT;    </span><br></pre></td></tr></table></figure>
<p>但使⽤ using 则可以为模板定义别名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> DogT = DogTemplate&lt;std::vector&lt;T&gt;, std::string&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="变长参数模板">16 变长参数模板</h3>
<p>在传统 C++ 中，类模板或函数模板只能接受固定数量的模板参数。</p>
<p><strong>⽽ C++11 允许任意多个、任意类别的模板参数，同时在定义时⽆需固定参数个数</strong>。如下所⽰：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt; <span class="keyword">class</span> <span class="title class_">DogT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传⼊多个不同类型的模板参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogT</span>&lt;<span class="type">int</span>, </span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;,</span><br><span class="line">            std::map&lt;std::string,</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;&gt;&gt; dogT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不传⼊参数（ 0 个参数）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogT</span>&lt;&gt; nothing;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第⼀个参数必传，之后为变⻓参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> require, <span class="keyword">typename</span>... Args&gt; <span class="keyword">class</span> <span class="title class_">CatT</span>;    </span><br></pre></td></tr></table></figure>
<p>同样的可⽀持模板函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_print</span><span class="params">(<span class="type">const</span> std::string&amp; str, Args... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使⽤ sizeof... 计算参数个数</span></span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h3 id="推的平凡联合体">17 推⼴的（⾮平凡）联合体</h3>
<p>联合体 Union 为我们提供了在⼀个结构内定义多种不同类型的成员的能⼒，但在传统 C++ 中，并不是所有的数据类型都能成为联合体的数据成员。例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="built_in">Dog</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">age</span>(a), <span class="built_in">size</span>(b) &#123;&#125;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">T</span> &#123;</span><br><span class="line">  <span class="comment">// C++11 之前为非法（d 不是 POD 类型）</span></span><br><span class="line">  <span class="comment">// C++11 之后合法</span></span><br><span class="line">  Dog d;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关 POD 类型参考下⽂的 #18 条</p>
<p>C++11 <strong>去除</strong>了上述联合体的限制 <strong>[3]</strong>，标准规定了 <strong>任何⾮引⽤类型都可以成为联合体的数据成员</strong>。</p>
<blockquote>
<p><strong>[3]</strong> 去除的原因是经过长期的实践证明为了兼容 C 所做的限制没有必要。</p>
</blockquote>
<h3 id="推的-pod-平凡类型与标准布局类型">18 推⼴的 POD （平凡类型与标准布局类型）</h3>
<p>POD 为 Plain Old Data 的缩写，Plain 突出其为⼀种普通数据类型，Old 体现其具有与 C 的兼容性，例如可以使⽤ memcpy() 函数进⾏复制、使⽤ memset() 函数进⾏初始化等。</p>
<p>具体地，C++11 将 POD 划分为两个概念的合集：平凡的（trival）和标准布局的（standard layout）。</p>
<p>其中平凡的类或结构体应该符合如下要求：</p>
<ol type="1">
<li>拥有平凡的默认构造函数和析构函数。即不⾃定义任何构造函数，或通过 <code>=default</code> 来显⽰指定使⽤默认构造函数</li>
<li>拥有平凡的拷贝构造函数和移动构造函数</li>
<li>拥有平凡的拷贝赋值运算符和移动赋值运算符</li>
<li>不包含虚函数以及虚基类</li>
</ol>
<p>C++11 同时提供了辅助类模板 is_trivial 来实现是否平凡的判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; is_trivial&lt;DogT&gt;::value &lt;&lt; endl;    </span><br></pre></td></tr></table></figure>
<p>POD 包含的另⼀个概念则是「标准布局」。标准布局的类或结构体需要符合如下要求：</p>
<ol type="1">
<li>所有⾮静态成员有相同的访问权限（public、private、protected）</li>
<li>类或结构体继承时满⾜如下两个条件之⼀：<br />
2.1 ⼦类中有⾮静态成员，且只有⼀个仅包含静态成员的基类</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B1</span> &#123; <span class="type">static</span> <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B2</span> &#123; <span class="type">static</span> <span class="type">int</span> b; &#125;;</span><br></pre></td></tr></table></figure>
<pre><code>2.2 基类有⾮静态成员，则⼦类没有⾮静态成员</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B2</span> &#123; <span class="type">int</span> a; &#125; ;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : B2 &#123; <span class="type">static</span> <span class="type">int</span> d; &#125;;</span><br></pre></td></tr></table></figure>
<pre><code>从上述条件可知，1\. 只要⼦类和基类同时都有⾮静态成员 2. ⼦类继承多个基类，有多个基类同时有⾮静态成员。 这两种情况都不属于标准布局。</code></pre>
<ol start="3" type="1">
<li>类中第⼀个⾮静态成员的类型与其基类不同</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> : B &#123; B b; &#125;;        <span class="comment">// 非标准布局，第一个非静态成员 b 就是基本类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> : B &#123; <span class="type">int</span> a; B b; &#125;; <span class="comment">// 标准布局，第一个非静态成员 a 不是基类 B 类型</span></span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>没有虚函数或虚基类</li>
<li>所有⾮静态数据成员均符合标准布局类型，其基类也符合标准布局（递归定义）</li>
</ol>
<p>同样 C++11 提供了辅助类模板 is_standard_layout 帮助我们判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; is_standard_layout&lt;Dog&gt;::value &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>最后，C++11 也提供了⼀次性判断是否为 POD 的辅助类模板 is_pod:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; is_pod&lt;Dog&gt;::value &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>了解 POD 的基本概念，POD 到底有怎样的作⽤或好处呢？POD 能够给我们带来如下优点：</p>
<ol type="1">
<li>字节赋值。安全的使⽤ memset 和 memcpy 对 POD 类型进⾏初始化和拷贝等操作</li>
<li>兼容 C 内存布局。以便与 C 函数进⾏互操作</li>
<li>保证静态初始化的安全。⽽静态初始化可有效提⾼程序性能</li>
</ol>
<h3 id="unicode-字符串字量">19 Unicode 字符串字⾯量</h3>
<p>在 #14 已有所提及，C++11 定义了 3 个常量字符串前缀：</p>
<ul>
<li>u8 代表 UTF-8 编码</li>
<li>u 代表 UTF-16 编码</li>
<li>U 代表 UTF-32 编码</li>
</ul>
<p>另外 C++11 还引⼊了⼀个字符串前缀 R 表⽰ 「<strong>原⽣字符串字⾯量</strong>」，所谓「原⽣字符串字⾯量」即表⽰字符串⽆需通过转义处理特殊字符，所见即所得：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⽤法： R&quot;分隔符 (原始字符 )分隔符&quot;</span></span><br><span class="line">string path = <span class="string">R&quot;(D:\workspace\vscode\java_demo)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// - 作为分隔符，</span></span><br><span class="line"><span class="comment">// 因为原始字符串含有 )&quot;，如果不添加 - 作为分隔符，则会导致字符串错误标示结束位置</span></span><br><span class="line"><span class="comment">// 分隔符应该尽量使用原始字符串中未出现的字符，以便正确标示开始与结尾</span></span><br><span class="line">string path2 = <span class="string">R&quot;-(a\b\c)&quot;\daaa\e)-&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="户定义字量">20 ⽤户定义字⾯量</h3>
<p>⽤户定义字⾯量即⽀持⽤户定义类型的字⾯量。</p>
<p>传统 C++ 提供了多种字⾯量，例如 "12.5" 为⼀个 double 类型字⾯量。"12.5f" 为⼀个 float 类型字⾯量。这些字⾯量是 C++ 标准中定义和规定的字⾯量，程序和⽤户⽆法⾃定义新的<strong>字⾯量类型</strong>或<strong>后缀</strong>。</p>
<p>C++11 则是引⼊了⽤户⾃定义字⾯量的能⼒。主要通过定义「字⾯量运算符函数」或函数模板实现。该运算符名称由⼀对相邻双引号前导。字⾯量运算符通常在⽤户定义字⾯量的地⽅被隐式调⽤。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户定义字面量运算符的实现</span></span><br><span class="line">S <span class="keyword">operator</span> <span class="string">&quot;&quot;</span>_mysuffix(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> v) &#123;</span><br><span class="line">  S s_;</span><br><span class="line">  S_.value = (<span class="type">int</span>) v;</span><br><span class="line">  <span class="keyword">return</span> s_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">S sv;</span><br><span class="line"><span class="comment">// 101 为类型为 S 的字面量</span></span><br><span class="line"><span class="comment">// _mysuffix 是我们自定义的后缀，如同 float 的 f 一般</span></span><br><span class="line">sv = <span class="number">101</span>_mysuffix;</span><br></pre></td></tr></table></figure>
<p>⽤户⾃定义字⾯量通常由以下⼏种类型：</p>
<ol type="1">
<li>数值型字面量<br />
1.1 整数型字面量<br />
1.2 浮点型字面量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OutputType <span class="keyword">operator</span> <span class="string">&quot;&quot;</span> _suffix(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>);</span><br><span class="line">OutputType <span class="keyword">operator</span> <span class="string">&quot;&quot;</span> _suffix(<span class="type">long</span> <span class="type">double</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Uses the &#x27;unsigned long long&#x27; overload.</span></span><br><span class="line">OutputType some_variable = <span class="number">1234</span>_suffix;</span><br><span class="line"><span class="comment">// Uses the &#x27;long double&#x27; overload.</span></span><br><span class="line">OutputType another_variable = <span class="number">3.1416</span>_suffix;     </span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>字符串字面量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OutputType <span class="keyword">operator</span> <span class="string">&quot;&quot;</span> _ssuffix(<span class="type">const</span> <span class="type">char</span>     * string_values, <span class="type">size_t</span> num_chars);</span><br><span class="line">OutputType <span class="keyword">operator</span> <span class="string">&quot;&quot;</span> _ssuffix(<span class="type">const</span> <span class="type">wchar_t</span>  * string_values, <span class="type">size_t</span> num_chars);</span><br><span class="line">OutputType <span class="keyword">operator</span> <span class="string">&quot;&quot;</span> _ssuffix(<span class="type">const</span> <span class="type">char16_t</span> * string_values, <span class="type">size_t</span> num_chars);</span><br><span class="line">OutputType <span class="keyword">operator</span> <span class="string">&quot;&quot;</span> _ssuffix(<span class="type">const</span> <span class="type">char32_t</span> * string_values, <span class="type">size_t</span> num_chars);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses the &#x27;const char *&#x27; overload.</span></span><br><span class="line">OutputType some_variable =   <span class="string">&quot;1234&quot;</span>_ssuffix; </span><br><span class="line"><span class="comment">// Uses the &#x27;const char *&#x27; overload.</span></span><br><span class="line">OutputType some_variable = <span class="string">u8&quot;1234&quot;</span>_ssuffix;</span><br><span class="line"><span class="comment">// Uses the &#x27;const wchar_t *&#x27;  overload. </span></span><br><span class="line">OutputType some_variable =  <span class="string">L&quot;1234&quot;</span>_ssuffix; </span><br><span class="line"><span class="comment">// Uses the &#x27;const char16_t *&#x27; overload.</span></span><br><span class="line">OutputType some_variable =  <span class="string">u&quot;1234&quot;</span>_ssuffix; </span><br><span class="line"><span class="comment">// Uses the &#x27;const char32_t *&#x27; overload.</span></span><br><span class="line">OutputType some_variable =  <span class="string">U&quot;1234&quot;</span>_ssuffix;     </span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>字符字面量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S <span class="keyword">operator</span> <span class="string">&quot;&quot;</span> _mysuffix(<span class="type">char</span> value) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> cv[] &#123;value,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  <span class="function">S <span class="title">sv_</span> <span class="params">(cv)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> sv_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">S cv &#123;<span class="string">&#x27;h&#x27;</span>_mysuffix&#125;;    </span><br></pre></td></tr></table></figure>
<blockquote>
<p>尽整些花里胡哨的特性</p>
</blockquote>
<h3 id="属性">21 属性</h3>
<p>C++11 引⼊了所谓的 「<strong>属性</strong>」来让程序员在代码中提供额外信息，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f() 永不返回</span></span><br><span class="line"><span class="type">void</span> f [[ noreturn ]] () &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;error&quot;</span>;  <span class="comment">// 虽然不能返回，但可以抛出异常</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>上述例⼦的展现了属性的基本形式，<strong>noreturn</strong> 表⽰该函数永不返回。</p>
<p>C++11 引⼊了两个属性：</p>
<table>
<thead>
<tr class="header">
<th>属性</th>
<th>版本</th>
<th>修饰⽬标</th>
<th>作⽤</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>noreturn</td>
<td>C++11</td>
<td>函数</td>
<td>指⽰函数不返回，没有return语句，不正常执⾏完毕，但是可以通过出异常或 者exit()函数退出</td>
</tr>
<tr class="even">
<td>carries_dependency</td>
<td>C++11</td>
<td>函数、变量</td>
<td>指⽰释放消费 std::memory_order 中的依赖链传⼊和传出该函数</td>
</tr>
</tbody>
</table>
<blockquote>
<p>概念与功能与 Java 中的注解有些类似</p>
</blockquote>
<h3 id="lambda-表达式">22 Lambda 表达式</h3>
<p>Lambda 表达式基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [捕获列表]：捕获外部变量，详见下文</span></span><br><span class="line"><span class="comment">// (参数列表): 函数参数列表</span></span><br><span class="line"><span class="comment">// mutable: 是否可以修改值捕获的外部变量</span></span><br><span class="line"><span class="comment">// 异常属性：exception 异常声明</span></span><br><span class="line">[捕获列表](参数列表) <span class="built_in">mutable</span>( 可选 ) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 传统做法</span></span><br><span class="line">  <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 lambda</span></span><br><span class="line">  <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [x](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>lambda 表达式中的「捕获列表」可以让 lambda 表达式内部使用其可见范围的外部变量，例如上例中的 <code>x</code>。捕获列表一般有以下几种类型：</p>
<p><strong>1. 值捕获</strong></p>
<p>与参数传递中值传递类似，被捕获的变量以值拷贝的方式传入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [a] () &#123; a+= <span class="number">1</span>; cout &lt;&lt; a &lt;&lt; endl;&#125;;</span><br><span class="line"></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">f1</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;    </span><br></pre></td></tr></table></figure>
<p><strong>2. 引用捕获</strong><br />
加上 &amp; 符号，即可通过引用捕获外部变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 引用捕获</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;a] () &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">f2</span>();    </span><br></pre></td></tr></table></figure>
<p><strong>3. 隐式捕获</strong></p>
<p>无需显示列出所有需要捕获的外部变量，通过 <code>[=]</code> 可以通过「值捕获」的方式捕获所有外部变量，<code>[&amp;]</code> 可以通过「引用捕获」的方式捕获所有外部变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f3 = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 值捕获</span></span><br><span class="line"><span class="built_in">f3</span>(); <span class="comment">// 输出：1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f4 = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 引用捕获</span></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">f4</span>(); <span class="comment">// 输出：2    </span></span><br></pre></td></tr></table></figure>
<p><strong>4. 混合方式</strong></p>
<p>以上方式的混合，<code>[=, &amp;x]</code> 表示变量 x 以引用形式捕获，其余变量以传值形式捕获。</p>
<p>最终 lambda 捕获外部变量总结如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>捕获形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[]</td>
<td>不捕获任何外部变量</td>
</tr>
<tr class="even">
<td>[变量名, …]</td>
<td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td>
</tr>
<tr class="odd">
<td>[this]</td>
<td>以值的形式捕获this指针</td>
</tr>
<tr class="even">
<td>[=]</td>
<td>以值的形式捕获所有外部变量</td>
</tr>
<tr class="odd">
<td>[&amp;]</td>
<td>以引用形式捕获所有外部变量</td>
</tr>
<tr class="even">
<td>[=, &amp;x]</td>
<td>变量x以引用形式捕获，其余变量以传值形式捕获</td>
</tr>
<tr class="odd">
<td>[&amp;, x]</td>
<td>变量x以值的形式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody>
</table>
<h3 id="noexcept-说明符与-noexcept-运算符">23 noexcept 说明符与 noexcept 运算符</h3>
<p>C++11 将异常的声明简化为以下两种情况：</p>
<ol type="1">
<li>函数可能抛出任何异常</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">// 可能抛出异常    </span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>函数不可能抛出任何异常</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 不可能抛出异常    </span></span><br></pre></td></tr></table></figure>
<p>使⽤ <strong>noexcept</strong> 能够让编译器更好的优化代码，同时 <strong>noexcept</strong> 修饰的函数如果抛出异常将会导致调⽤ <code>std::terminate()</code> ⽴即终⽌程序。</p>
<p>noexcept 还可作为运算符使⽤，来判断⼀个表达式是否产⽣异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">func</span>()) &lt;&lt; endl;    </span><br></pre></td></tr></table></figure>
<h3 id="alignof-与-alignas">24 alignof 与 alignas</h3>
<p>C++11 引⼊了 <strong>alignof</strong> 和 <strong>alignas</strong> 来实现对内存对齐的控制。</p>
<p><strong>alignof</strong>: 能够获取对齐⽅式<br />
<strong>alignas</strong>: ⾃定义结构的对齐⽅式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(std::<span class="type">max_align_t</span>) B &#123;</span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="type">float</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">alignof</span>(A) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">alignof</span>(B) &lt;&lt; endl;    </span><br></pre></td></tr></table></figure>
<h3 id="多线程内存模型">25 多线程内存模型</h3>
<p>请参见 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a25e0754e2b9">LevelDB 中的跳表实现</a> 中的 「<strong>C++ 中的 atomic 和 memory_order</strong>」一节。</p>
<h3 id="线程局部存储">26 线程局部存储</h3>
<p>在多线程程序中，全局以及静态变量会被多个线程共享，这在某些场景下是符合期望和需求的。</p>
<p>但在另⼀些场景下，我们希望能有线程级的变量，这种变量是线程独享的，不受其他线程影响。我们称之为<strong>线程局部存储（TLS， thread local storage）</strong>。</p>
<p>C++11 引⼊了 <strong>thread_local</strong> ⽤来声明线程局部存储，如下所⽰：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">thread_local</span> num;    </span><br></pre></td></tr></table></figure>
<h3 id="gc-接口">27 GC 接口</h3>
<p>众所周知 C++ 是⼀门显式堆内存管理的语⾔，程序员需要时时刻刻关注⾃⼰对内存空间的分配和销毁。 ⽽如果程序员没有正确进⾏堆内存管理，就会造成程序的异常、错误、崩溃等。从语⾔层⾯是讲，这些不正确的内存管理主要有：</p>
<ul>
<li><strong>野指针</strong>：内存已经被销毁，但指向它的指针依然被使⽤</li>
<li><strong>重复释放</strong>：释放已经被释放过的内存，或者释放被重新分配过的内存，导致重复释放错误</li>
<li><strong>内存泄漏</strong>：程序中不再需要的内存空间却没有被及时释放，导致随着程序不断运⾏内存不断被⽆谓消耗</li>
</ul>
<p>显式内存管理可以为程序员提供极⼤的编程灵活性，但也提⾼了出错的概率。为此，C++11 进⼀步改造了智能指针，同时也提供了⼀个 <strong>「最⼩垃圾回收」</strong>的标准。</p>
<p>⽬前⾮常多的现代语⾔都全⾯⽀持「垃圾回收」，例如 Java、Python、C#、Ruby、PHP 等都⽀持「垃圾回收」。 为实现「垃圾回收」，最重要的⼀点就是<strong>判断对象或内存何时能够被回收</strong>。判断对象或内存是否可回收的⽅法主要有：</p>
<ol type="1">
<li><strong>引用计数</strong></li>
<li><strong>跟踪处理（跟踪对象关系图）</strong>。如 Java 中的「<strong>对象可达性分析</strong>」。</li>
</ol>
<p>确定了对象或内存可被回收后，就需要进⾏回收，⽽这⾥又存在不同的回收策略和回收算法（简单描述）：</p>
<ol type="1">
<li><strong>标记-清除</strong><br />
第⼀步对对象和内存进⾏标记是否可回收，第⼆步对标记的内存进⾏回收。显然这种⽅法将导致⼤量的内存碎⽚</li>
<li><strong>标记-整理</strong><br />
第⼀步同样是标记。但是第⼆步不是直接清理，⽽是将「活对象」向左靠齐（整理）。但移动⼤量对象，将导致程 序中的引⽤需要进⾏更新。如果对象死亡的⽐较多，就要进⾏⽐较多的移动操作。所以适合「长寿」的对象。</li>
<li><strong>复制算法</strong>。将堆空间分为两个部分：<strong>from</strong> 和 <strong>to</strong>。from 空间⽤满后启动扫描标记，找出其中活着的对象，将其复制到 to 空间， 然后清空 from 空间。之后原先 to 变成了 from 空间供程序分配内存，原先的 from 变成 to，等待下⼀次垃圾回收收容那些「幸存者」。如果有⼤量幸存者，那么拷贝将导致较⼤性能消耗。因此适合短寿「<strong>朝⽣暮死</strong>」的对象。</li>
</ol>
<p>⽽在实现时通常采⽤「分代收集」算法，即将堆空间分为 <strong>「新⽣代」</strong>和 <strong>「⽼年代」</strong>，新⽣代朝⽣暮死适合「拷贝算法」，⽼年代长寿适合「标记清理」或「标记整理」。</p>
<p>上述介绍了垃圾回收的相关算法，C++11 则是制定了「最⼩垃圾回收」的标准，所谓「最⼩」指的其实就是它压根就不是⼀个完整的 GC，⽽是为了后续的 GC 铺垫，⽬前也只是提供了⼀些库函数来辅助 GC，如：<br />
declare_reachable(声明⼀个对象不能被回收)、undeclare_reachable(声明⼀个对象可以被回收)。</p>
<p>由于 C++ 中的指针⼗分灵活，这种灵活性将导致 GC 误判从⽽回收内存，因此提供这两个函数保护对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">p1 += <span class="number">10</span>;             <span class="comment">// 将导致 GC 回收内存空间</span></span><br><span class="line">p1 -= <span class="number">10</span>;             <span class="comment">// 指针的灵活性：又移动回来了</span></span><br><span class="line">*p1 = <span class="number">10</span>;             <span class="comment">// 内存已被回收，导致程序错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 declare_reachable 保护对象不被 GC</span></span><br><span class="line"><span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">declare_reachable</span>(p2); <span class="comment">// p2 不可回收</span></span><br><span class="line"></span><br><span class="line">p2 += <span class="number">10</span>;              <span class="comment">// GC 不会回收</span></span><br><span class="line">p2 -= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">*p2 = <span class="number">10</span>;              <span class="comment">// 程序正常    </span></span><br></pre></td></tr></table></figure>
<p>从上可知，这两个函数就是为旧程序兼容即将到来<strong>[4]</strong>的 C++ GC 而设计的。</p>
<blockquote>
<p><strong>[4]</strong> 看样子是不会到来了。</p>
</blockquote>
<p>上述介绍了这么多，最后再来介绍最尴尬的⼀点：<strong>现在还没有编译器实现 C++11 有关 GC 的标准</strong>。</p>
<blockquote>
<p>可以暂时忽略这条 GC 特性，实际上 C++ 的很多特性都可以忽略</p>
</blockquote>
<h3 id="范围-for">28 范围 for</h3>
<p>类似 Java 中的 foreach 循环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : vec) &#123;</span><br><span class="line">  std::cout &lt;&lt; element &lt;&lt; std::endl;  <span class="comment">// read only</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h3 id="static_assert">29 static_assert</h3>
<p>我们常⽤ assert，即运⾏时断⾔。但很多事情不该在运⾏时采取判断和检查，而应该在编译期就进⾏严格断⾔，例如数组的长度等。</p>
<p>C++11 引⼊了 static_assert 实现编译期断⾔：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">void</span> *) == <span class="number">4</span>,<span class="string">&quot;64位系统不支持&quot;</span>);    </span><br></pre></td></tr></table></figure>
<h3 id="智能指针">30 智能指针</h3>
<p>C++98 提供了模板类型「auto_ptr」来实现智能指针。auto_ptr 以对象的⽅式管理分配的内存，并在适当的时机释放内存。程序员只需要将 new 操作返回的指针作为 auto_ptr 的初始值即可，如下所⽰：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>(<span class="keyword">new</span> <span class="type">int</span>);    </span><br></pre></td></tr></table></figure>
<p>但 auto_ptr 存在「进⾏拷贝时会将原指针置为 NULL」等缺陷，因此 C++11 引⼊了 <strong>unique_ptr、shared_ptr、 weak_ptr</strong> 三种智能指针。</p>
<ul>
<li><strong>unique_ptr</strong>: unique_ptr 和指定对象的内存空间紧密绑定，不允许与其他 unique_ptr 指针共享同⼀个对象内存。即<strong>内存所有权在同⼀个时间内是唯⼀的</strong>，但所有权却可以通过 #05 条中提及的 move 和移动语义进⾏来实现「所有权」 转移。如下所⽰：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">111</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p2 = p1;        <span class="comment">// ⾮法，不可共享内存所有权</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">move</span>(p1);  <span class="comment">// 合法，移交所有权。p1 将丧失所有权</span></span><br><span class="line"></span><br><span class="line">p3.<span class="built_in">reset</span>();                     <span class="comment">// 显式释放内存    </span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>shared_ptr</strong>：与 unique_ptr 相对，可以共享内存所有权，即多个 shared_ptr 可以指向同⼀个对象的内存。同时 shared_ptr 采⽤<strong>引⽤计数法</strong>来判断内存是否还被需要，从⽽判断是否需要进⾏回收。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">222</span>))</span></span>;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p5 = p4;  <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">p4.<span class="built_in">reset</span>();               <span class="comment">// 「释放」内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于采⽤引⽤计数法，p4.reset() 仅仅使得引⽤数减⼀</span></span><br><span class="line"><span class="comment">// 所指向的内存由于仍有 p5 所指向，所以不会被回收</span></span><br><span class="line"><span class="comment">// 访问 *p5 是合法且有效的</span></span><br><span class="line">cout &lt;&lt; *p5 &lt;&lt; endl;      <span class="comment">// 输出 222    </span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>weak_ptr</strong>：weak_ptr 可以指向 shared_ptr 指向的内存，且在必要时可以通过成员 lock 来返回⼀个指向当前内存的 shared_ptr 指针，如果当前内存已经被释放，那么将 lock() 返回 nullptr。⽽另⼀个重点则是 weak_ptr <strong>不参与引⽤计数</strong>。如同⼀个「虚拟指针」⼀样指向 shared_ptr 指向的对象内存，⼀⽅⾯不妨碍内存的释放，另⼀⽅⾯又可以通过 weak_ptr 判断内存是否有效以及是否已经被释放：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">333</span>))</span></span>;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p7 = p6;</span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; weak_p8 = p7;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p9_from_weak_p8 = weak_p8.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p9_from_weak_p8 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;内存有效&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;内存已被释放&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p6.<span class="built_in">reset</span>();</span><br><span class="line">p7.<span class="built_in">reset</span>(); <span class="comment">// weak_p8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存已被释放，即使 weak_p8 还「指向」该内存    </span></span><br></pre></td></tr></table></figure>
<p>weak_ptr 还有⼀个⾮常重要的应⽤并是解决 shared_ptr 引⽤计数法所带来的 <strong>「循环引⽤」</strong>问题。所谓「循环引⽤」 如下图所⽰：</p>
<img src="/2023/09/10/cpp_11_14_17_20/pointer1.png" class="" title="pointer1.png">
<p>由于 ObjA 和 ObjB 内部有成员变量相互引⽤，即使将 P1 和 P2 引⽤去除，这两个对象的引⽤计数仍然不为 0。但实际上两个对象已经不可访问，理应被回收。</p>
<p>使⽤ weak_ptr 来实现上⾯两个对象的相互引⽤则可以解决该问题，如下图所⽰：</p>
<img src="/2023/09/10/cpp_11_14_17_20/pointer2.png" class="" title="pointer2.png">
<p>将 P1 和 P2 引⽤去除，此时 ObjA 和 ObjB 内部是通过 weak_ptr 相互引用的，由于 <strong>weak_ptr 不参与引用计数</strong>，因此 ObjA 和 ObjB 的引用计数被判断为 0，ObjA 和 ObjB 将被正确回收。</p>
<h2 id="c14-新特性">C++14 新特性</h2>
<h3 id="变量模板">01 变量模板</h3>
<p>我们已经有了类模板、函数模板，现在 C++14 为我们带来了变量模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; pi&lt;<span class="type">float</span>&gt; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然在以前也可以通过函数模板来模拟</span></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">pi_fn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">T</span>(<span class="number">3.1415926535897932385</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h3 id="泛型-lambda">02 泛型 lambda</h3>
<p>所谓「泛型 lambda」，就是在形参声明中使用 auto 类型指示说明符的 lambda。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;    </span><br></pre></td></tr></table></figure>
<h3 id="lambda-初始化捕获">03 lambda 初始化捕获</h3>
<p>C++11 lambda 已经为我们提供了值捕获和引⽤捕获，但针对的实际都是左值，⽽<strong>右值对象⽆法被捕获</strong>，这个问题在 C++14 中得到了解决:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda1 = [value = <span class="number">1</span> + a] &#123;<span class="keyword">return</span> value;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动捕获</span></span><br><span class="line"><span class="keyword">auto</span> lambda2 = [value = std::<span class="built_in">move</span>(ptr)] &#123;<span class="keyword">return</span> *value;&#125;;    </span><br></pre></td></tr></table></figure>
<h3 id="newdelete-elision">04 new/delete elision</h3>
<blockquote>
<p>不知怎么翻译好，new/delete 消除？new/delete 省略？<br />
在 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fzh.cppreference.com%2Fw%2Fcpp%2F14">cppreference c++14</a> 列出了这条，但没有详细说明。</p>
</blockquote>
<p>由于 C++14 新提供了 make_unique 函数，unique_ptr 可在析构是自动删除，再加上 make_shared 和 shared_ptr，基本可以覆盖大多数场景和需求了。所以从 C++14 开始， new/delete 的使用应该会大幅度减少。</p>
<h3 id="constexpr-函数上放松的限制">05 constexpr 函数上放松的限制</h3>
<p>在 C++11 的 #08 条中已经提及 constexpr 修饰的函数除了可以包含 using 指令、typedef 语句以及 static_assert 断⾔ 外，只能包含⼀条 return 语句。</p>
<p>⽽ C++14 则放开了该限制，constexpr 修饰的函数可包含 <strong>if/switch 等条件语句，也可包含 for 循环</strong>。</p>
<h3 id="进制字量">06 ⼆进制字⾯量</h3>
<p>C++14 的数字可⽤⼆进制形式表达，前缀使⽤ <code>0b</code> 或 <code>0B</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0b101010</span>; <span class="comment">// C++14    </span></span><br></pre></td></tr></table></figure>
<h3 id="数字分隔符">07 数字分隔符</h3>
<p>使⽤单引号 <code>'</code> 来提⾼数字可读性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> integer_literal = <span class="number">100&#x27;0000</span>;    </span><br></pre></td></tr></table></figure>
<blockquote>
<p>GC、模块、协程等重大特性唯唯诺诺，可有可无的特性 C++ 重拳出击！</p>
</blockquote>
<h3 id="函数的返回类型推导">08 函数的返回类型推导</h3>
<p>上文提及了 C++11 中使用 auto/decltype 配合尾置返回值实现了函数返回值的推导，C++14 实现了一个 auto 并自动推导返回值类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Func</span><span class="params">()</span></span>; <span class="comment">// 返回类型由编译器推断    </span></span><br></pre></td></tr></table></figure>
<h3 id="带默认成员初始化器的聚合类">09 带默认成员初始化器的聚合类</h3>
<p>C++11 增加了默认成员初始化器，如果构造函数没有初始化某个成员，并且这个成员拥有默认成员初始化器，就会⽤默认成员初始化器来初始化成员。</p>
<p>而在 C++11 中，聚合类（aggregate type）的定义被改为「明确排除任何含有默认成员初始化器」的类型。</p>
<p>因此，在 C++11 中，如果⼀个类含有默认成员初始化器，就不允许使⽤聚合初始化。C++14放松了这⼀限制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CXX14_aggregate</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">42</span>;  <span class="comment">// 带有默认成员初始化器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 中不允许</span></span><br><span class="line"><span class="comment">// 但 C++14允许 且 a.y 将被初始化为42</span></span><br><span class="line">CXX14_aggregate a = &#123; <span class="number">1</span> &#125;;     </span><br></pre></td></tr></table></figure>
<h3 id="decltypeauto">10 decltype(auto)</h3>
<blockquote>
<p>允许 auto 的类型声明使⽤ decltype 的规则。也即，允许不必显式指定作为decltype参数的表达式，而使用decltype对于给定表达式的推断规则。<br />
—— From <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FC%252B%252B14">Wikipedia C++14</a></p>
</blockquote>
<p>看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在另一个函数中对下面两个函数进行转发调用</span></span><br><span class="line"><span class="function">std::string  <span class="title">lookup1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">lookup2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 C++11 中，需要这么实现</span></span><br><span class="line"><span class="function">std::string <span class="title">look_up_a_string_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">returnlookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">look_up_a_string_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">returnlookup2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 C++14 中，可以通过 decltype(auto) 实现</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">look_up_a_string_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">look_up_a_string_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup2</span>();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h2 id="c17-新特性">C++17 新特性</h2>
<h3 id="折叠表达式">01 折叠表达式</h3>
<p>上文介绍了 C++11 中介绍了「变长参数模板」(C++11 第 #16 条)。在 C++11 中对变长参数进行展开比较麻烦，通常采用递归函数的方式进行展开：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  <span class="comment">// 递归终止函数</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;last&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T head, Args... rest)</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;parameter &quot;</span> &lt;&lt; head &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">print</span>(rest...); <span class="comment">// 递归展开 rest 变长参数</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>C++17 引入「折叠表达式」来进一步支持变长参数的展开：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⼀元左折叠</span></span><br><span class="line"><span class="comment">// 只有一个操作符 「-」，且展开符 ... 位于参数包 args 的左侧，故为一元左折叠</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_val_left</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (... - args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">sub_val_left</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);   <span class="comment">// ((2 - 3) - 4) = -5;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一元右折叠</span></span><br><span class="line"><span class="comment">// 只有一个操作符 「-」，且展开符 ... 位于参数包 args 的右侧，故为一元右折叠</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_val_right</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (args - ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">sub_val_right</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// (2 - (3 - 4)) = 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元左折叠</span></span><br><span class="line"><span class="comment">// 左右有两个操作符 ，且展开符 ... 位于参数包 args 的左侧，故为二元左折叠</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_one_left</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span> - ... - args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> t  = <span class="built_in">sub_one_left</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// ((1 - 2) - 3) - 4 = -8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元右折叠</span></span><br><span class="line"><span class="comment">// 左右有两个操作符，且展开符 ... 位于参数包 args 的右侧，故为二元右折叠</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sub_one_right</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (args - ... - <span class="number">1</span>);        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> t  = <span class="built_in">sub_one_right</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">//  2 - (3 - (4 - 1)) = 2</span></span><br></pre></td></tr></table></figure>
<h3 id="类模板实参推导">02 类模板实参推导</h3>
<p>C++17 之前类模板⽆法进⾏参数推导：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="type">int</span>, string&gt; a&#123; <span class="number">1</span>, <span class="string">&quot;a&quot;</span>s &#125;; <span class="comment">// 需要指明 int, string 类型</span></span><br></pre></td></tr></table></figure>
<p>C++17 实现了类模板的实参类型推导：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair a&#123; <span class="number">1</span>, <span class="string">&quot;a&quot;</span>s &#125;; <span class="comment">// C++17，类模板可自行推导实参类型</span></span><br></pre></td></tr></table></figure>
<h3 id="auto-占位的类型模板形参">03 auto 占位的⾮类型模板形参</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> n&gt; <span class="keyword">struct</span> <span class="title class_">B</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">B&lt;<span class="number">5</span>&gt; b1;    <span class="comment">// OK: 非类型模板形参类型为 int</span></span><br><span class="line">B&lt;<span class="string">&#x27;a&#x27;</span>&gt; b2;  <span class="comment">// OK: 非类型模板形参类型为 char</span></span><br><span class="line">B&lt;<span class="number">2.5</span>&gt; b3;  <span class="comment">// 错误（C++20前）：非类型模板形参类型不能是 double</span></span><br></pre></td></tr></table></figure>
<h3 id="编译期的-constexpr-if-语句">04 编译期的 constexpr if 语句</h3>
<p>C++17 将 constexpr 这个关键字引⼊到 if 语句中，允许在代码中声明常量表达式的判断条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_info</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">1.1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码将在<strong>编译期</strong>进行 if 语句的判断，从而在<strong>编译期</strong>选定其中一条分支。</p>
<h3 id="内联变量inline-变量">05 内联变量（inline 变量）</h3>
<p>看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// student.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> age;  <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">Student</span> &#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> age;  <span class="comment">// 静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// student.cpp</span></span><br><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> Student::foo = <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<p>在 C++17 之前，如果想要使用全局变量或类的静态成员变量，需要在头文件中声明，然后在每个 cpp 文件中定义。</p>
<p>C++17 支持声明<strong>内联变量</strong>达到相同的效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// student.h</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">   <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="结构化绑定">06 结构化绑定</h3>
<blockquote>
<p>类似于 JavaScript 中的解构赋值</p>
</blockquote>
<p>⽰例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">double</span>, string&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">  <span class="comment">// 创建 e[2]</span></span><br><span class="line">  <span class="comment">// 复制 arr 到 e, 然后 a1 指代 e[0], b1 指代 e[1]</span></span><br><span class="line">  <span class="keyword">auto</span> [a1, b1] = arr;</span><br><span class="line">  cout &lt;&lt; a1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a2 指代 arr[0], b2 指代 arr[1]</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; [a2, b2] = arr;</span><br><span class="line">  cout &lt;&lt; a2 &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b2&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 结构化绑定 tuple</span></span><br><span class="line">  <span class="keyword">auto</span> [x, y, z] = <span class="built_in">f</span>();</span><br><span class="line">  cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ifswitch-语句的变量初始化">07 if/switch 语句的变量初始化</h3>
<p>if/switch 语句声明并初始化变量，形式为：if (init; condition) 和 switch (init; condition)。例⼦：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// int count = 5; 这条初始化语句直接写在 if 语句中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="type">int</span> count = <span class="number">5</span>; i &gt; count) &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// char c(getchar()); 这条初始化语句直接写在 switch 语句中</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="type">char</span> <span class="built_in">c</span>(<span class="built_in">getchar</span>()); c) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: <span class="built_in">left</span>(); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="built_in">right</span>(); <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u8-char">08 u8-char</h3>
<p>字符前缀：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">u8&#x27;c-字符&#x27;</span> <span class="comment">// UTF-8 字符字面量    </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意和上文的「字符串前缀」相区分，C++11 引入的 u8 是<strong>字符串</strong>前缀，C++17 补充 u8 可作为<strong>字符</strong>的前缀。</p>
</blockquote>
<h3 id="简化的嵌套命名空间">09 简化的嵌套命名空间</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123; <span class="keyword">namespace</span> Y &#123; … &#125;&#125;  <span class="comment">// 传统</span></span><br><span class="line"><span class="keyword">namespace</span> X::Y &#123; … &#125;              <span class="comment">// C++17 简化命名空间</span></span><br></pre></td></tr></table></figure>
<h3 id="using-声明语句可以声明多个名称">10 using 声明语句可以声明多个名称</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;A::f(int)&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>)</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;B::f(double)&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> : A, B &#123;</span><br><span class="line">    <span class="keyword">using</span> A::f, B::f; <span class="comment">// C++17</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="将-noexcept-作为类型系统的一部分">11 将 noexcept 作为类型系统的一部分</h3>
<p>与返回类型相似，异常说明成为函数类型的一部分，但<strong>不是函数签名的一部分</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面函数是不同类型函数，但拥有相同的函数签名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="新的求值顺序规则">12 新的求值顺序规则</h3>
<p>在 C++17 之前，为了满足各个编译器在不同平台上做相应的优化，C++ 对一些求值顺序未做严格规定。最典型的例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; i &lt;&lt; i++;       <span class="comment">// C++17 之前，未定义行为</span></span><br><span class="line">a[i] = i++;             <span class="comment">// C++17 之前，未定义行为</span></span><br><span class="line"><span class="built_in">f</span>(++i, ++i);            <span class="comment">// C++17 之前，未定义行为</span></span><br></pre></td></tr></table></figure>
<p>具体的，C++17 规定了以下求值顺序：</p>
<ul>
<li>a.b</li>
<li>a-&gt;b</li>
<li>a-&gt;*b</li>
<li>a(b1, b2, b3)</li>
<li>b @= a</li>
<li>a[b]</li>
<li>a &lt;&lt; b</li>
<li>a &gt;&gt; b</li>
</ul>
<p>顺序规则为：<strong>a 的求值和所有副作用先序于 b，但同一个字母的顺序不定</strong></p>
<h3 id="强制的复制消除guaranteed-copy-elision">13 强制的复制消除（guaranteed copy elision）</h3>
<p>C++17 引入「强制的复制消除」，以便在<strong>满足一定条件下</strong>能够<strong>确保</strong>消除对象的复制。</p>
<p>在 C++11 之前已经存在所谓的复制消除技术（copy elision），即编译器的返回值优化 RVO/NRVO。</p>
<blockquote>
<p>RVO(return value optimization): 返回值优化<br />
NRVO(named return value optimization)：具名返回值优化</p>
</blockquote>
<p>看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在传统的复制消除（copy elision）规则下，上述代码将会产生一个临时对象，并将其拷贝给「返回值」。这个过程可能会被优化掉，也就是拷贝/移动函数根本不会被调用。但程序还是必须提供相应的拷贝函数。</p>
<p>再看如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T t = <span class="built_in">Func</span>();</span><br></pre></td></tr></table></figure>
<p>上述代码会将返回值拷贝给 t，这个拷贝操作依然可能被优化掉，但同样的，程序依然需要提供相应的拷贝函数。</p>
<p>从上文可知，在传统的复制消除规则下，下面代码是非法的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的复制消除即使优化了拷贝函数的调用</span></span><br><span class="line"><span class="comment">// 但还是会检查是否定义了拷贝函数等</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="built_in">T</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">T</span>(<span class="type">const</span> T&amp;) = <span class="keyword">delete</span>; <span class="comment">// C++11 中如果不提供相应的拷贝函数将会导致 return 与 赋值错误</span></span><br><span class="line">    <span class="built_in">T</span>(T&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T t = <span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而「强制复制消除」对于纯右值 prvalue<strong>[5]</strong>，将会真正消除上述复制过程<strong>[6]</strong>，也不会检查是否提供了拷贝/移动函数，所以上述代码在 C++17 中是合法的。</p>
<blockquote>
<p><strong>[5]</strong> 在 C++17 之前，纯右值为临时对象，而 C++17 对纯右值 prvalue 的定义进行了扩展：能够产生临时对象但还未产生临时对象的表达式，如上例代码中的 Func();<br />
<strong>[6]</strong> 消除的原理：在满足「纯右值赋值给泛左值」这个条件时，T t = Func(); 会被优化成类似于 T t = T(); 这中间不会产生临时对象。</p>
</blockquote>
<p>但另一方面，对于「具名临时对象」，不会进行「强制复制消除」：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   T t = ...;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T 还是必须提供拷贝/移动函数，所以 C++17 对于具名返回值优化 NRVO (named return value optimization) 没有变化。</p>
<p>关于强制复制消除，可以参考下面链接的第一个回答，回答的很清楚：<br />
<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F38043319%2Fhow-does-guaranteed-copy-elision-work">How does guaranteed copy elision work?</a></p>
<blockquote>
<p>这一切是否来源于 C++ 的初始设计问题： = 运算符的默认重载，赋予了 = 运算符对象拷贝的语义。</p>
</blockquote>
<h3 id="lambda-表达式捕获-this">14 lambda 表达式捕获 *this</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Baz</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 this 捕获对象，之后在 lambda 即可访问对象的成员变量 s</span></span><br><span class="line">    <span class="keyword">return</span>[<span class="keyword">this</span>]&#123; std::cout &lt;&lt; s &lt;&lt; std::endl; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  std::string s;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> f1 = Baz&#123; <span class="string">&quot;ala&quot;</span> &#125;.<span class="built_in">foo</span>();</span><br><span class="line">  <span class="keyword">auto</span> f2 = Baz&#123; <span class="string">&quot;ula&quot;</span> &#125;.<span class="built_in">foo</span>();</span><br><span class="line">  <span class="built_in">f1</span>();</span><br><span class="line">  <span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但上述代码存在一个缺陷：捕获的是当前对象，如果 lambda 表达式对成员变量的访问超出了当前对象的生命周期，就会导致问题。</p>
<p>C++17 提供了 <code>*this</code> 捕获当前对象的<strong>副本</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>[*<span class="keyword">this</span>]&#123; std::cout &lt;&lt; s &lt;&lt; std::endl; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="constexpr-的-lambda-表达式">15 constexpr 的 lambda 表达式</h3>
<p>C++17 的 lambda 声明为 constexpr 类型，这样的 lambda 表达式可以用在其他需要 constexpr 类型的上下文中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [y]() <span class="keyword">constexpr</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> y + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="属性命名空间不必重复">16 属性命名空间不必重复</h3>
<p>在上文的 C++11 #21 条中已经介绍了属性的概念，对于由实现定义的行为的非标准属性，可能会带有命名空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[gnu::always_inline, gnu::<span class="type">const</span>, gnu::hot, nodiscard]]</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 声明 f 带四个属性</span></span><br><span class="line"></span><br><span class="line">[[gnu::always_inline, gnu::<span class="type">const</span>, gnu::hot, nodiscard]]</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 同上，但使用含有四个属性的单个属性说明符</span></span><br></pre></td></tr></table></figure>
<p>C++11 中上述属性的命名空间需要重复声明，C++17 简化了属性命名空间的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">using</span> gnu : <span class="type">const</span>, always_inline, hot]] [[nodiscard]]</span><br><span class="line"><span class="type">int</span> f[[gnu::always_inline]](); <span class="comment">// 属性可出现于多个说明符中</span></span><br></pre></td></tr></table></figure>
<h3 id="新属性-fallthrough-nodiscard-和-maybe_unused">17 新属性 [[fallthrough]] [[nodiscard]] 和 [[maybe_unused]]</h3>
<p>C++11 仅自带了两个标准属性，C++17 继续扩展了几个标准属性。</p>
<p><strong>fallthrough</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码因为没有 case 中没有 break;</span></span><br><span class="line"><span class="comment">// 所以将会发生 case 穿透</span></span><br><span class="line"><span class="comment">// 编译时编译器将会发出警告</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    result++;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    result++;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    result++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有时候我们需要 case 穿透，如匹配到 2 就一直执行后续的 case</span></span><br><span class="line"><span class="comment">// 此时可以使用属性 [[fallthrough]]，使用后，编译器将不会发出警告</span></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      result++;</span><br><span class="line">      [[fallthrough]];  <span class="comment">// Added</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      result++;</span><br><span class="line">      [[fallthrough]];  <span class="comment">// Added</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>nodiscard</strong><br />
在开发过程中经常需要对函数返回值进行检查，这一步骤在不少业务场景下是必须的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 许多人会遗漏对返回值进行检查的步骤</span></span><br><span class="line"><span class="comment">// 导致了很多业务层面潜在的缺陷</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CallService</span>() != ret) &#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++17 引入 [[nodiscard]] 属性来「提醒」调用者检查函数的返回值</span></span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">CallService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CallServiceRemote</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CallService</span>();              <span class="comment">// 如果只调用而不检查，编译器将发出警告</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CallService</span>() != ret) &#123; <span class="comment">// pass</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>maybe_unused</strong><br />
如果我们以 -Wunused 与 -Wunused-parameter 编译以下代码，编译器则可能报出警告：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> result = a + b;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_FEATURE_C</span></span><br><span class="line">  result += c;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因是编译器认为 c 是未用到的变量，但实际上并非无用。C++17 中可以使用 [[maybe_unused]] 来抑制「针对未使用实体」的警告:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, [[maybe_unused]] <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> result = a + b;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_FEATURE_C</span></span><br><span class="line">  result += c;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="has_include">18 __has_include</h3>
<p>表明指定名称的头或源文件是否存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&quot;has_include.h&quot;</span>)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> NUM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> NUM 0   </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="c20-新特性">C++20 新特性</h3>
<h3 id="特性测试宏">01 特性测试宏</h3>
<p>为 C++11 和其后所引入的 C++ 语言和程序库的功能特性定义了一组预处理器宏。使之成为检测这些功能特性是否存在的一种简单且可移植的方式。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__has_cpp_attribute(fallthrough)     <span class="comment">// 判断是否支持 fallthrough 属性</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_binary_literals              <span class="comment">// 检查「二进制字面量」特性是否存在 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_char8_t                          <span class="comment">// char8 t</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_coroutines                     <span class="comment">// 协程</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="三路比较运算符">02 三路比较运算符 &lt;=&gt;</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若 lhs &lt; rhs 则 (a &lt;=&gt; b) &lt; 0</span></span><br><span class="line"><span class="comment">// 若 lhs &gt; rhs 则 (a &lt;=&gt; b) &gt; 0</span></span><br><span class="line"><span class="comment">// 而若 lhs 和 rhs 相等/等价则 (a &lt;=&gt; b) == 0</span></span><br><span class="line"></span><br><span class="line">lhs &lt;=&gt; rhs</span><br></pre></td></tr></table></figure>
<h3 id="范围-for-中的初始化语句和初始化器">04 范围 for 中的初始化语句和初始化器</h3>
<p>C++17 引入了 if/switch 的初始化语句，C++20 引入了范围 for 的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 auto list = getList(); 初始化语句直接放在了范围 for 语句中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> list = <span class="built_in">getList</span>(); <span class="keyword">auto</span>&amp; ele : list) &#123;</span><br><span class="line">    <span class="comment">// ele = ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外 C++20 的范围 for 还可支持一定的函数式编程风格，例如引入管道符 | 实现函数组合：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 范围库</span></span><br><span class="line"><span class="keyword">auto</span> even = [](<span class="type">int</span> i)&#123; <span class="keyword">return</span> <span class="number">0</span> == i % <span class="number">2</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> square = [](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i * i; &#125;;</span><br><span class="line"><span class="comment">// ints 输出到 std::view::filter(even) ，处理后得到所有偶数</span></span><br><span class="line"><span class="comment">// 上一个结果输出到 std::view::transform(square)，将所有偶数求平方</span></span><br><span class="line"><span class="comment">// 循环遍历所有偶数的平方</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : ints | std::view::<span class="built_in">filter</span>(even) | </span><br><span class="line">                      std::view::<span class="built_in">transform</span>(square)) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="char8_t">05 char8_t</h3>
<p>C++20 新增加 char8_t 类型。</p>
<p>char8_t 用来表示 UTF-8 字符，要求大到足以表示任何 UTF-8 编码单元（ 8 位）。</p>
<h3 id="no_unique_address">06 [[no_unique_address]]</h3>
<p>[[no_unique_address]] 属性修饰的数据成员可以被优化为<strong>不占空间</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;; <span class="comment">// 空类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  Empty e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  [[no_unique_address]] Empty e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Z</span> &#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  [[no_unique_address]] Empty e1, e2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">W</span> &#123;</span><br><span class="line">  <span class="type">char</span> c[<span class="number">2</span>];</span><br><span class="line">  [[no_unique_address]] Empty e1, e2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 任何空类类型对象的大小至少为 1</span></span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(Empty) &gt;= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 至少需要多一个字节以给 e 唯一地址</span></span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(X) &gt;= <span class="built_in">sizeof</span>(<span class="type">int</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优化掉空成员</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;sizeof(Y) == sizeof(int) is &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; (<span class="built_in">sizeof</span>(Y) == <span class="built_in">sizeof</span>(<span class="type">int</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e1 与 e2 不能共享同一地址，因为它们拥有相同类型，尽管它们标记有 [[no_unique_address]]。</span></span><br><span class="line">  <span class="comment">// 然而，其中一者可以与 c 共享地址。</span></span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(Z) &gt;= <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e1 与 e2 不能拥有同一地址，但它们之一能与 c[0] 共享，而另一者与 c[1] 共享</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;sizeof(W) == 2 is &quot;</span> &lt;&lt; (<span class="built_in">sizeof</span>(W) == <span class="number">2</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="likely">07 [[likely]]</h3>
<p>[[likely]] 属性用来告诉编译器哪条分支执行的概率会更大，从而帮助编译器进行代码编译的优化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) [[likely]] &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一直觉真的是奇葩特性，好奇能优化到什么程度以至于专门增加语言特性来要求程序员配合这种优化<br />
包括下文的头文件，让我觉得 C++ 很多时候不是编译器为程序员服务，而是程序员为编译器服务</p>
</blockquote>
<h3 id="unlikely">08 [[unlikely]]</h3>
<p>与 [[likely]] 相对应：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;b) [[unlikely]] &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lambda-初始化捕获中的包展开">09 lambda 初始化捕获中的包展开</h3>
<p>在 C++20 之前，lambda 表达式对与包展开无法进行初始化捕获，如果想要对包展开进行初始化捕获，需要通过 make_tuple 和 apply 来实现，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">delay_invoke_foo</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对 args 进行 make_tuple，然后再用 apply 恢复</span></span><br><span class="line">    <span class="keyword">return</span> [tup=std::<span class="built_in">make_tuple</span>(std::<span class="built_in">move</span>(args)...)]() -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">apply</span>([](<span class="keyword">auto</span> <span class="type">const</span>&amp;... args) -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">foo</span>(args...);</span><br><span class="line">        &#125;, tup);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++20 将直接支持 lambda 对包展开进行初始化捕获，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">delay_invoke_foo</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接 ...args = xxxxx</span></span><br><span class="line">    <span class="keyword">return</span> [...args=std::<span class="built_in">move</span>(args)]() -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">foo</span>(args...);</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移除了在多种上下文语境中使用-typename-关键字以消除类型歧义的要求">10 移除了在多种上下文语境中，使用 typename 关键字以消除类型歧义的要求</h3>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.open-std.org%2Fjtc1%2Fsc22%2Fwg21%2Fdocs%2Fpapers%2F2018%2Fp0634r3.html">P0634R3</a><br />
C++20 之前，在使用了模板类型的地方需要使用 typename 来消除歧义，如下所示：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::vector&lt;T&gt;::iterator <span class="comment">// std::vector&lt;T&gt;::iterator 之前必须使用 typename 关键字</span></span><br></pre></td></tr></table></figure>
<p>C++20 则允许在一些上下文语境中省略 typename，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::vector&lt;T&gt;::iterator <span class="comment">// 省略 typename 关键字</span></span><br></pre></td></tr></table></figure>
<h3 id="constevalconstinit">11 consteval、constinit</h3>
<p><strong>consteval</strong><br />
上文提及过 constexpr 函数可以在编译期运行，也可以在运行期执行。C++20 为了更加明确场景和语义，提供了只能在编译期执行的 consteval，consteval 修饰的函数返回的值如果不能在编译器确定，则编译无法通过。</p>
<p><strong>constinit</strong><br />
在 C++ 中，对于静态存储期的变量的初始化，通常会有两种情况：</p>
<ul>
<li>在编译期初始化</li>
<li>在被第一次加载声明时初始化</li>
</ul>
<p>其中第二种情况由于静态变量初始化顺序的原因存在着隐藏的风险。</p>
<p>所以 C++20 提供了 constinit，以便使某些应该在编译期初始化的变量被确保的在编译期初始化。</p>
<h3 id="更为宽松的-constexpr-要求">12 更为宽松的 constexpr 要求</h3>
<p>从 C++11 一直到 C++20 就一直在给 constexpr 「打补丁」，就不能一次性扩展其能力吗</p>
<blockquote>
<p>引用自 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fjimmysue.me%2Fc-20-features%2F%23constexpr-string--vector">C++20 新增特性</a><br />
C++20 中 constexpr 扩展的能力：</p>
<ul>
<li>constexpr虚函数
<ul>
<li>constexpr 的虚函数可以重写非 constexpr 的虚函数</li>
<li>非 constexpr 虚函数将重载 constexpr 的虚函数</li>
</ul></li>
<li>constexpr 函数支持:
<ul>
<li>使用 dynamic_cast() 和 typeid</li>
<li>动态内存分配</li>
<li>更改union成员的值</li>
<li>包含 try/catch
<ul>
<li>但是不允许 throw 语句</li>
<li>在触发常量求值的时候 try/catch 不发生作用</li>
<li>需要开启 constexpr std::vector</li>
</ul></li>
</ul></li>
<li>constexpr 支持 string &amp; vector 类型</li>
</ul>
</blockquote>
<h3 id="规定有符号整数以补码实现">13 规定有符号整数以补码实现</h3>
<p>在 C++20 之前，有符号整数的实现没有明确以标准的形式规定（虽然在实现时基本都采用补码）。C++20 明确规定了有符号整数使用补码实现。</p>
<h3 id="使用圆括号的聚合初始化">14 使用圆括号的聚合初始化</h3>
<p>C++20 引入了一些新的聚合初始化形式，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T object = &#123; .designator = arg1 , .designator &#123; arg2 &#125; ... &#125;;  <span class="comment">//(since C++20)</span></span><br><span class="line">T object &#123; .designator = arg1 , .designator &#123; arg2 &#125; ... &#125;;     <span class="comment">// (since C++20)</span></span><br><span class="line"><span class="function">T <span class="title">object</span> <span class="params">(arg1, arg2, ...)</span></span>;                                                           <span class="comment">// (since C++20)</span></span><br></pre></td></tr></table></figure>
<p>其中之前没有过的就是第三种形式： <code>T object (arg1, arg2, ...)</code>，使用圆括号进行初始化。</p>
<h3 id="协程">15 协程</h3>
<p><strong>进程</strong>：操作系统资源分配的基本单元。调度涉及到用户空间和内核空间的切换，资源消耗较大。<br />
<strong>线程</strong>：操作系统运行的基本单元。在同一个进程资源的框架下，实现抢占式多任务，相对进程，降低了执行单元切换的资源消耗。<br />
<strong>协程</strong>：和线程非常类似。但是转变一个思路实现协作式多任务，由用户来实现协作式调度（主动交出控制权）</p>
<p>高德纳 Donald Knuth：</p>
<blockquote>
<p>子程序就是协程的一种特例</p>
</blockquote>
<p>协程是广义的函数（子程序），只是它的流程由用户进行一定程度的函数过程切换和控制</p>
<p>举一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 协程实现的生产者和消费者</span><br><span class="line"><span class="function">def <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">  r =</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">  while True:</span></span><br><span class="line"><span class="string">    n = yield r</span></span><br><span class="line"><span class="string">    if not n:</span></span><br><span class="line"><span class="string">      return</span></span><br><span class="line"><span class="string">    print(&#x27;</span>[CONSUMER] Consuming %s..<span class="number">.&#x27;</span> % n)</span><br><span class="line">    time.<span class="built_in">sleep</span>(<span class="number">1</span>)</span><br><span class="line">    r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line">def <span class="built_in">produce</span>(c):</span><br><span class="line">  c.<span class="built_in">next</span>()</span><br><span class="line">  n = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">    r = c.<span class="built_in">send</span>(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">  c.<span class="built_in">close</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  c = <span class="built_in">consumer</span>()</span><br><span class="line">  <span class="built_in">produce</span>(c)</span><br></pre></td></tr></table></figure>
<p>生产者生产消息，待消费者执行完毕后，通过 yield 让出控制权切换回生产者继续生产。</p>
<blockquote>
<p><strong>yield</strong>: 执行到这里主动让出控制权，返回一个值，并等待上一个上下文对自己的进一步调度</p>
</blockquote>
<p>上面是<strong>协程的</strong>的纯粹概念，但是很多语言对协程会有不同的实现和封装，导致协程的概念被进一步扩展和延伸。</p>
<p>例如 <strong>golang</strong> 中的 Goroutines 其实并不是一个纯粹的协程概念，而是对协程和线程的封装和实现，可以说在用户状态下的执行单元调度，同时又解决了传统协程无法利用多核能力的缺陷。所以很多资料将其称为 「<strong>轻量级线程</strong>」或 「<strong>用户态线程</strong>」。</p>
<p>另外，在异步编程方面，协程有一个特别的优势：<br />
<strong>通过更符合人类直觉的顺序执行来表达异步逻辑</strong>。</p>
<p>在 JS 生态中（尤其以 Node.js 为代表）我们编写异步逻辑，经常使用回调来实现结果返回。而如果是多层级异步调用的场景，容易陷入 「<strong>callback hell 回调地狱</strong>」。</p>
<p>如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="built_in">readFile</span>(fileA, <span class="built_in">function</span> (err, data) &#123;</span><br><span class="line">  fs.<span class="built_in">readFile</span>(fileB, <span class="built_in">function</span> (err, data) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>JS 后续引入了 Promise，简化回调调用形式，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">readFile</span>(fileA)</span><br><span class="line">.<span class="built_in">then</span>(<span class="built_in">function</span>(data)&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(data.<span class="built_in">toString</span>());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="built_in">then</span>(<span class="built_in">function</span>()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">readFile</span>(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="built_in">then</span>(<span class="built_in">function</span>(data)&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(data.<span class="built_in">toString</span>());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="built_in">catch</span>(<span class="built_in">function</span>(err) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>再后续引入了协程的一种实现——<strong>Generator 生成器</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">function* <span class="title">gen</span><span class="params">()</span></span>&#123;</span><br><span class="line">  var url = <span class="string">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class="line">  var result = yield <span class="built_in">fetch</span>(url);</span><br><span class="line">  console.<span class="built_in">log</span>(result.bio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = <span class="built_in">gen</span>();</span><br><span class="line">var result = g.<span class="built_in">next</span>();</span><br><span class="line"></span><br><span class="line">result.value.<span class="built_in">then</span>(<span class="built_in">function</span>(data)&#123;</span><br><span class="line">  <span class="keyword">return</span> data.<span class="built_in">json</span>();</span><br><span class="line">&#125;).<span class="built_in">then</span>(<span class="built_in">function</span>(data)&#123;</span><br><span class="line">  g.<span class="built_in">next</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Generator 函数可以暂停执行(yield)和恢复执行(next)，这是它能用来实现异步编程的根本原因</p>
</blockquote>
<p>而 JS 后续底层通过 yield/generator 实现的 async &amp; await 异步编程体验，也会使得 JS 程序员对协程的直观感受为「回调调度器」。</p>
<p>而 C++20 引入的则是相对纯粹的协程，例如可以实现一个 generator函数或者生成器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">experimental::generator&lt;<span class="type">int</span>&gt; <span class="title">GetSequenceGenerator</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> startValue, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> numberOfValues)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> startValue; i &lt; startValue + numberOfValues; ++i)&#123; </span><br><span class="line">        <span class="type">time_t</span> t = system_clock::<span class="built_in">to_time_t</span>(system_clock::<span class="built_in">now</span>()); </span><br><span class="line">        cout &lt;&lt; std:: <span class="built_in">ctime</span>(&amp;t); <span class="keyword">co_yield</span> i; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> gen = <span class="built_in">GetSequenceGenerator</span>(<span class="number">10</span>, <span class="number">5</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : gen) &#123; </span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">&quot;(Press enter for next value)&quot;</span> &lt;&lt; endl; </span><br><span class="line">        cin.<span class="built_in">ignore</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模块">16 模块</h3>
<p><strong>历史包袱-头文件</strong></p>
<p>请看如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Play</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// game.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">LaunchSteam</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>由于 C/C++ 时代 .obj 等结果文件可能来自于其他语言。固每个源文件不与其他源文件产生关联，需独立编译。在这样的背景下，我们站在编译器的角度尝试编译 person.cpp ，会发现编译将无法进行。原因是 Play 的<strong>返回类型、参数类型等元信息</strong>无法获取。那么是否可以生成外部符号等待链接阶段呢？</li>
<li>答案是否定的。即无法推迟到链接阶段。原因是 C++ 编译时不会将函数的返回值、参数等元信息编译进 .obj 等结果，固在<strong>链接阶段</strong>依然获取不到 Play 函数相关的元信息。之所以没有像 Java/C# 等现代语言这样将元信息写到编译结果中，是因为 C/C++ 时代内存等资源稀缺，所以想方设法的节省各种资源。</li>
</ol>
<p>而由于上述历史原因，导致了 C++ 最终将这种不便转交给了程序员。程序员在调用另一个源文件的函数时需要<strong>事先声明函数原型</strong>，而如果在每个使用到相应函数的源文件中都重复声明一次就太过于低级，于是出现了所谓的头文件，简化声明工作。</p>
<p>另一方面，头文件从一定程度起到了接口描述的作用，但有些人把头文件当作是「实现与接口分离的设计思想」下的成果就非常的牵强了。</p>
<p>头文件本质上是围绕着编译期的一种概念，是 C/C++ 由于历史原因不得不由程序员使用头文件辅助编译器完成编译工作。</p>
<p>而接口的概念是围绕着业务开发或编程阶段的，是另一层面的事情。</p>
<p>如果不好理解，可以思考一下，Java/C# 没有头文件的语言是如何实现所谓「头文件提供接口」这一功能的？</p>
<p>如果需要实现，编译器可以直接从源码文件抽离出接口信息生成接口文件即可，而且还可以根据访问权限来决定哪些该对外暴露，哪些不能暴露。甚至可以以 .h 为后缀让那些觉得「<strong>头文件起到接口作用</strong>」的程序员好受些。</p>
<p>C++20 引入了模块，模块的其中一个作用就是将 <code>header</code> 与<code>编译单元</code>统一在了一起。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> example; <span class="comment">//声明一个模块名字为example</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second)</span> </span>&#123; <span class="comment">//可以导出的函数</span></span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 example 模块</span></span><br><span class="line"><span class="keyword">import</span> example; <span class="comment">//导入上述定义的模块</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//调用example模块中的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="限定与概念concepts">17 限定与概念(concepts)</h3>
<p>concepts 是 C++20 的重要更新之一，它是模板能力的扩展。在 C++20 之前，我们的模板参数是没有明确限定的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> L, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">const</span> L&amp; list, <span class="type">const</span> T&amp; t)</span></span>; <span class="comment">// 从 list 列表中查找 t</span></span><br></pre></td></tr></table></figure>
<p>上面的参数类型 L 与 T 没有任何的限制，但实际上是<strong>存在着隐含的限定条件</strong>的：</p>
<ul>
<li>L 应该是一个可迭代类型</li>
<li>L 中的元素类型应该和 T 类型相同</li>
<li>L 中的元素应该和 T 类型可进行相等比较</li>
</ul>
<p>程序员应当知晓上述隐含条件，否则编译器就会输出一堆错误。而现在可以通过 concepts 将上述限定条件告知编译器，在使用错误将得到直观的错误原因。</p>
<p>例如使用 concepts 限定参数可 hash：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义概念</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Hashable = <span class="built_in">requires</span>(T a) &#123;</span><br><span class="line">  <span class="comment">// 下面语句的限定含义为：</span></span><br><span class="line">  <span class="comment">// 限定  std::hash(a) 返回值可转换成 std::size_t</span></span><br><span class="line">  &#123; std::hash&lt;T&gt;&#123;&#125;(a) &#125; -&gt; std::convertible_to&lt;std::<span class="type">size_t</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用概念对模板参数进行限定</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">my_hash</span><span class="params">(T)</span> <span class="keyword">requires</span> Hashable&lt;T&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述的 <code>my_hash</code> 函数也可通过简化的方式进行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;Hashable T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">my_hash</span><span class="params">(T)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缩略函数模板">18 缩略函数模板</h3>
<p>通常声明函数模板的形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;C1 T&gt; <span class="type">void</span> <span class="title">f2</span><span class="params">(T)</span></span>; <span class="comment">// C1 如果是一个 concept 概念</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>C++20 可以采用 <code>auto</code> 或 <code>concept auto</code> 来实现更为简短的函数模板声明形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">auto</span>)</span></span>;       <span class="comment">// 等同于 template&lt;class T&gt; void f(T);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(C1 <span class="keyword">auto</span>)</span></span>; <span class="comment">// template&lt;C1 T&gt; void f2(T);</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="数组长度推导">19 数组长度推导</h3>
<p>C++20 将允许 <code>new int[]&#123;1, 2, 3&#125;</code> 的写法，编译器可自动推导数组长度。</p>
<h3 id="小结">小结</h3>
<p>C++ 最根本的设计理念就是为了<strong>运行效率</strong>服务，甚至专门增加新特性要求程序员配合编译器来做优化。但另一方面， C++ 后期一直从 Java/JavaScript/Go/Python 等语言中借鉴特性，而其中很多是无关紧要的语法糖，对于真正至关重要的特性却又一直拖到了 0202 年才推出标准。</p>
<blockquote>
<p>C++ 20 真正在业界扎稳又是要到何年何月，至于形成与其他现代语言一样完善、统一的生态更是遥不可期</p>
</blockquote>
<p>这导致本就繁杂的 C++ 的语法随着时间推移变得更加混乱，这进一步提高了 C++ 的学习与使用成本。唯一的好处就是提高了部分现有 C++ 程序员的自豪感，毕竟部分程序员是以自己掌握的<strong>工具难度</strong>为傲的。这些人不仅将「工具的难度」与「技术水平」挂钩，有时甚至以此标榜自己的智商。建议有此想法的人<strong>阅读并背诵新华字典全典</strong>或者<strong>用汇编完成所有工作</strong>。</p>
<p>C++ 有其对应的应用场景，在一些运行效率要求极高的基础组件的开发上，在绝大多数的游戏开发场景下，C++ 有其不可替代性。但在一些上层的应用场景，尤其是在更接近用户的互联网业务上使用 C++ 基本都是由于历史债务<strong>[7]</strong>。</p>
<blockquote>
<p><strong>[7]</strong>: 例如我现在所在的部门。即使围绕 C++ 积累了大量的组件、工具和平台，不少人自认为开发效率也不低，但实际上和业界在开发效率上至少有 2 ～ 3 年以上的差距<strong>[8]</strong>，而且就目前能预见的，这差距只会越来越大。</p>
<p><strong>[8]</strong>: 游戏和基础组件场景除外，这里指那些不该使用 C++ 却由于历史原因使用 C++而现在又没有决心改变的场景和业务。当然这也只是从技术层面上讲，实际情况可能是业务上难以改变，或者改变的风险大于收益。但这不该是心安理得的理由，开发效率落后于业界依然是一个客观事实。</p>
</blockquote>
<h3 id="相关代码">相关代码</h3>
<p>针对上述特性编写了一些例子代码（更新中），有需要可<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FYueHub%2Fdemo%2Ftree%2Fmaster%2Fcpp-demo">点此查看</a><strong>[9]</strong></p>
<blockquote>
<p><strong>[9]</strong>: 文件名为 <strong>cpp版本号_特性序号_特性名称</strong></p>
</blockquote>
<h3 id="参考资料">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fchangkun.de%2Fmodern-cpp%2Fzh-cn%2F02-usability%2Findex.html">现代C++教程：高速上手C++11/14/17/20</a><br />
<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.cppreference.com%2F">cppreference</a><br />
<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fzh.cppreference.com%2F">cppreference 中文</a><br />
<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fchenxiaowei.gitbook.io%2Fc-17-stl-cook-book%2F">C++17 STL Cook Book</a><br />
<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http%3A%2F%2Fopen-std.org%2FJTC1%2FSC22%2FWG21%2Fdocs%2Fpapers%2F2017%2Fp0636r2.html">Changes between C++14 and C++17</a><br />
深入理解 C++11 新特性解析与应用<br />
<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fskyscribe.github.io%2Fpost%2F2019%2F06%2F23%2Fcpp-20-modules-concepts-coroutine%2F">C++20 - 下一个大版本功能确定</a></p>
<h3 id="汪">汪</h3>
<p>汪## 目标</p>
<h3 id="原理">原理</h3>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Ferret@NJTech
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://njuferret.github.io/2023/09/10/cpp_11_14_17_20/" title="C++11&#x2F;14&#x2F;17&#x2F;20 特性介绍 转">https://njuferret.github.io/2023/09/10/cpp_11_14_17_20/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 基础语法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/08/22/2023-08-22_qt/" rel="prev" title="Qt开发经验_转">
                  <i class="fa fa-angle-left"></i> Qt开发经验_转
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Ferret@NJTech</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.20/fancybox/fancybox.umd.js" integrity="sha256-q8XkJ6dj5VwSvzI8+nATCHHQG+Xv/dAZBCgqmu93zOY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
